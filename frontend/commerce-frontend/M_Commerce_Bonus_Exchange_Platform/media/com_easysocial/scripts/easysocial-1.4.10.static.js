
/*!
 * jQuery JavaScript Library v1.11.1pre
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-09-04T08:47Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var trim = "".trim;

var support = {};



var
	version = "1.11.1pre",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return a 'clean' array
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return just the object
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: deletedIds.sort,
	splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return obj - parseFloat( obj ) >= 0;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( support.ownLast ) {
			for ( key in obj ) {
				return hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: trim && !trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( indexOf ) {
				return indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		while ( j < len ) {
			first[ i++ ] = second[ j++ ];
		}

		// Support: IE<9
		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
		if ( len !== len ) {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: function() {
		return +( new Date() );
	},

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.18
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-02-05
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select t=''><option selected=''></option></select>";

			// Support: IE8, Opera 10-12
			// Nothing should be selected when empty strings follow ^= or $= or *=
			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );

					} else if ( !(--remaining) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	}
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
	if ( document.addEventListener ) {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );

	} else {
		document.detachEvent( "onreadystatechange", completed );
		window.detachEvent( "onload", completed );
	}
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	// readyState === "complete" is good enough for us to call the dom ready in oldIE
	if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
		detach();
		jQuery.ready();
	}
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
	break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

jQuery(function() {
	// We need to execute this one support test ASAP because we need to know
	// if body.style.zoom needs to be set.

	var container, div,
		body = document.getElementsByTagName("body")[0];

	if ( !body ) {
		// Return for frameset docs that don't have a body
		return;
	}

	// Setup
	container = document.createElement( "div" );
	container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

	div = document.createElement( "div" );
	body.appendChild( container ).appendChild( div );

	if ( typeof div.style.zoom !== strundefined ) {
		// Support: IE<8
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		div.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1";

		if ( (support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 )) ) {
			// Prevent IE 6 from affecting layout for positioned elements #11048
			// Prevent IE from shrinking the body in IE 7 mode #12869
			// Support: IE<8
			body.style.zoom = 1;
		}
	}

	body.removeChild( container );

	// Null elements to avoid leaks in IE
	container = div = null;
});




(function() {
	var div = document.createElement( "div" );

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
	var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
		nodeType = +elem.nodeType || 1;

	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
	return nodeType !== 1 && nodeType !== 9 ?
		false :

		// Nodes accept data unless otherwise specified; rejection can be conditional
		!noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements (space-suffixed to avoid Object.prototype collisions)
	// throw uncatchable exceptions if you attempt to set expando properties
	noData: {
		"applet ": true,
		"embed ": true,
		// ...but Flash objects (which have this classid) *can* handle expandos
		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[0],
			attrs = elem && elem.attributes;

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {
						name = attrs[i].name;

						if ( name.indexOf("data-") === 0 ) {
							name = jQuery.camelCase( name.slice(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		length = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < length; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = document.createElement("div"),
		input = document.createElement("input");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a>";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName( "tbody" ).length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone =
		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	input.type = "checkbox";
	input.checked = true;
	fragment.appendChild( input );
	support.appendChecked = input.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE6-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// #11217 - WebKit loses check when the name is after the checked attribute
	fragment.appendChild( div );
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	support.noCloneEvent = true;
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}

	// Null elements to avoid leaks in IE.
	fragment = div = input = null;
})();


(function() {
	var i, eventName,
		div = document.createElement( "div" );

	// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
	for ( i in { submit: true, change: true, focusin: true }) {
		eventName = "on" + i;

		if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
			div.setAttribute( eventName, "t" );
			support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Even when returnValue equals to undefined Firefox will still show alert
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined && (
				// Support: IE < 9
				src.returnValue === false ||
				// Support: Android < 4.0
				src.getPreventDefault && src.getPreventDefault() ) ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					jQuery._removeData( doc, fix );
				} else {
					jQuery._data( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!support.noCloneEvent || !support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						deletedIds.push( id );
					}
				}
			}
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}


(function() {
	var a, shrinkWrapBlocksVal,
		div = document.createElement( "div" ),
		// Support: Firefox<29, Android 2.3 (Prefixed box-sizing versions).
		divReset =
			"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
			"display:block;padding:0;margin:0;border:0";

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];

	a.style.cssText = "float:left;opacity:.5";

	// Make sure that element opacity exists
	// (IE uses filter instead)
	// Use a regex to work around a WebKit issue. See #5145
	support.opacity = /^0.5/.test( a.style.opacity );

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!a.style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Null elements to avoid leaks in IE.
	a = div = null;

	support.shrinkWrapBlocks = function() {
		var body, container, div, containerStyles;

		if ( shrinkWrapBlocksVal == null ) {
			body = document.getElementsByTagName( "body" )[ 0 ];
			if ( !body ) {
				// Test fired too early or in an unsupported environment, exit.
				return;
			}

			containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px";
			container = document.createElement( "div" );
			div = document.createElement( "div" );

			body.appendChild( container ).appendChild( div );

			// Will be changed later if needed.
			shrinkWrapBlocksVal = false;

			if ( typeof div.style.zoom !== strundefined ) {
				// Support: IE6
				// Check if elements with layout shrink-wrap their children
				div.style.cssText = divReset + ";width:1px;padding:1px;zoom:1";
				div.innerHTML = "<div></div>";
				div.firstChild.style.width = "5px";
				shrinkWrapBlocksVal = div.offsetWidth !== 3;
			}

			body.removeChild( container );

			// Null elements to avoid leaks in IE.
			body = container = div = null;
		}

		return shrinkWrapBlocksVal;
	};

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
	rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "";
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, computed ) {
		var left, rs, rsLeft, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed[ name ] : undefined;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "" || "auto";
	};
}




function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			var condition = conditionFn();

			if ( condition == null ) {
				// The test was not ready at this point; screw the hook this time
				// but check again when needed next time.
				return;
			}

			if ( condition ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal,
		pixelPositionVal,
		div = document.createElement( "div" ),
		containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
		// Support: Firefox<29, Android 2.3 (Prefixed box-sizing versions).
		divReset =
			"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
			"display:block;padding:0;margin:0;border:0";

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];

	a.style.cssText = "float:left;opacity:.5";

	// Make sure that element opacity exists
	// (IE uses filter instead)
	// Use a regex to work around a WebKit issue. See #5145
	support.opacity = /^0.5/.test( a.style.opacity );

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!a.style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Null elements to avoid leaks in IE.
	a = div = null;

	jQuery.extend(support, {
		reliableHiddenOffsets: function() {
			if ( reliableHiddenOffsetsVal != null ) {
				return reliableHiddenOffsetsVal;
			}

			var container, tds, isSupported,
				div = document.createElement( "div" ),
				body = document.getElementsByTagName( "body" )[ 0 ];

			if ( !body ) {
				// Return for frameset docs that don't have a body
				return;
			}

			// Setup
			div.setAttribute( "className", "t" );
			div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

			container = document.createElement( "div" );
			container.style.cssText = containerStyles;

			body.appendChild( container ).appendChild( div );

			// Support: IE8
			// Check if table cells still have offsetWidth/Height when they are set
			// to display:none and there are still other visible table cells in a
			// table row; if so, offsetWidth/Height are not reliable for use when
			// determining if an element has been hidden directly using
			// display:none (it is still safe to use offsets if a parent element is
			// hidden; don safety goggles and see bug #4512 for more information).
			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
			tds = div.getElementsByTagName( "td" );
			tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
			isSupported = ( tds[ 0 ].offsetHeight === 0 );

			tds[ 0 ].style.display = "";
			tds[ 1 ].style.display = "none";

			// Support: IE8
			// Check if empty table cells still have offsetWidth/Height
			reliableHiddenOffsetsVal = isSupported && ( tds[ 0 ].offsetHeight === 0 );

			body.removeChild( container );

			// Null elements to avoid leaks in IE.
			div = body = null;

			return reliableHiddenOffsetsVal;
		},

		boxSizing: function() {
			if ( boxSizingVal == null ) {
				computeStyleTests();
			}
			return boxSizingVal;
		},

		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},

		pixelPosition: function() {
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return pixelPositionVal;
		},

		// Support: Android 2.3
		reliableMarginRight: function() {
			var body, container, div, marginDiv,
				// Support: IE<9.
				// IE should pass the test but we're using getComputedStyle
				// to compute it so just return true if the method is not present.
				reliableMarginRightVal = true;

			// Use window.getComputedStyle because jsdom on node.js will break without it.
			if ( window.getComputedStyle ) {
				body = document.getElementsByTagName( "body" )[ 0 ];
				if ( !body ) {
					// Test fired too early or in an unsupported environment, exit.
					return;
				}

				container = document.createElement( "div" );
				div = document.createElement( "div" );
				container.style.cssText = containerStyles;

				body.appendChild( container ).appendChild( div );

				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// Fails in WebKit before Feb 2011 nightlies
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				marginDiv = div.appendChild( document.createElement( "div" ) );
				marginDiv.style.cssText = div.style.cssText = divReset;
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";

				reliableMarginRightVal =
					!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );

				body.removeChild( container );
			}

			return reliableMarginRightVal;
		}
	});

	function computeStyleTests() {
		var container, div,
			body = document.getElementsByTagName( "body" )[ 0 ];

		if ( !body ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		container = document.createElement( "div" );
		div = document.createElement( "div" );
		container.style.cssText = containerStyles;

		body.appendChild( container ).appendChild( div );

		// Support: Firefox<29, Android 2.3 (Prefixed box-sizing versions).
		div.style.cssText =
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:absolute;display:block;padding:1px;border:1px;width:4px;" +
				"margin-top:1%;top:1%";

		// Workaround failing boxSizing test due to offsetWidth returning wrong value
		// with some non-1 values of body zoom, ticket #13543
		jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
			boxSizingVal = div.offsetWidth === 4;
		});

		// Will be changed later if needed.
		boxSizingReliableVal = true;
		pixelPositionVal = false;

		// Use window.getComputedStyle because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			boxSizingReliableVal =
				( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
		}

		body.removeChild( container );

		// Null elements to avoid leaks in IE.
		div = body = null;
	}

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
		ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,

	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Support: IE
				// Swallow errors from 'invalid' CSS values (#5509)
				try {
					// Support: Chrome, Safari
					// Setting style to blank string required to delete "style: x !important;"
					style[ name ] = "";
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, dDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );
		dDisplay = defaultDisplay( elem.nodeName );
		if ( display === "none" ) {
			display = dDisplay;
		}
		if ( display === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !support.inlineBlockNeedsLayout || dDisplay === "inline" ) {
				style.display = "inline-block";
			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !support.shrinkWrapBlocks() ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var a, input, select, opt,
		div = document.createElement("div" );

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName("a")[ 0 ];

	// First batch of tests.
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE8 only
	// Check if we can trust getAttribute("value")
	input = document.createElement( "input" );
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	// Null elements to avoid leaks in IE.
	a = input = select = opt = div = null;
})();


var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					jQuery.text( elem );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

						// Support: IE6
						// When new option element is added to select box we need to
						// force reflow of newly added node in order to workaround delay
						// of initialization properties
						try {
							option.selected = optionSet = true;

						} catch ( _ ) {

							// Will be executed only in IE6
							option.scrollHeight;
						}

					} else {
						option.selected = false;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}

				return options;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = support.getSetAttribute,
	getSetInput = support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		} :
		function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
			}
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			if ( name === "value" || value === elem.getAttribute( name ) ) {
				return value;
			}
		}
	};

	// Some attributes are constructed with empty-string values when not defined
	attrHandle.id = attrHandle.name = attrHandle.coords =
		function( elem, name, isXML ) {
			var ret;
			if ( !isXML ) {
				return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
			}
		};

	// Fixing value retrieval on a button requires this module
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			if ( ret && ret.specified ) {
				return ret.value;
			}
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}

if ( !support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
	// Attempt to parse using the native JSON parser first
	if ( window.JSON && window.JSON.parse ) {
		// Support: Android 2.3
		// Workaround failure to string-cast null input
		return window.JSON.parse( data + "" );
	}

	var requireNonComma,
		depth = null,
		str = jQuery.trim( data + "" );

	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	// after removing valid tokens
	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

		// Force termination if we see a misplaced comma
		if ( requireNonComma && comma ) {
			depth = 0;
		}

		// Perform no more replacements after returning to outermost depth
		if ( depth === 0 ) {
			return token;
		}

		// Commas must not follow "[", "{", or ","
		requireNonComma = open || comma;

		// Determine new depth
		// array/object open ("[" or "{"): depth += true - false (increment)
		// array/object close ("]" or "}"): depth += false - true (decrement)
		// other cases ("," or primitive): depth += true - true (numeric cast)
		depth += !close - !open;

		// Remove this token
		return "";
	}) ) ?
		( Function( "return " + str ) )() :
		jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	try {
		if ( window.DOMParser ) { // Standard
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} else { // IE
			xml = new ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}
	} catch( e ) {
		xml = undefined;
	}
	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType.charAt( 0 ) === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// FOUNDRY_HACK
		// Method to trigger ajax send
		jqXHR.send = function() {

			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {

			// FOUNDRY_HACK
			// Autostart option. If autostart is false,
			// ajax will not begin until send() is manually called.
			options.autostart!==false && jqXHR.send();
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
		(!support.reliableHiddenOffsets() &&
			((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
	// Support: IE6+
	function() {

		// XHR cannot access local files, always use ActiveX for that case
		return !this.isLocal &&

			// Support: IE7-8
			// oldIE XHR does not support non-RFC2616 methods (#13240)
			// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
			// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
			// Although this check for six methods instead of eight
			// since IE also does not support "trace" and "connect"
			/^(get|post|head|put|delete|options)$/i.test( this.type ) &&

			createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

var xhrId = 0,
	xhrCallbacks = {},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	});
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( options ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !options.crossDomain || support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					// Open the socket
					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						// Support: IE<9
						// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
						// request header to a null-value.
						//
						// To keep consistent with other XHR implementations, cast the value
						// to string and ignore `undefined`.
						if ( headers[ i ] !== undefined ) {
							xhr.setRequestHeader( i, headers[ i ] + "" );
						}
					}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( options.hasContent && options.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, statusText, responses;

						// Was never called and is aborted or complete
						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
							// Clean up
							delete xhrCallbacks[ id ];
							callback = undefined;
							xhr.onreadystatechange = jQuery.noop;

							// Abort manually if needed
							if ( isAbort ) {
								if ( xhr.readyState !== 4 ) {
									xhr.abort();
								}
							} else {
								responses = {};
								status = xhr.status;

								// Support: IE<10
								// Accessing binary-data responseText throws an exception
								// (#11426)
								if ( typeof xhr.responseText === "string" ) {
									responses.text = xhr.responseText;
								}

								// Firefox throws an exception when accessing
								// statusText for faulty cross-domain requests
								try {
									statusText = xhr.statusText;
								} catch( e ) {
									// We normalize with Webkit giving an empty statusText
									statusText = "";
								}

								// Filter status for non standard behaviors

								// If the request is local and we have data: assume a success
								// (success with no data won't get notified, that's the best we
								// can do given current implementations)
								if ( !status && options.isLocal && !options.crossDomain ) {
									status = responses.text ? 200 : 404;
								// IE - #1450: sometimes returns 1223 when it should be 204
								} else if ( status === 1223 ) {
									status = 204;
								}
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, xhr.getAllResponseHeaders() );
						}
					};

					if ( !options.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						// Add to the list of active xhr callbacks
						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;

// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || "",
		version: match[ 2 ] || "0"
	};
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
	browser[ matched.browser ] = true;
	browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
	browser.webkit = true;
} else if ( browser.webkit ) {
	browser.safari = true;
}

jQuery.browser = browser;

})();




jQuery.version = "4.0";
jQuery.long_version = "4.0.37";

jQuery.uid = function(p,s) {
	return ((p) ? p : "") + Math.random().toString().replace(".","") + ((s) ? s : "");
};

jQuery.globalNamespace = jQuery.uid("Foundry");

window[jQuery.globalNamespace] = jQuery;

jQuery.run = function(command) {
	return (jQuery.isFunction(command)) ? command(jQuery) : null;
};

jQuery.initialize = function(options) {

	if (jQuery.initialized) return;

	jQuery.extend(jQuery, options);

	if (jQuery.environment=="development") {
		window.F = jQuery;
	}

	jQuery.initialized = true;

	// Execute any pending modules
	FD40.module.execute();
}

// Register jquery into bootloader
FD40.jquery(jQuery);

// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




return jQuery;

}));

FD40.plugin("lodash", function($) {

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      // hack: Add ability to reset memoized values
      memoized.reset = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        if (hasOwnProperty.call(cache, key)) {
          delete cache[key];
        }
      }
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = $._ = runInContext();

  // expose Lo-Dash methods to jQuery
  $.each(_, function(prop, func){
    if (!Object.hasOwnProperty.call(_, prop) || /VERSION/.test(name)) return;
    if (!$[prop]) $[prop] = func;
  });

});

FD40.plugin("bootstrap3", function($) {

var jQuery = $;
/*!
 * Bootstrap v3.0.3 (http://getbootstrap.com)
 * Copyright 2015 Twitter, Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0
 */

if (window["Foundry/Bootstrap"]) { throw new Error("An instance of Bootstrap has been initialized before this.") } else { window["Foundry/Bootstrap"] = { version: "3.0.3", foundry: jQuery } }

/* ========================================================================
 * Bootstrap: transition.js v3.0.3
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      'WebkitTransition' : 'webkitTransitionEnd'
    , 'MozTransition'    : 'transitionend'
    , 'OTransition'      : 'oTransitionEnd otransitionend'
    , 'transition'       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false, $el = this
    $(this).one($.support.transition.end, function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.0.3
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-bs-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.hasClass('alert') ? $this : $this.parent()
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      $parent.trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one($.support.transition.end, removeElement)
        .emulateTransitionEnd(150) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  var old = $.fn.alert

  $.fn.alert = function (option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.0.3
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element = $(element)
    this.options  = $.extend({}, Button.DEFAULTS, options)
  }

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (!data.resetText) $el.data('resetText', $el[val]())

    $el[val](data[state] || this.options[state])

    // push to event loop to allow forms to submit
    setTimeout(function () {
      state == 'loadingText' ?
        $el.addClass(d).attr(d, d) :
        $el.removeClass(d).removeAttr(d);
    }, 0)
  }

  Button.prototype.toggle = function () {
    var $parent = this.$element.closest('[data-bs-toggle="buttons"]')
    var changed = true

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') === 'radio') {
        // see if clicking on current one
        if ($input.prop('checked') && this.$element.hasClass('active'))
          changed = false
        else
          $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  var old = $.fn.button

  $.fn.button = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document).on('click.bs.button.data-api', '[data-bs-toggle^=button]', function (e) {
    var $btn = $(e.target)
    if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
    $btn.button('toggle')
    e.preventDefault()
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.0.3
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      =
    this.sliding     =
    this.interval    =
    this.$active     =
    this.$items      = null

    this.options.pause == 'hover' && this.$element
      .on('mouseenter', $.proxy(this.pause, this))
      .on('mouseleave', $.proxy(this.cycle, this))
  }

  Carousel.DEFAULTS = {
    interval: 5000
  , pause: 'hover'
  , wrap: true
  }

  Carousel.prototype.cycle =  function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getActiveIndex = function () {
    this.$active = this.$element.find('.item.active')
    this.$items  = this.$active.parent().children()

    return this.$items.index(this.$active)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getActiveIndex()

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) })
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition.end) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || $active[type]()
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var fallback  = type == 'next' ? 'first' : 'last'
    var that      = this

    if (!$next.length) {
      if (!this.options.wrap) return
      $next = this.$element.find('.item')[fallback]()
    }

    this.sliding = true

    isCycling && this.pause()

    var e = $.Event('slide.bs.carousel', { relatedTarget: $next[0], direction: direction })

    if ($next.hasClass('active')) return

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      this.$element.one('slid.bs.carousel', function () {
        var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()])
        $nextIndicator && $nextIndicator.addClass('active')
      })
    }

    if ($.support.transition && this.$element.hasClass('slide')) {
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one($.support.transition.end, function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () { that.$element.trigger('slid.bs.carousel') }, 0)
        })
        .emulateTransitionEnd(600)
    } else {
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger('slid.bs.carousel')
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  var old = $.fn.carousel

  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  $(document).on('click.bs.carousel.data-api', '[data-bs-slide], [data-bs-slide-to]', function (e) {
    var $this   = $(this), href
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-bs-slide-to')
    if (slideIndex) options.interval = false

    $target.carousel(options)

    if (slideIndex = $this.attr('data-bs-slide-to')) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  })

  $(window).on('load', function () {
    $('[data-bs-ride="carousel"]').each(function () {
      var $carousel = $(this)
      $carousel.carousel($carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.0.3
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.transitioning = null

    if (this.options.parent) this.$parent = $(this.options.parent)
    if (this.options.toggle) this.toggle()
  }

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var startEvent = $.Event('show.bs.collapse')
    this.$element.triggerHandler(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var actives = this.$parent && this.$parent.find('> .panel > .in')

    if (actives && actives.length) {
      var hasData = actives.data('bs.collapse')
      if (hasData && hasData.transitioning) return
      actives.collapse('hide')
      hasData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')
      [dimension](0)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('in')
        [dimension]('auto')
      this.transitioning = 0
      this.$element.trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one($.support.transition.end, $.proxy(complete, this))
      .emulateTransitionEnd(350)
      [dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.triggerHandler(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element
      [dimension](this.$element[dimension]())
      [0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse')
      .removeClass('in')

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .trigger('hidden.bs.collapse')
        .removeClass('collapsing')
        .addClass('collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one($.support.transition.end, $.proxy(complete, this))
      .emulateTransitionEnd(350)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  var old = $.fn.collapse

  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-bs-toggle=collapse]', function (e) {
    var $this   = $(this), href
    var target  = $this.attr('data-target')
        || e.preventDefault()
        || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
    var $target = $(target)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()
    var parent  = $this.attr('data-parent')
    var $parent = parent && $(parent)

    if (!data || !data.transitioning) {
      if ($parent) $parent.find('[data-bs-toggle=collapse][data-parent="' + parent + '"]').not($this).addClass('collapsed')
      $this[$target.hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
    }

    $target.collapse(option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.0.3
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-bs-toggle=dropdown]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      $parent.triggerHandler(e = $.Event('show.bs.dropdown'))

      if (e.isDefaultPrevented()) return

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown')

      $this.focus()
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27)/.test(e.keyCode)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive || (isActive && e.keyCode == 27)) {
      if (e.which == 27) $parent.find(toggle).focus()
      return $this.click()
    }

    var $items = $('[role=menu] li:not(.divider):visible a', $parent)

    if (!$items.length) return

    var index = $items.index($items.filter(':focus'))

    if (e.keyCode == 38 && index > 0)                 index--                        // up
    if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index=0

    $items.eq(index).focus()
  }

  function clearMenus() {
    $(backdrop).remove()
    $(toggle).each(function (e) {
      var $parent = getParent($(this))
      if (!$parent.hasClass('open')) return
      $parent.triggerHandler(e = $.Event('hide.bs.dropdown'))
      if (e.isDefaultPrevented()) return
      $parent.removeClass('open').trigger('hidden.bs.dropdown')
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  var old = $.fn.dropdown

  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown_ form, .dropdown-static', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api'  , toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle + ', [role=menu]' , Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.0.3
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options   = options
    this.$element  = $(element)
    this.$backdrop =
    this.isShown   = null

    if (this.options.remote) this.$element.load(this.options.remote)
  }

  Modal.DEFAULTS = {
      backdrop: true
    , keyboard: true
    , show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this[!this.isShown ? 'show' : 'hide'](_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.triggerHandler(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.escape()

    this.$element.on('click.dismiss.modal', '[data-bs-dismiss="modal"]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(document.body) // don't move modals dom position
      }

      that.$element.show()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one($.support.transition.end, function () {
            that.$element.focus().trigger(e)
          })
          .emulateTransitionEnd(300) :
        that.$element.focus().trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.triggerHandler(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one($.support.transition.end, $.proxy(this.hideModal, this))
        .emulateTransitionEnd(300) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.focus()
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keyup.dismiss.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.removeBackdrop()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that    = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .appendTo(document.body)

      this.$element.on('click.dismiss.modal', $.proxy(function (e) {
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus.call(this.$element[0])
          : this.hide.call(this)
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one($.support.transition.end, callback)
          .emulateTransitionEnd(150) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      $.support.transition && this.$element.hasClass('fade')?
        this.$backdrop
          .one($.support.transition.end, callback)
          .emulateTransitionEnd(150) :
        callback()

    } else if (callback) {
      callback()
    }
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  var old = $.fn.modal

  $.fn.modal = function (option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-bs-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
    var option  = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    e.preventDefault()

    $target
      .modal(option, this)
      .one('hide', function () {
        $this.is(':visible') && $this.focus()
      })
  })

  $(document)
    .on('show.bs.modal',  '.modal.bs', function () { $(document.body).addClass('modal-open') })
    .on('hidden.bs.modal', '.modal.bs', function () { $(document.body).removeClass('modal-open') })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.0.3
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.DEFAULTS = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled  = true
    this.type     = type
    this.$element = $(element)
    this.options  = this.getOptions(options)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focus'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay
      , hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.'+ this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.triggerHandler(e)

      if (e.isDefaultPrevented()) return

      var $tip = this.tip()

      this.setContent()

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement.split('-')[0]);

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var $parent = this.$element.parent()

        var orgPlacement = placement
        var docScroll    = document.documentElement.scrollTop || document.body.scrollTop
        var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth()
        var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
        var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left

        placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :
                    placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :
                    placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :
                    placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)
      this.$element.trigger('shown.bs.' + this.type)
    }
  }

  Tooltip.prototype.applyPlacement = function(offset, placement) {
    var replace
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    $tip
      .offset(offset)
      .addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      replace = true
      offset.top = offset.top + height - actualHeight
    }

    if (['top', 'bottom'].indexOf(placement.split('-')[0]) === 0) {
      var delta = 0

      if (offset.left < 0) {
        delta       = offset.left * -2
        offset.left = 0

        $tip.offset(offset)

        actualWidth  = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight
      }

      this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
    }

    if (['left', 'right'].indexOf(placement.split('-')[0]) === 0) {
      this.replaceArrow(actualHeight - height, actualHeight, 'top')
    }

    if (replace) $tip.offset(offset)
  }

  Tooltip.prototype.replaceArrow = function(delta, dimension, position) {
    this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function () {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
    }

    this.$element.triggerHandler(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one($.support.transition.end, complete)
        .emulateTransitionEnd(150) :
      complete()

    this.$element.trigger('hidden.bs.' + this.type)

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function () {
    var el = this.$element[0]
    return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
      width: el.offsetWidth
    , height: el.offsetHeight
    }, this.$element.offset())
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {

    return placement == 'left-top'     ? { top: pos.top, left: pos.left - actualWidth } :
           placement == 'left-bottom'  ? { top: pos.top + pos.height - actualHeight, left: pos.left - actualWidth } :
           placement == 'right-top'    ? { top: pos.top, left: pos.left + pos.width } :
           placement == 'right-bottom' ? { top: pos.top + pos.height - actualHeight, left: pos.left + pos.width } :
           placement == 'top-left'     ? { top: pos.top - actualHeight, left: pos.left } :
           placement == 'top-right'    ? { top: pos.top - actualHeight, left: pos.left + pos.width - actualWidth } :
           placement == 'bottom-left'  ? { top: pos.top + pos.height, left: pos.left } :
           placement == 'bottom-right' ? { top: pos.top + pos.height, left: pos.left + pos.width - actualWidth } :
           placement == 'bottom'       ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.tip = function () {
    return this.$tip = this.$tip || $(this.options.template)
  }

  Tooltip.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')
  }

  Tooltip.prototype.validate = function () {
    if (!this.$element[0].parentNode) {
      this.hide()
      this.$element = null
      this.options  = null
    }
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type) : this
    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    this.hide().$element.off('.' + this.type).removeData('bs.' + this.type)
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  var old = $.fn.tooltip

  $.fn.tooltip = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.0.3
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.DEFAULTS = $.extend({} , $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right'
  , trigger: 'click'
  , content: ''
  , template: '<div id="fd" class="fd-popover"><div class="arrow"></div><h3 class="fd-popover-title"></h3><div class="fd-popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.fd-popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.fd-popover-content')[this.options.html ? 'html' : 'text'](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.fd-popover-title').html()) $tip.find('.fd-popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.arrow')
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  var old = $.fn.popover

  $.fn.popover = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.0.3
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    var href
    var process  = $.proxy(this.process, this)

    this.$element       = $(element).is('body') ? $(window) : $(element)
    this.$body          = $('body')
    this.$scrollElement = this.$element.on('scroll.bs.scroll-spy.data-api', process)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target
      || ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
      || '') + ' .nav li > a'
    this.offsets        = $([])
    this.targets        = $([])
    this.activeTarget   = null

    this.refresh()
    this.process()
  }

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.refresh = function () {
    var offsetMethod = this.$element[0] == window ? 'offset' : 'position'

    this.offsets = $([])
    this.targets = $([])

    var self     = this
    var $targets = this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#\w/.test(href) && $(href)

        return ($href
          && $href.length
          && [[ $href[offsetMethod]().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        self.offsets.push(this[0])
        self.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight
    var maxScroll    = scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets.last()[0]) && this.activate(i)
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
        && this.activate( targets[i] )
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    $(this.selector)
      .parents('.active')
      .removeClass('active')

    var selector = this.selector
      + '[data-target="' + target + '"],'
      + this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length)  {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  var old = $.fn.scrollspy

  $.fn.scrollspy = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load', function () {
    $('[data-bs-spy="scroll"]').each(function () {
      var $spy = $(this)
      $spy.scrollspy($spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.0.3
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var previous = $ul.find('.active:last a')[0]
    var e        = $.Event('show.bs.tab', {
      relatedTarget: previous
    })

    $this.triggerHandler(e)

    if (e.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.parent('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $this.trigger({
        type: 'shown.bs.tab'
      , relatedTarget: previous
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && $active.hasClass('fade')

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
        .removeClass('active')

      element.addClass('active')

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu')) {
        element.closest('li.dropdown').addClass('active')
      }

      callback && callback()
    }

    transition ?
      $active
        .one($.support.transition.end, next)
        .emulateTransitionEnd(150) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  var old = $.fn.tab

  $.fn.tab = function ( option ) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  $(document).on('click.bs.tab.data-api', '[data-bs-toggle="tab"], [data-bs-toggle="pill"]', function (e) {
    e.preventDefault()
    $(this).tab('show')
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.0.3
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)
    this.$window = $(window)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element = $(element)
    this.affixed  =
    this.unpin    = null

    this.checkPosition()
  }

  Affix.RESET = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var scrollHeight = $(document).height()
    var scrollTop    = this.$window.scrollTop()
    var position     = this.$element.offset()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top()
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()

    var affix = this.unpin   != null && (scrollTop + this.unpin <= position.top) ? false :
                offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ? 'bottom' :
                offsetTop    != null && (scrollTop <= offsetTop) ? 'top' : false

    if (this.affixed === affix) return
    if (this.unpin) this.$element.css('top', '')

    this.affixed = affix
    this.unpin   = affix == 'bottom' ? position.top - scrollTop : null

    this.$element.removeClass(Affix.RESET).addClass('affix' + (affix ? '-' + affix : ''))

    if (affix == 'bottom') {
      this.$element.offset({ top: document.body.offsetHeight - offsetBottom - this.$element.height() })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  var old = $.fn.affix

  $.fn.affix = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-bs-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom) data.offset.bottom = data.offsetBottom
      if (data.offsetTop)    data.offset.top    = data.offsetTop

      $spy.affix(data)
    })
  })

}(jQuery);
/**
 * bootstrap-notify.js v1.0
 * --
 * http://twitter.com/nijikokun
 * Copyright 2012 Nijiko Yonskai, Goodybag
 * --
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

!function ($) {
  var Notification = function (element, options) {
    // Element collection
    this.$element = $(element);
    this.$note    = $('<div class="alert"></div>');
    this.options  = $.extend(true, $.fn.notify.defaults, options);

    // Setup from options
    if(this.options.transition)
      if(this.options.transition == 'fade')
        this.$note.addClass('in').addClass(this.options.transition);
      else this.$note.addClass(this.options.transition);
    else this.$note.addClass('fade').addClass('in');

    if(this.options.type)
      this.$note.addClass('alert-' + this.options.type);
    else this.$note.addClass('alert-success');

    if(!this.options.message && this.$element.data("message") !== '') // dom text
      this.$note.html(this.$element.data("message"));
    else
      if(typeof this.options.message === 'object')
        if(this.options.message.html)
          this.$note.html(this.options.message.html);
        else if(this.options.message.text)
          this.$note.text(this.options.message.text);
      else
        this.$note.html(this.options.message);

    if(this.options.closable)
      var link = $('<a class="close pull-right" href="javascript: void(0);">&times;</a>');
      $(link).on('click', $.proxy(onClose, this));
      this.$note.prepend(link);

    return this;
  };

  onClose = function() {
    this.options.onClose();
    $(this.$note).remove();
    this.options.onClosed();
  };

  Notification.prototype.show = function () {
    if(this.options.fadeOut.enabled)
      this.$note.delay(this.options.fadeOut.delay || 3000).fadeOut('slow', $.proxy(onClose, this));

    this.$element.append(this.$note);
    this.$note.alert();
  };

  Notification.prototype.hide = function () {
    if(this.options.fadeOut.enabled)
      this.$note.delay(this.options.fadeOut.delay || 3000).fadeOut('slow', $.proxy(onClose, this));
    else onClose.call(this);
  };

  $.fn.notify = function (options) {
    return new Notification(this, options);
  };

  $.fn.notify.defaults = {
    type: 'success',
    closable: true,
    transition: 'fade',
    fadeOut: {
      enabled: true,
      delay: 3000
    },
    message: null,
    onClose: function () {},
    onClosed: function () {}
  }
}($);

});

FD40.plugin("responsive", function($) {

// $(selector).responsive({condition});
// $(selector).responsive([{condition1}, {condition2}]);

/*var defaultOptions = {
	// main element width to calculate
	elementWidth: function() {}, // a function that returns pixel value

	// array of conditions of ascending thresholdWidth
	conditions: [{

		// threshold for this condition
		at: 0,// threshold value

		// condition specific options
		switchTo: '',// classname to apply to the node
		alsoSwitch: {
			'selector': 'class'
		}, //  objects with element and class
		switchStylesheet: '',
		whenApplied: '', // function to run
		whenRemoved: '' // reverse function that reverses any action in target function
	}]
}*/

var defaultOptions = {
	elementWidth: function(elem) {
		return elem.outerWidth(true);
	}
};

$.responsive = function(elem, options) {

	// $.responsive(elem, conditions);
	if ($.isArray(options)) {
		options = {
			conditions: options
		}
	}

	var options = $.extend({}, defaultOptions, options);

	return new Responsive(elem, options);
};

$.fn.responsive = function(conditions) {

	if (conditions) {
		$.responsive($(this), conditions);
	}

	return this;
};

var $window = $(window),
	$isFunc = $.isFunction;

var Responsive = function(elem, options) {

	var self = this;

	// If there is an existing instance, kill it.
	$(elem).each(function(){

		var elem = $(this),
			instance = $(this).data("$responsive");

		if (instance instanceof Responsive) {
			instance.destroy();
		}
	});

	// Construct instance
	$.extend(self, {
		// Accept node, selectors, jQuery elements.
		elem      : elem,
		options   : options,
		conditions: $.sortBy($.makeArray(options.conditions), function(condition){ return condition.at; }),
		event     : "resize.responsive." + $.uid(),
		handler   : $.debounce(function(){ self.set(); }, 250)
	});

	// Delete conditions prop from options
	delete options.conditions;

	// Wait until document is ready before
	// applying responsive events
	$(function(){

		// Attach resize handler to window
		$window.on(self.event, self.handler);

		// Set conditions
		self.set();
	});

	// Set conditions once again
	// on window load event.
	$(window).load(function(){

		self.set();
	});
}

$.extend(Responsive.prototype, {

	set: function() {

		var self = this,
			elementWidth = self.options.elementWidth;

		$(self.elem).each(function(){

			var elem = $(this),
				currentWidth = ($isFunc(elementWidth)) ? elementWidth(elem) : elementWidth;

			// Store instance within element
			$(elem).data("$responsive", self);

			// Remove current condition
			self.removeCondition(elem.data("currentCondition"), elem);

			// Analyze all conditions
			$.each(self.conditions, function(i, condition) {

				var thresholdWidth = condition.at;

				if (currentWidth <= thresholdWidth) {
					self.applyCondition(condition, elem);
					return false;
				}
			});
		});
	},

	applyCondition: function(condition, elem) {

		var switchTo, alsoSwitch, switchStylesheet, whenApplied;

		// Classnames to remove
		(switchTo = condition.switchTo) &&
			elem.addClass(switchTo);

		// Classnames to remove on other elements
		(alsoSwitch = condition.alsoSwitch) &&
			$.each(alsoSwitch, function(selector, classname) {
				$(selector).addClass(classname);
			});

		// Stylesheets to remove
		(switchStylesheet = condition.switchStylesheet) &&
			$.each($.makeArray(switchStylesheet), function(i, url) {
				// Load stylesheet if it hasn't been loaded.
				var stylesheet = $('link[href$="' + url + '"]');
				if (stylesheet.length < 1) {
					$('<link/>')
						.attr({
							rel : 'stylesheet',
							type: 'text/css',
							href: url
						})
						.appendTo('head');
				}
			});

		// Callback to execute when this condition is removed.
		(whenApplied = condition.whenApplied) &&
			$isFunc(whenApplied) && whenApplied();

		elem.data("currentCondition", condition)
			.trigger("responsive", [condition]);
	},

	removeCondition: function(condition, elem) {

		if (!condition) return;

		var switchTo, alsoSwitch, switchStylesheet, whenRemoved;

		// Classnames to remove
		(switchTo = condition.switchTo) &&
			elem.removeClass(switchTo);

		// Classnames to remove on other elements
		(alsoSwitch = condition.alsoSwitch) &&
			$.each(alsoSwitch, function(selector, classname) {
				$(selector).removeClass(classname);
			});

		// Stylesheets to remove
		(switchStylesheet = condition.switchStylesheet) &&
			$.each($.makeArray(switchStylesheet), function(i, url) {
				$('link[href$="' + url + '"]').remove();
			});

		// Callback to execute when this condition is removed.
		(whenRemoved = condition.whenRemoved) &&
			$isFunc(whenRemoved) && whenRemoved();

		elem.removeData("currentCondition");
	},

	resetToDefault: function(current) {

		var self = this,
			elem = $(self.elem);

		$.each(self.conditions, function(i, condition) {
			if (current && i == current) return;
			self.removeCondition(condition, elem);
		});
	},

	destroy: function() {

		if (self.destroyed) return;

		$window.off(this.event);

		var self = this;

		$(self.elem).each(function(){
			var elem = $(this);
			self.removeCondition(elem.data("currentCondition"), elem);
			elem.removeData("$responsive");
		});

		self.destroyed = true;
	}
});
});

FD40.plugin("utils", function($) {

/**
 * jquery.Bloop
 * Binary loop helper.
 * https://github.com/jstonne/jquery.Bloop
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

	var Bloop = function(items) {

		this.items = items;
		this.start = 0;
		this.end = items.length - 1;
		this.node = null;
		this.stopped = false;
	};

	$.extend(Bloop.prototype, {

		isLooping: function() {

			if (this.stopped) return false;

			if (Math.abs(this.start - this.end) > 1) {
				this.node = Math.floor((this.start + this.end) / 2);
				return true;
			}

			return false;
		},

		flip: function(flip) {

			if (flip) {
				this.end = this.node - 1;
			} else {
				this.start = this.node + 1;
			}
		},

		stop: function() {
			this.stop = true;
		}
	});


	$.Bloop = function(items){

		return new Bloop(items);
	}

})();
;/*!
 * jquery.Chunk
 * Utility to handle large arrays by processing
 * them in smaller manageable chunks.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Chunk = function(array, options) {

	if ($.isArray(array)) {
		array = [];
	}

	var options = $.extend({},
		{
			size: 256,
			every: 1000
		},
		options
	);

	var self = $.extend($.Deferred(), {

		size: options.size,

		every: options.every,

		from: 0,

		to: array.length,

		process: function(callback) {

			self.process.fn = callback;

			return self;
		},

		chunkStart: function(callback) {

			self.chunkStart.fn = callback;

			return self;
		},

		chunkEnd: function(callback) {

			self.chunkEnd.fn = callback;

			return self;
		},

		start: function() {

			self.stopped = false;

			self.iterate();

			return self;
		},

		iterate: function() {

			if (self.stopped) return;

			var iterator = self.process.fn;

			if (!iterator) return;

			self.to = from.size + self.size;

			var max = array.length;

			if (self.to > max) {

				self.to = max;
			}

			var range = {from: self.from, to: self.to};

			// Trigger chunkStart event
			self.chunkStart.fn && self.chunkStart.fn.call(self, range.from, range.to);

			while (self.from < self.to) {

				if (self.stopped) break;

				iterator.call(self, array[self.from]);

				self.from++;
			}

			// Trigger chunkEnd event
			self.chunkEnd.fn && self.chunkEnd.fn.call(self, range.from, range.to);

			// Always get the latest array length because
			// it may change through iteration
			self.completed = (self.from >= array.length - 1);

			if (self.completed) {

				self.resolveWith(self);

			} else {

				self.nextIteration = setTimeout(self.iterate, self.every);
			}

			return self;
		},

		pause: function() {

			self.stopped = true;

			clearTimeout(self.nextIteration);

			return self;
		},

		restart: function() {

			if (self.state()==="rejected") return self;

			self.from = 0;

			self.start();

			return self;
		},

		stop: function() {

			self.pause();

			self.rejectWith(self, [self.from]);

			return self;
		}
	});

	return self;
};
;/**
 * jquery.Enqueue
 * Execute only the last added callback.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(isFunction) {

	var Enqueue = function() {
		this.lastId = 0;
	};

	Enqueue.prototype.queue = function(filter) {

 		var self = this,
 			id = $.uid();
 			self.lastId = id;

		return function() {

			if (self.lastId===id) {

				var args = arguments,
					args = (isFunction(filter)) ? filter.apply(this, args) : args;

				return (isFunction(self.fn)) ? self.fn.apply(this, args) : args;
			}
		}
	};

	$.Enqueue = function(fn) {

		var self = new Enqueue();

		if (isFunction(fn)) self.fn = fn;

		var func = $.proxy(self.queue, self);

		func.reset = function() {
			self.lastId = 0;
		};

		return func;
	};
})($.isFunction);
;/**
 * jquery.Exception
 * Standardized exception object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){
    var consoleMethod = {
        error: "error",
        warning: "warn",
        success: "log",
        info: "info"
    };

    // $.Exception("message");
    // $.Exception("success", "message");
    // $.Exception("error", "message", data);
    // $.Exception({type: "info", message: "message", foo: "bar", key: "val"});
    $.Exception = function(exception) {

        // Normalize arguments
        var args = arguments,
            simple = args.length==1,
            hasData = args.length==3;

        exception = $.isPlainObject(exception) ?
            exception :
            {
                type   : simple ? "error" : args[0],
                message: simple ? args[0] : args[1]
            }

        hasData && $.extend(exception, args[2]);

        if ($.environment=="development") {
            console[consoleMethod[exception.type]](exception.message, exception);
        }

        return exception;
    }
})();;/**
 * jquery.IE
 * Returns the current IE version.
 *
 * Based on Padolsey's IE detection script.
 * https://gist.github.com/padolsey/527683
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.IE = (function(){

    // It seems Padolsey's IE detection script
    // doesn't work on IE10 and 11.
    var ua = navigator.userAgent;
    if (ua.match(/MSIE 9/)) return 9;
    if (ua.match(/MSIE 10/)) return 10;
    if (ua.match(/rv:11/i)) return 11;

    var undef,
        v = 3,
        div = document.createElement('div'),
        all = div.getElementsByTagName('i');

    while (
        v++,
        div.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->',
        all[0]
    );

    return v > 4 ? v : undef;

}());;/**
 * jquery.Task
 * Task runner utility.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Task = function(props) {

    var task = $.extend(
        $.Deferred(),
        {
            data: {},
            list: [],
            add: function(name) {

                var item = $.extend(
                    $.Deferred(),
                    {
                        name: name,
                        item: item
                    }
                );

                task.list.push(item);

                return item;
            },
            process: function() {

                if (!task._promise) {

                    task._promise =
                        $.when.apply($, task.list)
                            .then(
                                task.resolve,
                                task.reject,
                                task.progress
                            );
                }

                return task;
            }
        },
        props
    );

    return task;
};;/**
 * jquery.Threads
 * A manager that controls threads a.k.a. execution of function simultaneously.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function() {

	var Threads = function(options) {
		this.threads = [];
		this.threadCount = 0;
		this.threadLimit = options.threadLimit || 1;
		this.threadDelay = options.threadDelay || 0;
	}

	$.extend(Threads.prototype, {

		add: function(thread, type) {

			if (!$.isFunction(thread)) return;

			thread.type = type || "normal";

			if (type=="deferred") {
				thread.deferred = $.Deferred().always($.proxy(this.next, this));
			}

			this.threads.push(thread);

			this.run();
		},

		addDeferred: function(thread) {

			return this.add(thread, "deferred");
		},

		next: function() {

			// Reduce thread count
			this.threadCount--;

			// And see if there's anymore task to run
			this.run();
		},

		run: function() {

			var self = this;

			setTimeout(function(){

				if (self.threads.length < 1) return;

				if (self.threadCount < self.threadLimit) {

					self.threadCount++;

					var thread = self.threads.shift();

					// Wrap in a try catch in case if the thread
					// throws an error it doesn't break our chain.
					try { thread.call(thread, thread.deferred); }
					catch(e) { console.error(e); }

					!thread.deferred && self.next();
				}

			}, self.threadDelay);
		}
	});

	$.Threads = function(options) {

		return new Threads(options);
	};

})();
;/**
 * jquery.callback
 * Creates a global callback function that gets
 * removed from the window object after it has executed.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.callback = function(func, persist){

	// Create callback
	if ($.isFunction(func)) {

		var funcName = $.uid("cb");

		window[funcName] = function(){

			// Destroy itself after callback has been called
			if (!persist) {
				delete window[funcName];
			}

			return func.apply(null, arguments);
		}

		return funcName;
	}

	// Callback method
	if ($.isString(func)) {
		switch (func) {
			case "destroy":
				var funcName = persist;
				delete window[funcName];
				break;
		}
	}
};/**
 * jquery.fn.checkList.
 * Multiple checkbox handler.
 *
 * $(e).checkList({
 *    check  : function(){},   // callback when an input is checked
 *    uncheck: function(){},   // callback when an input is unchecked
 *
 *    // returns checked elements & unchecked elements in separate arguments
 *    change : function(checked, unchecked){}
 * })
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checkList = function(options) {

    var defaultOptions = {
        checkbox: ".checkbox",
        masterCheckbox: ".master-checkbox",
        check: function() {},
        uncheck: function() {},
        change: function() {}
    }

    var options = $.extend({}, defaultOptions, options),
        checkList       = this,
        checkboxes      = checkList.find(options.checkbox),
        masterCheckbox  = checkList.find(options.masterCheckbox),
        disableChangeEvent = false;

    var change = function() {

        if (!disableChangeEvent) {

            var checked = checkboxes.filter(':checked'),
                unchecked = checkboxes.not(':checked');

            if (checked.length < 1) {
                masterCheckbox.removeAttr("checked");
            }

            if (checked.length == checkboxes.length) {
                masterCheckbox.prop("checked", true);
            }

            options.change.call(checkList, checked, unchecked);
        }
    }

    checkboxes.checked(

        // checked
        function() {
            options.check.apply(checkList);
            change();
        },

        // unchecked
        function() {
            options.uncheck.apply(checkList);
            change();
        }
    );

    masterCheckbox.checked(

        // checked
        function() {
            disableChangeEvent = true;
            checkboxes.checked(true);
            disableChangeEvent = false;
            change();
        },

        // unchecked
        function() {
            disableChangeEvent = true;
            checkboxes.checked(false);
            disableChangeEvent = false;
            change();
        }
    );

    change();

    return this;
};;/**
 * jquery.classManip
 * Utilities to manipulate classnames.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * $.fn.switchClass
 * Swaps a classname for another classname that bears identical prefix.
 *
 * $("div").switchClass("state-busy")l;
 *
 * Before:
 * <div class="state-idle"></div>
 *
 * After:
 * <div class="state-busy"></div>
 */
$.fn.switchClass = function(classname, delimiter){

	var delimiter = delimiter || "-",
		prefix = classname.split(delimiter)[0] + delimiter,
		length = prefix.length;

	return this.each(function(){

		var $el = $(this),
			classnames =
				$.map(($el.attr("class") || "").split(" "), function(classname){
					return (classname.slice(0, length)==prefix || classname=="") ? null : classname;
				});
			classnames.push(classname);

		$el.attr("class", classnames.join(" "));
	});
};

/**
 * $.fn.activateClass
 * Add classname on current set of elements and
 * remove classname on previous set of elements.
 *
 * $(".item").find("[data-id=64]").activateClass("active");
 *
 * Before:
 * <div class="item active" data-id="62"></div>
 * <div class="item" data-id="63"></div>
 * <div class="item" data-id="64"></div>
 *
 * After:
 * <div class="item" data-id="62"></div>
 * <div class="item" data-id="63"></div>
 * <div class="item active" data-id="64"></div>
 */
$.fn.activateClass = function(className) {
    this.prevObject.removeClass(className);
    return $(this).addClass(className);
};;/**
 * jquery.color
 * Color helpers.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
(function(){

var hexToRgb = function(hex) {
    var hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
    return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
};

var hexToHsb = function(hex) {
    return rgbToHsb(hexToRgb(hex));
};

var rgbToHsb = function(rgb) {
    var hsb = {h: 0, s: 0, b: 0};
    var min = Math.min(rgb.r, rgb.g, rgb.b);
    var max = Math.max(rgb.r, rgb.g, rgb.b);
    var delta = max - min;
    hsb.b = max;
    hsb.s = max != 0 ? 255 * delta / max : 0;
    if (hsb.s != 0) {
        if (rgb.r == max) hsb.h = (rgb.g - rgb.b) / delta;
        else if (rgb.g == max) hsb.h = 2 + (rgb.b - rgb.r) / delta;
        else hsb.h = 4 + (rgb.r - rgb.g) / delta;
        hsb.h *= 60;
    } else hsb.h = 360;
    if (hsb.h < 0) hsb.h += 360;
    hsb.s *= 100/255;
    hsb.b *= 100/255;
    return hsb;
};

var hsbToRgb = function(hsb) {
    var rgb = {};
    var h = hsb.h;
    var s = hsb.s*255/100;
    var v = hsb.b*255/100;
    if(s == 0) {
        rgb.r = rgb.g = rgb.b = v;
    } else {
        var t1 = v;
        var t2 = (255-s)*v/255;
        var t3 = (t1-t2)*(h%60)/60;
        if(h==360) h = 0;
        if(h<60) {rgb.r=t1; rgb.b=t2; rgb.g=t2+t3}
        else if(h<120) {rgb.g=t1; rgb.b=t2; rgb.r=t1-t3}
        else if(h<180) {rgb.g=t1; rgb.r=t2; rgb.b=t2+t3}
        else if(h<240) {rgb.b=t1; rgb.r=t2; rgb.g=t1-t3}
        else if(h<300) {rgb.b=t1; rgb.g=t2; rgb.r=t2+t3}
        else if(h<360) {rgb.r=t1; rgb.g=t2; rgb.b=t1-t3}
        else {rgb.r=0; rgb.g=0; rgb.b=0}
    }
    return {r:Math.round(rgb.r), g:Math.round(rgb.g), b:Math.round(rgb.b)};
};

var rgbToHex = function(rgb) {
    var hex = [
        rgb.r.toString(16),
        rgb.g.toString(16),
        rgb.b.toString(16)
    ];
    $.each(hex, function (nr, val) {
        if (val.length == 1) {
            hex[nr] = '0' + val;
        }
    });
    return hex.join('');
};

var hsbToHex = function (hsb) {
    return rgbToHex(hsbToRgb(hsb));
};

var fixHsb = function (hsb) {
    return {
        h: Math.min(360, Math.max(0, hsb.h)),
        s: Math.min(100, Math.max(0, hsb.s)),
        b: Math.min(100, Math.max(0, hsb.b))
    };
};

var fixRgb = function (rgb) {
    return {
        r: Math.min(255, Math.max(0, rgb.r)),
        g: Math.min(255, Math.max(0, rgb.g)),
        b: Math.min(255, Math.max(0, rgb.b))
    };
};

var fixHex = function (hex) {
    var len = 6 - hex.length;

    if (len == 3) {
        var chars = hex.split(""), chr, hex = "";
        while (chr = chars.shift()) hex += chr + chr;
    } else {
        while (len--) hex = "0" + hex;
    }

    hex.replace(/[^A-Fa-f0-9]/g, "0");

    return hex;
};

$.extend($, {
    hexToRgb: hexToRgb,
    hexToHsb: hexToHsb,
    rgbToHsb: rgbToHsb,
    hsbToRgb: hsbToRgb,
    rgbToHex: rgbToHex,
    hsbToHex: hsbToHex,
    fixHsb: fixHsb,
    fixRgb: fixRgb,
    fixHex: fixHex
});

})();;;/**
 * jquery.fn.htmlData
 * Utilities to handle data within jQuery elements.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * jquery.fn.htmlData
 * Converts inline data attributes into objects.
 */
$.fn.htmlData = function(prefix, nested) {

    var nested = nested===undefined ? true : nested,
        re = new RegExp("^" + "data-" + (prefix ? prefix + "-" : "") + "(.*)", "i"),
        parts,
        data = {};

    // Extract options from data attributes
    $.each(this[0].attributes, function(i, attr){

        if (attr.specified && (parts = attr.name.match(re)) && parts[1]) {
            if (nested) {
                var props = parts[1].split("-"),
                    i, prop, obj = data; max = props.length - 1;

                for (i=0; i<=max; i++) {
                    prop = props[i];
                    if (i==max) {
                        obj[prop] = attr.value;
                    } else {
                        !obj[prop] && (obj[prop] = {});
                        obj = obj[prop];
                    }
                }
            } else {
                data[parts[1]] = attr.value;
            }
        }
    });

    return data;
};

/**
 * jquery.fn.defineData
 * Creates persistent data that cannot be changed.
 */
$.fn.defineData = function(name, value) {

    if (this.data(name)===undefined) {
        this.data(name, value);
    }

    return this;
};/**
 * jquery.deletes
 * Remove properties from objects.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.deletes = function(obj, props) {
    $.each(props, function(i, prop){
        delete obj[prop];
    });
};
;/**
 * jquery.fn.disabled
 * jquery.fn.enabled
 *
 * Determine if an element is disabled.
 * Also lets you disable or enable an element.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */


$.fn.disabled = function(state) {
	return (state===undefined) ?
				(this.is(":disabled") || this.hasClass('disabled')) :
				this.prop('disabled', !!state).toggleClass("disabled", !!state);
};

$.fn.enabled = function(state) {
	return (state===undefined) ? !this.disabled() : this.disabled(!state);
};
;/**
 * jquery.distinct
 * Enhanced version of jQuery.unique that also removes
 * removes object/string/integer duplicates within an array.
 * https://github.com/jstonne/jquery.distinct
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.distinct = function(items) {

	var uniqueElements = $.unique;

	if (items.length < 1) {
		return;
	};

	// If item is an array of DOM elements
	if (items[0].nodeType) {

		return uniqueElements.apply(this, arguments);
	};

	// If item is an array of objects
	if (typeof items[0]=='object') {

		var unique = Math.random(),
			uniqueObjects = [];

		$.each(items, function(i) {

			if (!items[i][unique]) {

				uniqueObjects.push(items[i]);

				items[i][unique] = true;
			}
		});

		$.each(uniqueObjects, function(i) {

			delete uniqueObjects[i][unique];
		});

		return uniqueObjects;
	};

	// Anything else (can be combination of string, integers and boolean)
	return $.grep(items, function(item, i) {

		return $.inArray(item, items) === i;
	});

};
;/**
 * jquery.fn.domManip
 * Shorthands for common DOM operations.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.tagName = function(){
    return (this[0] || {}).tagName;
};

$.create = function(tagName) {
    return $(document.createElement(tagName));
};

$.fn.editable = function(editable) {
    if ($.isUndefined(editable)) return this.prop("contenteditable")==="true";
    this.prop("contenteditable", editable);
    editable===false && this.removeAttr("contenteditable");
    return this;
};/**
 * jquery.download
 * Simulate a download programatically.
 *
 * The download url should return the correct
 * Content-Type in the response headers to work.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.download = function(src) {
    return $("<iframe>").hide().appendTo("body").bind("load", function(){$(this).remove()}).attr("src", src);
};;/**
 * jquery.eventManip
 * Utilities to handle events in jQuery.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * jquery.ns
 * Adds namespace to events.
 * $(el).on($.ns("mousedown keyup keydown", ".foobar"), function(){});
 */
$.ns = function(event, ns) {
    return event.split(" ").join(ns + " ") + ns;
};


/**
 * jquery.getPointerPosition
 * Get pointer position whether it came from mouse or touch events.
 */
$.getPointerPosition = function(event) {

    return event.type.match("touch") ?
        {
            x: event.originalEvent.changedTouches[0].pageX,
            y: event.originalEvent.changedTouches[0].pageY
        } :
        {
            x: event.pageX,
            y: event.pageY
        };
};;/**
 * jquery.eventable
 * Extend objects with simple event system.
 *
 * Requires jquery.deletes.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function() {

	var instance = "___eventable",
		publicMethods = ["on", "off", "fire"],
		getEventName = function(name){
			return name.split(".")[0];
		};

	var Eventable = function(mode) {
		this.fnList = {};
		this.events = {};
		this.mode = mode;
	}

	$.extend(
		Eventable.prototype,
		{
			createEvent: function(name) {

				return this.events[name] = $.Callbacks(this.mode);
			},

			on: function(name, fn) {

				if (!name || !$.isFunction(fn)) return this;

				var fnList = this.fnList;

				(fnList[name] || (fnList[name] = [])).push(fn);

				// Translate into base event name
				var basename = getEventName(name);

				// Add the event
				(this.events[basename] || this.createEvent(basename)).add(fn);

				return this;
			},

			off: function(name) {

				if (!name) return this;

				var basename = getEventName(name),
					event = this.events[basename];

				if (!event) return this;

				var removeCallbacks = function(fnList) {

					$.each(fnList, function(i, fn) {
						event.remove(fn);
					});
				}

				if (basename!==name) {

					$.each(this.fnList, function(name, fnList) {

						if (name.indexOf(basename) > -1) {

							removeCallbacks(fnList);
						}
					});

				} else {

					removeCallbacks(this.fnList[name]);
				}

				return this;
			},

			fire: function(name) {

				var event = this.events[name];

				if (!event) return;

				event.fire.apply(event, $.makeArray(arguments).slice(1));

				return this;
			},

			destroy: function() {
				for (name in this.events) {
					this.events[name].disable();
				}
			}
		}
	);

	$.eventable = function(obj, mode) {

		var eventable = obj[instance];

		if (eventable && mode==="destroy") {
			eventable.destroy();
			$.deletes(obj, publicMethods);
			return delete obj[instance];
		}

		eventable = obj[instance] = new Eventable(mode);

		obj.on = $.proxy(eventable.on, eventable);
		obj.off = $.proxy(eventable.off, eventable);
		obj.fire = $.proxy(eventable.fire, eventable);

		return obj;
	}

})();
;/**
 * jquery.fn.checkList.
 * Multiple checkbox handler.
 *
 * $(e).checkList({
 *    check  : function(){},   // callback when an input is checked
 *    uncheck: function(){},   // callback when an input is unchecked
 *
 *    // returns checked elements & unchecked elements in separate arguments
 *    change : function(checked, unchecked){}
 * })
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checkList = function(options) {

    var defaultOptions = {
        checkbox: ".checkbox",
        masterCheckbox: ".master-checkbox",
        check: function() {},
        uncheck: function() {},
        change: function() {}
    }

    var options = $.extend({}, defaultOptions, options),
        checkList       = this,
        checkboxes      = checkList.find(options.checkbox),
        masterCheckbox  = checkList.find(options.masterCheckbox),
        disableChangeEvent = false;

    var change = function() {

        if (!disableChangeEvent) {

            var checked = checkboxes.filter(':checked'),
                unchecked = checkboxes.not(':checked');

            if (checked.length < 1) {
                masterCheckbox.removeAttr("checked");
            }

            if (checked.length == checkboxes.length) {
                masterCheckbox.prop("checked", true);
            }

            options.change.call(checkList, checked, unchecked);
        }
    }

    checkboxes.checked(

        // checked
        function() {
            options.check.apply(checkList);
            change();
        },

        // unchecked
        function() {
            options.uncheck.apply(checkList);
            change();
        }
    );

    masterCheckbox.checked(

        // checked
        function() {
            disableChangeEvent = true;
            checkboxes.checked(true);
            disableChangeEvent = false;
            change();
        },

        // unchecked
        function() {
            disableChangeEvent = true;
            checkboxes.checked(false);
            disableChangeEvent = false;
            change();
        }
    );

    change();

    return this;
};/**
 * jquery.fn.checked
 * Checked/unchecked event handler for checkbox & radio button.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checked = function(checked, unchecked) {

	// Return checked value if no arguments are given;
	if (arguments.length < 1)
		return this.is(':checked');

	this.each(function(i) {

		var input = $(this);

		if (typeof checked == "boolean") {
			input.attr('checked', checked).trigger('change');
			return;
		}

		if (input.is('input[type=checkbox]') || input.is('input[type=radio]')) {
			input
				.off('change.checked')
				.on('change.checked', function() {
					try {
						return (input.is(':checked')) ? checked.apply(input) : unchecked.apply(input);
					} catch(e) {};
				});
		}
	});

	return this;
};
;/**
 * jquery.fn.locate
 * Locate a related child element based on data attribute.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.locate = function(key) {

    var prefix = "data";

    $.each(this[0].attributes, function(i, attr){
        if (attr.specified && attr.value==="$") {
            prefix = attr.name;
            return false;
        }
    });

    return this.find("[" + prefix + "-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + "]");
};
;/**
 * jquery.fn.noscroll
 * Disable scrollbar on elements
 * with the ability to restore it.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

    var props = ["overflow", "overflow-x", "overflow-y"];

    $.fn.noscroll = function(lock) {

        if (lock===undefined) lock = true;

        return this.each(function(){

            var el = $(this),
                overflow = el.data("noscroll");

            // No original overflow values was stored before
            if (!overflow && lock) {

                // Get the original overflow values
                overflow = {};
                $.each(props, function(i, prop){
                    overflow[prop] = el.css(prop);
                });

                // Store original values
                el.data("noscroll", overflow);
            }

            if (lock) {
                $.each(props, function(i, prop){
                    el.css(prop, "hidden");
                });
            } else {
                overflow && el.css(overflow);
            }
        });
    };

})();
;/**
* Copyright 2012, Digital Fusion
* Licensed under the MIT license.
* http://teamdf.com/jquery-plugins/license/
*
* @author Sam Sehnert
* @desc A small plugin that checks whether elements are within
* the user visible viewport of a web browser.
* only accounts for vertical position, not horizontal.
*/

$.fn.visible = function(partial) {

	var $t = $(this),
		$w = $(window);

	if ($t.length < 1) return;

	var viewTop      = $w.scrollTop(),
		viewBottom   = viewTop + $w.height(),
		_top         = $t.offset().top,
		_bottom      = _top + $t.height(),
		compareTop    = partial === true ? _bottom : _top,
		compareBottom = partial === true ? _top : _bottom;

	return ((compareBottom <= viewBottom) && (compareTop >= viewTop));
};;/**
 * jquery.fn.where
 * Filter jQuery elements by data attributes.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.where = $.fn.filterBy = function(key, val, operator) {

	var operator = operator || "=",
		selector = "[data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + operator + val + "]";

	return this.filter(selector);
};
;/**
 * jquery.formManip
 * Utilities to manipulate form elements.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

// For checkboxes and radio buttons
$.fn.checked = function(checked, unchecked) {

    // Return checked value if no arguments are given;
    if (arguments.length < 1)
        return this.is(':checked');

    this.each(function(i) {

        var input = $(this);

        if (typeof checked == "boolean") {
            input.attr('checked', checked).trigger('change');
            return;
        }

        if (input.is('input[type=checkbox]') || input.is('input[type=radio]')) {
            input
                .off('change.checked')
                .on('change.checked', function() {
                    try {
                        return (input.is(':checked')) ? checked.apply(input) : unchecked.apply(input);
                    } catch(e) {};
                });
        }
    });

    return this;
};

// For select boxes
$.fn.selectAll = function() {
    return this.each(function(){this.select()});
};

$.fn.unselect = function() {
    return this.each(function(){
        var input = this,
            value = input.value;
            input.value += " ";
            input.value = value;
    });
};;/**
 * jquery.formSerializers
 * Serializes form values to Object or JSON.
 * Utilities to manipulate html content.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.toObject = $.fn.serializeObject = function() {

	var obj = {};

	$.each($(this).serializeArray(), function(i, prop) {
		if (obj.hasOwnProperty(prop.name)) {
			// Convert it into an array
			if (!$.isArray(obj[prop.name])) {
				obj[prop.name] = [obj[prop.name]];
			}
			obj[prop.name].push(prop.value);
		} else {
			obj[prop.name] = prop.value;
		}
	});

	return obj;
};

$.fn.toJSON = $.fn.serializeJSON = function() {

	return JSON.stringify($(this).serializeObject());
};
;/**
 * jquery.htmlManip
 * Utilities to manipulate html content.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.sanitizeHTML = function(html) {
    return $($.parseHTML(html, document, true)).toHTML();
};

// This also encodes html entities.
$.toHTML = function(str) {
    return $("<div>").html(str).html();
};

$.fn.toHTML = function() {
    return $.toHTML(this.clone());
};

// Based on http://stackoverflow.com/questions/1231770/innerhtml-removes-attribute-quotes-in-internet-explorer
$.toXHTML = function(obj, maintainUppercaseTag) {

    var zz = obj.innerHTML ? String(obj.innerHTML) : obj,
        z  = zz.match(/(<.+[^>])/g);

    if (z) {
        for (var i=0; i<z.length; (i=i+1)) {

            var y,
                zSaved = z[i],
                attrRE = /\=[a-zA-Z\.\:\[\]_\(\)\&\$\%#\@\!0-9\/]+[?\s+|?>]/g;

            z[i] =
                z[i].replace(/([<|<\/].+?\w+).+[^>]/, function(a){
                    return a;
                });

            y = z[i].match(attrRE);

            if (y) {
                var j = 0,
                    len = y.length;

                while (j < len) {

                    var replaceRE = /(\=)([a-zA-Z\.\:\[\]_\(\)\&\$\%#\@\!0-9\/]+)?([\s+|?>])/g,
                        replacer = function() {
                            var args = Array.prototype.slice.call(arguments);
                            return '="' + (maintainUppercaseTag ? args[2] : args[2].toLowerCase()) + '"' + args[3];
                        };

                    z[i] = z[i].replace(y[j], y[j].replace(replaceRE,replacer));
                    j += 1;
                }
            }

            zz = zz.replace(zSaved,z[i]);
        }
    }

    return zz;
};

$.fn.xhtml = function() {
    return $.IE ? $.toXHTML(this[0]) : this.html();
};

/**
 * jquery.buildHTML
 * Converts html string into jQuery element where
 * script tags within it gets removed after it is
 * inserted into the DOM.
 *
 * Using $.buildHTML(html) over $(html) also circumvents
 * CloudFlare from modifying the execution behaviour of
 * script elements.
 */

$.buildHTML = function(html, keepScripts) {

    // If a jquery element was passed in, return as it is.
    if (html instanceof $) return html;

    var doc = document;

    // If CloudFlare exists, use document from iframe
    // because CloudFlare Rocketscript overrides native methods.
    if (window["CloudFlare"]) {

        var iframe = $.buildHTML.iframe;

        // If iframe wasn't created, or iframe was removed or detached,
        // create the iframe element again;
        if (!iframe || !iframe.contentDocument) {

            // Create iframe
            var iframe =
                $.buildHTML.iframe =
                document.createElement("iframe");

            // Hide iframe
            iframe.style.display = "none";

            // Append iframe to body
            document.body.appendChild(iframe);
        }

        doc = iframe.contentDocument;
    }

    // Trim out any whitespace so no unusable text nodes are introduced.
    var html = $.trim(html),

        // Build html fragment while keeping a separate reference to the script
        scripts = [],
        fragment = $.buildFragment([html], doc, scripts),

        // Convert childNodes into a proper array
        nodes = $.merge([], fragment.childNodes);

    // If we want to remove the script after
    // it is appended to the DOM & executed
    if (!keepScripts && scripts.length > 0) {

        // Create script remover
        var script = doc.createElement("script");
            // This is wrapped in try..catch because Cloudflare's
            // proxy node executes this twice for some reason.
            // The second time this executes, the callback has been removed,
            // so let it fail silently.
            script.text = "try{" + $.callback(function(){$(scripts).remove();}) + "();}catch(e){}";

        // Go through nodes in reverse
        var i = nodes.length-1, node, inserted;

        while (node = nodes[i--]) {

            // If a script node is found first, we'll just append
            // script remover next to it to ensure this last script
            // executes before any script removal happens.
            if (node.nodeName==="SCRIPT") {
                inserted = nodes.push(script);
            } else if (node.nodeType===1) {
                inserted = node.appendChild(script);
            }

            if (inserted) break;
        }

        // If script remover was not inserted,
        // then just add it to the array of nodes
        if (!inserted) nodes.push(script);

        // Add script remover itself to the
        // array of scripts to be removed.
        scripts.push(script);
    }

    // Convert nodes into jquery instance and return
    return $(nodes);
};;/**
 * jquery.intersects
 * jquery.fn.intersectsWith
 *
 * Determines if an area intersects with another area.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.intersects = function(a, b) {

	if ($.isArray(b)) {
	   b = {top: b.y, left: b.x, bottom: b.y, right: b.x}
	}

	return (
	   b.left <= a.right  &&
	   a.left <= b.right  &&
	   b.top  <= a.bottom &&
	   a.top  <= b.bottom
	);
};

$.fn.intersectsWith = function(top, left, width, height) {

	// TODO: intersectsWith(element)

	var offset = this.offset(),

	   reference = {
	        top   : offset.top,
	        left  : offset.left,
	        bottom: offset.top  + (sourceHeight = this.height()),
	        right : offset.left + (sourceWidth  = this.width()),
	        width : sourceWidth,
	        height: sourceHeight
	   },

	   subject = {
	        top   : top,
	        left  : left,
	        bottom: top  + (height || (height = 0)),
	        right : left + (width  || (width  = 0)),
	        width : width,
	        height: height
	   };

	return ($.intersects(reference, subject)) ? {reference: reference, subject: subject} : false;
};;/**
 * jquery.isDeferred
 * Test if an object is a jQuery Deferred object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.isDeferred = function(obj) {
	return obj && $.isFunction(obj.always);
};
;/**
 * jquery.number
 * Utilities to deal with numbers.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.isNumeric = function(n) {
	// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
	return !isNaN(parseFloat(n)) && isFinite(n);
};

$.rotateNumber = function(n, min, max, offset) {

	if (offset===undefined) {
		offset = 0;
	}

	n += offset;

	if (n < min) {
		n += max + 1;
	} else if (n > max) {
		n -= max + 1;
	}

	return n;
};;/**
 * jquery.regExpEscape
 * Makes string regex safe.
 * http://stackoverflow.com/questions/2593637/how-to-escape-regular-expression-in-javascript
 */

$.regExpEscape = function(str) {
    return str.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
}
;/**
 * jquery.remap
 * Utility for remapping properties of an object selectively from another object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.remap = function(to, from, props) {
	$.each(props, function(i, prop){
		to[prop] = from[prop];
	});
	return obj;
};
;/**
 * jquery.throttledAjax
 * jQuery AJAX with throttling.
 *
 * Requires jquery.Threads.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

var self = $.Ajax = function(options) {

    // Start ajax manually
    options.autostart = false;

	var ajax = $.ajax(options);

    self.queue
        .addDeferred(function(queue){

            // Start ajax now
            ajax.send();

    		// Mark this queue as resolved
    		setTimeout(queue.resolve, self.interval);
    	});

	return ajax;
}

self.queue    = $.Threads({threadLimit: 1});
self.interval = 1200;

// Do not throttle ajax calls on Joomla 3.2 and above.
var version = $.joomla.version.split("."),
    majorVersion = version[0],
    minorVersion = version[1];

if (majorVersion >= 3 && minorVersion >= 2) {
    self.interval = 0;
}

})();;/*!
 * jquery.transitionClass.
 * jQuery functions to invoke classnames that has CSS3 transitions.
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

// addTransitoryClass
$.fn.addTransitoryClass = function(classname, duration) {
    var elem = this.addClass(classname);
    setTimeout(function(){elem.removeClass(classname)}, duration || 1);
    return this;
};

// addClassAfter
// removeClassAfter
var classAfter = function(operation, classname, timer) {
    var elem = this;
    setTimeout(function(){elem[operation+"Class"](classname)}, timer || 50);
    return this;
};

$.fn.addClassAfter = function(classname, timer) {
    return classAfter.call(this, "add", classname, timer);
};

$.fn.removeClassAfter = function(classname, timer) {
    return classAfter.call(this, "remove", classname, timer);
};

// addTransitionClass
// removeTransitionClass
var transitionClass = function(toggle, classname, duration, callback) {
    var suffix = toggle ? "-in" : "-out";
    this.addTransitoryClass(classname.replace(/ /g, suffix + " ") + suffix, duration || 1000)
        [(toggle ? "add" : "remove") + "ClassAfter"](classname);
    callback && setTimeout(callback, duration);
    return this;
};

$.fn.addTransitionClass = function(classname, duration, callback) {
    return transitionClass.call(this, true, classname, duration, callback);
};

$.fn.removeTransitionClass = function(classname, duration, callback) {
    return transitionClass.call(this, false, classname, duration, callback);
};

})();;/**
 * jquery.trimSeparators
 * Trims whitespace and separators.
 *
 * Turns this: ",df        ,,,  ,,,abc, sdasd sdfsdf    ,   asdsad, ,, , "
 * into this : "df,abc,sdasd sdfsdf,asdsad"
 *
 * Requires jquery.distinct
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.trimSeparators = function(keyword, separator, removeDuplicates) {

	var s = separator;

	keyword = keyword
		.replace(new RegExp('^['+s+'\\s]+|['+s+',\\s]+$','g'), '') // /^[,\s]+|[,\s]+$/g
		.replace(new RegExp(s+'['+s+'\\s]*'+s,'g'), s)             // /,[,\s]*,/g
		.replace(new RegExp('[\\s]+'+s,'g'), s)                    // /[\s]+,/g
		.replace(new RegExp(s+'[\\s]+','g'), s);                   // /,[\s]+/g

	if (removeDuplicates) {
		keyword = $.distinct(keyword.split(s)).join(s);
	}

	return keyword;
};
;/**
 * jquery.uid
 * Generates a unique id with optional prefix/suffix.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.uid = function(p,s) {
	return ((p) ? p : '') + Math.random().toString().replace('.','') + ((s) ? s : '');
};

});

FD40.plugin("storage", function($) {


	var store = {},
		win = window,
		doc = document,
		localStorageName = 'localStorage',
		scriptTag = 'script',
		storage

	store.disabled = false
	store.set = function(key, value) {}
	store.get = function(key) {}
	store.remove = function(key) {}
	store.clear = function() {}
	store.transact = function(key, defaultVal, transactionFn) {
		var val = store.get(key)
		if (transactionFn == null) {
			transactionFn = defaultVal
			defaultVal = null
		}
		if (typeof val == 'undefined') { val = defaultVal || {} }
		transactionFn(val)
		store.set(key, val)
	}
	store.getAll = function() {}
	store.forEach = function() {}

	store.serialize = function(value) {
		return JSON.stringify(value)
	}
	store.deserialize = function(value) {
		if (typeof value != 'string') { return undefined }
		try { return JSON.parse(value) }
		catch(e) { return value || undefined }
	}

	// Functions to encapsulate questionable FireFox 3.6.13 behavior
	// when about.config::dom.storage.enabled === false
	// See https://github.com/marcuswestin/store.js/issues#issue/13
	function isLocalStorageNameSupported() {
		try { return (localStorageName in win && win[localStorageName]) }
		catch(err) { return false }
	}

	if (isLocalStorageNameSupported()) {
		storage = win[localStorageName]
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key) }
			storage.setItem(key, store.serialize(val))
			return val
		}
		store.get = function(key) { return store.deserialize(storage.getItem(key)) }
		store.remove = function(key) { storage.removeItem(key) }
		store.clear = function() { storage.clear() }
		store.getAll = function() {
			var ret = {}
			store.forEach(function(key, val) {
				ret[key] = val
			})
			return ret
		}
		store.forEach = function(callback) {
			for (var i=0; i<storage.length; i++) {
				var key = storage.key(i)
				callback(key, store.get(key))
			}
		}
	} else if (doc.documentElement.addBehavior) {
		var storageOwner,
			storageContainer
		// Since #userData storage applies only to specific paths, we need to
		// somehow link our data to a specific path.  We choose /favicon.ico
		// as a pretty safe option, since all browsers already make a request to
		// this URL anyway and being a 404 will not hurt us here.  We wrap an
		// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
		// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
		// since the iframe access rules appear to allow direct access and
		// manipulation of the document element, even for a 404 page.  This
		// document can be used instead of the current document (which would
		// have been limited to the current path) to perform #userData storage.
		try {
			storageContainer = new ActiveXObject('htmlfile')
			storageContainer.open()
			storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>')
			storageContainer.close()
			storageOwner = storageContainer.w.frames[0].document
			storage = storageOwner.createElement('div')
		} catch(e) {
			// somehow ActiveXObject instantiation failed (perhaps some special
			// security settings or otherwse), fall back to per-path storage
			storage = doc.createElement('div')
			storageOwner = doc.body
		}
		function withIEStorage(storeFunction) {
			return function() {
				var args = Array.prototype.slice.call(arguments, 0)
				args.unshift(storage)
				// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
				// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
				storageOwner.appendChild(storage)
				storage.addBehavior('#default#userData')
				storage.load(localStorageName)
				var result = storeFunction.apply(store, args)
				storageOwner.removeChild(storage)
				return result
			}
		}

		// In IE7, keys cannot start with a digit or contain certain chars.
		// See https://github.com/marcuswestin/store.js/issues/40
		// See https://github.com/marcuswestin/store.js/issues/83
		var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
		function ieKeyFix(key) {
			return key.replace(/^d/, '___$&').replace(forbiddenCharsRegex, '___')
		}
		store.set = withIEStorage(function(storage, key, val) {
			key = ieKeyFix(key)
			if (val === undefined) { return store.remove(key) }
			storage.setAttribute(key, store.serialize(val))
			storage.save(localStorageName)
			return val
		})
		store.get = withIEStorage(function(storage, key) {
			key = ieKeyFix(key)
			return store.deserialize(storage.getAttribute(key))
		})
		store.remove = withIEStorage(function(storage, key) {
			key = ieKeyFix(key)
			storage.removeAttribute(key)
			storage.save(localStorageName)
		})
		store.clear = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes
			storage.load(localStorageName)
			for (var i=0, attr; attr=attributes[i]; i++) {
				storage.removeAttribute(attr.name)
			}
			storage.save(localStorageName)
		})
		store.getAll = function(storage) {
			var ret = {}
			store.forEach(function(key, val) {
				ret[key] = val
			})
			return ret
		}
		store.forEach = withIEStorage(function(storage, callback) {
			var attributes = storage.XMLDocument.documentElement.attributes
			for (var i=0, attr; attr=attributes[i]; ++i) {
				callback(attr.name, store.deserialize(storage.getAttribute(attr.name)))
			}
		})
	}

	try {
		var testKey = '__storejs__'
		store.set(testKey, testKey)
		if (store.get(testKey) != testKey) { store.disabled = true }
		store.remove(testKey)
	} catch(e) {
		store.disabled = true
	}
	store.enabled = !store.disabled

	$.Storage = store;
});

FD40.plugin("uri", function($) {

$.isUrl = function(s)
{
	var regexp = /^(http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
	return regexp.test(s);
};


var Query = function (queryString) {

    // query string parsing, parameter manipulation and stringification

    'use strict';

    var // parseQuery(q) parses the uri query string and returns a multi-dimensional array of the components
        parseQuery = function (q) {
            var arr = [], i, ps, p, kvp, k, v;

            if (typeof (q) === 'undefined' || q === null || q === '') {
                return arr;
            }

            if (q.indexOf('?') === 0) {
                q = q.substring(1);
            }

            ps = q.toString().split(/[&;]/);

            for (i = 0; i < ps.length; i++) {
                p = ps[i];
                kvp = p.split('=');
                k = kvp[0];
                v = p.indexOf('=') === -1 ? null : (kvp[1] === null ? '' : kvp[1]);
                arr.push([k, v]);
            }

            return arr;
        },

        params = parseQuery(queryString),

        // toString() returns a string representation of the internal state of the object
        toString = function () {
            var s = '', i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (s.length > 0) {
                    s += '&';
                }
                if (param[1] === null) {
                  s += param[0];
                }
                else {
                  s += param.join('=');
                }
            }
            return s.length > 0 ? '?' + s : s;
        },

        decode = function (s) {
            s = decodeURIComponent(s);
            s = s.replace('+', ' ');
            return s;
        },

        // getParamValues(key) returns the first query param value found for the key 'key'
        getParamValue = function (key) {
            var param, i;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (decode(key) === decode(param[0])) {
                    return param[1];
                }
            }
        },

        // getParamValues(key) returns an array of query param values for the key 'key'
        getParamValues = function (key) {
            var arr = [], i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (decode(key) === decode(param[0])) {
                    arr.push(param[1]);
                }
            }
            return arr;
        },

        // deleteParam(key) removes all instances of parameters named (key)
        // deleteParam(key, val) removes all instances where the value matches (val)
        deleteParam = function (key, val) {

            var arr = [], i, param, keyMatchesFilter, valMatchesFilter;

            for (i = 0; i < params.length; i++) {

                param = params[i];
                keyMatchesFilter = decode(param[0]) === decode(key);
                valMatchesFilter = decode(param[1]) === decode(val);

                if ((arguments.length === 1 && !keyMatchesFilter) || (arguments.length === 2 && !keyMatchesFilter && !valMatchesFilter)) {
                    arr.push(param);
                }
            }

            params = arr;

            return this;
        },

        // addParam(key, val) Adds an element to the end of the list of query parameters
        // addParam(key, val, index) adds the param at the specified position (index)
        addParam = function (key, val, index) {

            if (arguments.length === 3 && index !== -1) {
                index = Math.min(index, params.length);
                params.splice(index, 0, [key, val]);
            } else if (arguments.length > 0) {
                params.push([key, val]);
            }
            return this;
        },

        // replaceParam(key, newVal) deletes all instances of params named (key) and replaces them with the new single value
        // replaceParam(key, newVal, oldVal) deletes only instances of params named (key) with the value (val) and replaces them with the new single value
        // this function attempts to preserve query param ordering
        replaceParam = function (key, newVal, oldVal) {

            var index = -1, i, param;

            if (arguments.length === 3) {
                for (i = 0; i < params.length; i++) {
                    param = params[i];
                    if (decode(param[0]) === decode(key) && decodeURIComponent(param[1]) === decode(oldVal)) {
                        index = i;
                        break;
                    }
                }
                deleteParam(key, oldVal).addParam(key, newVal, index);
            } else {
                for (i = 0; i < params.length; i++) {
                    param = params[i];
                    if (decode(param[0]) === decode(key)) {
                        index = i;
                        break;
                    }
                }
                deleteParam(key);
                addParam(key, newVal, index);
            }
            return this;
        };

    // public api
    return {
        getParamValue: getParamValue,
        getParamValues: getParamValues,
        deleteParam: deleteParam,
        addParam: addParam,
        replaceParam: replaceParam,

        toString: toString
    };
};
var Uri = function (uriString) {

    // uri string parsing, attribute manipulation and stringification

    'use strict';

    /*global Query: true */
    /*jslint regexp: false, plusplus: false */

    var strictMode = false,

        urlExtractor = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi,

        // parseUri(str) parses the supplied uri and returns an object containing its components
        parseUri = function (str) {

            /*jslint unparam: true */
            var parsers = {
                    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                },
                keys = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                q = {
                    name: "queryKey",
                    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                },
                m = parsers[strictMode ? "strict" : "loose"].exec(str),
                uri = {},
                i = 14;

            while (i--) {
                uri[keys[i]] = m[i] || "";
            }

            uri[q.name] = {};
            uri[keys[12]].replace(q.parser, function ($0, $1, $2) {
                if ($1) {
                    uri[q.name][$1] = $2;
                }
            });

            return uri;
        },

        uriParts = parseUri(uriString || ''),

        queryObj = new Query(uriParts.query),


        /*
            Basic get/set functions for all properties
        */

        protocol = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.protocol = val;
            }
            return uriParts.protocol;
        },

        hasAuthorityPrefixUserPref = null,

        // hasAuthorityPrefix: if there is no protocol, the leading // can be enabled or disabled
        hasAuthorityPrefix = function (val) {

            if (typeof val !== 'undefined') {
                hasAuthorityPrefixUserPref = val;
            }

            if (hasAuthorityPrefixUserPref === null) {
                return (uriParts.source.indexOf('//') !== -1);
            } else {
                return hasAuthorityPrefixUserPref;
            }
        },

        userInfo = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.userInfo = val;
            }
            return uriParts.userInfo;
        },

        host = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.host = val;
            }
            return uriParts.host;
        },

        port = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.port = val;
            }
            return uriParts.port;
        },

        path = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.path = val;
            }
            return uriParts.path;
        },

        query = function (val) {
            if (typeof val !== 'undefined') {
                queryObj = new Query(val);
            }
            return queryObj;
        },

        anchor = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.anchor = val;
            }
            return uriParts.anchor;
        },


        /*
            Fluent setters for Uri uri properties
        */

        setProtocol = function (val) {
            protocol(val);
            return this;
        },

        setHasAuthorityPrefix = function (val) {
            hasAuthorityPrefix(val);
            return this;
        },

        setUserInfo = function (val) {
            userInfo(val);
            return this;
        },

        setHost = function (val) {
            host(val);
            return this;
        },

        setPort = function (val) {
            port(val);
            return this;
        },

        setPath = function (val) {
            path(val);
            return this;
        },

        setQuery = function (val) {
            query(val);
            return this;
        },

        setAnchor = function (val) {
            anchor(val);
            return this;
        },

        /*
            Query method wrappers
        */
        getQueryParamValue = function (key) {
            return query().getParamValue(key);
        },

        getQueryParamValues = function (key) {
            return query().getParamValues(key);
        },

        deleteQueryParam = function (key, val) {
            if (arguments.length === 2) {
                query().deleteParam(key, val);
            } else {
                query().deleteParam(key);
            }

            return this;
        },

        addQueryParam = function (key, val, index) {
            if (arguments.length === 3) {
                query().addParam(key, val, index);
            } else {
                query().addParam(key, val);
            }
            return this;
        },

        replaceQueryParam = function (key, newVal, oldVal) {
            if (arguments.length === 3) {
                query().replaceParam(key, newVal, oldVal);
            } else {
                query().replaceParam(key, newVal);
            }

            return this;
        },

        /*
            Converters
        */

        // toPath() converts a relative path into its absolute path, e.g.
        //
        // Current path:  /foo/bar/today
        // Relative path: ../tomorrow
        // Result:        /foo/bar/tomorrow

        toPath = function (val) {
            if (val===undefined) {
                return uriParts.path;
            }

            // If relative path starts with '/'
            if (val.substring(0,1)=='/') {
                return uriParts.path = val;
            }

            var base_path = uriParts.path.split('/'),
                rel_path = val.split('/');

            if (base_path.slice(-1)[0]==='') {
                base_path.pop();
            }

            var part;
            while (part = rel_path.shift()) {
                switch (part) {
                    case '..':
                        if (base_path.length > 1) {
                            base_path.pop();
                        }
                        break;

                    case '.':
                        // skip
                        break;

                    default:
                        base_path.push(part);
                }
            }

            uriParts.path = base_path.join('/');

            return this;
        },

        /*
            Serialization
        */

        // toString() stringifies the current state of the uri
        toString = function () {

            var s = '',
                is = function (s) {
                    return (s !== null && s !== '');
                };

            if (is(protocol())) {
                s += protocol();
                if (protocol().indexOf(':') !== protocol().length - 1) {
                    s += ':';
                }
                s += '//';
            } else {
                if (hasAuthorityPrefix() && is(host())) {
                    s += '//';
                }
            }

            if (is(userInfo()) && is(host())) {
                s += userInfo();
                if (userInfo().indexOf('@') !== userInfo().length - 1) {
                    s += '@';
                }
            }

            if (is(host())) {
                s += host();
                if (is(port())) {
                    s += ':' + port();
                }
            }

            if (is(path())) {
                s += path();
            } else {
                if (is(host()) && (is(query().toString()) || is(anchor()))) {
                    s += '/';
                }
            }
            if (is(query().toString())) {
                if (query().toString().indexOf('?') !== 0) {
                    s += '?';
                }
                s += query().toString();
            }

            if (is(anchor())) {
                if (anchor().indexOf('#') !== 0) {
                    s += '#';
                }
                s += anchor();
            }

            return s;
        },

        extract = function(i) {
            var urls = uriString.match(urlExtractor) || [];
            return (i===undefined) ? urls : (urls[i] || "");
        },

        /*
            Cloning
        */

        // clone() returns a new, identical Uri instance
        clone = function () {
            return new Uri(toString());
        };

    // public api
    return {

        protocol: protocol,
        hasAuthorityPrefix: hasAuthorityPrefix,
        userInfo: userInfo,
        host: host,
        port: port,
        path: path,
        query: query,
        anchor: anchor,

        setProtocol: setProtocol,
        setHasAuthorityPrefix: setHasAuthorityPrefix,
        setUserInfo: setUserInfo,
        setHost: setHost,
        setPort: setPort,
        setPath: setPath,
        setQuery: setQuery,
        setAnchor: setAnchor,

        getQueryParamValue: getQueryParamValue,
        getQueryParamValues: getQueryParamValues,
        deleteQueryParam: deleteQueryParam,
        addQueryParam: addQueryParam,
        replaceQueryParam: replaceQueryParam,
        extract: extract,

        toPath: toPath,

        toString: toString,
        clone: clone
    };
};
$.uri = function (s) {
    return new Uri(s);
}

});

FD40.plugin("mvc", function($) {

(function(){
	// Several of the methods in this plugin use code adapated from Prototype
	//  Prototype JavaScript framework, version 1.6.0.1
	//  (c) 2005-2007 Sam Stephenson
	var regs = {
		undHash: /_|-/,
		colons: /::/,
		words: /([A-Z]+)([A-Z][a-z])/g,
		lowUp: /([a-z\d])([A-Z])/g,
		dash: /([a-z\d])([A-Z])/g,
		replacer: /\{([^\}]+)\}/g,
		dot: /\./
	},
		// gets the nextPart property from current
		// add - if true and nextPart doesnt exist, create it as an empty object
		getNext = function(current, nextPart, add){
			return current[nextPart] !== undefined ? current[nextPart] : ( add && (current[nextPart] = {}) );
		},
		// returns true if the object can have properties (no nulls)
		isContainer = function(current){
			var type = typeof current;
			return current && ( type == 'function' || type == 'object' );
		},
		// a reference
		getObject,
		/**
		 * @class jQuery.String
		 * @parent jquerymx.lang
		 *
		 * A collection of useful string helpers. Available helpers are:
		 * <ul>
		 *   <li>[jQuery.String.capitalize|capitalize]: Capitalizes a string (some_string &raquo; Some_string)</li>
		 *   <li>[jQuery.String.camelize|camelize]: Capitalizes a string from something undercored
		 *       (some_string &raquo; someString, some-string &raquo; someString)</li>
		 *   <li>[jQuery.String.classize|classize]: Like [jQuery.String.camelize|camelize],
		 *       but the first part is also capitalized (some_string &raquo; SomeString)</li>
		 *   <li>[jQuery.String.niceName|niceName]: Like [jQuery.String.classize|classize], but a space separates each 'word' (some_string &raquo; Some String)</li>
		 *   <li>[jQuery.String.underscore|underscore]: Underscores a string (SomeString &raquo; some_string)</li>
		 *   <li>[jQuery.String.sub|sub]: Returns a string with {param} replaced values from data.
		 *       <code><pre>
		 *       $.String.sub("foo {bar}",{bar: "far"})
		 *       //-> "foo far"</pre></code>
		 *   </li>
		 * </ul>
		 *
		 */

		str = $.String = $.extend($.String || {} , {


			/**
			 * @function getObject
			 * Gets an object from a string.  It can also modify objects on the
			 * 'object path' by removing or adding properties.
			 *
			 *     Foo = {Bar: {Zar: {"Ted"}}}
		 	 *     $.String.getObject("Foo.Bar.Zar") //-> "Ted"
			 *
			 * @param {String} name the name of the object to look for
			 * @param {Array} [roots] an array of root objects to look for the
			 *   name.  If roots is not provided, the window is used.
			 * @param {Boolean} [add] true to add missing objects to
			 *  the path. false to remove found properties. undefined to
			 *  not modify the root object
			 * @return {Object} The object.
			 */
			getObject : getObject = function( name, roots, add ) {

				// the parts of the name we are looking up
				// ['App','Models','Recipe']
				var parts = name ? name.split(regs.dot) : [],
					length =  parts.length,
					current,
					ret,
					i,
					r = 0,
					type;

				// make sure roots is an array
				roots = $.isArray(roots) ? roots : [roots || window];

				if(length == 0){
					return roots[0];
				}
				// for each root, mark it as current
				while( current = roots[r++] ) {
					// walk current to the 2nd to last object
					// or until there is not a container
					for (i =0; i < length - 1 && isContainer(current); i++ ) {
						current = getNext(current, parts[i], add);
					}
					// if we can get a property from the 2nd to last object
					if( isContainer(current) ) {

						// get (and possibly set) the property
						ret = getNext(current, parts[i], add);

						// if there is a value, we exit
						if( ret !== undefined ) {
							// if add is false, delete the property
							if ( add === false ) {
								delete current[parts[i]];
							}
							return ret;

						}
					}
				}
			},
			/**
			 * Capitalizes a string
			 * @param {String} s the string.
			 * @return {String} a string with the first character capitalized.
			 */
			capitalize: function( s, cache ) {
				return s.charAt(0).toUpperCase() + s.substr(1);
			},
			/**
			 * Capitalizes a string from something undercored. Examples:
			 * @codestart
			 * jQuery.String.camelize("one_two") //-> "oneTwo"
			 * "three-four".camelize() //-> threeFour
			 * @codeend
			 * @param {String} s
			 * @return {String} a the camelized string
			 */
			camelize: function( s ) {
				s = str.classize(s);
				return s.charAt(0).toLowerCase() + s.substr(1);
			},
			/**
			 * Like [jQuery.String.camelize|camelize], but the first part is also capitalized
			 * @param {String} s
			 * @return {String} the classized string
			 */
			classize: function( s , join) {
				var parts = s.split(regs.undHash),
					i = 0;
				for (; i < parts.length; i++ ) {
					parts[i] = str.capitalize(parts[i]);
				}

				return parts.join(join || '');
			},
			/**
			 * Like [jQuery.String.classize|classize], but a space separates each 'word'
			 * @codestart
			 * jQuery.String.niceName("one_two") //-> "One Two"
			 * @codeend
			 * @param {String} s
			 * @return {String} the niceName
			 */
			niceName: function( s ) {
				return str.classize(s,' ');
			},

			/**
			 * Underscores a string.
			 * @codestart
			 * jQuery.String.underscore("OneTwo") //-> "one_two"
			 * @codeend
			 * @param {String} s
			 * @return {String} the underscored string
			 */
			underscore: function( s ) {
				return s.replace(regs.colons, '/').replace(regs.words, '$1_$2').replace(regs.lowUp, '$1_$2').replace(regs.dash, '_').toLowerCase();
			},
			/**
			 * Returns a string with {param} replaced values from data.
			 *
			 *     $.String.sub("foo {bar}",{bar: "far"})
			 *     //-> "foo far"
			 *
			 * @param {String} s The string to replace
			 * @param {Object} data The data to be used to look for properties.  If it's an array, multiple
			 * objects can be used.
			 * @param {Boolean} [remove] if a match is found, remove the property from the object
			 */
			sub: function( s, data, remove ) {
				var obs = [];
				obs.push(s.replace(regs.replacer, function( whole, inside ) {

					// !-- FOUNDRY HACK --! //
					// Prefer {foobar} over foobar

					//convert inside to type
					var ob = getObject(whole, data, typeof remove == 'boolean' ? !remove : remove) ||
							 getObject(inside, data, typeof remove == 'boolean' ? !remove : remove),
						type = typeof ob;

					if ((type === 'object' || type === 'function') && type !== null) {
						obs.push(ob);
						return "";
					} else {
						return ""+ob;
					}
				}));
				return obs.length <= 1 ? obs[0] : obs;
			},
			_regs : regs
		});

	// !-- FOUNDRY HACK --! //
	// Expose string methods to $.
	$.extend($, str);
})();(function(){
	/**
	 * @add jQuery.String
	 */
	$.String.
	/**
	 * Splits a string with a regex correctly cross browser
	 * 
	 *     $.String.rsplit("a.b.c.d", /\./) //-> ['a','b','c','d']
	 * 
	 * @param {String} string The string to split
	 * @param {RegExp} regex A regular expression
	 * @return {Array} An array of strings
	 */
	rsplit = function( string, regex ) {
		var result = regex.exec(string),
			retArr = [],
			first_idx, last_idx;
		while ( result !== null ) {
			first_idx = result.index;
			last_idx = regex.lastIndex;
			if ( first_idx !== 0 ) {
				retArr.push(string.substring(0, first_idx));
				string = string.slice(first_idx);
			}
			retArr.push(result[0]);
			string = string.slice(result[0].length);
			result = regex.exec(string);
		}
		if ( string !== '' ) {
			retArr.push(string);
		}
		return retArr;
	};
})();(function(){
	
	var digitTest = /^\d+$/,
		keyBreaker = /([^\[\]]+)|(\[\])/g,
		plus = /\+/g,
		paramTest = /([^?#]*)(#.*)?$/;
	
	/**
	 * @add jQuery.String
	 */
	$.String = $.extend($.String || {}, { 
		
		/**
		 * @function deparam
		 * 
		 * Takes a string of name value pairs and returns a Object literal that represents those params.
		 * 
		 * @param {String} params a string like <code>"foo=bar&person[age]=3"</code>
		 * @return {Object} A JavaScript Object that represents the params:
		 * 
		 *     {
		 *       foo: "bar",
		 *       person: {
		 *         age: "3"
		 *       }
		 *     }
		 */
		deparam: function(params){
		
			if(! params || ! paramTest.test(params) ) {
				return {};
			} 
		   
		
			var data = {},
				pairs = params.split('&'),
				current;
				
			for(var i=0; i < pairs.length; i++){
				current = data;
				var pair = pairs[i].split('=');
				
				// if we find foo=1+1=2
				if(pair.length != 2) { 
					pair = [pair[0], pair.slice(1).join("=")]
				}
				  
        var key = decodeURIComponent(pair[0].replace(plus, " ")), 
          value = decodeURIComponent(pair[1].replace(plus, " ")),
					parts = key.match(keyBreaker);
		
				for ( var j = 0; j < parts.length - 1; j++ ) {
					var part = parts[j];
					if (!current[part] ) {
						// if what we are pointing to looks like an array
						current[part] = digitTest.test(parts[j+1]) || parts[j+1] == "[]" ? [] : {}
					}
					current = current[part];
				}
				lastPart = parts[parts.length - 1];
				if(lastPart == "[]"){
					current.push(value)
				}else{
					current[lastPart] = value;
				}
			}
			return data;
		}
	});
	
})();(function(){
	/**
	 * @attribute destroyed
	 * @parent specialevents
	 * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/dom/destroyed/destroyed.js
	 * @test jquery/event/destroyed/qunit.html
	 * Provides a destroyed event on an element.
	 * <p>
	 * The destroyed event is called when the element
	 * is removed as a result of jQuery DOM manipulators like remove, html,
	 * replaceWith, etc. Destroyed events do not bubble, so make sure you don't use live or delegate with destroyed
	 * events.
	 * </p>
	 * <h2>Quick Example</h2>
	 * @codestart
	 * $(".foo").bind("destroyed", function(){
	 *    //clean up code
	 * })
	 * @codeend
	 * <h2>Quick Demo</h2>
	 * @demo jquery/event/destroyed/destroyed.html
	 * <h2>More Involved Demo</h2>
	 * @demo jquery/event/destroyed/destroyed_menu.html
	 */

	var oldClean = $.cleanData;

	$.cleanData = function( elems ) {
		for ( var i = 0, elem;
		(elem = elems[i]) !== undefined; i++ ) {
			$(elem).triggerHandler("destroyed");
			//$.event.remove( elem, 'destroyed' );
		}
		oldClean(elems);
	};

})();(function(){
	/**
	 * @function closest
	 * @parent dom
	 * @plugin jquery/dom/closest
	 * Overwrites closest to allow open > selectors.  This allows controller
	 * actions such as:
	 *
	 *     ">li click" : function( el, ev ) { ... }
	 */
	var oldClosest = $.fn._closest = $.fn.closest;
	$.fn.closest = function(selectors, context){

		// FOUNDRY_HACK
		// If a jQuery or node element was passed in, use original closest method.
		if (selectors instanceof $ || $.isElement(selectors)) {
			return oldClosest.call(this, arguments);
		}

		var rooted = {}, res, result, thing, i, j, selector, rootedIsEmpty = true, selector, selectorsArr = selectors;
		if(typeof selectors == "string") selectorsArr = [selectors];

		$.each(selectorsArr, function(i, selector){
		    if(selector.indexOf(">") == 0 ){
				if(selector.indexOf(" ") != -1){
					throw " closest does not work with > followed by spaces!"
				}
				rooted[( selectorsArr[i] = selector.substr(1)  )] = selector;
				if(typeof selectors == "string") selectors = selector.substr(1);
				rootedIsEmpty = false;
			}
		})

		res = oldClosest.call(this, selectors, context);

		if(rootedIsEmpty) return res;
		i =0;
		while(i < res.length){
			result = res[i], selector = result.selector;
			if (rooted[selector] !== undefined) {
				result.selector = rooted[selector];
				rooted[selector] = false;
				if(typeof result.selector !== "string"  || result.elem.parentNode !== context ){
					res.splice(i,1);
						continue;
				}
			}
			i++;
		}
		return res;
	}
})();(function(){
    // break
    /**
     * @function jQuery.cookie
     * @parent dom
     * @plugin jquery/dom/cookie
     * @author Klaus Hartl/klaus.hartl@stilbuero.de
     *
     *  JavaScriptMVC's packaged cookie plugin is written by
     *  Klaus Hartl (stilbuero.de)<br />
	 *  Dual licensed under the MIT and GPL licenses:<br />
	 *  http://www.opensource.org/licenses/mit-license.php<br />
	 *  http://www.gnu.org/licenses/gpl.html
	 *  </p>
	 *  <p>
	 *  Create a cookie with the given name and value and other optional parameters.
	 *  / Get the value of a cookie with the given name.
	 *  </p>
	 *  <h3>Quick Examples</h3>
	 *
	 *  Set the value of a cookie.
	 *
	 *     $.cookie('the_cookie', 'the_value');
	 *
	 *  Create a cookie with all available options.
	 *  @codestart
	 *  $.cookie('the_cookie', 'the_value',
	 *  { expires: 7, path: '/', domain: 'jquery.com', secure: true });
	 *  @codeend
	 *
	 *  Create a session cookie.
	 *  @codestart
	 *  $.cookie('the_cookie', 'the_value');
	 *  @codeend
	 *
	 *  Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
	 *  used when the cookie was set.
	 *  @codestart
	 *  $.cookie('the_cookie', null);
	 *  @codeend
	 *
	 *  Get the value of a cookie.
	 *  @codestart
	 *  $.cookie('the_cookie');
	 *  @codeend
	 *
     *
     * @param {String} [name] The name of the cookie.
     * @param {String} [value] The value of the cookie.
     * @param {Object} [options] An object literal containing key/value pairs to provide optional cookie attributes.<br />
     * @param {Number|Date} [expires] Either an integer specifying the expiration date from now on in days or a Date object.
     *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
     *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
     *                             when the the browser exits.<br />
     * @param {String} [path] The value of the path atribute of the cookie (default: path of page that created the cookie).<br />
     * @param {String} [domain] The value of the domain attribute of the cookie (default: domain of page that created the cookie).<br />
     * @param {Boolean} secure If true, the secure attribute of the cookie will be set and the cookie transmission will
     *                        require a secure protocol (like HTTPS).<br />
     * @return {String} the value of the cookie or {undefined} when setting the cookie.
     */
    $.cookie = function(name, value, options) {
        if (typeof value != 'undefined') { // name and value given, set cookie
            options = options ||
            {};
            if (value === null) {
                value = '';
                options.expires = -1;
            }
            if (typeof value == 'object' && jQuery.toJSON) {
                value = jQuery.toJSON(value);
            }
            var expires = '';
            if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
                var date;
                if (typeof options.expires == 'number') {
                    date = new Date();
                    date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
                }
                else {
                    date = options.expires;
                }
                expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
            }
            // CAUTION: Needed to parenthesize options.path and options.domain
            // in the following expressions, otherwise they evaluate to undefined
            // in the packed version for some reason...
            var path = options.path ? '; path=' + (options.path) : '';
            var domain = options.domain ? '; domain=' + (options.domain) : '';
            var secure = options.secure ? '; secure' : '';
            document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
        }
        else { // only name given, get cookie
            var cookieValue = null;
            if (document.cookie && document.cookie != '') {
                var cookies = document.cookie.split(';');
                for (var i = 0; i < cookies.length; i++) {
                    var cookie = jQuery.trim(cookies[i]);
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) == (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            if (jQuery.evalJSON && cookieValue && cookieValue.match(/^\s*\{/)) {
                try {
                    cookieValue = jQuery.evalJSON(cookieValue);
                }
                catch (e) {
                }
            }
            return cookieValue;
        }
    };

})();(function(){

	// =============== HELPERS =================

	    // if we are initializing a new class
	var initializing = false,
		makeArray = $.makeArray,
		isFunction = $.isFunction,
		isArray = $.isArray,
		extend = $.extend,
		getObject = $.String.getObject,
		concatArgs = function(arr, args){
			return arr.concat(makeArray(args));
		},

		// tests if we can get super in .toString()
		fnTest = /xyz/.test(function() {
			xyz;
		}) ? /\b_super\b/ : /.*/,

		// overwrites an object with methods, sets up _super
		//   newProps - new properties
		//   oldProps - where the old properties might be
		//   addTo - what we are adding to
		inheritProps = function( newProps, oldProps, addTo ) {
			addTo = addTo || newProps
			for ( var name in newProps ) {
				// Check if we're overwriting an existing function
				addTo[name] = isFunction(newProps[name]) &&
							  isFunction(oldProps[name]) &&
							  fnTest.test(newProps[name]) ? (function( name, fn ) {
					return function() {
						var tmp = this._super,
							ret;

						// Add a new ._super() method that is the same method
						// but on the super-class
						this._super = oldProps[name];

						// The method only need to be bound temporarily, so we
						// remove it when we're done executing
						ret = fn.apply(this, arguments);
						this._super = tmp;
						return ret;
					};
				})(name, newProps[name]) : newProps[name];
			}
		},
		STR_PROTOTYPE = 'prototype'

	/**
	 * @class jQuery.Class
	 * @plugin jquery/class
	 * @parent jquerymx
	 * @download dist/jquery/jquery.class.js
	 * @test jquery/class/qunit.html
	 * @description Easy inheritance in JavaScript.
	 *
	 * Class provides simulated inheritance in JavaScript. Use clss to bridge the gap between
	 * jQuery's functional programming style and Object Oriented Programming. It
	 * is based off John Resig's [http://ejohn.org/blog/simple-javascript-inheritance/|Simple Class]
	 * Inheritance library.  Besides prototypal inheritance, it includes a few important features:
	 *
	 *   - Static inheritance
	 *   - Introspection
	 *   - Namespaces
	 *   - Setup and initialization methods
	 *   - Easy callback function creation
	 *
	 *
	 * The [mvc.class Get Started with jQueryMX] has a good walkthrough of $.Class.
	 *
	 * ## Static v. Prototype
	 *
	 * Before learning about Class, it's important to
	 * understand the difference between
	 * a class's __static__ and __prototype__ properties.
	 *
	 *     //STATIC
	 *     MyClass.staticProperty  //shared property
	 *
	 *     //PROTOTYPE
	 *     myclass = new MyClass()
	 *     myclass.prototypeMethod() //instance method
	 *
	 * A static (or class) property is on the Class constructor
	 * function itself
	 * and can be thought of being shared by all instances of the
	 * Class. Prototype propertes are available only on instances of the Class.
	 *
	 * ## A Basic Class
	 *
	 * The following creates a Monster class with a
	 * name (for introspection), static, and prototype members.
	 * Every time a monster instance is created, the static
	 * count is incremented.
	 *
	 * @codestart
	 * $.Class('Monster',
	 * /* @static *|
	 * {
	 *   count: 0
	 * },
	 * /* @prototype *|
	 * {
	 *   init: function( name ) {
	 *
	 *     // saves name on the monster instance
	 *     this.name = name;
	 *
	 *     // sets the health
	 *     this.health = 10;
	 *
	 *     // increments count
	 *     this.constructor.count++;
	 *   },
	 *   eat: function( smallChildren ){
	 *     this.health += smallChildren;
	 *   },
	 *   fight: function() {
	 *     this.health -= 2;
	 *   }
	 * });
	 *
	 * hydra = new Monster('hydra');
	 *
	 * dragon = new Monster('dragon');
	 *
	 * hydra.name        // -> hydra
	 * Monster.count     // -> 2
	 * Monster.shortName // -> 'Monster'
	 *
	 * hydra.eat(2);     // health = 12
	 *
	 * dragon.fight();   // health = 8
	 *
	 * @codeend
	 *
	 *
	 * Notice that the prototype <b>init</b> function is called when a new instance of Monster is created.
	 *
	 *
	 * ## Inheritance
	 *
	 * When a class is extended, all static and prototype properties are available on the new class.
	 * If you overwrite a function, you can call the base class's function by calling
	 * <code>this._super</code>.  Lets create a SeaMonster class.  SeaMonsters are less
	 * efficient at eating small children, but more powerful fighters.
	 *
	 *
	 *     Monster("SeaMonster",{
	 *       eat: function( smallChildren ) {
	 *         this._super(smallChildren / 2);
	 *       },
	 *       fight: function() {
	 *         this.health -= 1;
	 *       }
	 *     });
	 *
	 *     lockNess = new SeaMonster('Lock Ness');
	 *     lockNess.eat(4);   //health = 12
	 *     lockNess.fight();  //health = 11
	 *
	 * ### Static property inheritance
	 *
	 * You can also inherit static properties in the same way:
	 *
	 *     $.Class("First",
	 *     {
	 *         staticMethod: function() { return 1;}
	 *     },{})
	 *
	 *     First("Second",{
	 *         staticMethod: function() { return this._super()+1;}
	 *     },{})
	 *
	 *     Second.staticMethod() // -> 2
	 *
	 * ## Namespaces
	 *
	 * Namespaces are a good idea! We encourage you to namespace all of your code.
	 * It makes it possible to drop your code into another app without problems.
	 * Making a namespaced class is easy:
	 *
	 *
	 *     $.Class("MyNamespace.MyClass",{},{});
	 *
	 *     new MyNamespace.MyClass()
	 *
	 *
	 * <h2 id='introspection'>Introspection</h2>
	 *
	 * Often, it's nice to create classes whose name helps determine functionality.  Ruby on
	 * Rails's [http://api.rubyonrails.org/classes/ActiveRecord/Base.html|ActiveRecord] ORM class
	 * is a great example of this.  Unfortunately, JavaScript doesn't have a way of determining
	 * an object's name, so the developer must provide a name.  Class fixes this by taking a String name for the class.
	 *
	 *     $.Class("MyOrg.MyClass",{},{})
	 *     MyOrg.MyClass.shortName //-> 'MyClass'
	 *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
	 *
	 * The fullName (with namespaces) and the shortName (without namespaces) are added to the Class's
	 * static properties.
	 *
	 *
	 * ## Setup and initialization methods
	 *
	 * <p>
	 * Class provides static and prototype initialization functions.
	 * These come in two flavors - setup and init.
	 * Setup is called before init and
	 * can be used to 'normalize' init's arguments.
	 * </p>
	 * <div class='whisper'>PRO TIP: Typically, you don't need setup methods in your classes. Use Init instead.
	 * Reserve setup methods for when you need to do complex pre-processing of your class before init is called.
	 *
	 * </div>
	 * @codestart
	 * $.Class("MyClass",
	 * {
	 *   setup: function() {} //static setup
	 *   init: function() {} //static constructor
	 * },
	 * {
	 *   setup: function() {} //prototype setup
	 *   init: function() {} //prototype constructor
	 * })
	 * @codeend
	 *
	 * ### Setup
	 *
	 * Setup functions are called before init functions.  Static setup functions are passed
	 * the base class followed by arguments passed to the extend function.
	 * Prototype static functions are passed the Class constructor
	 * function arguments.
	 *
	 * If a setup function returns an array, that array will be used as the arguments
	 * for the following init method.  This provides setup functions the ability to normalize
	 * arguments passed to the init constructors.  They are also excellent places
	 * to put setup code you want to almost always run.
	 *
	 *
	 * The following is similar to how [jQuery.Controller.prototype.setup]
	 * makes sure init is always called with a jQuery element and merged options
	 * even if it is passed a raw
	 * HTMLElement and no second parameter.
	 *
	 *     $.Class("jQuery.Controller",{
	 *       ...
	 *     },{
	 *       setup: function( el, options ) {
	 *         ...
	 *         return [$(el),
	 *                 $.extend(true,
	 *                    this.Class.defaults,
	 *                    options || {} ) ]
	 *       }
	 *     })
	 *
	 * Typically, you won't need to make or overwrite setup functions.
	 *
	 * ### Init
	 *
	 * Init functions are called after setup functions.
	 * Typically, they receive the same arguments
	 * as their preceding setup function.  The Foo class's <code>init</code> method
	 * gets called in the following example:
	 *
	 *     $.Class("Foo", {
	 *       init: function( arg1, arg2, arg3 ) {
	 *         this.sum = arg1+arg2+arg3;
	 *       }
	 *     })
	 *     var foo = new Foo(1,2,3);
	 *     foo.sum //-> 6
	 *
	 * ## Proxies
	 *
	 * Similar to jQuery's proxy method, Class provides a
	 * [jQuery.Class.static.proxy proxy]
	 * function that returns a callback to a method that will always
	 * have
	 * <code>this</code> set to the class or instance of the class.
	 *
	 *
	 * The following example uses this.proxy to make sure
	 * <code>this.name</code> is available in <code>show</code>.
	 *
	 *     $.Class("Todo",{
	 *       init: function( name ) {
	 *       	this.name = name
	 *       },
	 *       get: function() {
	 *         $.get("/stuff",this.proxy('show'))
	 *       },
	 *       show: function( txt ) {
	 *         alert(this.name+txt)
	 *       }
	 *     })
	 *     new Todo("Trash").get()
	 *
	 * Callback is available as a static and prototype method.
	 *
	 * ##  Demo
	 *
	 * @demo jquery/class/class.html
	 *
	 *
	 * @constructor
	 *
	 * To create a Class call:
	 *
	 *     $.Class( [NAME , STATIC,] PROTOTYPE ) -> Class
	 *
	 * <div class='params'>
	 *   <div class='param'><label>NAME</label><code>{optional:String}</code>
	 *   <p>If provided, this sets the shortName and fullName of the
	 *      class and adds it and any necessary namespaces to the
	 *      window object.</p>
	 *   </div>
	 *   <div class='param'><label>STATIC</label><code>{optional:Object}</code>
	 *   <p>If provided, this creates static properties and methods
	 *   on the class.</p>
	 *   </div>
	 *   <div class='param'><label>PROTOTYPE</label><code>{Object}</code>
	 *   <p>Creates prototype methods on the class.</p>
	 *   </div>
	 * </div>
	 *
	 * When a Class is created, the static [jQuery.Class.static.setup setup]
	 * and [jQuery.Class.static.init init]  methods are called.
	 *
	 * To create an instance of a Class, call:
	 *
	 *     new Class([args ... ]) -> instance
	 *
	 * The created instance will have all the
	 * prototype properties and methods defined by the PROTOTYPE object.
	 *
	 * When an instance is created, the prototype [jQuery.Class.prototype.setup setup]
	 * and [jQuery.Class.prototype.init init]  methods
	 * are called.
	 */

	clss = $.Class = function() {
		if (arguments.length) {
			clss.extend.apply(clss, arguments);
		}
	};

	/* @Static*/
	extend(clss, {
		/**
		 * @function proxy
		 * Returns a callback function for a function on this Class.
		 * Proxy ensures that 'this' is set appropriately.
		 * @codestart
		 * $.Class("MyClass",{
		 *     getData: function() {
		 *         this.showing = null;
		 *         $.get("data.json",this.proxy('gotData'),'json')
		 *     },
		 *     gotData: function( data ) {
		 *         this.showing = data;
		 *     }
		 * },{});
		 * MyClass.showData();
		 * @codeend
		 * <h2>Currying Arguments</h2>
		 * Additional arguments to proxy will fill in arguments on the returning function.
		 * @codestart
		 * $.Class("MyClass",{
		 *    getData: function( <b>callback</b> ) {
		 *      $.get("data.json",this.proxy('process',<b>callback</b>),'json');
		 *    },
		 *    process: function( <b>callback</b>, jsonData ) { //callback is added as first argument
		 *        jsonData.processed = true;
		 *        callback(jsonData);
		 *    }
		 * },{});
		 * MyClass.getData(showDataFunc)
		 * @codeend
		 * <h2>Nesting Functions</h2>
		 * Proxy can take an array of functions to call as
		 * the first argument.  When the returned callback function
		 * is called each function in the array is passed the return value of the prior function.  This is often used
		 * to eliminate currying initial arguments.
		 * @codestart
		 * $.Class("MyClass",{
		 *    getData: function( callback ) {
		 *      //calls process, then callback with value from process
		 *      $.get("data.json",this.proxy(['process2',callback]),'json')
		 *    },
		 *    process2: function( type,jsonData ) {
		 *        jsonData.processed = true;
		 *        return [jsonData];
		 *    }
		 * },{});
		 * MyClass.getData(showDataFunc);
		 * @codeend
		 * @param {String|Array} fname If a string, it represents the function to be called.
		 * If it is an array, it will call each function in order and pass the return value of the prior function to the
		 * next function.
		 * @return {Function} the callback function.
		 */
		proxy: function( funcs ) {

			//args that should be curried
			var args = makeArray(arguments),
				self;

			// get the functions to callback
			funcs = args.shift();

			// if there is only one function, make funcs into an array
			if (!isArray(funcs) ) {
				funcs = [funcs];
			}

			// keep a reference to us in self
			self = this;

			
			return function class_cb() {
				// add the arguments after the curried args
				var cur = concatArgs(args, arguments),
					isString,
					length = funcs.length,
					f = 0,
					func;

				// go through each function to call back
				for (; f < length; f++ ) {
					func = funcs[f];
					if (!func ) {
						continue;
					}

					// set called with the name of the function on self (this is how this.view works)
					isString = typeof func == "string";
					if ( isString && self._set_called ) {
						self.called = func;
					}

					// call the function
					cur = (isString ? self[func] : func).apply(self, cur || []);

					// pass the result to the next function (if there is a next function)
					if ( f < length - 1 ) {
						cur = !isArray(cur) || cur._use_call ? [cur] : cur
					}
				}
				return cur;
			}
		},
		/**
		 * @function newInstance
		 * Creates a new instance of the class.  This method is useful for creating new instances
		 * with arbitrary parameters.
		 * <h3>Example</h3>
		 * @codestart
		 * $.Class("MyClass",{},{})
		 * var mc = MyClass.newInstance.apply(null, new Array(parseInt(Math.random()*10,10))
		 * @codeend
		 * @return {class} instance of the class
		 */
		newInstance: function() {
			// get a raw instance objet (init is not called)
			var inst = this.rawInstance(),
				args;

			// call setup if there is a setup
			if ( inst.setup ) {
				args = inst.setup.apply(inst, arguments);
			}
			// call init if there is an init, if setup returned args, use those as the arguments
			if ( inst.init ) {
				inst.init.apply(inst, isArray(args) ? args : arguments);
			}
			return inst;
		},
		/**
		 * Setup gets called on the inherting class with the base class followed by the
		 * inheriting class's raw properties.
		 *
		 * Setup will deeply extend a static defaults property on the base class with
		 * properties on the base class.  For example:
		 *
		 *     $.Class("MyBase",{
		 *       defaults : {
		 *         foo: 'bar'
		 *       }
		 *     },{})
		 *
		 *     MyBase("Inheriting",{
		 *       defaults : {
		 *         newProp : 'newVal'
		 *       }
		 *     },{}
		 *
		 *     Inheriting.defaults -> {foo: 'bar', 'newProp': 'newVal'}
		 *
		 * @param {Object} baseClass the base class that is being inherited from
		 * @param {String} fullName the name of the new class
		 * @param {Object} staticProps the static properties of the new class
		 * @param {Object} protoProps the prototype properties of the new class
		 */
		setup: function( baseClass, fullName ) {
			// set defaults as the merger of the parent defaults and this object's defaults
			this.defaults = extend(true, {}, baseClass.defaults, this.defaults);
			return arguments;
		},
		rawInstance: function() {
			// prevent running init
			initializing = true;
			var inst = new this();
			initializing = false;
			// allow running init
			return inst;
		},
		/**
		 * Extends a class with new static and prototype functions.  There are a variety of ways
		 * to use extend:
		 *
		 *     // with className, static and prototype functions
		 *     $.Class('Task',{ STATIC },{ PROTOTYPE })
		 *     // with just classname and prototype functions
		 *     $.Class('Task',{ PROTOTYPE })
		 *     // with just a className
		 *     $.Class('Task')
		 *
		 * You no longer have to use <code>.extend</code>.  Instead, you can pass those options directly to
		 * $.Class (and any inheriting classes):
		 *
		 *     // with className, static and prototype functions
		 *     $.Class('Task',{ STATIC },{ PROTOTYPE })
		 *     // with just classname and prototype functions
		 *     $.Class('Task',{ PROTOTYPE })
		 *     // with just a className
		 *     $.Class('Task')
		 *
		 * @param {String} [fullName]  the classes name (used for classes w/ introspection)
		 * @param {Object} [klass]  the new classes static/class functions
		 * @param {Object} [proto]  the new classes prototype functions
		 *
		 * @return {jQuery.Class} returns the new class
		 */
		extend: function( fullName, klass, proto ) {
			// figure out what was passed and normalize it
			if ( typeof fullName != 'string' ) {
				proto = klass;
				klass = fullName;
				fullName = null;
			}
			if (!proto ) {
				proto = klass;
				klass = null;
			}

			proto = proto || {};
			var _super_class = this,
				_super = this[STR_PROTOTYPE],
				name, shortName, namespace, prototype;

			// Instantiate a base class (but only create the instance,
			// don't run the init constructor)
			initializing = true;
			prototype = new this();
			initializing = false;

			// Copy the properties over onto the new prototype
			inheritProps(proto, _super, prototype);

			// The dummy class constructor
			function Class() {
				// All construction is actually done in the init method
				if ( initializing ) return;

				// we are being called w/o new, we are extending
				if ( this.constructor !== Class && arguments.length ) {
					return arguments.callee.extend.apply(arguments.callee, arguments)
				} else { //we are being called w/ new
					return this.Class.newInstance.apply(this.Class, arguments)
				}
			}
			// Copy old stuff onto class
			for ( name in this ) {
				if ( this.hasOwnProperty(name) ) {
					Class[name] = this[name];
				}
			}

			// copy new static props on class
			inheritProps(klass, this, Class);

			// do namespace stuff
			if ( fullName ) {

				var root;
				if (klass && klass.root) {
					root = klass.root;
					if ($.isString(root)) {
						root = getObject(root, window, true);
					}
				}

				var parts = fullName.split(/\./),
					shortName = parts.pop(),
					current = getObject(parts.join('.'), root || window, true),
					namespace = current;

				

				// !-- FOUNDRY HACK --! //
				// Inherit any existing properties from the namespace where Class is being assigned to.
				extend(true, Class, current[shortName]);

				current[shortName] = Class;
			}

			// set things that can't be overwritten
			extend(Class, {
				prototype: prototype,
				/**
				 * @attribute namespace
				 * The namespaces object
				 *
				 *     $.Class("MyOrg.MyClass",{},{})
				 *     MyOrg.MyClass.namespace //-> MyOrg
				 *
				 */
				namespace: namespace,
				/**
				 * @attribute shortName
				 * The name of the class without its namespace, provided for introspection purposes.
				 *
				 *     $.Class("MyOrg.MyClass",{},{})
				 *     MyOrg.MyClass.shortName //-> 'MyClass'
				 *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
				 *
				 */
				shortName: shortName,
				constructor: Class,
				/**
				 * @attribute fullName
				 * The full name of the class, including namespace, provided for introspection purposes.
				 *
				 *     $.Class("MyOrg.MyClass",{},{})
				 *     MyOrg.MyClass.shortName //-> 'MyClass'
				 *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
				 *
				 */
				fullName: fullName
			});

			//make sure our prototype looks nice
			Class[STR_PROTOTYPE].Class = Class[STR_PROTOTYPE].constructor = Class;



			// call the class setup
			var args = Class.setup.apply(Class, concatArgs([_super_class],arguments));

			// call the class init
			if ( Class.init ) {
				Class.init.apply(Class, args || concatArgs([_super_class],arguments));
			}

			/* @Prototype*/
			return Class;
			/**
			 * @function setup
			 * If a setup method is provided, it is called when a new
			 * instances is created.  It gets passed the same arguments that
			 * were given to the Class constructor function (<code> new Class( arguments ... )</code>).
			 *
			 *     $.Class("MyClass",
			 *     {
			 *        setup: function( val ) {
			 *           this.val = val;
			 *         }
			 *     })
			 *     var mc = new MyClass("Check Check")
			 *     mc.val //-> 'Check Check'
			 *
			 * Setup is called before [jQuery.Class.prototype.init init].  If setup
			 * return an array, those arguments will be used for init.
			 *
			 *     $.Class("jQuery.Controller",{
			 *       setup : function(htmlElement, rawOptions){
			 *         return [$(htmlElement),
			 *                   $.extend({}, this.Class.defaults, rawOptions )]
			 *       }
			 *     })
			 *
			 * <div class='whisper'>PRO TIP:
			 * Setup functions are used to normalize constructor arguments and provide a place for
			 * setup code that extending classes don't have to remember to call _super to
			 * run.
			 * </div>
			 *
			 * Setup is not defined on $.Class itself, so calling super in inherting classes
			 * will break.  Don't do the following:
			 *
			 *     $.Class("Thing",{
			 *       setup : function(){
			 *         this._super(); // breaks!
			 *       }
			 *     })
			 *
			 * @return {Array|undefined} If an array is return, [jQuery.Class.prototype.init] is
			 * called with those arguments; otherwise, the original arguments are used.
			 */
			//break up
			/**
			 * @function init
			 * If an <code>init</code> method is provided, it gets called when a new instance
			 * is created.  Init gets called after [jQuery.Class.prototype.setup setup], typically with the
			 * same arguments passed to the Class
			 * constructor: (<code> new Class( arguments ... )</code>).
			 *
			 *     $.Class("MyClass",
			 *     {
			 *        init: function( val ) {
			 *           this.val = val;
			 *        }
			 *     })
			 *     var mc = new MyClass(1)
			 *     mc.val //-> 1
			 *
			 * [jQuery.Class.prototype.setup Setup] is able to modify the arguments passed to init.  Read
			 * about it there.
			 *
			 */
			//Breaks up code
			/**
			 * @attribute constructor
			 *
			 * A reference to the Class (or constructor function).  This allows you to access
			 * a class's static properties from an instance.
			 *
			 * ### Quick Example
			 *
			 *     // a class with a static property
			 *     $.Class("MyClass", {staticProperty : true}, {});
			 *
			 *     // a new instance of myClass
			 *     var mc1 = new MyClass();
			 *
			 *     // read the static property from the instance:
			 *     mc1.constructor.staticProperty //-> true
			 *
			 * Getting static properties with the constructor property, like
			 * [jQuery.Class.static.fullName fullName], is very common.
			 *
			 */
		}

	})





	clss.callback = clss[STR_PROTOTYPE].callback = clss[STR_PROTOTYPE].
	/**
	 * @function proxy
	 * Returns a method that sets 'this' to the current instance.  This does the same thing as
	 * and is described better in [jQuery.Class.static.proxy].
	 * The only difference is this proxy works
	 * on a instance instead of a class.
	 * @param {String|Array} fname If a string, it represents the function to be called.
	 * If it is an array, it will call each function in order and pass the return value of the prior function to the
	 * next function.
	 * @return {Function} the callback function
	 */
	proxy = clss.proxy;


})();(function(){
	// ------- HELPER FUNCTIONS  ------

	// Binds an element, returns a function that unbinds
	var bind = function( el, ev, callback, eventData ) {
		var wrappedCallback,
			binder = el.bind && el.unbind ? el : $(isFunction(el) ? [el] : el);
		//this is for events like >click.
		if ( ev.indexOf(">") === 0 ) {
			ev = ev.substr(1);
			wrappedCallback = function( event ) {
				if ( event.target === el ) {
					callback.apply(this, arguments);
				}
			};
		}
		// !-- FOUNDRY HACK --! //
		// Support for passing event data
		if (eventData) {
			binder.bind(ev, eventData, wrappedCallback || callback);
		} else {
			binder.bind(ev, wrappedCallback || callback);
		}
		// if ev name has >, change the name and bind
		// in the wrapped callback, check that the element matches the actual element
		return function() {
			binder.unbind(ev, wrappedCallback || callback);
			el = ev = callback = wrappedCallback = null;
		};
	},
		makeArray = $.makeArray,
		isArray = $.isArray,
		isFunction = $.isFunction,
		isString = $.isString,
		extend = $.extend,
		Str = $.String,
		each = $.each,
		getObject = Str.getObject,

		STR_PROTOTYPE = 'prototype',
		STR_CONSTRUCTOR = 'constructor',
		slice = Array[STR_PROTOTYPE].slice,

		// Binds an element, returns a function that unbinds
		delegate = function( el, selector, ev, callback, eventData ) {

			// !-- FOUNDRY HACK --! //
			// Make event delegation work with direct child selector
			if ( selector.indexOf(">") === 0 ) {
				selector = (el.data("directSelector") + " " || "") + selector;
			}

			var binder = el.delegate && el.undelegate ? el : $(isFunction(el) ? [el] : el)

			// !-- FOUNDRY HACK --! //
			// Support for passing event data
			if (eventData) {
				binder.delegate(selector, ev, eventData, callback);
			} else {
				binder.delegate(selector, ev, callback);
			}

			return function() {
				binder.undelegate(selector, ev, callback);
				binder = el = ev = callback = selector = null;
			};
		},

		// calls bind or unbind depending if there is a selector
		binder = function( el, ev, callback, selector, eventData ) {
			// !-- FOUNDRY HACK --! //
			// Support for passing event data
			return selector ? delegate(el, selector, ev, callback, eventData) : bind(el, ev, callback, eventData);
		},

		// moves 'this' to the first argument, wraps it with jQuery if it's an element
		shifter = function shifter(context, name) {
			var method = typeof name == "string" ? context[name] : name;

			// !-- FOUNDRY HACK --! //
			// Support for passing event data
			if (isArray(method) && isFunction(method[1])) {
				method = method[1];
			}

			return function() {
				context.called = name;
    			return method.apply(context, [this.nodeName ? $(this) : this].concat( slice.call(arguments, 0) ) );
			};
		},
		// matches dots
		dotsReg = /\./g,
		// matches controller
		controllersReg = /_?controllers?/ig,
		//used to remove the controller from the name
		underscoreAndRemoveController = function( className ) {
			return Str.underscore(className.replace($.globalNamespace + ".", "").replace(dotsReg, '_').replace(controllersReg, ""));
		},
		// checks if it looks like an action
		// actionMatcher = /[^\w]/,

		// !-- FOUNDRY HACK --! //
		// Prevent inclusion of single word property name that starts with a symbol, e.g. $family from MooTools.
		// This is coming from an environment where jQuery and MooTools may coexist.
		actionMatcher = /^\S(.*)\s(.*)/,

		// handles parameterized action names
		parameterReplacer = /\{([^\}]+)\}/g,
		controllerReplacer = /\{([^\.]+[\.][^\.]+)\}/g,
		breaker = /^(?:(.*?)\s)?([\w\.\:>]+)$/,
		basicProcessor,
		data = function(el, data){
			return $.data(el, "controllers", data)
		};
	/**
	 * @class jQuery.Controller
	 * @parent jquerymx
	 * @plugin jquery/controller
	 * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/controller/controller.js
	 * @test jquery/controller/qunit.html
	 * @inherits jQuery.Class
	 * @description jQuery widget factory.
	 *
	 * jQuery.Controller helps create organized, memory-leak free, rapidly performing
	 * jQuery widgets.  Its extreme flexibility allows it to serve as both
	 * a traditional View and a traditional Controller.
	 *
	 * This means it is used to
	 * create things like tabs, grids, and contextmenus as well as
	 * organizing them into higher-order business rules.
	 *
	 * Controllers make your code deterministic, reusable, organized and can tear themselves
	 * down auto-magically. Read about [http://jupiterjs.com/news/writing-the-perfect-jquery-plugin
	 * the theory behind controller] and
	 * a [http://jupiterjs.com/news/organize-jquery-widgets-with-jquery-controller walkthrough of its features]
	 * on Jupiter's blog. [mvc.controller Get Started with jQueryMX] also has a great walkthrough.
	 *
	 * Controller inherits from [jQuery.Class $.Class] and makes heavy use of
	 * [http://api.jquery.com/delegate/ event delegation]. Make sure
	 * you understand these concepts before using it.
	 *
	 * ## Basic Example
	 *
	 * Instead of
	 *
	 *
	 *     $(function(){
	 *       $('#tabs').click(someCallbackFunction1)
	 *       $('#tabs .tab').click(someCallbackFunction2)
	 *       $('#tabs .delete click').click(someCallbackFunction3)
	 *     });
	 *
	 * do this
	 *
	 *     $.Controller('Tabs',{
	 *       click: function() {...},
	 *       '.tab click' : function() {...},
	 *       '.delete click' : function() {...}
	 *     })
	 *     $('#tabs').tabs();
	 *
	 *
	 * ## Tabs Example
	 *
	 * @demo jquery/controller/controller.html
	 *
	 * ## Using Controller
	 *
	 * Controller helps you build and organize jQuery plugins.  It can be used
	 * to build simple widgets, like a slider, or organize multiple
	 * widgets into something greater.
	 *
	 * To understand how to use Controller, you need to understand
	 * the typical lifecycle of a jQuery widget and how that maps to
	 * controller's functionality:
	 *
	 * ### A controller class is created.
	 *
	 *     $.Controller("MyWidget",
	 *     {
	 *       defaults :  {
	 *         message : "Remove Me"
	 *       }
	 *     },
	 *     {
	 *       init : function(rawEl, rawOptions){
	 *         this.element.append(
	 *            "<div>"+this.options.message+"</div>"
	 *           );
	 *       },
	 *       "div click" : function(div, ev){
	 *         div.remove();
	 *       }
	 *     })
	 *
	 * This creates a <code>$.fn.my_widget</code> jQuery helper function
	 * that can be used to create a new controller instance on an element. Find
	 * more information [jquery.controller.plugin  here] about the plugin gets created
	 * and the rules around its name.
	 *
	 * ### An instance of controller is created on an element
	 *
	 *     $('.thing').my_widget(options) // calls new MyWidget(el, options)
	 *
	 * This calls <code>new MyWidget(el, options)</code> on
	 * each <code>'.thing'</code> element.
	 *
	 * When a new [jQuery.Class Class] instance is created, it calls the class's
	 * prototype setup and init methods. Controller's [jQuery.Controller.prototype.setup setup]
	 * method:
	 *
	 *  - Sets [jQuery.Controller.prototype.element this.element] and adds the controller's name to element's className.
	 *  - Merges passed in options with defaults object and sets it as [jQuery.Controller.prototype.options this.options]
	 *  - Saves a reference to the controller in <code>$.data</code>.
	 *  - [jquery.controller.listening Binds all event handler methods].
	 *
	 *
	 * ### The controller responds to events
	 *
	 * Typically, Controller event handlers are automatically bound.  However, there are
	 * multiple ways to [jquery.controller.listening listen to events] with a controller.
	 *
	 * Once an event does happen, the callback function is always called with 'this'
	 * referencing the controller instance.  This makes it easy to use helper functions and
	 * save state on the controller.
	 *
	 *
	 * ### The widget is destroyed
	 *
	 * If the element is removed from the page, the
	 * controller's [jQuery.Controller.prototype.destroy] method is called.
	 * This is a great place to put any additional teardown functionality.
	 *
	 * You can also teardown a controller programatically like:
	 *
	 *     $('.thing').my_widget('destroy');
	 *
	 * ## Todos Example
	 *
	 * Lets look at a very basic example -
	 * a list of todos and a button you want to click to create a new todo.
	 * Your HTML might look like:
	 *
	 * @codestart html
	 * &lt;div id='todos'>
	 *  &lt;ol>
	 *    &lt;li class="todo">Laundry&lt;/li>
	 *    &lt;li class="todo">Dishes&lt;/li>
	 *    &lt;li class="todo">Walk Dog&lt;/li>
	 *  &lt;/ol>
	 *  &lt;a class="create">Create&lt;/a>
	 * &lt;/div>
	 * @codeend
	 *
	 * To add a mousover effect and create todos, your controller might look like:
	 *
	 *     $.Controller('Todos',{
	 *       ".todo mouseover" : function( el, ev ) {
	 *         el.css("backgroundColor","red")
	 *       },
	 *       ".todo mouseout" : function( el, ev ) {
	 *         el.css("backgroundColor","")
	 *       },
	 *       ".create click" : function() {
	 *         this.find("ol").append("<li class='todo'>New Todo</li>");
	 *       }
	 *     })
	 *
	 * Now that you've created the controller class, you've must attach the event handlers on the '#todos' div by
	 * creating [jQuery.Controller.prototype.setup|a new controller instance].  There are 2 ways of doing this.
	 *
	 * @codestart
	 * //1. Create a new controller directly:
	 * new Todos($('#todos'));
	 * //2. Use jQuery function
	 * $('#todos').todos();
	 * @codeend
	 *
	 * ## Controller Initialization
	 *
	 * It can be extremely useful to add an init method with
	 * setup functionality for your widget.
	 *
	 * In the following example, I create a controller that when created, will put a message as the content of the element:
	 *
	 *     $.Controller("SpecialController",
	 *     {
	 *       init: function( el, message ) {
	 *         this.element.html(message)
	 *       }
	 *     })
	 *     $(".special").special("Hello World")
	 *
	 * ## Removing Controllers
	 *
	 * Controller removal is built into jQuery.  So to remove a controller, you just have to remove its element:
	 *
	 * @codestart
	 * $(".special_controller").remove()
	 * $("#containsControllers").html("")
	 * @codeend
	 *
	 * It's important to note that if you use raw DOM methods (<code>innerHTML, removeChild</code>), the controllers won't be destroyed.
	 *
	 * If you just want to remove controller functionality, call destroy on the controller instance:
	 *
	 * @codestart
	 * $(".special_controller").controller().destroy()
	 * @codeend
	 *
	 * ## Accessing Controllers
	 *
	 * Often you need to get a reference to a controller, there are a few ways of doing that.  For the
	 * following example, we assume there are 2 elements with <code>className="special"</code>.
	 *
	 * @codestart
	 * //creates 2 foo controllers
	 * $(".special").foo()
	 *
	 * //creates 2 bar controllers
	 * $(".special").bar()
	 *
	 * //gets all controllers on all elements:
	 * $(".special").controllers() //-> [foo, bar, foo, bar]
	 *
	 * //gets only foo controllers
	 * $(".special").controllers(FooController) //-> [foo, foo]
	 *
	 * //gets all bar controllers
	 * $(".special").controllers(BarController) //-> [bar, bar]
	 *
	 * //gets first controller
	 * $(".special").controller() //-> foo
	 *
	 * //gets foo controller via data
	 * $(".special").data("controllers")["FooController"] //-> foo
	 * @codeend
	 *
	 * ## Calling methods on Controllers
	 *
	 * Once you have a reference to an element, you can call methods on it.  However, Controller has
	 * a few shortcuts:
	 *
	 * @codestart
	 * //creates foo controller
	 * $(".special").foo({name: "value"})
	 *
	 * //calls FooController.prototype.update
	 * $(".special").foo({name: "value2"})
	 *
	 * //calls FooController.prototype.bar
	 * $(".special").foo("bar","something I want to pass")
	 * @codeend
	 *
	 * These methods let you call one controller from another controller.
	 *
	 */
	var controllerRoot = $.globalNamespace + ".Controller";

	$.Controller = function(name) {

		// !-- FOUNDRY HACK --! //
		// By default, all controllers are created under the
		// $.Controller root namespace.
		var args = makeArray(arguments),
			_static = {
				root: controllerRoot
			},
			_prototype;

		if (args.length > 2) {
			// Namespace can be overriden
			_static = $.extend(_static, args[1]);
			_prototype = args[2];
		} else {
			_prototype = args[1];
		}

		if (_static.namespace) {
			name = _static.namespace + "." + name;
		}

		return $.Controller.Class(name, _static, _prototype);
	}

	var controllerClass = controllerRoot + ".Class";

	$.Class(controllerClass,
	/**
	 * @Static
	 */
	{
		/**
		 * Does 2 things:
		 *
		 *   - Creates a jQuery helper for this controller.</li>
		 *   - Calculates and caches which functions listen for events.</li>
		 *
		 * ### jQuery Helper Naming Examples
		 *
		 *
		 *     "TaskController" -> $().task_controller()
		 *     "Controllers.Task" -> $().controllers_task()
		 *
		 */
		setup: function(baseClass, name) {

			// Allow contollers to inherit "defaults" from superclasses as it done in $.Class
			this._super.apply(this, arguments);

			// if you didn't provide a name, or are controller, don't do anything
			if (!this.shortName || this.fullName == controllerClass) {
				return;
			}

			// !-- FOUNDRY HACK --! //
			// Added support for expandable elements.
			var elements = this.elements || [],
				i = 0,
				defaults = this.defaults;

			while (element = elements[i++]) {

			    var start  = element.indexOf("{"),
				    end    = element.indexOf("}"),
				    length = element.length,
				    prefix = element.slice(0, start),
				    suffix = element.slice(end + 1),
				    names  = element.slice(start + 1, end).split("|"),
				    j = 0;

				    // "^width [data-eb{label|slider}]" turns into
				    // widthLabel  => [data-eb-label]
				    // widthSlider => [data-eb-slider]

				    // "^width [data-eb".match(/^\^(\S*)\s(.*)/);
				    // 0 ==> "^width [data-eb"
				    // 1 ==> "width",
				    // 2 ==> "[data-eb"
				    var parts = prefix.match(/^\^(\S*)\s(.*)/),
				    	propPrefix = "";

				    if (parts) {
				    	propPrefix = parts[1] + "-";
				    	prefix = parts[2];
				    }

					while (name = names[j++]) {
						var prop = "{" + $.camelize(propPrefix + name) + "}";

						!$.has(defaults, prop) &&
							(defaults[prop] = prefix + name + suffix);
					}
			}

			// cache the underscored names
			this._fullName = underscoreAndRemoveController(this.fullName);
			this._shortName = underscoreAndRemoveController(this.shortName);

			var controller = this,
				/**
				 * @attribute pluginName
				 * Setting the <code>pluginName</code> property allows you
				 * to change the jQuery plugin helper name from its
				 * default value.
				 *
				 *     $.Controller("Mxui.Layout.Fill",{
				 *       pluginName: "fillWith"
				 *     },{});
				 *
				 *     $("#foo").fillWith();
				 */
				funcName, forLint;

			// !-- FOUNDRY HACK --! //
			// Make creation of jQuery plugin by testing the existence of pluginName.
			if (isString(this.pluginName)) {

				// !-- FOUNDRY HACK --! //
				// Add a reference to the fullname
				var _fullName = this._fullName;
				var pluginname = this.pluginName;

				// create jQuery plugin
				if (!$.fn[pluginname] ) {
					$.fn[pluginname] = function( options ) {

						var args = makeArray(arguments);

						// Returning controller instance if it exists
						if ($.isString(options) && options==="controller") {

							var controllers = data(this[0]),
								instance = controllers && controllers[_fullName];

							return instance;
						}

						return this.each(function() {
							//check if created
							var controllers = data(this),
								//plugin is actually the controller instance
								//plugin = controllers && controllers[pluginname];

								// !-- FOUNDRY HACK --! //
								// Check using controller full name
								instance = controllers && controllers[_fullName];

							if (instance) {

								// call a method on the controller with the remaining args
								if ($.isString(options)) {
									var method = instance[options];
									$.isFunction(method) && method.apply(instance, args.slice(1));
									return;
								}

								// call the plugin's update method
								instance.update.apply(instance, args);

							} else {
								//create a new controller instance
								controller.newInstance.apply(controller, [this].concat(args));
							}
						});
					};
				}
			}

			// !-- FOUNDRY HACK --! //
			// If a prototype factory function was given instead of a prototype object,
			// we expect the factory function to return the prototype object upon execution
			// of the factory function. This factory function gets executed during the
			// instantiation of the controller.

			var args         = makeArray(arguments),
				prototype    = this[STR_PROTOTYPE],
				protoFactory = args[(args.length > 3) ? 3 : 2];

			if (isFunction(protoFactory)) {

				// Remap the factory function
				this.protoFactory = protoFactory;

				// Attempt to execute the prototype factory once to get
				// a list of actions that we can cache first.
				prototype = this.protoFactory.call(this, null);
			}

			// calculate and cache actions
			this.actions = {};

			// !-- FOUNDRY HACK --! //
			// Support for handlers that also pass in event data
			for (funcName in prototype) {

				if (funcName=='constructor') continue;

				if (this._isAction(funcName)) {

					var method   = prototype[funcName],
						isMethod = isFunction(method) || (isArray(method) && isFunction(method[1]));

					if (!isMethod) continue;

					this.actions[funcName] = this._action(funcName);
				}
			}

			// !-- FOUNDRY HACK --! //
			// Controller has been created. Resolve module.
			$.module("$:/Controllers/" + this.fullName).resolve(this);
		},

		hookup: function( el ) {
			return new this(el);
		},

		/**
		 * @hide
		 * @param {String} methodName a prototype function
		 * @return {Boolean} truthy if an action or not
		 */
		_isAction: function( methodName ) {
			if ( actionMatcher.test(methodName) ) {
				return true;
			} else {
				return $.inArray(methodName, this.listensTo) > -1 || $.event.special[methodName] || processors[methodName];
			}

		},
		/**
		 * @hide
		 * This takes a method name and the options passed to a controller
		 * and tries to return the data necessary to pass to a processor
		 * (something that binds things).
		 *
		 * For performance reasons, this called twice.  First, it is called when
		 * the Controller class is created.  If the methodName is templated
		 * like : "{window} foo", it returns null.  If it is not templated
		 * it returns event binding data.
		 *
		 * The resulting data is added to this.actions.
		 *
		 * When a controller instance is created, _action is called again, but only
		 * on templated actions.
		 *
		 * @param {Object} methodName the method that will be bound
		 * @param {Object} [options] first param merged with class default options
		 * @return {Object} null or the processor and pre-split parts.
		 * The processor is what does the binding/subscribing.
		 */
		_action: function( methodName, options ) {
			// reset the test index
			parameterReplacer.lastIndex = 0;

			//if we don't have options (a controller instance), we'll run this later
			if (!options && parameterReplacer.test(methodName) ) {
				return null;
			}

			// !-- FOUNDRY HACK --! //
			// Ability to bind custom event to self.
			// "{self} customEvent"
			methodName = methodName.replace("{self} ", "");

			// If we have options, run sub to replace templates "{}" with a value from the options
			// or the window
			var convertedName = methodName;

			if (options) {

				var bindingOtherController = false;

				if (controllerReplacer.test(methodName)) {

					var controller, selector = "";
					convertedName =
						methodName
							.replace(controllerReplacer, function(whole, inside){
								var parts = inside.split(".");
								controller = options["{"+parts[0]+"}"] || {};
								if ($.isControllerInstance(controller)) {
									selector = (controller[parts[1]] || {})["selector"];
								}
								return selector;
							})
							.match(breaker);

					// If there is a selector, this will be true.
					bindingOtherController = !!selector;

					convertedName = [controller.element].concat(convertedName || []);
				}

				if (!bindingOtherController) {

					convertedName = Str.sub(methodName, [options, window]);
				}
			}

			// If a "{}" resolves to an object, convertedName will be an array
			var arr = isArray(convertedName),

				// get the parts of the function = [convertedName, delegatePart, eventPart]
				parts = (arr ? convertedName[1] : convertedName).match(breaker),
				event = parts[2],
				processor = processors[event] || basicProcessor;

			return {
				processor: processor,
				parts: parts,
				delegate : arr ? convertedName[0] : undefined
			};
		},

		/**
		 * @attribute processors
		 * An object of {eventName : function} pairs that Controller uses to hook up events
		 * auto-magically.  A processor function looks like:
		 *
		 *     jQuery.Controller.processors.
		 *       myprocessor = function( el, event, selector, cb, controller ) {
		 *          //el - the controller's element
		 *          //event - the event (myprocessor)
		 *          //selector - the left of the selector
		 *          //cb - the function to call
		 *          //controller - the binding controller
		 *       };
		 *
		 * This would bind anything like: "foo~3242 myprocessor".
		 *
		 * The processor must return a function that when called,
		 * unbinds the event handler.
		 *
		 * Controller already has processors for the following events:
		 *
		 *   - change
		 *   - click
		 *   - contextmenu
		 *   - dblclick
		 *   - focusin
		 *   - focusout
		 *   - keydown
		 *   - keyup
		 *   - keypress
		 *   - mousedown
		 *   - mouseenter
		 *   - mouseleave
		 *   - mousemove
		 *   - mouseout
		 *   - mouseover
		 *   - mouseup
		 *   - reset
		 *   - resize
		 *   - scroll
		 *   - select
		 *   - submit
		 *
		 * Listen to events on the document or window
		 * with templated event handlers:
		 *
		 *
		 *     $.Controller('Sized',{
		 *       "{window} resize" : function(){
		 *         this.element.width(this.element.parent().width() / 2);
		 *       }
		 *     });
		 *
		 *     $('.foo').sized();
		 */
		processors: {},
		/**
		 * @attribute listensTo
		 * An array of special events this controller
		 * listens too.  You only need to add event names that
		 * are whole words (ie have no special characters).
		 *
		 *     $.Controller('TabPanel',{
		 *       listensTo : ['show']
		 *     },{
		 *       'show' : function(){
		 *         this.element.show();
		 *       }
		 *     })
		 *
		 *     $('.foo').tab_panel().trigger("show");
		 *
		 */
		listensTo: [],
		/**
		 * @attribute defaults
		 * A object of name-value pairs that act as default values for a controller's
		 * [jQuery.Controller.prototype.options options].
		 *
		 *     $.Controller("Message",
		 *     {
		 *       defaults : {
		 *         message : "Hello World"
		 *       }
		 *     },{
		 *       init : function(){
		 *         this.element.text(this.options.message);
		 *       }
		 *     })
		 *
		 *     $("#el1").message(); //writes "Hello World"
		 *     $("#el12").message({message: "hi"}); //writes hi
		 *
		 * In [jQuery.Controller.prototype.setup setup] the options passed to the controller
		 * are merged with defaults.  This is not a deep merge.
		 */
		defaults: {},

		hostname: "parent"
	},
	/**
	 * @Prototype
	 */
	{
		/**
		 * Setup is where most of controller's magic happens.  It does the following:
		 *
		 * ### 1. Sets this.element
		 *
		 * The first parameter passed to new Controller(el, options) is expected to be
		 * an element.  This gets converted to a jQuery wrapped element and set as
		 * [jQuery.Controller.prototype.element this.element].
		 *
		 * ### 2. Adds the controller's name to the element's className.
		 *
		 * Controller adds it's plugin name to the element's className for easier
		 * debugging.  For example, if your Controller is named "Foo.Bar", it adds
		 * "foo_bar" to the className.
		 *
		 * ### 3. Saves the controller in $.data
		 *
		 * A reference to the controller instance is saved in $.data.  You can find
		 * instances of "Foo.Bar" like:
		 *
		 *     $("#el").data("controllers")['foo_bar'].
		 *
		 * ### Binds event handlers
		 *
		 * Setup does the event binding described in [jquery.controller.listening Listening To Events].
		 *
		 * @param {HTMLElement} element the element this instance operates on.
		 * @param {Object} [options] option values for the controller.  These get added to
		 * this.options and merged with [jQuery.Controller.static.defaults defaults].
		 * @return {Array} return an array if you wan to change what init is called with. By
		 * default it is called with the element and options passed to the controller.
		 */
		setup: function(elem, options) {

			var instance  = this,
				Class     = instance[STR_CONSTRUCTOR],
				prototype = instance[STR_PROTOTYPE];

			var _fullName = Class._fullName;

			// !-- FOUNDRY HACK --! //
			// Unique id for every controller instance.
			instance.instanceId = $.uid(_fullName + '_');

			// !-- FOUNDRY HACK --! //
			// Added defaultOptions as an alternative to defaults
			var instanceOptions = instance.options
								= extend(true, {}, Class.defaults, Class.defaultOptions, options);

			// Convert HTML element into a jQuery element
			// and store it inside instance.element.
			var element = instance.element
						= $(elem);

			// !-- FOUNDRY HACK --! //
			// Execute factory function if exists, extends the properties
			// of the returned object onto the instance.
			if (Class.protoFactory) {

				// This is where "self" keyword is passed as first argument.
				prototype = Class.protoFactory.apply(Class, [instance, instanceOptions, element]);

				// Extend the properties of the prototype object onto the instance.
				extend(true, instance, prototype);
			}

			// !-- FOUNDRY HACK --! //
			// Use _fullName instead
			// This actually does $(e).data("controllers", _fullName);
			(data(elem) || data(elem, {}))[_fullName] = instance;

			// !-- FOUNDRY HACK --~ //
			// Add a unique direct selector for every controller instance.
			if (!element.data("directSelector")) {
				var selector = $.uid("DS");
				element
					.addClass(selector)
					.data("directSelector", "." + selector);
			}

			// !-- FOUNDRY HACK --! //
			// Augment selector properties into selector functions.
			// The rest are passed in as controller properties.
			instance.selectors = {};

			for (var name in instanceOptions) {

				if (!name.match(/^\{.+\}$/)) continue;

				var key = name.replace(/^\{|\}$/g,''),
					val = instanceOptions[name];

				// Augmented selector function
				if (isString(val)) {

					var selectorFuncExtension = instance[key];

					instance[key] = instance.selectors[key] = (function(instance, selector, funcName) {

						// Selector shorthand for controllers
						selector = /^(\.|\#)$/.test(selector) ? selector + funcName : selector;

						// Create selector function
						var selectorFunc = function(filter) {

							var elements = (selectorFunc.baseElement || instance.element).find(selector);

							if ($.isString(filter)) {
								elements = elements.filter(filter);
							}

							if ($.isPlainObject(filter)) {
								$.each(filter, function(key, val){
									elements = elements.filterBy(key, val);
								});
							}

							return elements;
						};

						// Keep the selector as a property of the function
						selectorFunc.selector = selector;

						selectorFunc.css = function() {

							var cssRule = selectorFunc.cssRule;

							if (!cssRule) {

								var directSelector = element.data("directSelector"),

									ruleSelector = $.map(selector.split(","), function(selector) {
														return directSelector + " " + selector
													});

								cssRule = selectorFunc.cssRule = $.cssRule(ruleSelector);
								cssRule.important = true;
							}

							return (arguments.length) ? cssRule.css.apply(cssRule, arguments) : cssRule;
						};

						selectorFunc.inside = function(el) {
							return $(el).find(selector);
						};

						selectorFunc.of = function(el) {
							return $(el).parents(selector).eq(0);
						};

				        selectorFunc.under = function(el) {

				            var nodes = [];

				            selectorFunc().each(function(){
				                if ($(this).parents().filter(el).length) {
				                    nodes.push(this);
				                }
				            });

				            return $(nodes);
				        };
				        
						if ($.isPlainObject(selectorFuncExtension)) {
							$.extend(selectorFunc, selectorFuncExtension);
						}

						return selectorFunc;

					})(instance, val, key);

				// Else just reference it, e.g. controller instance
				} else {

					instance[key] = val;
				}
			}

			// !-- FOUNDRY HACK --! //
			// Augment view properties into view functions.
			// self.view.listItem(useHtml, data, callback);
			var views = instanceOptions.view;

			// Prevent augmented functions from being
			// extended onto the prototype view function.
			var __view = instance.view;

			instance.view = function() {
				return __view.apply(this, arguments);
			};

			each(views || {}, function(name, view){

				instance.view[name] = function(useHtml) {

					var args = makeArray(arguments);

					if ($.isBoolean(useHtml)) {
						args = args.slice(1);
					} else {
						useHtml = false;
					}

					return instance.view.apply(instance, [useHtml, name].concat(args));
				}
			});

			// !-- FOUNDRY HACK --! //
			// Instance property override
			$.extend(instance, instanceOptions.controller);

			// !--- FOUNDRY HACK --! //
			instance.pluginInstances = {};

			/**
			 * @attribute called
			 * String name of current function being called on controller instance.  This is
			 * used for picking the right view in render.
			 * @hide
			 */
			instance.called = "init";

			// bind all event handlers
			instance._bind();

			var __init = instance.init || $.noop;

			// !-- FOUNDRY HACK --! //
			// Trigger init event when controller is created.
			instance.init = function(){
				instance.init = __init;
				result = __init.apply(instance, arguments);
				instance.trigger("init." + Class.fullName.toLowerCase(), [instance]);
				return result;
			}

			/**
			 * @attribute element
			 * The controller instance's delegated element. This
			 * is set by [jQuery.Controller.prototype.setup setup]. It
			 * is a jQuery wrapped element.
			 *
			 * For example, if I add MyWidget to a '#myelement' element like:
			 *
			 *     $.Controller("MyWidget",{
			 *       init : function(){
			 *         this.element.css("color","red")
			 *       }
			 *     })
			 *
			 *     $("#myelement").my_widget()
			 *
			 * MyWidget will turn #myelement's font color red.
			 *
			 * ## Using a different element.
			 *
			 * Sometimes, you want a different element to be this.element.  A
			 * very common example is making progressively enhanced form widgets.
			 *
			 * To change this.element, overwrite Controller's setup method like:
			 *
			 *     $.Controller("Combobox",{
			 *       setup : function(el, options){
			 *          this.oldElement = $(el);
			 *          var newEl = $('<div/>');
			 *          this.oldElement.wrap(newEl);
			 *          this._super(newEl, options);
			 *       },
			 *       init : function(){
			 *          this.element //-> the div
			 *       },
			 *       ".option click" : function(){
			 *         // event handler bound on the div
			 *       },
			 *       destroy : function(){
			 *          var div = this.element; //save reference
			 *          this._super();
			 *          div.replaceWith(this.oldElement);
			 *       }
			 *     }
			 */
			return [element, instanceOptions].concat(makeArray(arguments).slice(2));
			/**
			 * @function init
			 *
			 * Implement this.
			 */
		},
		/**
		 * Bind attaches event handlers that will be
		 * removed when the controller is removed.
		 *
		 * This used to be a good way to listen to events outside the controller's
		 * [jQuery.Controller.prototype.element element].  However,
		 * using templated event listeners is now the prefered way of doing this.
		 *
		 * ### Example:
		 *
		 *     init: function() {
		 *        // calls somethingClicked(el,ev)
		 *        this.bind('click','somethingClicked')
		 *
		 *        // calls function when the window is clicked
		 *        this.bind(window, 'click', function(ev){
		 *          //do something
		 *        })
		 *     },
		 *     somethingClicked: function( el, ev ) {
		 *
		 *     }
		 *
		 * @param {HTMLElement|jQuery.fn|Object} [el=this.element]
		 * The element to be bound.  If an eventName is provided,
		 * the controller's element is used instead.
		 *
		 * @param {String} eventName The event to listen for.
		 * @param {Function|String} func A callback function or the String name of a controller function.  If a controller
		 * function name is given, the controller function is called back with the bound element and event as the first
		 * and second parameter.  Otherwise the function is called back like a normal bind.
		 * @return {Integer} The id of the binding in this._bindings
		 */

		on: function(eventName) {

			var args = makeArray(arguments),
				element = this.element,
				length = args.length;

			// Listen to the controller's element
			// on(eventName, eventHandler);
			if (length==2) {
				return this._binder(element, eventName, args[1]);
			}

			// Listen to controller's child elements matching the selector
			// on(eventName, selector, eventHandler);
			// args[1] == selector, jquery collection or dom node.
			// args[2] == eventHandler.
			if (length==3 && isString(args[1])) {
				return this._binder(element, eventName, args[2], args[1]);
			} else {
				return this._binder(args[1], eventName, args[2]);
			}

			// Listen to an element from another element
			// on(eventName, element, selector, eventHandler);
			if (length==4) {
				return this._binder($(args[1]), eventName, args[3], args[2]);
			}
		},

		// !-- FOUNDRY HACK --! //
		// Rename this.bind from this_bind. Conflict with mootools.
		// _bind: function( el, eventName, func ) {
		_bind: function() {

			var instance = this,
				Class    = instance[STR_CONSTRUCTOR],
				actions  = Class.actions,
				bindings = instance._bindings = [],
				element  = instance.element;

			each(actions || {}, function(name, action){

				if (!actions.hasOwnProperty(name)) return;

				var ready = Class.actions[name] || Class._action(name, instance.options);

				// Translate to the controller element first
				if ($.isControllerInstance(ready.delegate)) {
					ready.delegate = ready.delegate.element;
				}

				bindings.push(
					ready.processor(
						ready.delegate || element,
						ready.parts[2],
						ready.parts[1],
						name,
						instance
					)
				);
			});

			//setup to be destroyed ... don't bind b/c we don't want to remove it
			var destroyCB = shifter(this,"destroy");
			element.bind("destroyed", destroyCB);
			bindings.push(function( el ) {
				$(el).unbind("destroyed", destroyCB);
			});
			return bindings.length;
		},
		_binder: function( el, eventName, func, selector ) {
			if ( typeof func == 'string' ) {
				func = shifter(this,func);
			}
			this._bindings.push(binder(el, eventName, func, selector));
			return this._bindings.length;
		},
		_unbind : function(){
			var el = this.element[0];
			each(this._bindings, function( key, value ) {
				value(el);
			});
			//adds bindings
			this._bindings = [];
		},
		// !-- FOUNDRY HACK --! //
		// Element event triggering
		trigger: function(name) {

			var el = this.element;
			if (!el) return;

			var event = $.Event(name);
				el.trigger.apply(el, [event].concat($.makeArray(arguments).slice(1)));

			return event;
		},
		/**
		 * Delegate will delegate on an elememt and will be undelegated when the controller is removed.
		 * This is a good way to delegate on elements not in a controller's element.<br/>
		 * <h3>Example:</h3>
		 * @codestart
		 * // calls function when the any 'a.foo' is clicked.
		 * this.delegate(document.documentElement,'a.foo', 'click', function(ev){
		 *   //do something
		 * })
		 * @codeend
		 * @param {HTMLElement|jQuery.fn} [element=this.element] the element to delegate from
		 * @param {String} selector the css selector
		 * @param {String} eventName the event to bind to
		 * @param {Function|String} func A callback function or the String name of a controller function.  If a controller
		 * function name is given, the controller function is called back with the bound element and event as the first
		 * and second parameter.  Otherwise the function is called back like a normal bind.
		 * @return {Integer} The id of the binding in this._bindings
		 */
		delegate: function( element, selector, eventName, func ) {
			if ( typeof element == 'string' ) {
				func = eventName;
				eventName = selector;
				selector = element;
				element = this.element;
			}
			return this._binder(element, eventName, func, selector);
		},
		/**
		 * Update extends [jQuery.Controller.prototype.options this.options]
		 * with the `options` argument and rebinds all events.  It basically
		 * re-configures the controller.
		 *
		 * For example, the following controller wraps a recipe form. When the form
		 * is submitted, it creates the recipe on the server.  When the recipe
		 * is `created`, it resets the form with a new instance.
		 *
		 *     $.Controller('Creator',{
		 *       "{recipe} created" : function(){
		 *         this.update({recipe : new Recipe()});
		 *         this.element[0].reset();
		 *         this.find("[type=submit]").val("Create Recipe")
		 *       },
		 *       "submit" : function(el, ev){
		 *         ev.preventDefault();
		 *         var recipe = this.options.recipe;
		 *         recipe.attrs( this.element.formParams() );
		 *         this.find("[type=submit]").val("Saving...")
		 *         recipe.save();
		 *       }
		 *     });
		 *     $('#createRecipes').creator({recipe : new Recipe()})
		 *
		 *
		 * @demo jquery/controller/demo-update.html
		 *
		 * Update is called if a controller's [jquery.controller.plugin jQuery helper] is
		 * called on an element that already has a controller instance
		 * of the same type.
		 *
		 * For example, a widget that listens for model updates
		 * and updates it's html would look like.
		 *
		 *     $.Controller('Updater',{
		 *       // when the controller is created, update the html
		 *       init : function(){
		 *         this.updateView();
		 *       },
		 *
		 *       // update the html with a template
		 *       updateView : function(){
		 *         this.element.html( "content.ejs",
		 *                            this.options.model );
		 *       },
		 *
		 *       // if the model is updated
		 *       "{model} updated" : function(){
		 *         this.updateView();
		 *       },
		 *       update : function(options){
		 *         // make sure you call super
		 *         this._super(options);
		 *
		 *         this.updateView();
		 *       }
		 *     })
		 *
		 *     // create the controller
		 *     // this calls init
		 *     $('#item').updater({model: recipe1});
		 *
		 *     // later, update that model
		 *     // this calls "{model} updated"
		 *     recipe1.update({name: "something new"});
		 *
		 *     // later, update the controller with a new recipe
		 *     // this calls update
		 *     $('#item').updater({model: recipe2});
		 *
		 *     // later, update the new model
		 *     // this calls "{model} updated"
		 *     recipe2.update({name: "something newer"});
		 *
		 * _NOTE:_ If you overwrite `update`, you probably need to call
		 * this._super.
		 *
		 * ### Example
		 *
		 *     $.Controller("Thing",{
		 *       init: function( el, options ) {
		 *         alert( 'init:'+this.options.prop )
		 *       },
		 *       update: function( options ) {
		 *         this._super(options);
		 *         alert('update:'+this.options.prop)
		 *       }
		 *     });
		 *     $('#myel').thing({prop : 'val1'}); // alerts init:val1
		 *     $('#myel').thing({prop : 'val2'}); // alerts update:val2
		 *
		 * @param {Object} options A list of options to merge with
		 * [jQuery.Controller.prototype.options this.options].  Often, this method
		 * is called by the [jquery.controller.plugin jQuery helper function].
		 */
		update: function( options ) {
			extend(this.options, options);
			this._unbind();
			this._bind();
		},
		/**
		 * Destroy unbinds and undelegates all event handlers on this controller,
		 * and prevents memory leaks.  This is called automatically
		 * if the element is removed.  You can overwrite it to add your own
		 * teardown functionality:
		 *
		 *     $.Controller("ChangeText",{
		 *       init : function(){
		 *         this.oldText = this.element.text();
		 *         this.element.text("Changed!!!")
		 *       },
		 *       destroy : function(){
		 *         this.element.text(this.oldText);
		 *         this._super(); //Always call this!
		 *     })
		 *
		 * Make sure you always call <code>_super</code> when overwriting
		 * controller's destroy event.  The base destroy functionality unbinds
		 * all event handlers the controller has created.
		 *
		 * You could call destroy manually on an element with ChangeText
		 * added like:
		 *
		 *     $("#changed").change_text("destroy");
		 *
		 */
		destroy: function() {

			if ( this._destroyed ) {
				return;
			}
			var fname = this[STR_CONSTRUCTOR]._fullName,
				controllers;

			// remove all plugins
			for (pname in this.pluginInstances) {
				this.removePlugin(pname);
			}

			// mark as destroyed
			this._destroyed = true;

			// remove the className
			this.element.removeClass(fname);

			// unbind bindings
			this._unbind();
			// clean up
			delete this._actions;

			delete this.element.data("controllers")[fname];

			$(this).triggerHandler("destroyed"); //in case we want to know if the controller is removed

			// !-- FOUNDRY HACK --! //
			// Reassign this.element to an empty jQuery element instead.
			this.element = $();
		},
		/**
		 * Queries from the controller's element.
		 * @codestart
		 * ".destroy_all click" : function() {
		 *    this.find(".todos").remove();
		 * }
		 * @codeend
		 * @param {String} selector selection string
		 * @return {jQuery.fn} returns the matched elements
		 */
		find: function( selector ) {
			return this.element.find(selector);
		},

		// !-- FOUNDRY HACK --! //
		// Quick acccess to views.
		view: function() {

			var args = makeArray(arguments),
				name,
				options = args,
				useHtml = false,
				context = this[STR_CONSTRUCTOR].component || $,
				html = "",
				view = this.options.view || {};

			if (typeof args[0] == "boolean") {
				useHtml = args[0];
				options = args.slice(1);
			}

			name = options[0] = view[options[0]];

			// If view is not assigned, return empty string.
			if (name==undefined) {
				return (useHtml) ? "" : $("");
			}

			html = context.View.apply(context, options);

			return (useHtml) ? html : $($.parseHTML($.trim(html)));
		},

		getPlugin: function(name) {

			return this.pluginInstances[name];
		},

		addSubscriber: function(instance) {

			var instances = ($.isArray(instance)) ? instance : [instance || {}];

			// Prep options
			var host = this,
				hostname = this.Class.hostname,
				options = {};
				options["{" + hostname + "}"] = host;

			$.map(instances, function(instance, i){

				// If this is not a controller instance.
				if (!$.isControllerInstance(instance)) return false;

				// If instance is already a subscriber,skip.
				if (instance.options[hostname]===this) return instance;

				// Also map itself as a method name
				instance[hostname] = host;

				// Attach publisher to subscriber
				return instance.update(options);
			});

			return instances;
		},

		// addPlugin(name, object, [options]);
		// The object should consist of a method called destroy();

		// addPlugin(name, function, [options]);
		// The function should return an object with a method called destroy();

		addPlugin: function(name, plugin, options) {

			if (!name) return;

			// This means we are working with plugin shorthand
			if ((!plugin && !options) || $.isPlainObject(plugin)) {
				options = plugin;
				plugin = [this.Class.root, this.Class.fullName, $.String.capitalize(name)].join(".");
			}

			// If plugin is a string, get the controller from it.
			if ($.isString(plugin)) {
				plugin = $.getController(plugin);
			}

			var isPluginInstance = $.isControllerInstance(plugin);

			// Controller class are also functions,
			// so this simple test is good enough.
			if (!isFunction(plugin) && !isPluginInstance) return;

			// Normalize plugin options
			var pluginOptions =
				this.Class.pluginExtendsInstance ?
					this.options[name] :
					(this.options.plugin || {})[name];

			options = $.extend(true, {element: this.element}, options, pluginOptions);

			// Determine plugin type
			var type =
				((isPluginInstance) ? "instance" :
				(($.isController(plugin)) ? "controller" : "function"));

			// Trigger addPlugin event so controller can decorate the options
			this.trigger("addPlugin", [name, plugin, options, type]);

			var hostname = this.Class.hostname;

			// Subcontrollers should have a way to listen back to host controller
			options["{" + hostname + "}"] = this;

			var pluginInstance;

			switch(type) {

				// Plugin instance
				case "instance":

					pluginInstance = plugin;

					// Update child plugin with custom plugin options from host
					plugin.update(options);

					plugin[hostname] = this;
					break;

				// Plugin controller
				case "controller":
					pluginInstance = options.element.addController(plugin, options);
					break;

				// Plugin function
				case "function":
					pluginInstance = plugin(this, options);
					break;
			}

			// If pluginInstance could not be created, stop.
			if (!pluginInstance) return;

			// Register plugin
			this.pluginInstances[name] = pluginInstance;

			// Also extend instance with a property point to the plugin
			if (this.Class.pluginExtendsInstance) {
				this[name] = pluginInstance;
			}

			// Host controller should also have a way to listen back to the child controller
			if (type!=="function") {

				var hostOptions = {};
				hostOptions["{" + name + "}"] = pluginInstance;

				this.update(hostOptions);
			}

			// Trigger registerPlugin
			this.trigger("registerPlugin", [name, pluginInstance, options, type]);

			return pluginInstance;
		},

		removePlugin: function(name) {

			var plugin = this.getPlugin(name);

			if (!plugin) return;

			// Trigger removePlugin
			this.trigger("removePlugin", [name, plugin]);

			delete this.pluginInstances[name];

			return $.isFunction(plugin.destroy) ? plugin.destroy() : null;
		},

		invokePlugin: function(name, method, args) {

			var plugin = this.getPlugin(name);

			// If plugin not exist, stop.
			if (!plugin) return;

			// If plugin method not exist, stop.
			if (!$.isFunction(plugin[method])) return;

			// Let any third party modify the arguments if required
			this.trigger("invokePlugin", [name, plugin, args]);

			return plugin[method].apply(this, args);
		},

		getMessageGroup: function() {

			// Find parent element
			var messageGroup = ($.isFunction(this.messageGroup)) ? this.messageGroup() : this.element.find("[data-message-group]");

			if (messageGroup.length < 1) {
				messageGroup = $("<div data-message-group></div>").prependTo(this.element);
			}

			return messageGroup;
		},

		setMessage: function(message, type) {

			// Normalize arguments
			var defaultOptions = {
					type   : "warning", // type: info, error, success
					message: "",
					parent : this.getMessageGroup(),
					element: $('<div class="alert fade in"><button type="button" class="close" data-bs-dismiss="alert">×</button></div>')
				},
				userOptions = {},
				isDeferred = $.isDeferred(message);

			// Normalize user options
			if ($.isPlainObject(message) && !isDeferred) {
				userOptions = message;
			} else {
				userOptions = {
					message: message,
					type   : type || "warning"
				}
			}

			var options = $.extend({}, defaultOptions, userOptions),
				element = options.element;

			if ($.isDeferred(message)) {

				var myself = arguments.callee,
					context = this;

				message.done(function(message, type) {
					options.message = message;
					options.type = type || "warning";
					myself.call(context, options);
					element.show();
				});

			} else {

				element
					.addClass("alert-" + options.type)
					.append(options.message);

				if ($('html').has(element).length < 1) {
					element.appendTo(options.parent);
				}
			}

			return element;
		},

		clearMessage: function() {

			this.getMessageGroup().empty();
		},

		//tells callback to set called on this.  I hate this.
		_set_called: true
	});

	var processors = $.Controller.Class.processors,

	//------------- PROCESSSORS -----------------------------
	//processors do the binding.  They return a function that
	//unbinds when called.
	//the basic processor that binds events
	basicProcessor = function( el, event, selector, methodName, controller ) {

		// !-- FOUNDRY HACK --! //
		// Support for passing event data

		var method = controller[methodName],
			eventData;

		if (isArray(method) && isFunction(method[1])) {
			eventData = method[0];
		}

		return binder(el, event, shifter(controller, methodName), selector, eventData);
	};


	//set common events to be processed as a basicProcessor
	each("change click contextmenu dblclick keydown keyup keypress mousedown mousemove mouseout mouseover mouseup reset resize scroll select submit focusin focusout mouseenter mouseleave".split(" "), function( i, v ) {
		processors[v] = basicProcessor;
	});
	/**
	 *  @add jQuery.fn
	 */

	//used to determine if a controller instance is one of controllers
	//controllers can be strings or classes

	var normalizeController = function(controller) {
		return controller.replace("$.Controller", controllerRoot);
	}

	var getController = function(controller) {
		if (isString(controller)) {
			controller = normalizeController(controller);
			controller = getObject(controller) || getObject(controllerRoot + "." + controller);
		};
		if (isController(controller)) {
			return controller;
		};
	}

	var isController = function(controller) {
		return isFunction(controller) && controller.hasOwnProperty("_fullName");
	}

	var flattenControllers = function(controllers) {
		return $.map(controllers, function(controller){
			return (isArray(controller)) ? flattenControllers(controller) : getController(controller);
		});
	};

	$.getController = getController;

	$.isController = function(controller) {
		return !!getController(controller);
	}

	$.isControllerInstance = function(instance) {
		return instance && instance[STR_CONSTRUCTOR] && isController(instance[STR_CONSTRUCTOR]);
	}

	$.isControllerOf = function(instance, controllers) {

		if (!controllers) return false;

		if (!isArray(controllers)) {
			controllers = [controllers];
		}

		for (var i=0; i<controllers.length; i++) {
			var controller = getController(controllers[i]);
			if (instance instanceof controller) return true;
		}

		return false;
	};

	$.fn.extend({
		/**
		 * @function controllers
		 * Gets all controllers in the jQuery element.
		 * @return {Array} an array of controller instances.
		 */
		controllers: function() {

			var candidates = flattenControllers(makeArray(arguments)),
				instances = [];

			this.each(function() {

				var controllers = $.data(this, "controllers");

				each(controllers || {}, function(_fullName, instance){

					if (!controllers.hasOwnProperty(_fullName)) return;

					if (!candidates.length || $.isControllerOf(instance, candidates)) {
						instances.push(instance);
					}
				});
			});

			return instances;
		},

		/**
		 * @function controller
		 * Gets a controller in the jQuery element.  With no arguments, returns the first one found.
		 * @param {Object} controller (optional) if exists, the first controller instance with this class type will be returned.
		 * @return {jQuery.Controller} the first controller.
		 */
		controller: function(controller, options) {

			// Getter
			if (options===undefined) {
				return this.controllers(controller)[0];
			}

			// Setter
			this.addController.apply(this, arguments);
			return this;
		},

		hasController: function(controller) {

			var _fullName =
				(getController(controller) || {})._fullName ||
				(isString(controller) ? underscoreAndRemoveController(normalizeController(controller)) : "");

			return (!_fullName) ? false : (($(this).data("controllers") || {}).hasOwnProperty(_fullName));
		},

		addController: function(controller, options, callback) {

			var Controller = getController(controller);

			if (!Controller) return;

			var instances = [];

			this.each(function(){

				// Do not add controller on script node or non-element nodes.
				if (this.nodeType!==1 || this.nodeName=="SCRIPT") return;

				// Just return existing instance
				var existingInstance = $(this).controller(controller);
				if (existingInstance) {
					instances.push(existingInstance);
					return;
				}

				// Or create a new instance
				var instance = new Controller(this, options);
				isFunction(callback) && callback.apply(instance, [$(this), instance]);
				instances.push(instance);
			});

			return (instances.length > 1) ? instances : instances[0];
		},

		removeController: function(controller) {
			this.each(function(){
				var instances = $(this).controllers(controller);
				while (instances.length) {
					instances.shift().destroy();
				}
			});
			return this;
		},

		addControllerWhenAvailable: function(controller) {

			var elements = this,
				args = arguments,
				task = $.Deferred();

			if ($.isController(controller)) {
				controller = controller.fullName;
			}

			if (!isString(controller)) {
				return task.reject();
			}

			$.module("$:/Controllers/" + controller)
				.pipe(
					function(){
						var instance = elements.addController.apply(elements, args);
						task.resolveWith(instance, [elements, instance]);
					},
					task.reject,
					task.fail
				);

			return task;
		},

		// @deprecated 2.2
		implement: function() {
			this.addController.apply(this, arguments);
			return this;
		}

	});

	// !-- FOUNDRY HACK --! //
	// Add support for augmented selector function on jQuery's DOM traversal/filtering methods.
	(function(){
	var fns = ["is", "find"],
		_fns = {},
		fn;

	while (fn = fns.shift()) {
		_fns[fn] = $.fn[fn];
	    $.fn[fn] = (function(fn) {
	        return function(obj) {
	            return _fns[fn].apply(this, (obj || {}).hasOwnProperty("of") ? [obj.selector] : arguments);
	        }
	    })(fn);
	}
	})();

})();(function(){

	// a path like string into something that's ok for an element ID
	var toId = function( src ) {
		return src.replace(/^\/\//, "").replace(/[\/\.]/g, "_");
	},
		makeArray = $.makeArray,
		// used for hookup ids
		id = 1;
	// this might be useful for testing if html
	// htmlTest = /^[\s\n\r\xA0]*<(.|[\r\n])*>[\s\n\r\xA0]*$/
	/**
	 * @class jQuery.View
	 * @parent jquerymx
	 * @plugin jquery/view
	 * @test jquery/view/qunit.html
	 * @download dist/jquery.view.js
	 *
	 * @description A JavaScript template framework.
	 *
	 * View provides a uniform interface for using templates with
	 * jQuery. When template engines [jQuery.View.register register]
	 * themselves, you are able to:
	 *
	 *  - Use views with jQuery extensions [jQuery.fn.after after], [jQuery.fn.append append],
	 *   [jQuery.fn.before before], [jQuery.fn.html html], [jQuery.fn.prepend prepend],
	 *   [jQuery.fn.replaceWith replaceWith], [jQuery.fn.text text].
	 *  - Template loading from html elements and external files.
	 *  - Synchronous and asynchronous template loading.
	 *  - [view.deferreds Deferred Rendering].
	 *  - Template caching.
	 *  - Bundling of processed templates in production builds.
	 *  - Hookup jquery plugins directly in the template.
	 *
	 * The [mvc.view Get Started with jQueryMX] has a good walkthrough of $.View.
	 *
	 * ## Use
	 *
	 *
	 * When using views, you're almost always wanting to insert the results
	 * of a rendered template into the page. jQuery.View overwrites the
	 * jQuery modifiers so using a view is as easy as:
	 *
	 *     $("#foo").html('mytemplate.ejs',{message: 'hello world'})
	 *
	 * This code:
	 *
	 *  - Loads the template a 'mytemplate.ejs'. It might look like:
	 *    <pre><code>&lt;h2>&lt;%= message %>&lt;/h2></pre></code>
	 *
	 *  - Renders it with {message: 'hello world'}, resulting in:
	 *    <pre><code>&lt;div id='foo'>"&lt;h2>hello world&lt;/h2>&lt;/div></pre></code>
	 *
	 *  - Inserts the result into the foo element. Foo might look like:
	 *    <pre><code>&lt;div id='foo'>&lt;h2>hello world&lt;/h2>&lt;/div></pre></code>
	 *
	 * ## jQuery Modifiers
	 *
	 * You can use a template with the following jQuery modifiers:
	 *
	 * <table>
	 * <tr><td>[jQuery.fn.after after]</td><td> <code>$('#bar').after('temp.jaml',{});</code></td></tr>
	 * <tr><td>[jQuery.fn.append append] </td><td>  <code>$('#bar').append('temp.jaml',{});</code></td></tr>
	 * <tr><td>[jQuery.fn.before before] </td><td> <code>$('#bar').before('temp.jaml',{});</code></td></tr>
	 * <tr><td>[jQuery.fn.html html] </td><td> <code>$('#bar').html('temp.jaml',{});</code></td></tr>
	 * <tr><td>[jQuery.fn.prepend prepend] </td><td> <code>$('#bar').prepend('temp.jaml',{});</code></td></tr>
	 * <tr><td>[jQuery.fn.replaceWith replaceWith] </td><td> <code>$('#bar').replaceWith('temp.jaml',{});</code></td></tr>
	 * <tr><td>[jQuery.fn.text text] </td><td> <code>$('#bar').text('temp.jaml',{});</code></td></tr>
	 * </table>
	 *
	 * You always have to pass a string and an object (or function) for the jQuery modifier
	 * to user a template.
	 *
	 * ## Template Locations
	 *
	 * View can load from script tags or from files.
	 *
	 * ## From Script Tags
	 *
	 * To load from a script tag, create a script tag with your template and an id like:
	 *
	 * <pre><code>&lt;script type='text/ejs' id='recipes'>
	 * &lt;% for(var i=0; i &lt; recipes.length; i++){ %>
	 *   &lt;li>&lt;%=recipes[i].name %>&lt;/li>
	 * &lt;%} %>
	 * &lt;/script></code></pre>
	 *
	 * Render with this template like:
	 *
	 * @codestart
	 * $("#foo").html('recipes',recipeData)
	 * @codeend
	 *
	 * Notice we passed the id of the element we want to render.
	 *
	 * ## From File
	 *
	 * You can pass the path of a template file location like:
	 *
	 *     $("#foo").html('templates/recipes.ejs',recipeData)
	 *
	 * However, you typically want to make the template work from whatever page they
	 * are called from.  To do this, use // to look up templates from JMVC root:
	 *
	 *     $("#foo").html('//app/views/recipes.ejs',recipeData)
	 *
	 * Finally, the [jQuery.Controller.prototype.view controller/view] plugin can make looking
	 * up a thread (and adding helpers) even easier:
	 *
	 *     $("#foo").html( this.view('recipes', recipeData) )
	 *
	 * ## Packaging Templates
	 *
	 * If you're making heavy use of templates, you want to organize
	 * them in files so they can be reused between pages and applications.
	 *
	 * But, this organization would come at a high price
	 * if the browser has to
	 * retrieve each template individually. The additional
	 * HTTP requests would slow down your app.
	 *
	 * Fortunately, [steal.static.views steal.views] can build templates
	 * into your production files. You just have to point to the view file like:
	 *
	 *     steal.views('path/to/the/view.ejs');
	 *
	 * ## Asynchronous
	 *
	 * By default, retrieving requests is done synchronously. This is
	 * fine because StealJS packages view templates with your JS download.
	 *
	 * However, some people might not be using StealJS or want to delay loading
	 * templates until necessary. If you have the need, you can
	 * provide a callback paramter like:
	 *
	 *     $("#foo").html('recipes',recipeData, function(result){
	 *       this.fadeIn()
	 *     });
	 *
	 * The callback function will be called with the result of the
	 * rendered template and 'this' will be set to the original jQuery object.
	 *
	 * ## Deferreds (3.0.6)
	 *
	 * If you pass deferreds to $.View or any of the jQuery
	 * modifiers, the view will wait until all deferreds resolve before
	 * rendering the view.  This makes it a one-liner to make a request and
	 * use the result to render a template.
	 *
	 * The following makes a request for todos in parallel with the
	 * todos.ejs template.  Once todos and template have been loaded, it with
	 * render the view with the todos.
	 *
	 *     $('#todos').html("todos.ejs",Todo.findAll());
	 *
	 * ## Just Render Templates
	 *
	 * Sometimes, you just want to get the result of a rendered
	 * template without inserting it, you can do this with $.View:
	 *
	 *     var out = $.View('path/to/template.jaml',{});
	 *
	 * ## Preloading Templates
	 *
	 * You can preload templates asynchronously like:
	 *
	 *     $.get('path/to/template.jaml',{},function(){},'view');
	 *
	 * ## Supported Template Engines
	 *
	 * JavaScriptMVC comes with the following template languages:
	 *
	 *   - EmbeddedJS
	 *     <pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre>
	 *
	 *   - JAML
	 *     <pre><code>h2(data.message);</code></pre>
	 *
	 *   - Micro
	 *     <pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre>
	 *
	 *   - jQuery.Tmpl
	 *     <pre><code>&lt;h2>${message}&lt;/h2></code></pre>

	 *
	 * The popular <a href='http://awardwinningfjords.com/2010/08/09/mustache-for-javascriptmvc-3.html'>Mustache</a>
	 * template engine is supported in a 2nd party plugin.
	 *
	 * ## Using other Template Engines
	 *
	 * It's easy to integrate your favorite template into $.View and Steal.  Read
	 * how in [jQuery.View.register].
	 *
	 * @constructor
	 *
	 * Looks up a template, processes it, caches it, then renders the template
	 * with data and optional helpers.
	 *
	 * With [stealjs StealJS], views are typically bundled in the production build.
	 * This makes it ok to use views synchronously like:
	 *
	 * @codestart
	 * $.View("//myplugin/views/init.ejs",{message: "Hello World"})
	 * @codeend
	 *
	 * If you aren't using StealJS, it's best to use views asynchronously like:
	 *
	 * @codestart
	 * $.View("//myplugin/views/init.ejs",
	 *        {message: "Hello World"}, function(result){
	 *   // do something with result
	 * })
	 * @codeend
	 *
	 * @param {String} view The url or id of an element to use as the template's source.
	 * @param {Object} data The data to be passed to the view.
	 * @param {Object} [helpers] Optional helper functions the view might use. Not all
	 * templates support helpers.
	 * @param {Object} [callback] Optional callback function.  If present, the template is
	 * retrieved asynchronously.  This is a good idea if you aren't compressing the templates
	 * into your view.
	 * @return {String} The rendered result of the view or if deferreds
	 * are passed, a deferred that will resolve to
	 * the rendered result of the view.
	 */
	var $view = $.View = function( view, data, helpers, callback ) {
		// if helpers is a function, it is actually a callback
		if ( typeof helpers === 'function' ) {
			callback = helpers;
			helpers = undefined;
		}

		// see if we got passed any deferreds
		var deferreds = getDeferreds(data);


		if ( deferreds.length ) { // does data contain any deferreds?
			// the deferred that resolves into the rendered content ...
			var deferred = $.Deferred();

			// add the view request to the list of deferreds
			deferreds.push(get(view, true))

			// wait for the view and all deferreds to finish
			$.when.apply($, deferreds).then(function( resolved ) {
				// get all the resolved deferreds
				var objs = makeArray(arguments),
					// renderer is last [0] is the data
					renderer = objs.pop()[0],
					// the result of the template rendering with data
					result;

				// make data look like the resolved deferreds
				if ( isDeferred(data) ) {
					data = usefulPart(resolved);
				}
				else {
					// go through each prop in data again,
					// replace the defferreds with what they resolved to
					for ( var prop in data ) {
						if ( isDeferred(data[prop]) ) {
							data[prop] = usefulPart(objs.shift());
						}
					}
				}
				// get the rendered result
				result = renderer(data, helpers);

				//resolve with the rendered view
				deferred.resolve(result);
				// if there's a callback, call it back with the result
				callback && callback(result);
			});
			// return the deferred ....
			return deferred.promise();
		}
		else {
			// no deferreds, render this bad boy
			var response,
				// if there's a callback function
				async = typeof callback === "function",
				// get the 'view' type
				deferred = get(view, async);

			// if we are async,
			if ( async ) {
				// return the deferred
				response = deferred;
				// and callback callback with the rendered result
				deferred.done(function( renderer ) {
					callback(renderer(data, helpers))
				})
			} else {
				// otherwise, the deferred is complete, so
				// set response to the result of the rendering
				deferred.done(function( renderer ) {
					response = renderer(data, helpers);
				});
			}

			return response;
		}
	},
		// makes sure there's a template, if not, has steal provide a warning
		checkText = function( text, url ) {
			if (!text.match(/[^\s]/) ) {
				
				throw "$.View ERROR: There is no template or an empty template at " + url;
			}
		},
		// returns a 'view' renderer deferred
		// url - the url to the view template
		// async - if the ajax request should be synchronous
		get = function( url, async ) {
			return $.ajax({
				url: url,
				dataType: "view",
				async: async
			});
		},
		// returns true if something looks like a deferred
		isDeferred = function( obj ) {
			return obj && $.isFunction(obj.always) // check if obj is a $.Deferred
		},
		// gets an array of deferreds from an object
		// this only goes one level deep
		getDeferreds = function( data ) {
			var deferreds = [];

			// pull out deferreds
			if ( isDeferred(data) ) {
				return [data]
			} else {
				for ( var prop in data ) {
					if ( isDeferred(data[prop]) ) {
						deferreds.push(data[prop]);
					}
				}
			}
			return deferreds;
		},
		// gets the useful part of deferred
		// this is for Models and $.ajax that resolve to array (with success and such)
		// returns the useful, content part
		usefulPart = function( resolved ) {
			return $.isArray(resolved) && resolved.length === 3 && resolved[1] === 'success' ? resolved[0] : resolved
		};



	// you can request a view renderer (a function you pass data to and get html)
	// Creates a 'view' transport.  These resolve to a 'view' renderer
	// a 'view' renderer takes data and returns a string result.
	// For example:
	//
	//  $.ajax({dataType : 'view', src: 'foo.ejs'}).then(function(renderer){
	//     renderer({message: 'hello world'})
	//  })
	$.ajaxTransport("view", function( options, orig ) {
		// the url (or possibly id) of the view content
		var url = orig.url,
			// check if a suffix exists (ex: "foo.ejs")
			suffix = url.match(/\.[\w\d]+$/),
			type,
			// if we are reading a script element for the content of the template
			// el will be set to that script element
			el,
			// a unique identifier for the view (used for caching)
			// this is typically derived from the element id or
			// the url for the template
			id,
			// the AJAX request used to retrieve the template content
			jqXHR,

			// used to generate the response
			response = function( text ) {
				// get the renderer function
				var func = type.renderer(id, text);
				// cache if if we are caching
				if ( $view.cache ) {
					$view.cached[id] = func;
				}
				// return the objects for the response's dataTypes
				// (in this case view)
				return {
					view: func
				};
			};

		// if we have an inline template, derive the suffix from the 'text/???' part
		// this only supports '<script></script>' tags
		if ( el = document.getElementById(url) ) {
			suffix = "."+el.type.match(/\/(x\-)?(.+)/)[2];
		}

		// if there is no suffix, add one
		if (!suffix ) {
			suffix = $view.ext;
			url = url + $view.ext;
		}

		// convert to a unique and valid id
		id = toId(url);

		// if a absolute path, use steal to get it
		// you should only be using // if you are using steal
		if ( url.match(/^\/\//) ) {
			var sub = url.substr(2);
			url = typeof steal === "undefined" ?
				url = "/" + sub :
				steal.root.mapJoin(sub) +'';
		}

		//set the template engine type
		type = $view.types[suffix];

		// !-- FOUNDRY HACK --! //
		// Retrieve templates stored within $.template
		var template = $.template()[orig.url];

		// return the ajax transport contract: http://api.jquery.com/extending-ajax/
		return {
			send: function( headers, callback ) {

				// !-- FOUNDRY HACK --! //
				// Retrieve templates stored within $.template
				if ( template ) {

					type = $view.types["." + template.type];

					return callback(200, "success", response(template.content));

				// if it is cached,
				} else if ( $view.cached[id] ) {

					// return the catched renderer
					return callback(200, "success", {
						view: $view.cached[id]
					});

				// otherwise if we are getting this from a script elment
				} else if ( el ) {
					// resolve immediately with the element's innerHTML
					callback(200, "success", response(el.innerHTML));
				} else {
					// make an ajax request for text
					jqXHR = $.ajax({
						async: orig.async,
						url: url,
						dataType: "text",
						error: function() {
							checkText("", url);
							callback(404);
						},
						success: function( text ) {
							// make sure we got some text back
							checkText(text, url);
							// cache and send back text
							callback(200, "success", response(text))
						}
					});
				}
			},
			abort: function() {
				jqXHR && jqXHR.abort();
			}
		}
	})
	$.extend($view, {
		/**
		 * @attribute hookups
		 * @hide
		 * A list of pending 'hookups'
		 */
		hookups: {},
		/**
		 * @function hookup
		 * Registers a hookup function that can be called back after the html is
		 * put on the page.  Typically this is handled by the template engine.  Currently
		 * only EJS supports this functionality.
		 *
		 *     var id = $.View.hookup(function(el){
		 *            //do something with el
		 *         }),
		 *         html = "<div data-view-id='"+id+"'>"
		 *     $('.foo').html(html);
		 *
		 *
		 * @param {Function} cb a callback function to be called with the element
		 * @param {Number} the hookup number
		 */
		hookup: function( cb ) {
			var myid = ++id;
			$view.hookups[myid] = cb;
			return myid;
		},
		/**
		 * @attribute cached
		 * @hide
		 * Cached are put in this object
		 */
		cached: {},
		/**
		 * @attribute cache
		 * Should the views be cached or reloaded from the server. Defaults to true.
		 */
		cache: true,
		/**
		 * @function register
		 * Registers a template engine to be used with
		 * view helpers and compression.
		 *
		 * ## Example
		 *
		 * @codestart
		 * $.View.register({
		 * 	suffix : "tmpl",
		 *  plugin : "jquery/view/tmpl",
		 * 	renderer: function( id, text ) {
		 * 		return function(data){
		 * 			return jQuery.render( text, data );
		 * 		}
		 * 	},
		 * 	script: function( id, text ) {
		 * 		var tmpl = $.tmpl(text).toString();
		 * 		return "function(data){return ("+
		 * 		  	tmpl+
		 * 			").call(jQuery, jQuery, data); }";
		 * 	}
		 * })
		 * @codeend
		 * Here's what each property does:
		 *
		 *    * plugin - the location of the plugin
		 *    * suffix - files that use this suffix will be processed by this template engine
		 *    * renderer - returns a function that will render the template provided by text
		 *    * script - returns a string form of the processed template function.
		 *
		 * @param {Object} info a object of method and properties
		 *
		 * that enable template integration:
		 * <ul>
		 *   <li>plugin - the location of the plugin.  EX: 'jquery/view/ejs'</li>
		 *   <li>suffix - the view extension.  EX: 'ejs'</li>
		 *   <li>script(id, src) - a function that returns a string that when evaluated returns a function that can be
		 *    used as the render (i.e. have func.call(data, data, helpers) called on it).</li>
		 *   <li>renderer(id, text) - a function that takes the id of the template and the text of the template and
		 *    returns a render function.</li>
		 * </ul>
		 */
		register: function( info ) {
			this.types["." + info.suffix] = info;

			if ( window.steal ) {
				steal.type(info.suffix + " view js", function( options, success, error ) {
					var type = $view.types["." + options.type],
						id = toId(options.rootSrc+'');

					options.text = type.script(id, options.text)
					success();
				})
			}
		},
		types: {},
		/**
		 * @attribute ext
		 * The default suffix to use if none is provided in the view's url.
		 * This is set to .ejs by default.
		 */
		ext: ".ejs",
		/**
		 * Returns the text that
		 * @hide
		 * @param {Object} type
		 * @param {Object} id
		 * @param {Object} src
		 */
		registerScript: function( type, id, src ) {
			return "$.View.preload('" + id + "'," + $view.types["." + type].script(id, src) + ");";
		},
		/**
		 * @hide
		 * Called by a production script to pre-load a renderer function
		 * into the view cache.
		 * @param {String} id
		 * @param {Function} renderer
		 */
		preload: function( id, renderer ) {
			$view.cached[id] = function( data, helpers ) {
				return renderer.call(data, data, helpers);
			};
		}

	});
	if ( window.steal ) {
		steal.type("view js", function( options, success, error ) {
			var type = $view.types["." + options.type],
				id = toId(options.rootSrc+'');

			options.text = "steal('" + (type.plugin || "jquery/view/" + options.type) + "').then(function($){" + "$.View.preload('" + id + "'," + options.text + ");\n})";
			success();
		})
	}

	//---- ADD jQUERY HELPERS -----
	//converts jquery functions to use views
	var convert, modify, isTemplate, isHTML, isDOM, getCallback, hookupView, funcs,
		// text and val cannot produce an element, so don't run hookups on them
		noHookup = {'val':true,'text':true};

	convert = function( func_name ) {
		// save the old jQuery helper
		var old = $.fn[func_name];

		// replace it wiht our new helper
		$.fn[func_name] = function() {

			var args = makeArray(arguments),
				callbackNum,
				callback,
				self = this,
				result;

			// if the first arg is a deferred
			// wait until it finishes, and call
			// modify with the result
			if ( isDeferred(args[0]) ) {
				args[0].done(function( res ) {
					modify.call(self, [res], old);
				})
				return this;
			}
			//check if a template
			else if ( isTemplate(args) ) {

				// if we should operate async
				if ((callbackNum = getCallback(args))) {
					callback = args[callbackNum];
					args[callbackNum] = function( result ) {
						modify.call(self, [result], old);
						callback.call(self, result);
					};
					$view.apply($view, args);
					return this;
				}
				// call view with args (there might be deferreds)
				result = $view.apply($view, args);

				// if we got a string back
				if (!isDeferred(result) ) {
					// we are going to call the old method with that string
					args = [result];
				} else {
					// if there is a deferred, wait until it is done before calling modify
					result.done(function( res ) {
						modify.call(self, [res], old);
					})
					return this;
				}
			}
			return noHookup[func_name] ? old.apply(this,args) :
				modify.call(this, args, old);
		};
	};

	// modifies the content of the element
	// but also will run any hookup
	modify = function( args, old ) {
		var res, stub, hooks;

		//check if there are new hookups
		for ( var hasHookups in $view.hookups ) {
			break;
		}

		//if there are hookups, get jQuery object
		if ( hasHookups && args[0] && isHTML(args[0]) ) {
			hooks = $view.hookups;
			$view.hookups = {};
			args[0] = $(args[0]);
		}
		res = old.apply(this, args);

		//now hookup the hookups
		if ( hooks
		/* && args.length*/
		) {
			hookupView(args[0], hooks);
		}
		return res;
	};

	// returns true or false if the args indicate a template is being used
	// $('#foo').html('/path/to/template.ejs',{data})
	// in general, we want to make sure the first arg is a string
	// and the second arg is data
	isTemplate = function( args ) {
		// save the second arg type
		var secArgType = typeof args[1];

		// the first arg is a string
		return typeof args[0] == "string" &&
				// the second arg is an object or function
		       (secArgType == 'object' || secArgType == 'function') &&
			   // but it is not a dom element
			   !isDOM(args[1]);
	};
	// returns true if the arg is a jQuery object or HTMLElement
	isDOM = function(arg){
		return arg.nodeType || arg.jquery
	};
	// returns whether the argument is some sort of HTML data
	isHTML = function( arg ) {
		if ( isDOM(arg) ) {
			// if jQuery object or DOM node we're good
			return true;
		} else if ( typeof arg === "string" ) {
			// if string, do a quick sanity check that we're HTML
			arg = $.trim(arg);
			return arg.substr(0, 1) === "<" && arg.substr(arg.length - 1, 1) === ">" && arg.length >= 3;
		} else {
			// don't know what you are
			return false;
		}
	};

	//returns the callback arg number if there is one (for async view use)
	getCallback = function( args ) {
		return typeof args[3] === 'function' ? 3 : typeof args[2] === 'function' && 2;
	};

	hookupView = function( els, hooks ) {
		//remove all hookups
		var hookupEls, len, i = 0,
			id, func;
		els = els.filter(function() {
			return this.nodeType != 3; //filter out text nodes
		})
		hookupEls = els.add("[data-view-id]", els);
		len = hookupEls.length;
		for (; i < len; i++ ) {
			if ( hookupEls[i].getAttribute && (id = hookupEls[i].getAttribute('data-view-id')) && (func = hooks[id]) ) {
				func(hookupEls[i], id);
				delete hooks[id];
				hookupEls[i].removeAttribute('data-view-id');
			}
		}
		//copy remaining hooks back
		$.extend($view.hookups, hooks);
	};

	/**
	 *  @add jQuery.fn
	 *  @parent jQuery.View
	 *  Called on a jQuery collection that was rendered with $.View with pending hookups.  $.View can render a
	 *  template with hookups, but not actually perform the hookup, because it returns a string without actual DOM
	 *  elements to hook up to.  So hookup performs the hookup and clears the pending hookups, preventing errors in
	 *  future templates.
	 *
	 * @codestart
	 * $($.View('//views/recipes.ejs',recipeData)).hookup()
	 * @codeend
	 */
	$.fn.hookup = function() {
		var hooks = $view.hookups;
		$view.hookups = {};
		hookupView(this, hooks);
		return this;
	};

	/**
	 *  @add jQuery.fn
	 */
	$.each([
	/**
	 *  @function prepend
	 *  @parent jQuery.View
	 *
	 *  Extending the original [http://api.jquery.com/prepend/ jQuery().prepend()]
	 *  to render [jQuery.View] templates inserted at the beginning of each element in the set of matched elements.
	 *
	 *  	$('#test').prepend('path/to/template.ejs', { name : 'javascriptmvc' });
	 *
	 *  @param {String|Object|Function} content A template filename or the id of a view script tag
	 *  or a DOM element, array of elements, HTML string, or jQuery object.
	 *  @param {Object} [data] The data to render the view with.
	 *  If rendering a view template this parameter always has to be present
	 *  (use the empty object initializer {} for no data).
	 */
	"prepend",
	/**
	 *  @function append
	 *  @parent jQuery.View
	 *
	 *  Extending the original [http://api.jquery.com/append/ jQuery().append()]
	 *  to render [jQuery.View] templates inserted at the end of each element in the set of matched elements.
	 *
	 *  	$('#test').append('path/to/template.ejs', { name : 'javascriptmvc' });
	 *
	 *  @param {String|Object|Function} content A template filename or the id of a view script tag
	 *  or a DOM element, array of elements, HTML string, or jQuery object.
	 *  @param {Object} [data] The data to render the view with.
	 *  If rendering a view template this parameter always has to be present
	 *  (use the empty object initializer {} for no data).
	 */
	"append",
	/**
	 *  @function after
	 *  @parent jQuery.View
	 *
	 *  Extending the original [http://api.jquery.com/after/ jQuery().after()]
	 *  to render [jQuery.View] templates inserted after each element in the set of matched elements.
	 *
	 *  	$('#test').after('path/to/template.ejs', { name : 'javascriptmvc' });
	 *
	 *  @param {String|Object|Function} content A template filename or the id of a view script tag
	 *  or a DOM element, array of elements, HTML string, or jQuery object.
	 *  @param {Object} [data] The data to render the view with.
	 *  If rendering a view template this parameter always has to be present
	 *  (use the empty object initializer {} for no data).
	 */
	"after",
	/**
	 *  @function before
	 *  @parent jQuery.View
	 *
	 *  Extending the original [http://api.jquery.com/before/ jQuery().before()]
	 *  to render [jQuery.View] templates inserted before each element in the set of matched elements.
	 *
	 *  	$('#test').before('path/to/template.ejs', { name : 'javascriptmvc' });
	 *
	 *  @param {String|Object|Function} content A template filename or the id of a view script tag
	 *  or a DOM element, array of elements, HTML string, or jQuery object.
	 *  @param {Object} [data] The data to render the view with.
	 *  If rendering a view template this parameter always has to be present
	 *  (use the empty object initializer {} for no data).
	 */
	"before",
	/**
	 *  @function text
	 *  @parent jQuery.View
	 *
	 *  Extending the original [http://api.jquery.com/text/ jQuery().text()]
	 *  to render [jQuery.View] templates as the content of each matched element.
	 *  Unlike [jQuery.fn.html] jQuery.fn.text also works with XML, escaping the provided
	 *  string as necessary.
	 *
	 *  	$('#test').text('path/to/template.ejs', { name : 'javascriptmvc' });
	 *
	 *  @param {String|Object|Function} content A template filename or the id of a view script tag
	 *  or a DOM element, array of elements, HTML string, or jQuery object.
	 *  @param {Object} [data] The data to render the view with.
	 *  If rendering a view template this parameter always has to be present
	 *  (use the empty object initializer {} for no data).
	 */
	"text",
	/**
	 *  @function html
	 *  @parent jQuery.View
	 *
	 *  Extending the original [http://api.jquery.com/html/ jQuery().html()]
	 *  to render [jQuery.View] templates as the content of each matched element.
	 *
	 *  	$('#test').html('path/to/template.ejs', { name : 'javascriptmvc' });
	 *
	 *  @param {String|Object|Function} content A template filename or the id of a view script tag
	 *  or a DOM element, array of elements, HTML string, or jQuery object.
	 *  @param {Object} [data] The data to render the view with.
	 *  If rendering a view template this parameter always has to be present
	 *  (use the empty object initializer {} for no data).
	 */
	"html",
	/**
	 *  @function replaceWith
	 *  @parent jQuery.View
	 *
	 *  Extending the original [http://api.jquery.com/replaceWith/ jQuery().replaceWith()]
	 *  to render [jQuery.View] templates replacing each element in the set of matched elements.
	 *
	 *  	$('#test').replaceWith('path/to/template.ejs', { name : 'javascriptmvc' });
	 *
	 *  @param {String|Object|Function} content A template filename or the id of a view script tag
	 *  or a DOM element, array of elements, HTML string, or jQuery object.
	 *  @param {Object} [data] The data to render the view with.
	 *  If rendering a view template this parameter always has to be present
	 *  (use the empty object initializer {} for no data).
	 */
	"replaceWith", "val"],function(i, func){
		convert(func);
	});

	//go through helper funcs and convert


})();(function(){

	// HELPER METHODS ==============
	var myEval = function( script ) {
		eval(script);
	},
		// removes the last character from a string
		// this is no longer needed
		// chop = function( string ) {
		//	return string.substr(0, string.length - 1);
		//},
		rSplit = $.String.rsplit,
		extend = $.extend,
		isArray = $.isArray,
		// regular expressions for caching
		returnReg = /\r\n/g,
		retReg = /\r/g,
		newReg = /\n/g,
		nReg = /\n/,
		slashReg = /\\/g,
		quoteReg = /"/g,
		singleQuoteReg = /'/g,
		tabReg = /\t/g,
		leftBracket = /\{/g,
		rightBracket = /\}/g,
		quickFunc = /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
		// escapes characters starting with \
		clean = function( content ) {
			return content.replace(slashReg, '\\\\').replace(newReg, '\\n').replace(quoteReg, '\\"').replace(tabReg, '\\t');
		},
		// escapes html
		// - from prototype  http://www.prototypejs.org/
		escapeHTML = function( content ) {
			return content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(quoteReg, '&#34;').replace(singleQuoteReg, "&#39;");
		},
		$View = $.View,
		bracketNum = function(content){
			var lefts = content.match(leftBracket),
				rights = content.match(rightBracket);

			return (lefts ? lefts.length : 0) -
				   (rights ? rights.length : 0);
		},
		/**
		 * @class jQuery.EJS
		 *
		 * @plugin jquery/view/ejs
		 * @parent jQuery.View
		 * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/view/ejs/ejs.js
		 * @test jquery/view/ejs/qunit.html
		 *
		 *
		 * Ejs provides <a href="http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/">ERB</a>
		 * style client side templates.  Use them with controllers to easily build html and inject
		 * it into the DOM.
		 *
		 * ###  Example
		 *
		 * The following generates a list of tasks:
		 *
		 * @codestart html
		 * &lt;ul>
		 * &lt;% for(var i = 0; i < tasks.length; i++){ %>
		 *     &lt;li class="task &lt;%= tasks[i].identity %>">&lt;%= tasks[i].name %>&lt;/li>
		 * &lt;% } %>
		 * &lt;/ul>
		 * @codeend
		 *
		 * For the following examples, we assume this view is in <i>'views\tasks\list.ejs'</i>.
		 *
		 *
		 * ## Use
		 *
		 * ### Loading and Rendering EJS:
		 *
		 * You should use EJS through the helper functions [jQuery.View] provides such as:
		 *
		 *   - [jQuery.fn.after after]
		 *   - [jQuery.fn.append append]
		 *   - [jQuery.fn.before before]
		 *   - [jQuery.fn.html html],
		 *   - [jQuery.fn.prepend prepend],
		 *   - [jQuery.fn.replaceWith replaceWith], and
		 *   - [jQuery.fn.text text].
		 *
		 * or [jQuery.Controller.prototype.view].
		 *
		 * ### Syntax
		 *
		 * EJS uses 5 types of tags:
		 *
		 *   - <code>&lt;% CODE %&gt;</code> - Runs JS Code.
		 *     For example:
		 *
		 *         <% alert('hello world') %>
		 *
		 *   - <code>&lt;%= CODE %&gt;</code> - Runs JS Code and writes the _escaped_ result into the result of the template.
		 *     For example:
		 *
		 *         <h1><%= 'hello world' %></h1>
		 *
		 *   - <code>&lt;%== CODE %&gt;</code> - Runs JS Code and writes the _unescaped_ result into the result of the template.
		 *     For example:
		 *
		 *         <h1><%== '<span>hello world</span>' %></h1>
		 *
		 *   - <code>&lt;%%= CODE %&gt;</code> - Writes <%= CODE %> to the result of the template.  This is very useful for generators.
		 *
		 *         <%%= 'hello world' %>
		 *
		 *   - <code>&lt;%# CODE %&gt;</code> - Used for comments.  This does nothing.
		 *
		 *         <%# 'hello world' %>
		 *
		 * ## Hooking up controllers
		 *
		 * After drawing some html, you often want to add other widgets and plugins inside that html.
		 * View makes this easy.  You just have to return the Contoller class you want to be hooked up.
		 *
		 * @codestart
		 * &lt;ul &lt;%= Mxui.Tabs%>>...&lt;ul>
		 * @codeend
		 *
		 * You can even hook up multiple controllers:
		 *
		 * @codestart
		 * &lt;ul &lt;%= [Mxui.Tabs, Mxui.Filler]%>>...&lt;ul>
		 * @codeend
		 *
		 * To hook up a controller with options or any other jQuery plugin use the
		 * [jQuery.EJS.Helpers.prototype.plugin | plugin view helper]:
		 *
		 * @codestart
		 * &lt;ul &lt;%= plugin('mxui_tabs', { option: 'value' }) %>>...&lt;ul>
		 * @codeend
		 *
		 * Don't add a semicolon when using view helpers.
		 *
		 *
		 * <h2>View Helpers</h2>
		 * View Helpers return html code.  View by default only comes with
		 * [jQuery.EJS.Helpers.prototype.view view] and [jQuery.EJS.Helpers.prototype.text text].
		 * You can include more with the view/helpers plugin.  But, you can easily make your own!
		 * Learn how in the [jQuery.EJS.Helpers Helpers] page.
		 *
		 * @constructor Creates a new view
		 * @param {Object} options A hash with the following options
		 * <table class="options">
		 *     <tbody><tr><th>Option</th><th>Default</th><th>Description</th></tr>
		 *     <tr>
		 *      <td>text</td>
		 *      <td>&nbsp;</td>
		 *      <td>uses the provided text as the template. Example:<br/><code>new View({text: '&lt;%=user%>'})</code>
		 *      </td>
		 *     </tr>
		 *     <tr>
		 *      <td>type</td>
		 *      <td>'<'</td>
		 *      <td>type of magic tags.  Options are '&lt;' or '['
		 *      </td>
		 *     </tr>
		 *     <tr>
		 *      <td>name</td>
		 *      <td>the element ID or url </td>
		 *      <td>an optional name that is used for caching.
		 *      </td>
		 *     </tr>
		 *    </tbody></table>
		 */
		EJS = function( options ) {
			// If called without new, return a function that
			// renders with data and helpers like
			// EJS({text: '<%= message %>'})({message: 'foo'});
			// this is useful for steal's build system
			if ( this.constructor != EJS ) {
				var ejs = new EJS(options);
				return function( data, helpers ) {
					return ejs.render(data, helpers);
				};
			}
			// if we get a function directly, it probably is coming from
			// a steal-packaged view
			if ( typeof options == "function" ) {
				this.template = {
					fn: options
				};
				return;
			}
			//set options on self
			extend(this, EJS.options, options);
			this.template = compile(this.text, this.type, this.name);
		};
	// add EJS to jQuery if it exists
	$ && ($.EJS = EJS);
	/**
	 * @Prototype
	 */
	EJS.prototype.
	/**
	 * Renders an object with view helpers attached to the view.
	 *
	 *     new EJS({text: "<%= message %>"}).render({
	 *       message: "foo"
	 *     },{helper: function(){ ... }})
	 *
	 * @param {Object} object data to be rendered
	 * @param {Object} [extraHelpers] an object with view helpers
	 * @return {String} returns the result of the string
	 */
	render = function( object, extraHelpers ) {
		object = object || {};
		this._extra_helpers = extraHelpers;
		var v = new EJS.Helpers(object, extraHelpers || {});
		return this.template.fn.call(object, object, v);
	};
	/**
	 * @Static
	 */

	extend(EJS, {
		/**
		 * Used to convert what's in &lt;%= %> magic tags to a string
		 * to be inserted in the rendered output.
		 *
		 * Typically, it's a string, and the string is just inserted.  However,
		 * if it's a function or an object with a hookup method, it can potentially be
		 * be ran on the element after it's inserted into the page.
		 *
		 * This is a very nice way of adding functionality through the view.
		 * Usually this is done with [jQuery.EJS.Helpers.prototype.plugin]
		 * but the following fades in the div element after it has been inserted:
		 *
		 * @codestart
		 * &lt;%= function(el){$(el).fadeIn()} %>
		 * @codeend
		 *
		 * @param {String|Object|Function} input the value in between the
		 * write magic tags: &lt;%= %>
		 * @return {String} returns the content to be added to the rendered
		 * output.  The content is different depending on the type:
		 *
		 *   * string - the original string
		 *   * null or undefined - the empty string ""
		 *   * an object with a hookup method - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
		 *   * a function - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
		 *   * an array - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
		 */
		text: function( input ) {
			// if it's a string, return
			if ( typeof input == 'string' ) {
				return input;
			}
			// if has no value
			if ( input === null || input === undefined ) {
				return '';
			}

			// if it's an object, and it has a hookup method
			var hook = (input.hookup &&
			// make a function call the hookup method

			function( el, id ) {
				input.hookup.call(input, el, id);
			}) ||
			// or if it's a function, just use the input
			(typeof input == 'function' && input) ||
			// of it its an array, make a function that calls hookup or the function
			// on each item in the array
			(isArray(input) &&
			function( el, id ) {
				for ( var i = 0; i < input.length; i++ ) {
					input[i].hookup ? input[i].hookup(el, id) : input[i](el, id);
				}
			});
			// finally, if there is a funciton to hookup on some dom
			// pass it to hookup to get the data-view-id back
			if ( hook ) {
				return "data-view-id='" + $View.hookup(hook) + "'";
			}
			// finally, if all else false, toString it
			return input.toString ? input.toString() : "";
		},
		/**
		 * Escapes the text provided as html if it's a string.
		 * Otherwise, the value is passed to EJS.text(text).
		 *
		 * @param {String|Object|Array|Function} text to escape.  Otherwise,
		 * the result of [jQuery.EJS.text] is returned.
		 * @return {String} the escaped text or likely a $.View data-view-id attribute.
		 */
		clean: function( text ) {
			//return sanatized text
			if ( typeof text == 'string' ) {
				return escapeHTML(text);
			} else if ( typeof text == 'number' ) {
				return text;
			} else {
				return EJS.text(text);
			}
		},
		/**
		 * @attribute options
		 * Sets default options for all views.
		 *
		 *     $.EJS.options.type = '['
		 *
		 * Only one option is currently supported: type.
		 *
		 * Type is the left hand magic tag.
		 */
		options: {
			type: '[',
			ext: '.ejs'
		}
	});
	// ========= SCANNING CODE =========
	// Given a scanner, and source content, calls block  with each token
	// scanner - an object of magicTagName : values
	// source - the source you want to scan
	// block - function(token, scanner), called with each token
	var scan = function( scanner, source, block ) {
		// split on /\n/ to have new lines on their own line.
		var source_split = rSplit(source, nReg),
			i = 0;
		for (; i < source_split.length; i++ ) {
			scanline(scanner, source_split[i], block);
		}

	},
		scanline = function( scanner, line, block ) {
			scanner.lines++;
			var line_split = rSplit(line, scanner.splitter),
				token;
			for ( var i = 0; i < line_split.length; i++ ) {
				token = line_split[i];
				if ( token !== null ) {
					block(token, scanner);
				}
			}
		},
		// creates a 'scanner' object.  This creates
		// values for the left and right magic tags
		// it's splitter property is a regexp that splits content
		// by all tags
		makeScanner = function( left, right ) {
			var scanner = {};
			extend(scanner, {
				left: left + '%',
				right: '%' + right,
				dLeft: left + '%%',
				dRight: '%%' + right,
				eeLeft : left + '%==',
				eLeft: left + '%=',
				cmnt: left + '%#',
				cleanLeft: left+"%~",
				scan: scan,
				lines: 0
			});
			scanner.splitter = new RegExp("(" + [scanner.dLeft, scanner.dRight, scanner.eeLeft, scanner.eLeft, scanner.cmnt, scanner.left, scanner.right + '\n', scanner.right, '\n'].join(")|(").
			replace(/\[/g, "\\[").replace(/\]/g, "\\]") + ")");
			return scanner;
		},


		// compiles a template where
		// source - template text
		// left - the left magic tag
		// name - the name of the template (for debugging)
		// returns an object like: {out : "", fn : function(){ ... }} where
		//   out -  the converted JS source of the view
		//   fn - a function made from the JS source
		compile = function( source, left, name ) {
			// make everything only use \n
			source = source.replace(returnReg, "\n").replace(retReg, "\n");
			// if no left is given, assume <
			left = left || '[';

			// put and insert cmds are used for adding content to the template
			// currently they are identical, I am not sure why
			var put_cmd = "___v1ew.push(",
				insert_cmd = put_cmd,
				// the text that starts the view code (or block function)
				startTxt = 'var ___v1ew = [];',
				// the text that ends the view code (or block function)
				finishTxt = "return ___v1ew.join('')",
				// initialize a buffer
				buff = new EJS.Buffer([startTxt], []),
				// content is used as the current 'processing' string
				// this is the content between magic tags
				content = '',
				// adds something to be inserted into the view template
				// this comes out looking like __v1ew.push("CONENT")
				put = function( content ) {
					buff.push(put_cmd, '"', clean(content), '");');
				},
				// the starting magic tag
				startTag = null,
				// cleans the running content
				empty = function() {
					content = ''
				},
				// what comes after clean or text
				doubleParen = "));",
				// a stack used to keep track of how we should end a bracket }
				// once we have a <%= %> with a leftBracket
				// we store how the file should end here (either '))' or ';' )
				endStack =[];

			// start going token to token
			scan(makeScanner(left, left === '[' ? ']' : '>'), source || "", function( token, scanner ) {
				// if we don't have a start pair
				var bn;
				if ( startTag === null ) {
					switch ( token ) {
					case '\n':
						content = content + "\n";
						put(content);
						buff.cr();
						empty();
						break;
						// set start tag, add previous content (if there is some)
						// clean content
					case scanner.left:
					case scanner.eLeft:
					case scanner.eeLeft:
					case scanner.cmnt:
						// a new line, just add whatever content w/i a clean
						// reset everything
						startTag = token;
						if ( content.length > 0 ) {
							put(content);
						}
						empty();
						break;

					case scanner.dLeft:
						// replace <%% with <%
						content += scanner.left;
						break;
					default:
						content += token;
						break;
					}
				}
				else {
					//we have a start tag
					switch ( token ) {
					case scanner.right:
						// %>
						switch ( startTag ) {
						case scanner.left:
							// <%

							// get the number of { minus }
							bn = bracketNum(content);
							// how are we ending this statement
							var last =
								// if the stack has value and we are ending a block
								endStack.length && bn == -1 ?
								// use the last item in the block stack
								endStack.pop() :
								// or use the default ending
								";";

							// if we are ending a returning block
							// add the finish text which returns the result of the
							// block
							if(last === doubleParen) {
								buff.push(finishTxt)
							}
							// add the remaining content
							buff.push(content, last);

							// if we have a block, start counting
							if(bn === 1 ){
								endStack.push(";")
							}
							break;
						case scanner.eLeft:
							// <%= clean content
							bn = bracketNum(content);
							if( bn ) {
								endStack.push(doubleParen)
							}
							if(quickFunc.test(content)){
								var parts = content.match(quickFunc)
								content = "function(__){var "+parts[1]+"=$(__);"+parts[2]+"}"
							}
							buff.push(insert_cmd, $.globalNamespace + ".EJS.clean(", content,bn ? startTxt : doubleParen);
							break;
						case scanner.eeLeft:
							// <%== content

							// get the number of { minus }
							bn = bracketNum(content);
							// if we have more {, it means there is a block
							if( bn ){
								// when we return to the same # of { vs } end wiht a doubleParen
								endStack.push(doubleParen)
							}

							buff.push(insert_cmd, $.globalNamespace + ".EJS.text(", content,
								// if we have a block
								bn ?
								// start w/ startTxt "var _v1ew = [])"
								startTxt :
								// if not, add doubleParent to close push and text
								doubleParen
								);
							break;
						}
						startTag = null;
						empty();
						break;
					case scanner.dRight:
						content += scanner.right;
						break;
					default:
						content += token;
						break;
					}
				}
			})
			if ( content.length > 0 ) {
				// Should be content.dump in Ruby
				buff.push(put_cmd, '"', clean(content) + '");');
			}
			var template = buff.close(),
				out = {
					out: 'try { with(_VIEW) { with (_CONTEXT) {' + template + " "+finishTxt+"}}}catch(e){e.lineNumber=null;throw e;}"
				};
			//use eval instead of creating a function, b/c it is easier to debug
			// myEval.call(out, 'this.fn = (function(_CONTEXT,_VIEW){' + out.out + '});\r\n//@ sourceURL=' + name + ".js");

			// !-- FOUNDRY HACK --! //
			// Removed //@ sourceURL as it will break with conditional compilation turned on in IE.
			myEval.call(out, 'this.fn = (function(_CONTEXT,_VIEW){ var $ = ' + $.globalNamespace + ';' + out.out + '});');

			return out;
		};


	// A Buffer used to add content to.
	// This is useful for performance and simplifying the
	// code above.
	// We also can use this so we know line numbers when there
	// is an error.
	// pre_cmd - code that sets up the buffer
	// post - code that finalizes the buffer
	EJS.Buffer = function( pre_cmd, post ) {
		// the current line we are on
		this.line = [];
		// the combined content added to this buffer
		this.script = [];
		// content at the end of the buffer
		this.post = post;
		// add the pre commands to the first line
		this.push.apply(this, pre_cmd);
	};
	EJS.Buffer.prototype = {
		// add content to this line
		// need to maintain your own semi-colons (for performance)
		push: function() {
			this.line.push.apply(this.line, arguments);
		},
		// starts a new line
		cr: function() {
			this.script.push(this.line.join(''), "\n");
			this.line = [];
		},
		//returns the script too
		close: function() {
			// if we have ending line content, add it to the script
			if ( this.line.length > 0 ) {
				this.script.push(this.line.join(''));
				this.line = [];
			}
			// if we have ending content, add it
			this.post.length && this.push.apply(this, this.post);
			// always end in a ;
			this.script.push(";");
			return this.script.join("");
		}

	};

	/**
	 * @class jQuery.EJS.Helpers
	 * @parent jQuery.EJS
	 * By adding functions to jQuery.EJS.Helpers.prototype, those functions will be available in the
	 * views.
	 *
	 * The following helper converts a given string to upper case:
	 *
	 * 	$.EJS.Helpers.prototype.toUpper = function(params)
	 * 	{
	 * 		return params.toUpperCase();
	 * 	}
	 *
	 * Use it like this in any EJS template:
	 *
	 * 	<%= toUpper('javascriptmvc') %>
	 *
	 * To access the current DOM element return a function that takes the element as a parameter:
	 *
	 * 	$.EJS.Helpers.prototype.upperHtml = function(params)
	 * 	{
	 * 		return function(el) {
	 * 			$(el).html(params.toUpperCase());
	 * 		}
	 * 	}
	 *
	 * In your EJS view you can then call the helper on an element tag:
	 *
	 * 	<div <%= upperHtml('javascriptmvc') %>></div>
	 *
	 *
	 * @constructor Creates a view helper.  This function
	 * is called internally.  You should never call it.
	 * @param {Object} data The data passed to the
	 * view.  Helpers have access to it through this._data
	 */
	EJS.Helpers = function( data, extras ) {
		this._data = data;
		this._extras = extras;
		extend(this, extras);
	};
	/**
	 * @prototype
	 */
	EJS.Helpers.prototype = {
		/**
		 * Hooks up a jQuery plugin on.
		 * @param {String} name the plugin name
		 */
		plugin: function( name ) {
			var args = $.makeArray(arguments),
				widget = args.shift();
			return function( el ) {
				var jq = $(el);
				jq[widget].apply(jq, args);
			};
		},
		/**
		 * Renders a partial view.  This is deprecated in favor of <code>$.View()</code>.
		 */
		view: function( url, data, helpers ) {
			helpers = helpers || this._extras;
			data = data || this._data;
			return $View(url, data, helpers); //new EJS(options).render(data, helpers);
		}
	};

	// options for steal's build
	$View.register({
		suffix: "ejs",
		//returns a function that renders the view
		script: function( id, src ) {
			return $.globalNamespace + ".EJS(function(_CONTEXT,_VIEW) { " + new EJS({
				text: src,
				name: id
			}).template.out + " })";
		},
		renderer: function( id, text ) {
			return EJS({
				text: text,
				name: id
			});
		}
	});
})();(function(){

	// Alias helpful methods from jQuery
	var isArray = $.isArray,
		isObject = function( obj ) {
			return typeof obj === 'object' && obj !== null && obj;
		},
		makeArray = $.makeArray,
		each = $.each,
		// listens to changes on val and 'bubbles' the event up
		// - val the object to listen to changes on
		// - prop the property name val is at on
		// - parent the parent object of prop
		hookup = function( val, prop, parent ) {
			// if it's an array make a list, otherwise a val
			if (val instanceof $.Observe){
				// we have an observe already
				// make sure it is not listening to this already
				unhookup([val], parent._namespace)
			} else if ( isArray(val) ) {
				val = new $.Observe.List(val)
			} else {
				val = new $.Observe(val)
			}
			// attr (like target, how you (delegate) to get to the target)
            // currentAttr (how to get to you)
            // delegateAttr (hot to get to the delegated Attr)

			//
			//
			//listen to all changes and trigger upwards
			val.bind("change" + parent._namespace, function( ev, attr ) {
				// trigger the type on this ...
				var args = $.makeArray(arguments),
					ev = args.shift();
				if(prop === "*"){
					args[0] = parent.indexOf(val)+"." + args[0]
				} else {
					args[0] = prop +  "." + args[0]
				}
				// change the attr
				//ev.origTarget = ev.origTarget || ev.target;
				// the target should still be the original object ...
				$.event.trigger(ev, args, parent)
			});

			return val;
		},
		unhookup = function(items, namespace){
			var item;
			for(var i =0; i < items.length; i++){
				item = items[i]
				if(  item && item.unbind ){
					item.unbind("change" + namespace)
				}
			}
		},
		// an id to track events for a given observe
		id = 0,
		collecting = null,
		// call to start collecting events (Observe sends all events at once)
		collect = function() {
			if (!collecting ) {
				collecting = [];
				return true;
			}
		},
		// creates an event on item, but will not send immediately
		// if collecting events
		// - item - the item the event should happen on
		// - event - the event name ("change")
		// - args - an array of arguments
		trigger = function( item, event, args ) {
			// send no events if initalizing
			if (item._init) {
				return;
			}
			if (!collecting ) {
				return $.event.trigger(event, args, item, true)
			} else {
				collecting.push({
					t: item,
					ev: event,
					args: args
				})
			}
		},
		// which batch of events this is for, might not want to send multiple
		// messages on the same batch.  This is mostly for
		// event delegation
		batchNum = 0,
		// sends all pending events
		sendCollection = function() {
			var len = collecting.length,
				items = collecting.slice(0),
				cur;
			collecting = null;
			batchNum ++;
			for ( var i = 0; i < len; i++ ) {
				cur = items[i];
				// batchNum
				$.event.trigger({
					type: cur.ev,
					batchNum : batchNum
				}, cur.args, cur.t)
			}

		},
		// a helper used to serialize an Observe or Observe.List where:
		// observe - the observable
		// how - to serialize with 'attrs' or 'serialize'
		// where - to put properties, in a {} or [].
		serialize = function( observe, how, where ) {
			// go through each property
			observe.each(function( name, val ) {
				// if the value is an object, and has a attrs or serialize function
				where[name] = isObject(val) && typeof val[how] == 'function' ?
				// call attrs or serialize to get the original data back
				val[how]() :
				// otherwise return the value
				val
			})
			return where;
		};

	/**
	 * @class jQuery.Observe
	 * @parent jquerymx.lang
	 * @test jquery/lang/observe/qunit.html
	 *
	 * Observe provides the awesome observable pattern for
	 * JavaScript Objects and Arrays. It lets you
	 *
	 *   - Set and remove property or property values on objects and arrays
	 *   - Listen for changes in objects and arrays
	 *   - Work with nested properties
	 *
	 * ## Creating an $.Observe
	 *
	 * To create an $.Observe, or $.Observe.List, you can simply use
	 * the `$.O(data)` shortcut like:
	 *
	 *     var person = $.O({name: 'justin', age: 29}),
	 *         hobbies = $.O(['programming', 'basketball', 'nose picking'])
	 *
	 * Depending on the type of data passed to $.O, it will create an instance of either:
	 *
	 *   - $.Observe, which is used for objects like: `{foo: 'bar'}`, and
	 *   - [jQuery.Observe.List $.Observe.List], which is used for arrays like `['foo','bar']`
	 *
	 * $.Observe.List and $.Observe are very similar. In fact,
	 * $.Observe.List inherits $.Observe and only adds a few extra methods for
	 * manipulating arrays like [jQuery.Observe.List.prototype.push push].  Go to
	 * [jQuery.Observe.List $.Observe.List] for more information about $.Observe.List.
	 *
	 * You can also create a `new $.Observe` simply by pass it the data you want to observe:
	 *
	 *     var data = {
	 *       addresses : [
	 *         {
	 *           city: 'Chicago',
	 *           state: 'IL'
	 *         },
	 *         {
	 *           city: 'Boston',
	 *           state : 'MA'
	 *         }
	 *         ],
	 *       name : "Justin Meyer"
	 *     },
	 *     o = new $.Observe(data);
	 *
	 * _o_ now represents an observable copy of _data_.
	 *
	 * ## Getting and Setting Properties
	 *
	 * Use [jQuery.Observe.prototype.attr attr] and [jQuery.Observe.prototype.attr attrs]
	 * to get and set properties.
	 *
	 * For example, you can read the property values of _o_ with
	 * `observe.attr( name )` like:
	 *
	 *     // read name
	 *     o.attr('name') //-> Justin Meyer
	 *
	 * And set property names of _o_ with
	 * `observe.attr( name, value )` like:
	 *
	 *     // update name
	 *     o.attr('name', "Brian Moschel") //-> o
	 *
	 * Observe handles nested data.  Nested Objects and
	 * Arrays are converted to $.Observe and
	 * $.Observe.Lists.  This lets you read nested properties
	 * and use $.Observe methods on them.  The following
	 * updates the second address (Boston) to 'New York':
	 *
	 *     o.attr('addresses.1').attrs({
	 *       city: 'New York',
	 *       state: 'NY'
	 *     })
	 *
	 * `attrs()` can be used to get all properties back from the observe:
	 *
	 *     o.attrs() // ->
	 *     {
	 *       addresses : [
	 *         {
	 *           city: 'Chicago',
	 *           state: 'IL'
	 *         },
	 *         {
	 *           city: 'New York',
	 *           state : 'MA'
	 *         }
	 *       ],
	 *       name : "Brian Moschel"
	 *     }
	 *
	 * ## Listening to property changes
	 *
	 * When a property value is changed, it creates events
	 * that you can listen to.  There are two ways to listen
	 * for events:
	 *
	 *   - [jQuery.Observe.prototype.bind bind] - listen for any type of change
	 *   - [jQuery.Observe.prototype.delegate delegate] - listen to a specific type of change
	 *
	 * With `bind( "change" , handler( ev, attr, how, newVal, oldVal ) )`, you can listen
	 * to any change that happens within the
	 * observe. The handler gets called with the property name that was
	 * changed, how it was changed ['add','remove','set'], the new value
	 * and the old value.
	 *
	 *     o.bind('change', function( ev, attr, how, nevVal, oldVal ) {
	 *
	 *     })
	 *
	 * `delegate( attr, event, handler(ev, newVal, oldVal ) )` lets you listen
	 * to a specific event on a specific attribute.
	 *
	 *     // listen for name changes
	 *     o.delegate("name","set", function(){
	 *
	 *     })
	 *
	 * Delegate lets you specify multiple attributes and values to match
	 * for the callback. For example,
	 *
	 *     r = $.O({type: "video", id : 5})
	 *     r.delegate("type=images id","set", function(){})
	 *
	 * This is used heavily by [jQuery.route $.route].
	 *
	 * @constructor
	 *
	 * @param {Object} obj a JavaScript Object that will be
	 * converted to an observable
	 */
	$.Class($.globalNamespace + '.Observe',
	/**
	 * @prototype
	 */
	{
		init: function( obj ) {
			// _data is where we keep the properties
			this._data = {};
			// the namespace this object uses to listen to events
			this._namespace = ".observe" + (++id);
			// sets all attrs
			this._init = true;
			this.attrs(obj);
			delete this._init;
		},
		/**
		 * Get or set an attribute on the observe.
		 *
		 *     o = new $.Observe({});
		 *
		 *     // sets a user property
		 *     o.attr('user',{name: 'hank'});
		 *
		 *     // read the user's name
		 *     o.attr('user.name') //-> 'hank'
		 *
		 * If a value is set for the first time, it will trigger
		 * an `'add'` and `'set'` change event.  Once
		 * the value has been added.  Any future value changes will
		 * trigger only `'set'` events.
		 *
		 *
		 * @param {String} attr the attribute to read or write.
		 *
		 *     o.attr('name') //-> reads the name
		 *     o.attr('name', 'Justin') //-> writes the name
		 *
		 * You can read or write deep property names.  For example:
		 *
		 *     o.attr('person', {name: 'Justin'})
		 *     o.attr('person.name') //-> 'Justin'
		 *
		 * @param {Object} [val] if provided, sets the value.
		 * @return {Object} the observable or the attribute property.
		 *
		 * If you are reading, the property value is returned:
		 *
		 *     o.attr('name') //-> Justin
		 *
		 * If you are writing, the observe is returned for chaining:
		 *
		 *     o.attr('name',"Brian").attr('name') //-> Justin
		 */
		attr: function( attr, val ) {

			if ( val === undefined ) {
				// if we are getting a value
				return this._get(attr)
			} else {
				// otherwise we are setting
				this._set(attr, val);
				return this;
			}
		},
		/**
		 * Iterates through each attribute, calling handler
		 * with each attribute name and value.
		 *
		 *     new Observe({foo: 'bar'})
		 *       .each(function(name, value){
		 *         equals(name, 'foo')
		 *         equals(value,'bar')
		 *       })
		 *
		 * @param {function} handler(attrName,value) A function that will get
		 * called back with the name and value of each attribute on the observe.
		 *
		 * Returning `false` breaks the looping.  The following will never
		 * log 3:
		 *
		 *     new Observe({a : 1, b : 2, c: 3})
		 *       .each(function(name, value){
		 *         console.log(value)
		 *         if(name == 2){
		 *           return false;
		 *         }
		 *       })
		 *
		 * @return {jQuery.Observe} the original observable.
		 */
		each: function() {
			return each.apply(null, [this.__get()].concat(makeArray(arguments)))
		},
		/**
		 * Removes a property
		 *
		 *     o =  new $.Observe({foo: 'bar'});
		 *     o.removeAttr('foo'); //-> 'bar'
		 *
		 * This creates a `'remove'` change event. Learn more about events
		 * in [jQuery.Observe.prototype.bind bind] and [jQuery.Observe.prototype.delegate delegate].
		 *
		 * @param {String} attr the attribute name to remove.
		 * @return {Object} the value that was removed.
		 */
		removeAttr: function( attr ) {
			// convert the attr into parts (if nested)
			var parts = isArray(attr) ? attr : attr.split("."),
				// the actual property to remove
				prop = parts.shift(),
				// the current value
				current = this._data[prop];

			// if we have more parts, call removeAttr on that part
			if ( parts.length ) {
				return current.removeAttr(parts)
			} else {
				// otherwise, delete
				delete this._data[prop];
				// create the event
				trigger(this, "change", [prop, "remove", undefined, current]);
				return current;
			}
		},
		// reads a property from the object
		_get: function( attr ) {
			var parts = isArray(attr) ? attr : (""+attr).split("."),
				current = this.__get(parts.shift());
			if ( parts.length ) {
				return current ? current._get(parts) : undefined
			} else {
				return current;
			}
		},
		// reads a property directly if an attr is provided, otherwise
		// returns the 'real' data object itself
		__get: function( attr ) {
			return attr ? this._data[attr] : this._data;
		},
		// sets attr prop as value on this object where
		// attr - is a string of properties or an array  of property values
		// value - the raw value to set
		// description - an object with converters / serializers / defaults / getterSetters?
		_set: function( attr, value ) {
			// convert attr to attr parts (if it isn't already)
			var parts = isArray(attr) ? attr : ("" + attr).split("."),
				// the immediate prop we are setting
				prop = parts.shift(),
				// its current value
				current = this.__get(prop);

			// if we have an object and remaining parts
			if ( isObject(current) && parts.length ) {
				// that object should set it (this might need to call attr)
				current._set(parts, value)
			} else if (!parts.length ) {
				// otherwise, we are setting it on this object
				// todo: check if value is object and transform
				// are we changing the value
				if ( value !== current ) {

					// check if we are adding this for the first time
					// if we are, we need to create an 'add' event
					var changeType = this.__get().hasOwnProperty(prop) ? "set" : "add";

					// set the value on data
					this.__set(prop,
					// if we are getting an object
					isObject(value) ?
					// hook it up to send event to us
					hookup(value, prop, this) :
					// value is normal
					value);



					// trigger the change event
					trigger(this, "change", [prop, changeType, value, current]);

					// if we can stop listening to our old value, do it
					current && unhookup([current], this._namespace);
				}

			} else {
				throw "jQuery.Observe: set a property on an object that does not exist"
			}
		},
		// directly sets a property on this object
		__set: function( prop, val ) {
			this._data[prop] = val;
			// add property directly for easy writing
			// check if its on the prototype so we don't overwrite methods like attrs
			if (!(prop in this.constructor.prototype)) {
				this[prop] = val
			}
		},
		/**
		 * Listens to changes on a jQuery.Observe.
		 *
		 * When attributes of an observe change, including attributes on nested objects,
		 * a `'change'` event is triggered on the observe.  These events come
		 * in three flavors:
		 *
		 *   - `add` - a attribute is added
		 *   - `set` - an existing attribute's value is changed
		 *   - `remove` - an attribute is removed
		 *
		 * The change event is fired with:
		 *
		 *  - the attribute changed
		 *  - how it was changed
		 *  - the newValue of the attribute
		 *  - the oldValue of the attribute
		 *
		 * Example:
		 *
		 *     o = new $.Observe({name : "Payal"});
		 *     o.bind('change', function(ev, attr, how, newVal, oldVal){
		 *       // ev    -> {type: 'change'}
		 *       // attr  -> "name"
		 *       // how   -> "add"
		 *       // newVal-> "Justin"
		 *       // oldVal-> undefined
		 *     })
		 *
		 *     o.attr('name', 'Justin')
		 *
		 * Listening to `change` is only useful for when you want to
		 * know every change on an Observe.  For most applications,
		 * [jQuery.Observe.prototype.delegate delegate] is
		 * much more useful as it lets you listen to specific attribute
		 * changes and sepecific types of changes.
		 *
		 *
		 * @param {String} eventType the event name.  Currently,
		 * only 'change' events are supported. For more fine
		 * grained control, use [jQuery.Observe.prototype.delegate].
		 *
		 * @param {Function} handler(event, attr, how, newVal, oldVal) A
		 * callback function where
		 *
		 *   - event - the event
		 *   - attr - the name of the attribute changed
		 *   - how - how the attribute was changed (add, set, remove)
		 *   - newVal - the new value of the attribute
		 *   - oldVal - the old value of the attribute
		 *
		 * @return {$.Observe} the observe for chaining.
		 */
		bind: function( eventType, handler ) {
			$.fn.bind.apply($([this]), arguments);
			return this;
		},
		/**
		 * Unbinds a listener.  This uses [http://api.jquery.com/unbind/ jQuery.unbind]
		 * and works very similar.  This means you can
		 * use namespaces or unbind all event handlers for a given event:
		 *
		 *     // unbind a specific event handler
		 *     o.unbind('change', handler)
		 *
		 *     // unbind all change event handlers bound with the
		 *     // foo namespace
		 *     o.unbind('change.foo')
		 *
		 *     // unbind all change event handlers
		 *     o.unbind('change')
		 *
		 * @param {String} eventType - the type of event with
		 * any optional namespaces.  Currently, only `change` events
		 * are supported with bind.
		 *
		 * @param {Function} [handler] - The original handler function passed
		 * to [jQuery.Observe.prototype.bind bind].
		 *
		 * @return {jQuery.Observe} the original observe for chaining.
		 */
		unbind: function( eventType, handler ) {
			$.fn.unbind.apply($([this]), arguments);
			return this;
		},
		/**
		 * Get the serialized Object form of the observe.  Serialized
		 * data is typically used to send back to a server.
		 *
		 *     o.serialize() //-> { name: 'Justin' }
		 *
		 * Serialize currently returns the same data
		 * as [jQuery.Observe.prototype.attrs].  However, in future
		 * versions, serialize will be able to return serialized
		 * data similar to [jQuery.Model].  The following will work:
		 *
		 *     new Observe({time: new Date()})
		 *       .serialize() //-> { time: 1319666613663 }
		 *
		 * @return {Object} a JavaScript Object that can be
		 * serialized with `JSON.stringify` or other methods.
		 *
		 */
		serialize: function() {
			return serialize(this, 'serialize', {});
		},
		/**
		 * Set multiple properties on the observable
		 * @param {Object} props
		 * @param {Boolean} remove true if you should remove properties that are not in props
		 */
		attrs: function( props, remove ) {
			if ( props === undefined ) {
				return serialize(this, 'attrs', {})
			}

			props = $.extend(true, {}, props);
			var prop, collectingStarted = collect();

			for ( prop in this._data ) {
				var curVal = this._data[prop],
					newVal = props[prop];

				// if we are merging ...
				if ( newVal === undefined ) {
					remove && this.removeAttr(prop);
					continue;
				}
				if ( isObject(curVal) && isObject(newVal) ) {
					curVal.attrs(newVal, remove)
				} else if ( curVal != newVal ) {
					this._set(prop, newVal)
				} else {

				}
				delete props[prop];
			}
			// add remaining props
			for ( var prop in props ) {
				newVal = props[prop];
				this._set(prop, newVal)
			}
			if ( collectingStarted ) {
				sendCollection();
			}
		}
	});
	// Helpers for list
	/**
	 * @class jQuery.Observe.List
	 * @inherits jQuery.Observe
	 * @parent jQuery.Observe
	 *
	 * An observable list.  You can listen to when items are push, popped,
	 * spliced, shifted, and unshifted on this array.
	 *
	 *
	 */
	var list = $.Observe($.globalNamespace + '.Observe.List',
	/**
	 * @prototype
	 */
	{
		init: function( instances, options ) {
			this.length = 0;
			this._namespace = ".list" + (++id);
			this._init = true;
			this.bind('change',this.proxy('_changes'));
			this.push.apply(this, makeArray(instances || []));
			$.extend(this, options);
			if(this.comparator){
				this.sort()
			}
			delete this._init;
		},
		_changes : function(ev, attr, how, newVal, oldVal){
			// detects an add, sorts it, re-adds?
			//console.log("")



			// if we are sorting, and an attribute inside us changed
			if(this.comparator && /^\d+./.test(attr) ) {

				// get the index
				var index = +(/^\d+/.exec(attr)[0]),
					// and item
					item = this[index],
					// and the new item
					newIndex = this.sortedIndex(item);

				if(newIndex !== index){
					// move ...
					[].splice.call(this, index, 1);
					[].splice.call(this, newIndex, 0, item);

					trigger(this, "move", [item, newIndex, index]);
					ev.stopImmediatePropagation();
					trigger(this,"change", [
						attr.replace(/^\d+/,newIndex),
						how,
						newVal,
						oldVal
					]);
					return;
				}
			}


			// if we add items, we need to handle
			// sorting and such

			// trigger direct add and remove events ...
			if(attr.indexOf('.') === -1){

				if( how === 'add' ) {
					trigger(this, how, [newVal,+attr]);
				} else if( how === 'remove' ) {
					trigger(this, how, [oldVal, +attr])
				}

			}
			// issue add, remove, and move events ...
		},
		sortedIndex : function(item){
			var itemCompare = item.attr(this.comparator),
				equaled = 0,
				i;
			for(var i =0; i < this.length; i++){
				if(item === this[i]){
					equaled = -1;
					continue;
				}
				if(itemCompare <= this[i].attr(this.comparator) ) {
					return i+equaled;
				}
			}
			return i+equaled;
		},
		__get : function(attr){
			return attr ? this[attr] : this;
		},
		__set : function(attr, val){
			this[attr] = val;
		},
		/**
		 * Returns the serialized form of this list.
		 */
		serialize: function() {
			return serialize(this, 'serialize', []);
		},
		/**
		 * Iterates through each item of the list, calling handler
		 * with each index and value.
		 *
		 *     new Observe.List(['a'])
		 *       .each(function(index, value){
		 *         equals(index, 1)
		 *         equals(value,'a')
		 *       })
		 *
		 * @param {function} handler(index,value) A function that will get
		 * called back with the index and value of each item on the list.
		 *
		 * Returning `false` breaks the looping.  The following will never
		 * log 'c':
		 *
		 *     new Observe(['a','b','c'])
		 *       .each(function(index, value){
		 *         console.log(value)
		 *         if(index == 1){
		 *           return false;
		 *         }
		 *       })
		 *
		 * @return {jQuery.Observe.List} the original observable.
		 */
		// placeholder for each
		/**
		 * Remove items or add items from a specific point in the list.
		 *
		 * ### Example
		 *
		 * The following creates a list of numbers and replaces 2 and 3 with
		 * "a", and "b".
		 *
		 *     var l = new $.Observe.List([0,1,2,3]);
		 *
		 *     l.bind('change', function( ev, attr, how, newVals, oldVals, where ) { ... })
		 *
		 *     l.splice(1,2, "a", "b"); // results in [0,"a","b",3]
		 *
		 * This creates 2 change events.  The first event is the removal of
		 * numbers one and two where it's callback values will be:
		 *
		 *   - attr - "1" - indicates where the remove event took place
		 *   - how - "remove"
		 *   - newVals - undefined
		 *   - oldVals - [1,2] -the array of removed values
		 *   - where - 1 - the location of where these items where removed
		 *
		 * The second change event is the addition of the "a", and "b" values where
		 * the callback values will be:
		 *
		 *   - attr - "1" - indicates where the add event took place
		 *   - how - "added"
		 *   - newVals - ["a","b"]
		 *   - oldVals - [1, 2] - the array of removed values
		 *   - where - 1 - the location of where these items where added
		 *
		 * @param {Number} index where to start removing or adding items
		 * @param {Object} count the number of items to remove
		 * @param {Object} [added] an object to add to
		 */
		splice: function( index, count ) {
			var args = makeArray(arguments),
				i;

			for ( i = 2; i < args.length; i++ ) {
				var val = args[i];
				if ( isObject(val) ) {
					args[i] = hookup(val, "*", this)
				}
			}
			if ( count === undefined ) {
				count = args[1] = this.length - index;
			}
			var removed = [].splice.apply(this, args);
			if ( count > 0 ) {
				trigger(this, "change", [""+index, "remove", undefined, removed]);
				unhookup(removed, this._namespace);
			}
			if ( args.length > 2 ) {
				trigger(this, "change", [""+index, "add", args.slice(2), removed]);
			}
			return removed;
		},
		/**
		 * Updates an array with a new array.  It is able to handle
		 * removes in the middle of the array.
		 *
		 * @param {Array} props
		 * @param {Boolean} remove
		 */
		attrs: function( props, remove ) {
			if ( props === undefined ) {
				return serialize(this, 'attrs', []);
			}

			// copy
			props = props.slice(0);

			var len = Math.min(props.length, this.length),
				collectingStarted = collect();
			for ( var prop = 0; prop < len; prop++ ) {
				var curVal = this[prop],
					newVal = props[prop];

				if ( isObject(curVal) && isObject(newVal) ) {
					curVal.attrs(newVal, remove)
				} else if ( curVal != newVal ) {
					this._set(prop, newVal)
				} else {

				}
			}
			if ( props.length > this.length ) {
				// add in the remaining props
				this.push(props.slice(this.length))
			} else if ( props.length < this.length && remove ) {
				this.splice(props.length)
			}
			//remove those props didn't get too
			if ( collectingStarted ) {
				sendCollection()
			}
		},
		sort: function(method, silent){
			var comparator = this.comparator,
				args = comparator ? [function(a, b){
					a = a[comparator]
					b = b[comparator]
					return a === b ? 0 : (a < b ? -1 : 1);
				}] : [],
				res = [].sort.apply(this, args);

			!silent && trigger(this, "reset");

		}
	}),


		// create push, pop, shift, and unshift
		// converts to an array of arguments
		getArgs = function( args ) {
			if ( args[0] && ($.isArray(args[0])) ) {
				return args[0]
			}
			else {
				return makeArray(args)
			}
		};
	// describes the method and where items should be added
	each({
		/**
		 * @function push
		 * Add items to the end of the list.
		 *
		 *     var l = new $.Observe.List([]);
		 *
		 *     l.bind('change', function(
		 *         ev,        // the change event
		 *         attr,      // the attr that was changed, for multiple items, "*" is used
		 *         how,       // "add"
		 *         newVals,   // an array of new values pushed
		 *         oldVals,   // undefined
		 *         where      // the location where these items where added
		 *         ) {
		 *
		 *     })
		 *
		 *     l.push('0','1','2');
		 *
		 * @return {Number} the number of items in the array
		 */
		push: "length",
		/**
		 * @function unshift
		 * Add items to the start of the list.  This is very similar to
		 * [jQuery.Observe.prototype.push].
		 */
		unshift: 0
	},
	// adds a method where
	// - name - method name
	// - where - where items in the array should be added


	function( name, where ) {
		list.prototype[name] = function() {
			// get the items being added
			var args = getArgs(arguments),
				// where we are going to add items
				len = where ? this.length : 0;

			// go through and convert anything to an observe that needs to be converted
			for ( var i = 0; i < args.length; i++ ) {
				var val = args[i];
				if ( isObject(val) ) {
					args[i] = hookup(val, "*", this)
				}
			}

			// if we have a sort item, add that
			if( args.length == 1 && this.comparator ) {
				// add each item ...
				// we could make this check if we are already adding in order
				// but that would be confusing ...
				var index = this.sortedIndex(args[0]);
				this.splice(index, 0, args[0]);
				return this.length;
			}

			// call the original method
			var res = [][name].apply(this, args)

			// cause the change where the args are:
			// len - where the additions happened
			// add - items added
			// args - the items added
			// undefined - the old value
			if ( this.comparator  && args.length > 1) {
				this.sort(null, true);
				trigger(this,"reset", [args])
			} else {
				trigger(this, "change", [""+len, "add", args, undefined])
			}


			return res;
		}
	});

	each({
		/**
		 * @function pop
		 *
		 * Removes an item from the end of the list.
		 *
		 *     var l = new $.Observe.List([0,1,2]);
		 *
		 *     l.bind('change', function(
		 *         ev,        // the change event
		 *         attr,      // the attr that was changed, for multiple items, "*" is used
		 *         how,       // "remove"
		 *         newVals,   // undefined
		 *         oldVals,   // 2
		 *         where      // the location where these items where added
		 *         ) {
		 *
		 *     })
		 *
		 *     l.pop();
		 *
		 * @return {Object} the element at the end of the list
		 */
		pop: "length",
		/**
		 * @function shift
		 * Removes an item from the start of the list.  This is very similar to
		 * [jQuery.Observe.prototype.pop].
		 *
		 * @return {Object} the element at the start of the list
		 */
		shift: 0
	},
	// creates a 'remove' type method


	function( name, where ) {
		list.prototype[name] = function() {

			var args = getArgs(arguments),
				len = where && this.length ? this.length - 1 : 0;


			var res = [][name].apply(this, args)

			// create a change where the args are
			// "*" - change on potentially multiple properties
			// "remove" - items removed
			// undefined - the new values (there are none)
			// res - the old, removed values (should these be unbound)
			// len - where these items were removed
			trigger(this, "change", [""+len, "remove", undefined, [res]])

			if ( res && res.unbind ) {
				res.unbind("change" + this._namespace)
			}
			return res;
		}
	});

	list.prototype.
	/**
	 * @function indexOf
	 * Returns the position of the item in the array.  Returns -1 if the
	 * item is not in the array.
	 * @param {Object} item
	 * @return {Number}
	 */
	indexOf = [].indexOf || function(item){
		return $.inArray(item, this)
	}

	/**
	 * @class $.O
	 */
	$.O = function(data, options){
		if(isArray(data) || data instanceof $.Observe.List){
			return new $.Observe.List(data, options)
		} else {
			return new $.Observe(data, options)
		}
	}
})();

});

FD40.plugin("joomla", function($) {

/**
 * joomla
 * Abstraction layer for Joomla client-side API.
 * https://github.com/foundry-modules/joomla
 *
 * Copyright (c) 2012 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var parser = {
	squeezebox: function() {
		return (self.isJoomla15) ? window.parent.document.getElementById('sbox-window') : window.parent.SqueezeBox;
	}
};

var self = $.Joomla = function(method, args) {

	// Overriding function
	if ($.isFunction(args)) {

		var fn = args;

		if (self.isJoomla15) {
			window[method] = fn;
		} else {
			window.Joomla[method] = fn;
		};

		return;
	}

	// Calling function
	var method = parser[method] || ((self.isJoomla15) ? window[method] : window.Joomla[method]);

	if ($.isFunction(method)) {
		return method.apply(window, args);
	}
};

var version = parseFloat($.joomla.version);
self.isJoomla15 = version <= 1.5;
self.isJoomla25 = version >= 1.6 && version <= 2.5;
self.isJoomla30 = version >= 3.0;
});

FD40.plugin("module", function($) {

/**
 * jquery.module.
 * An AMD manager built on top of $.Deferred() backbone.
 * An alternative take on RequireJS's define().
 *
 * Part of the jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var Module = function(name) {

	var module = this,
		ready = $.Callbacks("once memory");

	$.extend(this, $.Deferred(), {

		// Name of the module
		name: name,

		// Module status
		// pending, ready, executing, resolved, rejected
		status: "pending",

		// When a module factory is received,
		// this event is fired.
		ready: function(fn) {
			if (fn===true) ready.fire.call(module, $);
			if ($.isFunction(fn)) ready.add(fn);
		}
	});

	// Listen to the events of the module
	// and update the module status as necessary.
	module.then(
		function() {
			module.exports = this;
			module.status  = "resolved";
		},
		function() {
			module.status  = "rejected";
		}
	);

	// Keep a copy of the original done method.
	// This is so that we can track when this done
	// method is being called for the first time,
	// and perform the necessary actions below.
	var done = module.done;

	module.done = function() {

		// Flag this module as required
		// This indicates that we should
		// execute the module factory.
		module.required = true;

		// Execute the module factory
		// if this module has received it
		// and it hasn't been executed yet.
		var factory = module.factory;
		if (factory && module.status==="ready") {
			factory.call(module, $);
		}

		// Replace this first-time done method
		// with the original done method.
		module.done = done;

		// Execute the original done method.
		return module.done.apply(this, arguments);
	}
}

$.module = (function() {

	var self = function(name, factory) {

		var module;

		if (typeof name === "string") {

			module = self.get(name);

			/** Facade #1. Get module.
			 *
			 *  $.module('foobar'); // returns module
             *
		     */
			if (factory === undefined) {
				return module;
			}

			/** Facade #2. Factory assignment.
             *
			 *  $.module('foobar', function() {
			 *
			 *      // This is required in every module factory.
			 *      // Resolve module, return exports.
			 *
			 *      this.resolveWith(exports, [args]);
			 *
		     *  });
             *
		     */

			if ($.isFunction(factory)) {

				// If module is resolved, don't let new factory overwrite it.
				if (module.status=="resolved") return module;

				module.factory = factory;

				module.status = "ready";

				// Indicates that the module factory
				// for this module has been received.
				module.ready("true");

				// If the module is required,
				// execute the module factory.
				if (module.required) {

					module.status = "executing";

					// Execute factory
					factory.call(module, $);
				}

				return module;
			}
		}

		/** Facade #3. Multiple factory assignments / Predefine modules.
		 *	This is used by Foundry compiler when combining multiple script files into one.
         *
		 *  $.module([
	     *
	     *      // Module task object
	     *      {
	     *			name: "module.name"
	     *			factory: function(){}
	     *      }
	     *
	     *      // Module which is loading
	     *      // but factory assignment kicks in later
	     *      "module.name"
		 *	]);
		 *
		 */

		// Predefine modules
		if ($.isArray(name)) {

			var tasks = $.map(name, function(task) {

				var module = self.get($.isString(task) ? task : task.name);

				if (!module) return;

				// If module is pending, set it to ready.
				// This trick require calls into thinking that
				// the script file of this module has been loaded,
				// so it won't go and load the script file again.
				if (module.status === "pending") {
					module.status = "ready";
				}

				if ($.isPlainObject(task)) return task;
			});

			// Run through the list of tasks and assign its factory to the module.
			$.each(tasks, function(i, task) {

				// Assign factory to module
				self(task.name, task.factory);
			});
		}
	}

	// $.module static methods
	$.extend(self, {

		registry: {},

		get: function(name) {
			if (!name) return;

			if ($.isModule(name)) {
				name = name.replace("module://", "");
			}

			return self.registry[name] || self.create(name);
		},

		create: function(name) {
			return self.registry[name] = new Module(name);
		},

		remove: function(name) {
			delete self.registry[name];
		}
	});

	return self;

})();

$.isModule = function(module) {

	if ($.isString(module)) {
		return !!module.match("module://");
	}

	return module && module instanceof Module;
}

});

FD40.plugin("script", function($) {

/**
 * jquery.script
 * Script injection utility built on top $.Deferred() backbone.
 * https://github.com/jstonne/jquery.script
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Script = function(fn) {

    var script = document.createElement("script");
    script.text = $.isString(fn) ? fn : $.callback(fn) + "();";

    return $(script);
};

$.script = (function(){

    var self = function(options) {

        if (options===undefined) {
            return;
        }

        if (typeof options==="string") {
            options = {
                url: options
            }
        }

        var script = new Script(options);

        return script;
    };

    var Script = function(options) {

        var script = $.extend(this, options);

        script.manager = $.Deferred();

        $.extend(script, script.manager.promise());

        script.load();
    };

    var head = document.getElementsByTagName("head")[0],
        baseElement = document.getElementsByTagName("base")[0];

    $.extend(Script.prototype, {

        timeout: 7000,

        retry: 3,

        retryCount: 1,

        type: "text/javascript",

        async: false,

        charset: "UTF-8",

        verbose: false,

        head: head,

        insert: function() {

            var node = this.node;

            this.head.appendChild(node);
        },

        remove: function() {

            var node = this.node;

            // This prevents IE7-8 locking up.
            setTimeout(function(){

                // Handle memory leak in IE
                node.onload = node.onerror = node.onreadystatechange = null;

                try {
                    head.removeChild(node);
                } catch(e) {};

            }, 1000);
        },

        load: function() {

            var script = this,
                node;

            script.endTime = undefined;

            script.startTime = new Date();

            script.node = node = document.createElement('script');

            script.insert();

            // Create a reference to these proxied functions,
            // so that we can detach them from event listeners.
            script._ready = $.proxy(script.ready, script);
            script._error = $.proxy(script.error, script);

            // On IE9, addEventListener() does not necessary fire the onload event after
            // the script is loaded, attachEvent() method behaves correctly.
            if (node.attachEvent && !$.browser.opera) {
                node.attachEvent("onreadystatechange", script._ready);
                node.attachEvent("onerror"           , script._error); // IE9 only.
            } else {
                node.addEventListener("load"         , script._ready, false);
                node.addEventListener("error"        , script._error, false);
            }

            $(node).attr({
                type    : script.type,
                async   : script.async,
                charset : script.charset,
                src     : script.url
            });

            script.monitor();
        },

        monitor: function() {

            var script = this;

            if (script.retryCount > script.retry) {

                script._error();

                return;
            }

            setTimeout(function() {

                if (script.state()!=="resolved") {

                    if (script.verbose) {
                        console.warn('$.script: Load timeout. [Retry: ' + script.retryCount + ']', script);
                    }

                    script.remove();

                    script.retryCount++;

                    script.load();
                }

            }, script.timeout * script.retryCount);

        },

        ready: function(event) {

            var script = this,
                node = script.node;

            // if (script.verbose) {
            //     console.info('$.script: Loaded' + (($.browser.msie) ? ' ' + script.url.replace($.scriptPath, '') + ' ': ''), script);
            // }

            if (event.type==="load" || /loaded|complete/.test(node.readyState)) {

                script.complete.call(script, event);

                script.manager.resolve(script);
            }
        },

        error: function(event) {

            var script = this;

            if (script.verbose) {
                console.error('$.script: Unable to load ', script);
            }

            script.complete.call(script, event);

            script.remove();

            script.manager.reject(script);
        },

        complete: function(event) {

            var script = this,
                node = script.node;

            script.endTime = new Date();

            if (node.detachEvent && !$.browser.opera) {
                node.detachEvent("onreadystatechange", script._ready);
                node.detachEvent("onerror"           , script._error);
            } else {
                node.removeEventListener("load"      , script._ready, false);
                node.removeEventListener("error"     , script._error, false);
            }
        }

    });

    return self;

})();

});

FD40.plugin("stylesheet", function($) {

/**
 * jquery.stylesheet
 * Stylesheet injector utility with workarounds
 * for IE's 31 stylesheet limitation.
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var head = document.getElementsByTagName('head')[0],
	stylesheets = document.styleSheets,
	IE_STYLESHEET = document.createStyleSheet,
	IE_MAX_STYLESHEET = 31,
	IE_MAX_IMPORT = 31,
	IE_MAX_RULE = 4095;

$.stylesheet = (function() {

	var self = function(url, attr) {

		var options = {};

		$.extend(

			options,

			self.defaultOptions,

			($.isPlainObject(url)) ?
				url :
				{
					url: url,
					attr: attr || {}
				}
		);

		// Create a new stylesheet object
		if (options.url===undefined) {

			return self.create(options);
		}

		// Loading an external stylesheet
		return self.load(options);
	};

	$.extend(self, {

		defaultOptions: {

			type: "text/css",

			rel: "stylesheet",

			media: "all",

			title: "",

			// Force link injection, ignores IE workarounds, overrides XHR value.
			forceInject: false,

			// @TODO: XHR loading.
			xhr: false
		},

		setup: function(options) {

			$.extend(self.defaultOptions, options);
		},

		availability: function() {

			// @TODO: Also calculate bleedImports.
			var stat = {},
				links = $('link[rel*="stylesheet"]')
				styles = $('style');

			stat.groups = IE_MAX_STYLESHEET - links.length - styles.length;

			stat.slots = stat.groups * IE_MAX_IMPORT;

			if (self.currentGroup) {
				stat.slots += IE_MAX_IMPORT - self.currentGroup.imports.length;
			}

			return stat;
		},

		get: function(style) {

			var i=0;

			for (; i<stylesheets.length; i++) {

				var stylesheet = stylesheets[i];

				if ((stylesheet.ownerNode || stylesheet.owningElement)==style) {
					return stylesheet;
				}
			}
		},

		create: function(options) {

			var stylesheet,
				style,
				length = stylesheets.length;

			if (IE_STYLESHEET) {
				// Unable to create further stylesheets
				if (length>=IE_MAX_STYLESHEET) return;
				stylesheet = document.createStyleSheet();
				style = stylesheet.ownerNode || stylesheet.owningElement;
			} else {
				style = document.createElement('style');
				head.appendChild(style);
			}

			$.extend(style, {
				type : options.type,
				title: options.title,
				media: options.media,
				rel  : options.rel
			});

			// Insert stylesheet content
			var content = options.content;
			if (content!==undefined) {
				if (IE_STYLESHEET) {
					stylesheet.cssText = content;
				} else {
					style.appendChild(document.createTextNode(content));
				}
			}

			return style;
		},

		nextAvailable: function(alsoCreateIfUnavailable) {

			var stylesheet,
				length = stylesheets.length;

			if (length) {

				var i;

				for (i=length; i--; i<0) {

					stylesheet = stylesheets[i];

					// If this is IE and the maximum amount of rules have exceeded,
					if (IE_STYLESHEET && ((stylesheet.cssRules || stylesheet.rules).length >= IE_MAX_RULE)) {

						// then this stylesheet cannot be used.
						stylesheet = undefined;

						// try an older stylesheet.
						continue;
					}

					break;
				}
			}

			return stylesheet.ownerNode || stylesheet.owningElement || ((alsoCreateIfUnavailable) ? self() : undefined);
		},

		load: function(options) {

			if ($.browser.msie && !options.forceInject) {

				return self._import(options);

			} else {

				// @TODO: Use onload/onerror events on browsers that support them.
				var link =
					$('<link>')
						.attr({
							href: options.url,
							type: options.type,
							rel: options.rel,
							media: options.media
						})
						.appendTo('head');

				return link[0];
			}
		},

		_import: function(options) {

			var failed;

			if (self.currentGroup===undefined) {

				var group;

				try {

					group = document.createStyleSheet();

					// It is only a getter on IE.
					// group.type = "text/css";

					group.media = "all";
					group.title = "jquery_stylesheet";

				} catch(e) {

					failed = true;

					if (options.verbose) {
						console.error('There is not enough slots left to create a new stylesheet group.');
					}
				}

				if (failed) return false;

				self.currentGroup = group;
			}

			try {

				self.currentGroup.addImport(options.url);

			} catch(e) {

				failed = true;

				if (options.verbose) {
					console.info('Import slots exceeded. Creating a new stylesheet group.');
				}
			}

			if (failed) {

				self.currentGroup = undefined;

				return self._import(options);
			}

			return true;
		}

	});

	return self;

})();

(function(){

var cssRule = function(selectors, rules, style) {

	$.extend(this, {
		id       : $.uid(),
		style    : style,
		selectors: [],
		preRule  : "",
		rules    : {},
		legacy   : $.IE===8,
		important: false
	});

	// If selector is given, automatically add rule.
	// Else assume caller wants a blank rule object.
	if (selectors) {
		this.set(selectors, rules);
	}
}

$.extend(cssRule.prototype, {

	set: function(selectors, rules) {

		// Normalize selectors into array
		if ($.isString(selectors)) {
			this.selectors = selectors.split(",");
		} else {
			this.selectors = selectors;
		}

		// Normalize rules
		if ($.isString(rules)) {
			this.preRule = rules + "\n";
			this.rules = {};
		} else {
			this.preRule = "";
			this.rules = rules || this.rules;
		}

		this.update();

		return this;
	},

	cssText: function() {
		return this.selectors.join(",") + "{" + this.ruleText() + "}\n";
	},

	ruleText: function() {

		var important = this.important;
		return this.preRule +
		       ((this.legacy) ? "-rule-id:" + this.id + ";" : "") +
			   $.map(this.rules, function(val, prop) {
			   		if ($.isNumeric(val) && !$.cssNumber[prop]) val += "px";
			   		if (important) val += " !important";
			   		return prop + ":" + val;
			   }).join(";");
	},

	update: function() {

		if (this.legacy) return this.updateLegacy();

		// Generate css text
		var cssText = this.cssText();

		// If new, insert textnode
		if (this.textNode===undefined) {
			this.textNode = document.createTextNode(cssText);
			this.style.appendChild(this.textNode);

		// Or update existing textnode.
		} else {
			this.textNode.nodeValue = cssText;
		}

		return this;
	},

	updateLegacy: function() {

		this.removeLegacy();

		var stylesheet = $.stylesheet.get(this.style),
			selectors = this.selectors,
			ruleText = this.ruleText(),
			i=0;

		for (;i<selectors.length;i++) {
			stylesheet.addRule(selectors[i], ruleText);
		}

		return this;
	},

	remove: function() {

		if (this.legacy) return this.removeLegacy();

		if (this.textNode!==undefined) {

			// Removing text node is so much quicker
			// than searching for the rule
			this.style.removeChild(this.textNode);

			delete this.textNode;
		}

		return this;
	},

	removeLegacy: function() {

		var stylesheet = $.stylesheet.get(this.style),
			rules = stylesheet.rules,
			i = 0;

		for (;i<rules.length;i++) {

			if (rules[i].cssText.match(this.id)!==null) {
				stylesheet.removeRule(i);
			}
		}

		return this;
	},

	css: function(prop, val) {

		// Getter
		if ($.isString(prop) && val===undefined) {
			return this.rules[prop];
		}

		// Setter
		if ($.isPlainObject(prop)) {
			$.extend(this.rules, prop);
		} else {
			this.rules[prop] = val;
		}

		this.update();

		return this;
	}
});

var self = $.cssRule = function(selector, rules, style) {

	var style = style || self.style || $.stylesheet.nextAvailable(true);

	// If no stylesheet available at this point, stop.
	if (!style) return;

	return new cssRule(selector, rules, style);
};

self.style = $.stylesheet();

})();

(function(){
$.cssUrl = function(url) {
	return 'url("' + encodeURI(url) + '")';
}
})();

});

FD40.plugin("language", function($) {

$.sprintf = function() {
    // http://kevin.vanzonneveld.net
    // +   original by: Ash Searle (http://hexmen.com/blog/)
    // + namespaced by: Michael White (http://getsprink.com)
    // +    tweaked by: Jack
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +      input by: Paulo Freitas
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +      input by: Brett Zamir (http://brett-zamir.me)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // *     example 1: sprintf("%01.2f", 123.1);
    // *     returns 1: 123.10
    // *     example 2: sprintf("[%10s]", 'monkey');
    // *     returns 2: '[    monkey]'
    // *     example 3: sprintf("[%'#10s]", 'monkey');
    // *     returns 3: '[####monkey]'
    var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuidfegEG])/g;
    var a = arguments,
        i = 0,
        format = a[i++];

    // pad()
    var pad = function (str, len, chr, leftJustify) {
        if (!chr) {
            chr = ' ';
        }
        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
        return leftJustify ? str + padding : padding + str;
    };

    // justify()
    var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
        var diff = minWidth - value.length;
        if (diff > 0) {
            if (leftJustify || !zeroPad) {
                value = pad(value, minWidth, customPadChar, leftJustify);
            } else {
                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
            }
        }
        return value;
    };

    // formatBaseX()
    var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
        // Note: casts negative numbers to positive ones
        var number = value >>> 0;
        prefix = prefix && number && {
            '2': '0b',
            '8': '0',
            '16': '0x'
        }[base] || '';
        value = prefix + pad(number.toString(base), precision || 0, '0', false);
        return justify(value, prefix, leftJustify, minWidth, zeroPad);
    };

    // formatString()
    var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
        if (precision != null) {
            value = value.slice(0, precision);
        }
        return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
    };

    // doFormat()
    var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
        var number;
        var prefix;
        var method;
        var textTransform;
        var value;

        if (substring == '%%') {
            return '%';
        }

        // parse flags
        var leftJustify = false,
            positivePrefix = '',
            zeroPad = false,
            prefixBaseX = false,
            customPadChar = ' ';
        var flagsl = flags.length;
        for (var j = 0; flags && j < flagsl; j++) {
            switch (flags.charAt(j)) {
            case ' ':
                positivePrefix = ' ';
                break;
            case '+':
                positivePrefix = '+';
                break;
            case '-':
                leftJustify = true;
                break;
            case "'":
                customPadChar = flags.charAt(j + 1);
                break;
            case '0':
                zeroPad = true;
                break;
            case '#':
                prefixBaseX = true;
                break;
            }
        }

        // parameters may be null, undefined, empty-string or real valued
        // we want to ignore null, undefined and empty-string values
        if (!minWidth) {
            minWidth = 0;
        } else if (minWidth == '*') {
            minWidth = +a[i++];
        } else if (minWidth.charAt(0) == '*') {
            minWidth = +a[minWidth.slice(1, -1)];
        } else {
            minWidth = +minWidth;
        }

        // Note: undocumented perl feature:
        if (minWidth < 0) {
            minWidth = -minWidth;
            leftJustify = true;
        }

        if (!isFinite(minWidth)) {
            throw new Error('sprintf: (minimum-)width must be finite');
        }

        if (!precision) {
            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;
        } else if (precision == '*') {
            precision = +a[i++];
        } else if (precision.charAt(0) == '*') {
            precision = +a[precision.slice(1, -1)];
        } else {
            precision = +precision;
        }

        // grab value using valueIndex if required?
        value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

        switch (type) {
        case 's':
            return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
        case 'c':
            return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
        case 'b':
            return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'o':
            return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'x':
            return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'X':
            return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
        case 'u':
            return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'i':
        case 'd':
            number = (+value) | 0;
            prefix = number < 0 ? '-' : positivePrefix;
            value = prefix + pad(String(Math.abs(number)), precision, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        case 'e':
        case 'E':
        case 'f':
        case 'F':
        case 'g':
        case 'G':
            number = +value;
            prefix = number < 0 ? '-' : positivePrefix;
            method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
            textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
            value = prefix + Math.abs(number)[method](precision);
            return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
        default:
            return substring;
        }
    };

    return format.replace(regex, doFormat);
}
/**
 * jquery.language.
 * Client-side access to server-side language.
 * https://github.com/foundry-modules/language
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var self = $.language = $.JText = function(key) {

	if (arguments.length < 2) {
		return self._(key);
	} else {
		return self.sprintf.apply(null, arguments);
	}
};

$.extend(self, {
	lang: {},

	add: function(key, val) {

		if ($.isPlainObject(key)) {
			$.extend(self.lang, key);
		} else {
			self.lang[key] = val;
		}
	},

	remove: function(key) {
		delete self.lang[key];
	},

	_: function(key) {
		return self.lang.hasOwnProperty(key) ? self.lang[key] : key;
	},

	sprintf: function() {
		var key = arguments[0];
		arguments[0] = self.lang[key];
		return $.sprintf.apply(null, arguments);
	}
});

});

FD40.plugin("template", function($) {

/**
 * jquery.template
 * Template repository
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.template = (function() {

	var defaultTemplate = {
		content: "",
		type: "ejs"
	};

	var self = function(name, content) {

		if (name===undefined) {
			return self.templates;
		}

		var template;

		if (typeof content == "string") {

			if ($.isPlainObject(content)) {

				template = content;

			} else {

				template = $.extend({}, defaultTemplate, {name: name, content: content});
			}

			self.templates[name] = template;

			return template;

		} else {

			template = self.templates[name] || {};

			return template.content || "";
		}
	};

	$.extend(self, {

		templates: {},

		remove: function(name) {

			delete self.templates[name];
		}
	});

	return self;

 })();

});

FD40.plugin("require", function($) {

/**
 * jquery.require.
 * A dependency loader built on top of $.Deferred() backbone.
 * An alternative take on RequireJS.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require = (function() {

	// internal function
	var getFolderPath = function(path) {
		return $.uri(path).setAnchor('').setQuery('').toPath('../').toString();
	};

	var self = function(options) {

		var batch = new Batch(options);

		self.batches[batch.id] = batch;

		return batch;
	};

	// Require methods & properties

	$.extend(self, {

		defaultOptions: {

			// Path selection order:
			path: (function() {

				var path =

					$.path + "/scripts/" ||

					// By "require_path" attribute
					$('[require-path]').attr('require-path') ||

					// By last script tag's "src" attribute
					getFolderPath($('script:last').attr('src')) ||

					// By window location
					getFolderPath(window.location.href);

				if (/^(\/|\.)/.test(path)) {
					path = $.uri(window.location.href).toPath(path).toString();
				}

				return path;
			})(),

			timeout: 10000,

			retry: 3,

			verbose: ($.environment=="development")
		},

		setup: function(options) {

			$.extend(self.defaultOptions, options);
		},

		batches: {},

		status: function(filter) {

			$.each(self.batches, function(i, batch){

				var count = {pending: 0, resolved: 0, rejected: 0, ready: 0, total: 0},
					messages = [];

				// Calculate statistics
				$.each(batch.tasks, function(i, task){

					state = (task.module && task.module.status=="ready") ? "ready" : task.state();
					count[state]++;
					count.total++;

					messages.push({
						state: state,
						content: '[' + state + '] ' + task.name 
					});
				});

				var batchName = batch.id + ": " + batch.state() + " [" + count.resolved + "/" + count.total + "]";

				if (filter && count[filter] < 1) return;

				if ($.IE) {

					console.log("$.require.batches[\"" + batch.id + "\"]");
					$.each(messages, function(i, message){
						console.log(message.content);
					});
					console.log("");

				} else {

					// Create log group
					console.groupCollapsed(batchName);

					// Generate list
					console.log("$.require.batches[\"" + batch.id + "\"]", batch);

					$.each(messages, function(i, message){

						var state   = message.state,
							content = message.content;

						if (!filter || state==filter) {
							switch (state) {
								case 'pending' : console.warn(content);  break;
								case 'rejected': console.error(content); break;
								default        : console.info(content);  break;
							}
						}
					});

					console.groupEnd(batchName);
				}
			});

			return "$.require.status(pending|resolved|rejected|ready);";
		},

		loaders: {},

		addLoader: function(name, factory) {

			// Static call, e.g.
			// $.require.script.setup({});
			self[name] = factory;

			// Create proxy functions to require loaders,
			// assigning current batch to factory's "this".
			Batch.prototype[name] = function() {

				var batch = this;

				// Reset auto-finalize timer
				batch.autoFinalize();

				// this == batch
				factory.apply(batch, arguments);

				// Ensure require calls are chainable
				return batch;
			};

			self.loaders[name] = self[name] = factory;
		},

		removeLoader: function(name) {
			delete Batch.prototype[name];
			delete self[name];
		}

	});

	// This serves as batch id counter, it increments
	// whenever a new batch instance is created.
	var id = 0;

	// Batch class.
	// When calling $.require(), it is actually
	// returning an new instance of this class.
	var Batch = function(options) {

		var required = $.Callbacks("once memory"),
		    isRequired = false;

		// We are extending the batch instance
		// with the following properties.
		var batch = $.extend(this, {

			// Unique ID for this batch.
			id: ++id,

			// This array keeps a list of tasks to load.
			tasks: [],

			// Stores options like load path, timeout and retry count. 
			options: $.extend({}, self.defaultOptions, options),

			// Require chain automatically finalizes itself after
			// 300ms if no promise methods were called in the require chain.
			// Set false to disable.
			autoFinalizeDuration: 300,

			// When batch is finalized, further loader calls will be ignored.
			finalized: false,

			// Determine if the contents of the loaded task is required.
			required: function(fn) {
				if (fn===true) isRequired=true && required.fire();
				if ($.isFunction(fn)) required.add(fn);
				return isRequired;
			}
		});

		return batch;
	}

	$.extend(Batch.prototype, {

		addTask: function(task) {

			var batch = this;

			// Don't add invalid tasks.
			// Tasks should be a deferred object.
			if (!$.isDeferred(task)) return;

			// Don't accept anymore tasks if this batch is finalized.
			// Batch is finalized upon calling any of the promises, e.g.
			// done, fail, progress, always, then, pipe
			if (batch.finalized) return;

			// Add this task to the batch's task list
			batch.tasks.push(task);

			// Decorate task with a reference to the current batch
			task.batch = batch;
		},

		autoFinalize: function() {

			var batch = this,
				duration = batch.autoFinalizeDuration;

			// If autoFinalize is disabled, stop.
			if (duration===false) return;

			// Clear previous timer
			clearTimeout(batch.autoFinalizeTimer);

			// Start a new timer
			batch.autoFinalizeTimer = 
				setTimeout(function(){
					batch.finalize();
				}, duration);
		},

		finalize: function() {

			var batch = this;

			// If this batch has been finalized, stop.
			if (batch.finalized) return;

			// Finalize all tasks so no further
			// tasks can be added to this batch.
			batch.finalized = true;

			// Create batch manager which is a
			// master deferred object for all tasks.
			var manager = batch.manager = $.when.apply(null, batch.tasks);

			// Now that tasks are finalized, we can override
			// this batch's pseudo-promise methods with actual
			// promise methods from batch manager.
			var promise  = manager.promise(),
				progress = $.Callbacks();

			$.extend(batch, promise, {

				// Progress & notify method behaves differently.
				// We want progress callback to continue executing
				// even after after manager has been resolved or rejected.
				progress: progress.add,
				notify  : progress.fire,

				// Done method also behaves differently.
				// It will trigger an event notifying all tasks that
				// there is a demand for the content of the task.
				// This is currently used to lazy execute module factories
				// to ensure they don't execute until they are asked for.
				done: function(){

					// Trigger required event
					batch.required(true);

					// After done has been called once, it will be
					// replaced with the actual done method from the
					// master deferred object.
					batch.done = promise.done;

					// And the actual done method gets executed.
					return batch.done.apply(batch, arguments);
				}
			});

			// Flag to indicate whether to make
			// generate debug messages.
			var verbose = batch.options.verbose;

			manager
				.progress(function(state, task){
					if (verbose && state=="rejected") {
						console.warn('Require: Task ' + task.name + ' failed to load.', task);
					}
				})
				.fail(function(){
					if (verbose) {
						console.warn('Require: Batch ' + batch.id + ' failed.', batch);
					}
				});

			// We wrap this in a setTimeout to let existing require chain
			// to continue execute. This ensures that progress call in that
			// require chain receives the activities of each task below.
			setTimeout(function(){

				// Always notify whenever there is an activity on every task.
				$.each(batch.tasks, function(i, task){
					task.then(
						function(){ batch.notify("resolved", task) },
						function(){ batch.notify("rejected", task) },
						function(){ batch.notify("progress", task) }
					);
				});
			}, 1);
		},

		expand: function(args, opts) {

			var args = $.makeArray(args),
				options = opts || {},
				names = [];

	        if ($.isPlainObject(args[0])) {
	            options = $.extend(args[0], opts);
	            names = args.slice(1);
	        } else {
	            names = args;
	        }

	        return {
	        	options: options,
	        	names: names
	        }
		}
	});

	// Masquerade newly created batch instances as a pseudo-promise object
	// until one of those promise's method is called. This is to ensure that
	// no callbacks are fired too early until all require tasks are finalized.
	$.each(["done","fail","progress","always","then"], function(i, method) {

		Batch.prototype[method] = function() {

			var batch = this;

			// Finalize batch
			batch.finalize();

			// Execute method that was originally called
			return batch[method].apply(batch, arguments);
		}
	});

	return self;

})();
/**
 * jquery.require.script
 * Script loader plugin for $.require.
 *
 * Part of jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('script', (function() {

	// IE & Opera thinks punycoded urls are cross-domain requests,
	// and rejects the ajax request because they think they don't have
	// the necesary transport to facilitate such requests.

	var ajaxHost = $.uri($.indexUrl).host(),
		documentHost = $.uri(document.location.href).host();

	if (ajaxHost!==documentHost && ajaxHost.match("xn--")) {
		$.support.cors = true;
	}

	var canAsync = document.createElement("script").async === true || "MozAppearance" in document.documentElement.style || window.opera;

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			options,
			{batch: batch}
		);

		// Create tasks and add it to the batch.
		var taskBefore;

		$.each(names, function(i, name) {

			var task = new self.task(name, options, taskBefore);

			batch.addTask(task);

			// Serial script loading
			if (options.serial && taskBefore!==undefined) {

				// Only start current task when the
				// task before is resolved/rejected.
				taskBefore.always(task.start);

			} else {

				task.start();
			}

			taskBefore = task;

		});

	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: '',

			extension: (($.mode=='compressed') ? 'min.js' : 'js'),

			// Serial script loading. Default: Parallel script loading.
			serial: false,

			// Asynchronous script execution. Default: Synchronous script execution.
			async: false,

			// Use XHR to load script. Default: Script injection.
			xhr: false
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		scripts: {},

		task: function(name, options, taskBefore) {

			var task = $.extend(this, $.Deferred());

			task.name = name;

			task.options = options;

			task.taskBefore = taskBefore;

			// Module assignment or module url override
			if ($.isArray(name)) {

				task.name = name[0] + "@" + name[1];

				task.moduleName = name[0];

				var overrideModuleUrl = name[2];

				// Module assignment
				if (!overrideModuleUrl) {

					// Set module flag
					task.defineModule = true;

					// Raise a warning if the module already exist
					if ($.module.registry[task.moduleName]) {
						console.warn("$.require.script: " + task.moduleName + ' exists! Using existing module instead.');
					}

					// Use XHR for module assignments
					task.options.xhr = true;
				}

				// Assign path to be resolved
				name = name[1];

				task.module = $.module(task.moduleName);
			}

			// Resolve name to paths

			// Absolute path
			if ($.isUrl(name)) {

				task.url = name;

			// Relative path
			} else if (/^(\/|\.)/.test(name)) {

				task.url = $.uri(task.options.path)
							.toPath(name)
							.toString();

			// Module path
			} else {

				task.url = $.uri(task.options.path)
							.toPath('./' + name + '.' + task.options.extension)
							.toString();

				task.module = $.module(name);
			}
		}

	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this,
				module = task.module;

			// If module has already been loaded,
			// we can skip the whole script loading process.
			if (module && module.status!=="pending") {
				task.waitForModule();
				return;
			}

			// Else load the script that has this module.
			task.load();
		},

		waitForModule: function() {

			var task = this,
				module = task.module;

			// Listen to the events in the module
			// without causing the module factory to execute.
			module.then(
				task.resolve,
				task.reject,
				task.notify
			);

			// When there is demand for this module,
			// we will call the module's done method.
			task.batch.required(function(){

				// This will execute the module factory
				// in case it wasn't executed before.
				module.done(task.resolve);
			});
		},

		load: function() {

			var task = this,
				taskBefore = task.taskBefore,
				options = {};

			// Use previously created script instance if exists,
			// else create a new one.
			task.script = self.scripts[task.url] || (function() {

				var script = (task.options.xhr) ?

					// Load script via ajax.
					$.ajax({

						url: task.url,

						dataType: "text"

					}) :

					// Load script using script injection.
					$.script({

						url: task.url,

						type: "text/javascript",

						async: task.options.async,

						timeout: task.batch.options.timeout,

						retry: task.batch.options.retry,

						verbose: task.batch.options.verbose

					});

				return self.scripts[task.url] = script;

			})();

			// At this point, script may be loaded, BUT may yet
			// to be executed under the following conditions:
			// - Module loaded via script injection/xhr.
			// - Script loaded via via xhr.
			task.script
				.done(function(data) {

					var resolveTask = function() {

						// If task loads a module, resolve/reject task only when
						// the module is resolved/rejected as the module itself
						// may perform additional require tasks.
						if (task.module) {

							task.waitForModule();

						} else {

							task.resolve();
						}
					};

					if (task.options.xhr) {

						if (task.defineModule) {

							// Create our own module factory
							task.module = $.module(task.moduleName, function() {

								var module = this;

								$.globalEval(data);

								module.resolveWith(data);
							});
						};

						// For XHR, if scripts needs to be executed synchronously
						// a.k.a. ordered script execution, then only eval it when
						// the task before it is resolved.
						if (!task.options.async || taskBefore) {

							taskBefore.done(function() {

								$.globalEval(data);

								resolveTask();

							});

							return;
						}

					};

					resolveTask();

				})
				.fail(function() {

					task.reject();
				});
		}
	});

	return self;

})()
);
/**
 * jquery.require.stylesheet
 * Stylesheet loader plugin for $.require.
 *
 * Part of jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('stylesheet', (function() {

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			{
				path: $.path + '/styles/'
			},
			options,
			{batch: batch}
		);

		$.each(names, function(i, name) {

			var task = new self.task(name, options),
				existingTask = self.stylesheets[task.url];

			task = existingTask || task;

			batch.addTask(task);

			if (!existingTask) {
				self.stylesheets[task.url] = task;
				task.start();
			}
		});
	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: '',

			extension: (($.mode=='compressed') ? 'min.css' : 'css'),

			// @TODO: XHR loading.
			// Use XHR to load stylesheet. Default: Link injection. @import() for IE.
			xhr: false
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		stylesheets: {},

		task: function(name, options) {

			var task = $.extend(this, $.Deferred());

			task.name = name;

			task.options = options;

			// Absolute path
			if ($.isUrl(name)) {

				task.url = name;

			// Relative path
			} else if (/^(\/|\.)/.test(name)) {

				task.url = $.uri(task.options.path)
							.toPath(name)
							.toString();

			// Module path
			} else {

				task.url = $.uri(task.options.path)
							.toPath('./' + name + '.' + task.options.extension)
							.toString();
			}

			// Remap task.url to task.options.url
			task.options.url = task.url;
		},

		loaders: {},

		loader: function(name) {

			// Pre-define loaders
			if ($.isArray(name)) {
				return $.map(name, function(name){
					return self.loader(name);
				});
			}

			// Resolve loaders
			if ($.isPlainObject(name)) {
				return $.map(name, function(name, options){
					return self.loader(name).resolve(options);
				});
			}

			// Get loader or create loaders
			var loader = self.loaders[name];

			if (!loader) {
				loader = self.loaders[name] = 
					$.Deferred()
						.done(function(options){
							if ($.isPlainObject(options)) return;
							$.stylesheet(options);
						});
			}

			return loader;
		}		
	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this;

			var loader = self.loaders[task.name];

			// If this stylesheet hasn't been requested yet
			if (!loader) {

				// Create a stylesheet loader
				loader = self.loader(task.name);

				// Insert the stylesheet
				if ($.stylesheet(task.options)) {
					loader.resolve();
				} else {
					loader.reject();
				}
			}

			loader.then(task.resolve, task.reject);
		}

	});

	return self;

})()
);
/**
 * jquery.require.template
 * Template loader plugin for $.require.
 *
 * Part of jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('template', (function() {

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			options,
			{batch: batch}
		);

		$.each(names, function(i, name) {

			var task = new self.task(name, options);

			batch.addTask(task);

			task.start();
		});

	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: '',

			extension: 'htm'
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		task: function(name, options) {

			var task = $.extend(this, $.Deferred());

			task.name = name;

			task.options = options;

			// Template definition
			if ($.isArray(name)) {

				task.name = name[0];

				// Assign path to be resolved
				name = name[1];
			}

			// Absolute path
			if ($.isUrl(name)) {

				task.url = name;

			// Relative path
			} else if (/^(\/|\.)/.test(name)) {

				task.url = $.uri(task.options.path)
							.toPath(name)
							.toString();

			// Template module
			} else {

				task.url = $.uri(task.options.path)
							.toPath('./' + name + '.' + task.options.extension)
							.toString();
			}
		},

		loaders: {},

		loader: function(name) {

			// Pre-define loaders
			if ($.isArray(name)) {
				return $.map(name, function(name){
					return self.loader(name);
				});
			}

			// Resolve loaders
			if ($.isPlainObject(name)) {
				return $.map(name, function(content, name){
					return self.loader(name).resolve(content);
				});
			}

			// Get loader or create loaders
			var loader = self.loaders[name];

			if (!loader) {
				loader = self.loaders[name] = 
					$.Deferred()
						.done(function(content){
							$.template(name, content);
						});
			}

			return loader;
		}
	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this;

			// See if there is an existing loader
			var loader = self.loaders[task.name];

			if (!loader) {

				loader = self.loader(task.name);

				loader.xhr = 
					$.Ajax({
							url: task.url,
							dataType: "text"
						})
						.then(loader.resolve, loader.reject)
						.then(task.resolve, task.reject);
			}

			// Keep a reference to the loader in the task
			task.loader = loader;

			return task;
		}
	});

	return self;

})()
);
/**
 * jquery.require.language
 * Language loader plugin for $.require.
 *
 * Part of foundry-module/require family.
 * https://github.com/foundry-modules/require
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */


$.require.addLoader('language', (function() {

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			options,
			{batch: batch}
		);

		var task = new self.task(names, options);

		batch.addTask(task);

		task.start();
	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: ''
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		loaders: {},

		task: function(names, options) {

			var task = $.extend(this, $.Deferred());

			task.name = names.join(',');
			
			task.options = options;

			task.url = options.path;

			task.names = names;
		},

		loaders: {},

		loader: function(name) {

			// Pre-define loaders
			if ($.isArray(name)) {
				return $.map(name, function(name){
					return self.loader(name);
				});
			}

			// Resolve loaders
			if ($.isPlainObject(name)) {
				return $.map(name, function(content, name){
					return self.loader(name).resolve(content);
				});
			}

			// Get loader or create loaders
			var loader = self.loaders[name];

			if (!loader) {
				loader = self.loaders[name] = 
					$.Deferred()
						.done(function(string){
							$.language.add(name, string);
						});
			}

			return loader;
		}
	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this;

			var loaders = [];

			var names = 
				$.map(task.names, function(name){

					// Get existing loader or predefine loaders
					// so that subsequent require calls requesting
					// the same language keys won't be loaded again.
					var loader = self.loader(name);

					// Keep it to our array of loaders
					loader.push(loader);

					// If the language has resolved or rejected
					// remove it from list of language keys to load
					if (/resolved|rejected/.test(loader.state())) return null;

					return name;
				});

			// When unable to load language strings,
			// reject language loaders.
			task.fail(function(){
				$.each(names, function(i, name){
					self.loader(name).reject();
				});
			});

			// When all language strings has been loaded,
			// then we can resolve this task.
			$.when.apply(null, loaders)
				.then(task.resolve, task.reject);

			// If there are no language strings to load,
			// then wait for existing loaders to resolve or reject itself.
			if (names.length < 1) return task;

			task.xhr = 
				$.Ajax({
					url: task.url,
					type: "POST",
					data: {
						keys: names
					}
				})
				.done(function(strings){

					// If returned data is a language key-pair object, resolve task.
					if ($.isPlainObject(strings)) {

						self.loader(strings);
						// We don't need to resolve as the $.when above will resolve for us.
					} else {
						task.reject();
					}
				})
				.fail(function(){
					task.reject();
				});

			return task;
		}
	});

	return self;

})()
);
/**
 * jquery.require.library
 * Foundry script loader.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('library', function() {

	var batch = this,
		args = $.makeArray(arguments),
		options = {},
		names;

	// Expand arguments into its actual definition
	if ($.isPlainObject(args[0])) {
		options = args[0];
		names = args.slice(1);
	} else {
		names = args;
	}

	$.extend(options, {
		path: $.scriptPath
	});

	return batch.script.apply(batch, [options].concat(names));

});
/**
 * jquery.require.stylesheet
 * Stylesheet loader plugin for $.require.
 *
 * Part of jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('image', (function() {

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			options,
			{batch: batch}
		);

		$.each(names, function(i, name) {

			var task = new self.task(name, options),
				existingTask = self.images[task.url];

			task = existingTask || task;

			batch.addTask(task);

			if (!existingTask) {
				self.images[task.url] = task;
				task.start();
			}
		});
	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: ''
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		images: {},

		task: function(name, options) {

			var task = $.extend(this, $.Deferred());

			task.name = name;

			task.options = options;

			// Absolute path
			if ($.isUrl(name)) {

				task.url = name;

			// Relative path
			} else if (/^(\/|\.)/.test(name)) {

				task.url = $.uri(task.options.path)
							.toPath(name)
							.toString();

			// Module path
			} else {

				task.url = $.uri(task.options.path)
							.toPath('./' + name)
							.toString();
			}

			// Remap task.url to task.options.url
			task.options.url = task.url;
		}

	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this;

			task.image = $(new Image())
							.load(function(){
								task.resolve();
							})
							.error(function(){
								task.reject();
							})
							.attr("src", task.options.url);
		}

	});

	return self;

})()
);

});

FD40.plugin("iframe-transport", function($) {

// This [jQuery](http://jquery.com/) plugin implements an `<iframe>`
// [transport](http://api.jquery.com/extending-ajax/#Transports) so that
// `$.ajax()` calls support the uploading of files using standard HTML file
// input fields. This is done by switching the exchange from `XMLHttpRequest`
// to a hidden `iframe` element containing a form that is submitted.

// The [source for the plugin](http://github.com/cmlenz/jquery-iframe-transport)
// is available on [Github](http://github.com/) and dual licensed under the MIT
// or GPL Version 2 licenses.

// ## Usage

// To use this plugin, you simply add an `iframe` option with the value `true`
// to the Ajax settings an `$.ajax()` call, and specify the file fields to
// include in the submssion using the `files` option, which can be a selector,
// jQuery object, or a list of DOM elements containing one or more
// `<input type="file">` elements:

//     $("#myform").submit(function() {
//         $.ajax(this.action, {
//             files: $(":file", this),
//             iframe: true
//         }).complete(function(data) {
//             console.log(data);
//         });
//     });

// The plugin will construct hidden `<iframe>` and `<form>` elements, add the
// file field(s) to that form, submit the form, and process the response.

// If you want to include other form fields in the form submission, include
// them in the `data` option, and set the `processData` option to `false`:

//     $("#myform").submit(function() {
//         $.ajax(this.action, {
//             data: $(":text", this).serializeArray(),
//             files: $(":file", this),
//             iframe: true,
//             processData: false
//         }).complete(function(data) {
//             console.log(data);
//         });
//     });

// ### Response Data Types

// As the transport does not have access to the HTTP headers of the server
// response, it is not as simple to make use of the automatic content type
// detection provided by jQuery as with regular XHR. If you can't set the
// expected response data type (for example because it may vary depending on
// the outcome of processing by the server), you will need to employ a
// workaround on the server side: Send back an HTML document containing just a
// `<textarea>` element with a `data-type` attribute that specifies the MIME
// type, and put the actual payload in the textarea:

//     <textarea data-type="application/json">
//       {"ok": true, "message": "Thanks so much"}
//     </textarea>

// The iframe transport plugin will detect this and pass the value of the
// `data-type` attribute on to jQuery as if it was the "Content-Type" response
// header, thereby enabling the same kind of conversions that jQuery applies
// to regular responses. For the example above you should get a Javascript
// object as the `data` parameter of the `complete` callback, with the
// properties `ok: true` and `message: "Thanks so much"`.

// ### Handling Server Errors

// Another problem with using an `iframe` for file uploads is that it is
// impossible for the javascript code to determine the HTTP status code of the
// servers response. Effectively, all of the calls you make will look like they
// are getting successful responses, and thus invoke the `done()` or
// `complete()` callbacks. You can only determine communicate problems using
// the content of the response payload. For example, consider using a JSON
// response such as the following to indicate a problem with an uploaded file:

//     <textarea data-type="application/json">
//       {"ok": false, "message": "Please only upload reasonably sized files."}
//     </textarea>

// ### Compatibility

// This plugin has primarily been tested on Safari 5 (or later), Firefox 4 (or
// later), and Internet Explorer (all the way back to version 6). While I
// haven't found any issues with it so far, I'm fairly sure it still doesn't
// work around all the quirks in all different browsers. But the code is still
// pretty simple overall, so you should be able to fix it and contribute a
// patch :)

// ## Annotated Source



  // Register a prefilter that checks whether the `iframe` option is set, and
  // switches to the "iframe" data type if it is `true`.
  $.ajaxPrefilter(function(options, origOptions, jqXHR) {
    if (options.iframe) {
      return "iframe";
    }
  });

  // Register a transport for the "iframe" data type. It will only activate
  // when the "files" option has been set to a non-empty list of enabled file
  // inputs.
  $.ajaxTransport("iframe", function(options, origOptions, jqXHR) {
    var form = null,
        iframe = null,
        name = "iframe-" + $.now(),
        files = $(options.files).filter(":file:enabled"),
        hasFiles = files.length > 0,
        markers = null;

    // This function gets called after a successful submission or an abortion
    // and should revert all changes made to the page to enable the
    // submission via this transport.
    function cleanUp() {
      if (hasFiles) {
        markers.replaceWith(function(idx) {
          return files.get(idx);
        });
      }
      form.remove();
      iframe.attr("src", "javascript:false;").remove();
    }

    // Remove "iframe" from the data types list so that further processing is
    // based on the content type returned by the server, without attempting an
    // (unsupported) conversion from "iframe" to the actual type.
    options.dataTypes.shift();

      form = $("<form enctype='multipart/form-data' method='post'></form>").
        hide().attr({action: options.url, target: name});

      // If there is any additional data specified via the `data` option,
      // we add it as hidden fields to the form. This (currently) requires
      // the `processData` option to be set to false so that the data doesn't
      // get serialized to a string.
      if (typeof(options.data) === "string" && options.data.length > 0) {
        $.error("data must not be serialized");
      }
      $.each(options.data || {}, function(name, value) {
        if ($.isPlainObject(value)) {
          name = value.name;
          value = value.value;
        }

        if (!$.isArray(value)) {
          value = [value];
        }

        $.each(value, function(i, value){
          $("<input type='hidden' />").attr({name:  name, value: value}).
            appendTo(form);
        });

      });


      // Add a hidden `X-Requested-With` field with the value `IFrame` to the
      // field, to help server-side code to determine that the upload happened
      // through this transport.
      $("<input type='hidden' value='IFrame' name='X-Requested-With' />").
        appendTo(form);

      // Move the file fields into the hidden form, but first remember their
      // original locations in the document by replacing them with disabled
      // clones. This should also avoid introducing unwanted changes to the
      // page layout during submission.
      if (hasFiles) {
        markers = files.after(function(idx) {
          return $(this).clone().prop("disabled", true);
        }).next();
        files.appendTo(form);
      }

      return {

        // The `send` function is called by jQuery when the request should be
        // sent.
        send: function(headers, completeCallback) {
          iframe = $("<iframe src='javascript:false;' name='" + name +
            "' id='" + name + "' style='display:none'></iframe>");

          // The first load event gets fired after the iframe has been injected
          // into the DOM, and is used to prepare the actual submission.
          iframe.bind("load", function() {

            // The second load event gets fired when the response to the form
            // submission is received. The implementation detects whether the
            // actual payload is embedded in a `<textarea>` element, and
            // prepares the required conversions to be made in that case.
            iframe.unbind("load").bind("load", function() {
              var doc = this.contentWindow ? this.contentWindow.document :
                (this.contentDocument ? this.contentDocument : this.document),
                root = doc.documentElement ? doc.documentElement : doc.body,
                textarea = root.getElementsByTagName("textarea")[0],
                type = textarea ? textarea.getAttribute("data-type") : null,
                status = textarea ? textarea.getAttribute("data-status") : 200,
                statusText = textarea ? textarea.getAttribute("data-statusText") : "OK",
                content = {
                  html: root.innerHTML,
                  text: type ?
                    textarea.value :
                    root ? (root.textContent || root.innerText) : null
                };
              cleanUp();
              completeCallback(status, statusText, content, type ?
                ("Content-Type: " + type) :
                null);
            });

            // Now that the load handler has been set up, submit the form.
            form[0].submit();
          });

          // After everything has been set up correctly, the form and iframe
          // get injected into the DOM so that the submission can be
          // initiated.
          $("body").append(form, iframe);
        },

        // The `abort` function is called by jQuery when the request should be
        // aborted.
        abort: function() {
          if (iframe !== null) {
            iframe.unbind("load").attr("src", "javascript:false;");
            cleanUp();
          }
        }

      };
  });


});

FD40.plugin("server", function($) {

/*!
 * jquery.server.
 * Extension of jquery.ajax with ability to parse server commands.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
var self = $.server = function(options) {

	var request = $.Deferred(),

		ajaxOptions = $.extend(true, {}, self.defaultOptions, options, {success: function(){}}),

		xhr = request.xhr =
			$.Ajax(ajaxOptions)
				.done(function(commands){

					if (typeof commands==="string") {
						try {
							commands = $.parseJSON(commands);
						} catch(e) {
							request.rejectWith(request, ["Unable to parse Ajax commands.", "error"])
						}
					}

					if (!$.isArray(commands)) {

						request.rejectWith(request, ["Invalid ajax commands.", "error"]);

					} else {

						var parse = function(command){
							var type = command.type,
								parser = self.parsers[type] || options[type];

							if ($.isFunction(parser)) {
								return parser.apply(request, command.data);
							}
						}

						// Execute all the notifications first
						var commands = $.map(commands, function(command) {
							if (command.type=="notify") {
								parse(command);
							} else {
								return command;
							}
						})

						$.each(commands, function(i, command) {
							parse(command);
						});
					}

					// If server did not resolve this request
					if (request.state()==="pending") {

						// We'll resolve it ourselves
						request.resolveWith(request);
					}
				})
				.fail(function(jqXHR, status, statusText){

					request.rejectWith(request, [statusText, status]);
				});

		// Add abort method
		request.abort = xhr.abort;

	return request;
};

self.defaultOptions = {
	type: 'POST',
	data: {
		tmpl: 'component',
		format: 'ajax',
		no_html: 1
	},
	cache: false,
	contentType: 'application/x-www-form-urlencoded',
	dataType: 'json'
};

self.parsers = {

	script: function() {

		var data = $.makeArray(arguments);

		// For hardcoded javascript codes
		if (typeof data[0] == 'string') {
			try { eval(data[0]) } catch(err) {};
			return;
		}

		/**
		* Execute each method and assign returned object back to the chain.
		*
		* Foundry().attr('checked', true);
		* 	is equivalent to:
		* window['Foundry']('.element')[attr]('checked', true);
		*/
		var chain = window, chainBroken = false;

		$.each(data, function(i, chainer)
		{
			if (chainer.property==="Foundry") {
				chainer.property = $.globalNamespace;
			}

			if (chainer.method==="Foundry") {
				chainer.method = $.globalNamespace;
			}

			try {
				switch(chainer.type)
				{
					case 'get':
						chain = chain[chainer.property];
						break;

					case 'set':
						chain[chainer.property] = chainer.value;
						chainBroken=true;
						break;

					case 'call':
						chain = chain[chainer.method].apply(chain, chainer.args);
						break;
				}
			} catch(err) {
				chainBroken = true;
			}
		})
	},

	resolve: function() {

		this.resolveWith(this, arguments);
	},

	reject: function() {

		this.rejectWith(this, arguments);
	},

	notify: function() {

		this.notifyWith(this, arguments);
	},

	redirect: function(url) {

		window.location = url;
	}
};
});

FD40.plugin("component", function($) {

/**
 * jquery.component.
 * Boilerplate for client-side MVC application.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var Component = $.Component = function(name, options) {

    if (arguments.length < 1) {
        return Component.registry;
    }

    if (arguments.length < 2) {
        return Component.registry[name];
    }

    return Component.register(name, options);
}

Component.registry = {};

Component.proxy = function(component, property, value) {

    // If it's a method
    if ($.isFunction(value)) {

        // Change the "this" context to the component itself
        component[property] = $.proxy(value, component);

    } else {

        component[property] = value;
    }
}

Component.register = function(name, options) {

    // If an abstract component was passed in
    var abstractComponent;

    // Normalize arguments
    if ($.isFunction(name)) {
        abstractComponent = name;
        name = abstractComponent.className;
        options = abstractComponent.options;
    }

    var self =

        // Put it in component registry
        Component.registry[name] =

        // Set it to the global namespace
        window[name] =

        // When called as a function, it will return the correct jQuery object.
        function(command) {

            return ($.isFunction(command)) ? command($) : component;
        };

    // Extend component with properties in component prototype
    $.each(Component.prototype, function(property, value) {

        Component.proxy(self, property, value);
    });

    self.$                 = $;
    self.options           = options;
    self.className         = name;
    self.identifier        = name.toLowerCase();
    self.componentName     = "com_" + self.identifier;
    self.prefix            = self.identifier + "/";
    self.version           = options.version;
    self.safeVersion       = self.version.replace(/\./g,"");
    self.environment       = options.environment  || $.environment;
    self.mode              = options.mode         || $.mode;
    self.debug             = (self.environment==='development');
    self.console           = Component.console(self);
    self.language          = options.language || $.locale.lang || "en";
    self.baseUrl           = options.baseUrl      || $.indexUrl + "?option=" + self.componentName;
    self.ajaxUrl           = options.ajaxUrl      || $.basePath + "/?option=" + self.componentName;
    self.scriptPath        = options.scriptPath   || $.rootPath + "/media/" + self.componentName + "/scripts/";
    self.stylePath         = options.stylePath    || $.rootPath + "/media/" + self.componentName + "/styles/";
    self.templatePath      = options.templatePath || options.scriptPath;
    self.languagePath      = options.languagePath || self.ajaxUrl + '&tmpl=component&no_html=1&controller=lang&task=getLanguage';
    self.viewPath          = options.viewPath     || self.ajaxUrl + '&tmpl=component&no_html=1&controller=themes&task=getAjaxTemplate';
    self.optimizeResources = true;
    self.resourcePath      = options.resourcePath || self.ajaxUrl + '&tmpl=component&no_html=1&controller=foundry&task=getResource';
    self.resourceInterval  = 1200; // Joomla session timestamp is per second, we add another 200ms just to be safe.
    self.scriptVersioning  = options.scriptVersioning || false;
    self.tasks             = [];

    // Register component to bootleader
    FD40.component(name, self);

    // If there's no abstract componet prior to this, we're done!
    if (!abstractComponent) return;

    // If we're on development mode
    if (self.debug) {

        // Execute queue in abstract component straightaway
        abstractComponent.queue.execute();

    // If we're on static or optimized mode
    } else {

        // Get component installers from bootloader and install them
        var installer, installers = FD40.installer(name);
        while(installer = installers.shift()) {
            self.install.apply(self, installer);
        }

        // Wait until definitions, scripts & resources are installed
        $.when(
            self.install("definitions"),
            self.install("scripts"),
            self.install("resources")
        ).done(function(){

            // Then only execute queue in abstract component.
            abstractComponent.queue.execute();
        });
    }

    var storage = self.storage = function(key, val) {

        var prefix = self.prefix,
            key = prefix + key,
            length = arguments.length;

        // Getter
        if (length==1) return $.Storage.get(key)

        // Setter (remove or set)
        if (length==2) return key===false ? $.Storage.remove(prefix + val) : $.Storage.set(key, val);

        return storage.getAll();
    };

    $.extend(self.storage, {

        getAll: function() {

            var prefix = self.prefix,
                i = prefix.length,
                storage = $.Storage.getAll(),
                obj = {};

            for (key in storage) {
                if (key.substr(0, i)==prefix) {
                    obj[key.substr(i)] = storage[key];
                }
            }

            return obj;
        },

        remove: function(key) {
            $.Storage.remove(self.prefix + key);
        },

        clear: function() {
            for (key in storage.getAll()) {
                storage.remove(key);
            }
        }
    });
}

Component.extend = function(property, value) {

    // For later components
    Component.prototype[property] = value;

    // For existing components
    $.each(Component.registry, function(name, component) {
        Component.proxy(component, property, value);
    });
}

$.template("component/console",'<div id="[%== component.identifier %]-console" class="foundry-console" style="display: none; z-index: 999999;"><div class="console-header"><div class="console-title">[%= component.className %] [%= component.version %]</div><div class="console-remove-button">x</div></div><div class="console-log-item-group"></div><style type="text/css">.foundry-console{position:fixed;width:50%;height:50%;bottom:0;left:0;background:white;box-shadow: 0 0 5px 0;margin-left: 25px;}.console-log-item-group{width: 100%;height: 100%;overflow-y:scroll;}.console-header{position: absolute;background:red;color:white;font-weight:bold;top:-24px;left: 0;line-height:24px;width:100%}.console-remove-button{text-align:center;cursor: pointer;display:block;width: 24px;float:right}.console-remove-button:hover{color: yellow}.console-title{padding: 0 5px;float:left}.console-log-item{padding: 5px}.console-log-item + .console-log-item{border-top: 1px solid #ccc}</style></div>');

Component.console = function(component) {

    return (function(self){

        var instance = function(method) {

                if (arguments.length < 1) {
                    return instance.toggle();
                }

                return instance[method] && instance[method].apply(instance, arguments);
            },

            element;

            instance.selector = "#" + self.identifier + "-console";

            instance.init = function() {

                element = $(instance.selector);

                if (element.length < 1) {
                    element = $($.View("component/console", {component: self})).appendTo("body");

                    element.find(".console-remove-button").click(function(){
                        element.hide();
                    });
                }

                instance.element = element;

                return arguments.callee;
            };

            instance.methods = {

                log: function(message, type, code) {

                    type = type || "info";

                    var itemGroup = element.find(".console-log-item-group"),
                        item =
                            $(document.createElement("div"))
                                .addClass("console-log-item type-" + type)
                                .attr("data-code", code)
                                .html(message);

                    itemGroup.append(item);
                    itemGroup[0].scrollTop = itemGroup[0].scrollHeight;

                    // Automatically show window on each log
                    if (self.debug) { element.show(); }
                },

                toggle: function() {
                    element.toggle();
                },

                reset: function() {
                    element.find(".console-log-item-group").empty();
                }
            };

        $.each(instance.methods, function(method, fn) {
            instance[method] = function() {
                instance.init(); // Always call init in case of destruction of element
                return fn.apply(instance, arguments);
            }
        });

        return instance;

    })(component);
}

var doc = $(document),
    proto = Component.prototype;

$.extend(proto, {

    run: function(command) {

        return ($.isFunction(command)) ? command($) : this;
    },

    ready: (function(){

        // Replace itself once document is ready
        doc.ready(function(){
            proto.ready = proto.run;
        });

        return function(callback) {

            if (!$.isFunction(callback)) return;

            // When document is ready
            doc.ready(function() {
                callback($);
            });
        }
    })(),

    install: function(name, factory) {

        var self = this,
            task = self.tasks[name] || (self.tasks[name] = $.Deferred());

        // Getter
        if (!factory) return task;

        // Setter
        var install = function(){
            factory($, self);
            return task.resolve();
        }

        // If this is installer contains component definitions,
        // install straightaway.
        if (name=="definitions") return install();

        // Else for component definitiosn to install first,
        // then only install this installer.
        $.when(self.install("definitions")).done(install);
    },

    token: function() {

        var self = this;

        if (self.token.value) return self.token.value;

        var identifier = self.identifier,
            span = 'span#' + identifier + '-token input',
            meta = 'meta[name="' + identifier + ':token"]',

            // Look for an updated token replaced by Joomla on page load and use
            // that token instead. This is for sites where cache is turned on.
            token = $(span).attr("name") || $(meta).attr("content");

        return self.token.value = token;
    },

    template: function(name) {

        var self = this;

        // Get all component templates
        if (name==undefined) {

            return $.grep($.template(), function(template) {

                return template.indexOf(self.prefix)==0;
            });
        }

        // Prepend component prefix
        arguments[0] = self.prefix + name;

        // Getter or setter
        return $.template.apply(null, arguments);
    },

    // Component require extends $.require with the following additional methods:
    // - resource()
    // - view()
    // - language()
    //
    // It also changes the behaviour of existing methods to load in component-specific behaviour.
    require: function(options) {

        var self = this,

            options = options || {},

            require = $.require(options),

            _require = {};

            // Keep a copy of the original method so the duck punchers below can use it.
            $.each(["library", "script", "language", "template", "done"], function(i, method){
                _require[method] = require[method];
            });

        // Resource call should NOT be called directly.
        // .resource({type: "view", name: "photo.item", loader: deferredObject})
        require.resource = function(resource) {

            // If this is not a valid resource object, skip.
            if (!$.isPlainObject(resource)) return;
            if (!resource.type || !resource.name || !$.isDeferred(resource.loader)) return;

            var batch = this;

            // Get resource collector
            var resourceCollector = self.resourceCollector;

            // If we haven't started collecting resources
            if (!resourceCollector) {

                // Then start collecting resources
                resourceCollector = self.resourceCollector = $.Deferred();

                $.extend(resourceCollector, {

                    name: $.uid("ResourceCollector"),

                    manifest: [],

                    loaderList: [],

                    loaders: [],

                    load: function() {

                        // End this batch of resource collecting
                        delete self.resourceCollector;

                        // If there are not resources to pull,
                        // just resolve resource collector.
                        if (resourceCollector.manifest.length < 0) {
                            resourceCollector.resolve();
                            return;
                        }

                        var retry = 0;

                        var loadResources = function(){

                            retry++;

                            $.Ajax(
                                {
                                    type: 'POST',
                                    url: self.resourcePath,
                                    dataType: "json",
                                    data: {
                                        resource: resourceCollector.manifest
                                    }
                                })
                                .done(function(manifest) {

                                    if (!$.isArray(manifest)) {
                                        resourceCollector.reject("Server did not return a valid resource manifest.");
                                        return;
                                    }

                                    $.each(manifest, function(i, resource) {

                                        var content = resource.content;

                                        resourceCollector.loaders[resource.id]
                                            [content!==undefined ? "resolve" : "reject"]
                                            (content);
                                    });

                                    if (retry > 1 && self.debug) {
                                        console.info("Attempt to try and get resources again was successful!");
                                    }
                                })
                                .fail(function(){
                                    if (retry > 2) {
                                        if (self.debug) { console.error("Unable to get resource again. Giving up!"); };
                                        return;
                                    }
                                    if (self.debug) {
                                        console.warn("Unable to get resource. Trying again...");
                                    }
                                    loadResources();
                                });
                        }

                        loadResources();

                        // Resolve resource collector when all is done
                        $.when.apply(null, resourceCollector.loaderList)
                            .done(resourceCollector.resolve)
                            .fail(resourceCollector.reject);
                    }
                });

                setTimeout(resourceCollector.load, self.resourceCollectionInterval);
            }

            // Create a resource id
            var id = resource.id = $.uid("Resource");

            // Add to the loader map
            // - to be used to resolve the loader with the returned content
            resourceCollector.loaders[id] = resource.loader;

            // Add to the loader list
            // - to be used with $.when()
            resourceCollector.loaderList.push(resource.loader);

            // Remove the reference to the loader
            // - so the loader doesn't get included in the manifest that gets sent to the server
            delete resource.loader;

            // Then add it to our list of resource manifest
            resourceCollector.manifest.push(resource);

            // Note: Only resource loaders are batch tasks, not resource collectors.
            // var task = resourceCollector;
            // batch.addTask(task);
            return require;
        };

        require.view = function() {

            var batch   = this,

                request = batch.expand(arguments, {path: self.viewPath}),

                loaders = {},

                options = request.options,

                names   = $.map(request.names, function(name) {

                    // Get template loader
                    var absoluteName = self.prefix + name,
                        loader = $.require.template.loaders[absoluteName];

                    // If this is being loaded, skip.
                    if (loader) return;

                    loader = $.require.template.loader(absoluteName);

                    loader.name = absoluteName;

                    // Add template loader as a task of this batch
                    batch.addTask(loader);

                    // Load as part of a coalesced ajax call if enabled
                    if (self.optimizeResources) {

                        require.resource({
                            type: "view",
                            name: name,
                            loader: loader
                        });

                        return;

                    } else {

                        loaders[name] = loader;
                        return name;
                    }
                });

            // Load using regular ajax call
            // This will always be zero when optimizeResources is enabled.
            if (names.length > 0) {

                $.Ajax(
                    {
                        url: options.path,
                        dataType: "json",
                        data: { names: names }
                    })
                    .done(function(templates) {

                        if (!$.isArray(templates)) return;

                        $.each(templates, function(i, template) {

                            var content = template.content;

                            loaders[template.name]
                                [content!==undefined ? "resolve" : "reject"]
                                (content);
                        });
                    });
            }

            return require;
        };

        require.language = function() {

            var batch   = this,

                request = batch.expand(arguments, {path: self.languagePath});

            // Load as part of a coalesced ajax call if enabled
            if (self.optimizeResources) {

                $.each(request.names, function(i, name) {

                    var loader = $.require.language.loaders[name];

                    if (loader) return;

                    loader = $.require.language.loader(name);

                    loader.name = name;

                    batch.addTask(loader);

                    require.resource({
                        type: "language",
                        name: name,
                        loader: loader
                    });
                });

            } else {

                _require.language.apply(require, [request.options].concat(request.names));
            }

            return require;
        };

        require.library = function() {

            _require.script.apply(this, arguments);

            return require;
        };

        require.script = function() {

            var batch = this,

                request = batch.expand(arguments, {path: self.scriptPath}),

                names = $.map(request.names, function(name) {

                    // Ignore module definitions
                    if ($.isArray(name) ||

                        // and urls
                        $.isUrl(name) ||

                        // and relative paths.
                        /^(\/|\.)/.test(name)) return name;

                    var moduleName = self.prefix + name,

                        moduleUrl =

                            $.uri(request.options.path)
                                .toPath(
                                    './' + name + '.' + (request.options.extension || 'js') +
                                    ((self.scriptVersioning) ? "?" + "version=" + self.safeVersion : "")
                                )
                                .toString();

                    return [[moduleName, moduleUrl, true]];
                });

            _require.script.apply(require, [request.options].concat(names));

            return require;
        };

        // Override path
        require.template = function() {

            var batch   = this,

                request = batch.expand(arguments, {path: self.templatePath});

            _require.template.apply(require, [request.options].concat(

                $.map(request.names, function(name) {

                    return [[self.prefix + name, name]];
                })
            ));

            return require;
        };

        require.app = function() {

            var batch = this,

                request = batch.expand(arguments, {path: self.scriptPath})

                names = $.map(request.names, function(name) {

                    // Ignore module definitions
                    if ($.isArray(name) ||

                        // and urls
                        $.isUrl(name) ||

                        // and relative paths.
                        /^(\/|\.)/.test(name)) return name;

                    var parts = name.split('/'),
                        path = $.rootPath + '/media/' + self.componentName + '/apps';

                    // Currently used by fields
                    if (parts.length===4) {
                        path += '/' + parts.shift();
                    }

                    // Build path
                    path += '/' + parts[0] + '/' + parts[1] + '/scripts/' + parts[2];

                    var moduleName = self.prefix + name,

                        moduleUrl = path + '.' +
                            (request.options.extension || 'js') +
                            ((self.scriptVersioning) ? "?" + "version=" + self.safeVersion : "");

                    return [[moduleName, moduleUrl, true]];
                });

            _require.script.apply(require, [request.options].concat(names));

            return require;
        };

        // Only execute require done callback when component is ready
        require.done = function(callback) {

            return _require.done.call(require, function(){

                self.ready(callback);
            });
        };

        return require;
    },

    module: function(name, factory) {

        var self = this;

        // TODO: Support for multiple module factory assignment
        if ($.isArray(name)) {
            return;
        }

        var fullname = self.prefix + name;

        return (factory) ?

            // Set module
            $.module.apply(null, [fullname, function(){

                var module = this;

                factory.call(module, $);
            }])

            :

            // Get module
            $.module(fullname);
    }
});
$.Component.extend("ajax", function(namespace, params, callback) {

    var self = this,
        date = new Date();

    var options = {
            url: self.ajaxUrl + "&_ts=" + date.getTime(),
            data: $.extend(
                params,
                {
                    option: self.componentName,
                    namespace: namespace
                }
            )
        };

    options = $.extend(true, options, self.options.ajax);

    options.data[self.token()] = 1;

    // This is for server-side function arguments
    if (options.data.hasOwnProperty('args')) {
        options.data.args = $.toJSON(options.data.args);
    }

    if ($.isPlainObject(callback)) {

        if (callback.type) {

            switch (callback.type) {

                case 'jsonp':

                    callback.dataType = 'jsonp';

                    // This ensure jQuery doesn't use XHR should it detect the ajax url is a local domain.
                    callback.crossDomain = true;

                    options.data.transport = 'jsonp';
                    break;

                case 'iframe':

                    // For use with iframe-transport
                    callback.iframe = true;

                    callback.processData = false;

                    callback.files = options.data.files;

                    delete options.data.files;

                    options.data.transport = 'iframe';
                    break;
            }

            delete callback.type;
        }

        $.extend(options, callback);
    }

    if ($.isFunction(callback)) {
        options.success = callback;
    }

    var ajax = $.server(options);

    ajax.progress(function(message, type, code) {
        if (self.debug && type=="debug") {
            self.console.log(message, type, code);
        }
    });

    return ajax;
});

$.Component.extend("Controller", function() {

    var self = this,
        args = $.makeArray(arguments),
        name = args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(name);
    };

    // Setter
    if (args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    } else {
        staticProps = {},
        protoFactory = args[1]
    }

    // Map component as a static property
    // of the controller class
    $.extend(staticProps, {
        root: self.className + '.Controller',
        component: self
    });

    return $.Controller.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("Model", function() {
    var self = this,
        args = $.makeArray(arguments),
        name = self.className + '.Model.' + args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(args[0]);
    }

    if( args.length==2) {
        staticProps = {},
        protoFactory = args[1]
    }

    if( args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    }

    // Map component as a static property
    // of the model class
    $.extend(staticProps, {
        component: self
    });

    return $.Model.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("Model.List", function() {
    var self = this,
        args = $.makeArray(arguments),
        name = self.className + '.Model.List.' + args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(args[0]);
    }

    if( args.length==2) {
        staticProps = {},
        protoFactory = args[1]
    }

    if( args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    }

    // Map component as a static property
    // of the model class
    $.extend(staticProps, {
        component: self
    });

    return $.Model.List.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("View", function(name) {

    var self = this;

    // Gett all component views
    if (arguments.length < 1) {
        return self.template();
    }

    // Prepend component prefix
    arguments[0] = self.prefix + arguments[0];

    // Getter or setter
    return $.View.apply(this, arguments);
});
// Component should always be the last core plugin to load.

// Execute all pending foundry modules
FD40.module.execute();

// Get all abstract components
$.each(FD40.component(), function(i, abstractComponent){

    // If this component is registered, stop.
    if (abstractComponent.registered) return;

    // Create an instance of the component
    $.Component.register(abstractComponent);
});

});
FD40.plugin("static", function($){
(function(){
var stylesheetNames = ["dialog/default"];
var state = ($.stylesheet({"content":".foundryDialog{background:url(images\/333-50.png);padding:5px;border:1px solid #333;border-radius:8px;-moz-border-radius:8px;-webkit-border-radius:8px}.foundryDialog.resizing{padding-bottom:7px}.foundryDialog .dialog-wrap{border:1px solid #333;border-radius:4px;-moz-border-radius:4px;-webkit-border-radius:4px;background:#fff;overflow:hidden;min-height:100%;height:100%}.foundryDialog .dialog-wrap>.in{position:relative}.foundryDialog .dialog-head{font:700 14px\/30px Arial;height:30px;padding:0 9px;border-top:1px solid #f5f5f5;border-bottom:1px solid #666;background:#eaeaea;color:#444 !important;border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;-webkit-border-radius:4px 4px 0 0;position:relative}.foundryDialog .dialog-body{background:#fff;padding:10px}.foundryDialog .dialog-body.type-iframe{padding:0}.foundryDialog .dialog-footer{background:#fafafa;border-top:1px solid #aaa;padding:6px;border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;-webkit-border-radius:0 0 4px 4px}.foundryDialog .dialog-buttons{text-align:right}.foundryDialog .dialog-closeButton{background:url(images\/cross-8.png) center;display:block;text-indent:-9999px;width:8px;height:8px;position:absolute !important;right:10px;top:50%;margin-top:-4px;opacity:.4;cursor:pointer}.foundryDialog .dialog-closeButton:hover{opacity:.7}.foundryDialog .dialog-loader{position:absolute;background:rgba(255,255,255,0.5);z-index:9999}.foundryDialog .loader-img{background:url(images\/ajax-loader.gif) center no-repeat;width:32px;height:32px;position:absolute;top:50%;left:50%;margin:-16px 0 0 -16px}"})) ? "resolve" : "reject";
$.each(stylesheetNames, function(i, stylesheet){ $.require.stylesheet.loader(stylesheet)[state](); });
})();
$.module(["uniform","chosen","event/drag","mousewheel","resize","expanding","ui/core","ui/mouse","ui/widget","textboxlist","autosize.input","scrollTo","tinyscrollbar","history","masonry","datetimepicker","","popbox","ui/position","gmaps","placeholder","image","imgareaselect","passwordstrength","mentions","dialog","easing","gritter"]);
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/**
Uniform v1.7.5
Copyright © 2009 Josh Pyles / Pixelmatrix Design LLC
http://pixelmatrixdesign.com

Requires jQuery 1.4 or newer

Much thanks to Thomas Reynolds and Buck Wilson for their help and advice on this

Disabling text selection is made possible by Mathias Bynens <http://mathiasbynens.be/>
and his noSelect plugin. <http://github.com/mathiasbynens/noSelect-jQuery-Plugin>

Also, thanks to David Kaneda and Eugene Bond for their contributions to the plugin

License:
MIT License - http://www.opensource.org/licenses/mit-license.php

Enjoy!

*/

(function($) {
  $.uniform = {
    options: {
      selectClass:   'selector',
      radioClass: 'radio',
      checkboxClass: 'checker',
      fileClass: 'uploader',
      filenameClass: 'filename',
      fileBtnClass: 'action',
      fileDefaultText: 'No file selected',
      fileBtnText: 'Choose File',
      checkedClass: 'checked',
      focusClass: 'focus',
      disabledClass: 'disabled',
      buttonClass: 'button',
      activeClass: 'active',
      hoverClass: 'hover',
      useID: true,
      idPrefix: 'uniform',
      resetSelector: false,
      autoHide: true
    },
    elements: []
  };

  if($.browser.msie && $.browser.version < 7){
    $.support.selectOpacity = false;
  }else{
    $.support.selectOpacity = true;
  }

  $.fn.uniform = function(options) {

    options = $.extend($.uniform.options, options);

    var el = this;
    //code for specifying a reset button
    if(options.resetSelector != false){
      $(options.resetSelector).mouseup(function(){
        function resetThis(){
          $.uniform.update(el);
        }
        setTimeout(resetThis, 10);
      });
    }
    
    function doInput(elem){
      $el = $(elem);
      $el.addClass($el.attr("type"));
      storeElement(elem);
    }
    
    function doTextarea(elem){
      $(elem).addClass("uniform");
      storeElement(elem);
    }
    
    function doButton(elem){
      var $el = $(elem);
      
      var divTag = $("<div>"),
          spanTag = $("<span>");
      
      divTag.addClass(options.buttonClass);
      
      if(options.useID && $el.attr("id") != "") divTag.attr("id", options.idPrefix+"-"+$el.attr("id"));
      
      var btnText;
      
      if($el.is("a") || $el.is("button")){
        btnText = $el.text();
      }else if($el.is(":submit") || $el.is(":reset") || $el.is("input[type=button]")){
        btnText = $el.attr("value");
      }
      
      btnText = btnText == "" ? $el.is(":reset") ? "Reset" : "Submit" : btnText;
      
      spanTag.html(btnText);
      
      $el.css("opacity", 0);
      $el.wrap(divTag);
      $el.wrap(spanTag);
      
      //redefine variables
      divTag = $el.closest("div");
      spanTag = $el.closest("span");
      
      if($el.is(":disabled")) divTag.addClass(options.disabledClass);
      
      divTag.bind({
        "mouseenter.uniform": function(){
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function(){
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        },
        "mousedown.uniform touchbegin.uniform": function(){
          divTag.addClass(options.activeClass);
        },
        "mouseup.uniform touchend.uniform": function(){
          divTag.removeClass(options.activeClass);
        },
        "click.uniform touchend.uniform": function(e){
          if($(e.target).is("span") || $(e.target).is("div")){    
            if(elem[0].dispatchEvent){
              var ev = document.createEvent('MouseEvents');
              ev.initEvent( 'click', true, true );
              elem[0].dispatchEvent(ev);
            }else{
              elem[0].click();
            }
          }
        }
      });
      
      elem.bind({
        "focus.uniform": function(){
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function(){
          divTag.removeClass(options.focusClass);
        }
      });
      
      $.uniform.noSelect(divTag);
      storeElement(elem);
      
    }

    function doSelect(elem){
      var $el = $(elem);
      
      var divTag = $('<div />'),
          spanTag = $('<span />');
      
      if(!$el.css("display") == "none" && options.autoHide){
        divTag.hide();
      }

      divTag.addClass(options.selectClass);

      if(options.useID && elem.attr("id") != ""){
        divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
      }
      
      var selected = elem.find(":selected:first");
      if(selected.length == 0){
        selected = elem.find("option:first");
      }
      spanTag.html(selected.html());
      
      elem.css('opacity', 0);
      elem.wrap(divTag);
      elem.before(spanTag);

      //redefine variables
      divTag = elem.parent("div");
      spanTag = elem.siblings("span");

      elem.bind({
        "change.uniform": function() {
          spanTag.text(elem.find(":selected").html());
          divTag.removeClass(options.activeClass);
        },
        "focus.uniform": function() {
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function() {
          divTag.removeClass(options.focusClass);
          divTag.removeClass(options.activeClass);
        },
        "mousedown.uniform touchbegin.uniform": function() {
          divTag.addClass(options.activeClass);
        },
        "mouseup.uniform touchend.uniform": function() {
          divTag.removeClass(options.activeClass);
        },
        "click.uniform touchend.uniform": function(){
          divTag.removeClass(options.activeClass);
        },
        "mouseenter.uniform": function() {
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function() {
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        },
        "keyup.uniform": function(){
          spanTag.text(elem.find(":selected").html());
        }
      });
      
      //handle disabled state
      if($(elem).prop("disabled")){
        //box is checked by default, check our box
        divTag.addClass(options.disabledClass);
      }
      $.uniform.noSelect(spanTag);
      
      storeElement(elem);

    }

    function doCheckbox(elem){
      var $el = $(elem);
      
      var divTag = $('<div />'),
          spanTag = $('<span />');
      
      if(!$el.css("display") == "none" && options.autoHide){
        divTag.hide();
      }
      
      divTag.addClass(options.checkboxClass);

      //assign the id of the element
      if(options.useID && elem.attr("id") != ""){
        divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
      }

      //wrap with the proper elements
      $(elem).wrap(divTag);
      $(elem).wrap(spanTag);

      //redefine variables
      spanTag = elem.parent();
      divTag = spanTag.parent();

      //hide normal input and add focus classes
      $(elem)
      .css("opacity", 0)
      .bind({
        "focus.uniform": function(){
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function(){
          divTag.removeClass(options.focusClass);
        },
        "click.uniform touchend.uniform": function(){
          if(!$(elem).prop("checked")){
            //box was just unchecked, uncheck span
            spanTag.removeClass(options.checkedClass);
          }else{
            //box was just checked, check span.
            spanTag.addClass(options.checkedClass);
          }
        },
        "mousedown.uniform touchbegin.uniform": function() {
          divTag.addClass(options.activeClass);
        },
        "mouseup.uniform touchend.uniform": function() {
          divTag.removeClass(options.activeClass);
        },
        "mouseenter.uniform": function() {
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function() {
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        }
      });
      
      //handle defaults
      if($(elem).prop("checked")){
        //box is checked by default, check our box
        spanTag.addClass(options.checkedClass);
      }

      //handle disabled state
      if($(elem).prop("disabled")){
        //box is checked by default, check our box
        divTag.addClass(options.disabledClass);
      }

      storeElement(elem);
    }

    function doRadio(elem){
      var $el = $(elem);
      
      var divTag = $('<div />'),
          spanTag = $('<span />');
          
      if(!$el.css("display") == "none" && options.autoHide){
        divTag.hide();
      }

      divTag.addClass(options.radioClass);

      if(options.useID && elem.attr("id") != ""){
        divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
      }

      //wrap with the proper elements
      $(elem).wrap(divTag);
      $(elem).wrap(spanTag);

      //redefine variables
      spanTag = elem.parent();
      divTag = spanTag.parent();

      //hide normal input and add focus classes
      $(elem)
      .css("opacity", 0)
      .bind({
        "focus.uniform": function(){
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function(){
          divTag.removeClass(options.focusClass);
        },
        "click.uniform touchend.uniform": function(){
          if(!$(elem).prop("checked")){
            //box was just unchecked, uncheck span
            spanTag.removeClass(options.checkedClass);
          }else{
            //box was just checked, check span
            var classes = options.radioClass.split(" ")[0];
            $("." + classes + " span." + options.checkedClass + ":has([name='" + $(elem).attr('name') + "'])").removeClass(options.checkedClass);
            spanTag.addClass(options.checkedClass);
          }
        },
        "mousedown.uniform touchend.uniform": function() {
          if(!$(elem).is(":disabled")){
            divTag.addClass(options.activeClass);
          }
        },
        "mouseup.uniform touchbegin.uniform": function() {
          divTag.removeClass(options.activeClass);
        },
        "mouseenter.uniform touchend.uniform": function() {
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function() {
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        }
      });

      //handle defaults
      if($(elem).prop("checked")){
        //box is checked by default, check span
        spanTag.addClass(options.checkedClass);
      }
      //handle disabled state
      if($(elem).prop("disabled")){
        //box is checked by default, check our box
        divTag.addClass(options.disabledClass);
      }

      storeElement(elem);

    }

    function doFile(elem){
      //sanitize input
      var $el = $(elem);

      var divTag = $('<div />'),
          filenameTag = $('<span>'+options.fileDefaultText+'</span>'),
          btnTag = $('<span>'+options.fileBtnText+'</span>');
      
      if(!$el.css("display") == "none" && options.autoHide){
        divTag.hide();
      }

      divTag.addClass(options.fileClass);
      filenameTag.addClass(options.filenameClass);
      btnTag.addClass(options.fileBtnClass);

      if(options.useID && $el.attr("id") != ""){
        divTag.attr("id", options.idPrefix+"-"+$el.attr("id"));
      }

      //wrap with the proper elements
      $el.wrap(divTag);
      $el.after(btnTag);
      $el.after(filenameTag);

      //redefine variables
      divTag = $el.closest("div");
      filenameTag = $el.siblings("."+options.filenameClass);
      btnTag = $el.siblings("."+options.fileBtnClass);

      //set the size
      if(!$el.attr("size")){
        var divWidth = divTag.width();
        //$el.css("width", divWidth);
        $el.attr("size", divWidth/10);
      }

      //actions
      var setFilename = function()
      {
        var filename = $el.val();
        if (filename === '')
        {
          filename = options.fileDefaultText;
        }
        else
        {
          filename = filename.split(/[\/\\]+/);
          filename = filename[(filename.length-1)];
        }
        filenameTag.text(filename);
      };

      // Account for input saved across refreshes
      setFilename();

      $el
      .css("opacity", 0)
      .bind({
        "focus.uniform": function(){
          divTag.addClass(options.focusClass);
        },
        "blur.uniform": function(){
          divTag.removeClass(options.focusClass);
        },
        "mousedown.uniform": function() {
          if(!$(elem).is(":disabled")){
            divTag.addClass(options.activeClass);
          }
        },
        "mouseup.uniform": function() {
          divTag.removeClass(options.activeClass);
        },
        "mouseenter.uniform": function() {
          divTag.addClass(options.hoverClass);
        },
        "mouseleave.uniform": function() {
          divTag.removeClass(options.hoverClass);
          divTag.removeClass(options.activeClass);
        }
      });

      // IE7 doesn't fire onChange until blur or second fire.
      if ($.browser.msie){
        // IE considers browser chrome blocking I/O, so it
        // suspends tiemouts until after the file has been selected.
        $el.bind('click.uniform.ie7', function() {
          setTimeout(setFilename, 0);
        });
      }else{
        // All other browsers behave properly
        $el.bind('change.uniform', setFilename);
      }

      //handle defaults
      if($el.prop("disabled")){
        //box is checked by default, check our box
        divTag.addClass(options.disabledClass);
      }
      
      $.uniform.noSelect(filenameTag);
      $.uniform.noSelect(btnTag);
      
      storeElement(elem);

    }
    
    $.uniform.restore = function(elem){
      if(elem == undefined){
        elem = $($.uniform.elements);
      }
      
      $(elem).each(function(){
        if($(this).is(":checkbox")){
          //unwrap from span and div
          $(this).unwrap().unwrap();
        }else if($(this).is("select")){
          //remove sibling span
          $(this).siblings("span").remove();
          //unwrap parent div
          $(this).unwrap();
        }else if($(this).is(":radio")){
          //unwrap from span and div
          $(this).unwrap().unwrap();
        }else if($(this).is(":file")){
          //remove sibling spans
          $(this).siblings("span").remove();
          //unwrap parent div
          $(this).unwrap();
        }else if($(this).is("button, :submit, :reset, a, input[type='button']")){
          //unwrap from span and div
          $(this).unwrap().unwrap();
        }
        
        //unbind events
        $(this).unbind(".uniform");
        
        //reset inline style
        $(this).css("opacity", "1");
        
        //remove item from list of uniformed elements
        var index = $.inArray($(elem), $.uniform.elements);
        $.uniform.elements.splice(index, 1);
      });
    };

    function storeElement(elem){
      //store this element in our global array
      elem = $(elem).get();
      if(elem.length > 1){
        $.each(elem, function(i, val){
          $.uniform.elements.push(val);
        });
      }else{
        $.uniform.elements.push(elem);
      }
    }
    
    //noSelect v1.0
    $.uniform.noSelect = function(elem) {
      function f() {
       return false;
      };
      $(elem).each(function() {
       this.onselectstart = this.ondragstart = f; // Webkit & IE
       $(this)
        .mousedown(f) // Webkit & Opera
        .css({ MozUserSelect: 'none' }); // Firefox
      });
     };

    $.uniform.update = function(elem){
      if(elem == undefined){
        elem = $($.uniform.elements);
      }
      //sanitize input
      elem = $(elem);

      elem.each(function(){
        //do to each item in the selector
        //function to reset all classes
        var $e = $(this);

        if($e.is("select")){
          //element is a select
          var spanTag = $e.siblings("span");
          var divTag = $e.parent("div");

          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);

          //reset current selected text
          spanTag.html($e.find(":selected").html());

          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }

        }else if($e.is(":checkbox")){
          //element is a checkbox
          var spanTag = $e.closest("span");
          var divTag = $e.closest("div");

          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);
          spanTag.removeClass(options.checkedClass);

          if($e.is(":checked")){
            spanTag.addClass(options.checkedClass);
          }
          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }

        }else if($e.is(":radio")){
          //element is a radio
          var spanTag = $e.closest("span");
          var divTag = $e.closest("div");

          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);
          spanTag.removeClass(options.checkedClass);

          if($e.is(":checked")){
            spanTag.addClass(options.checkedClass);
          }

          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }
        }else if($e.is(":file")){
          var divTag = $e.parent("div");
          var filenameTag = $e.siblings(options.filenameClass);
          btnTag = $e.siblings(options.fileBtnClass);

          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);

          filenameTag.text($e.val());

          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }
        }else if($e.is(":submit") || $e.is(":reset") || $e.is("button") || $e.is("a") || elem.is("input[type=button]")){
          var divTag = $e.closest("div");
          divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);
          
          if($e.is(":disabled")){
            divTag.addClass(options.disabledClass);
          }else{
            divTag.removeClass(options.disabledClass);
          }
          
        }
        
      });
    };

    return this.each(function() {
      if($.support.selectOpacity){
        var elem = $(this);

        if(elem.is("select")){
          //element is a select
          if(elem.attr("multiple") != true){
            //element is not a multi-select
            if(elem.attr("size") == undefined || elem.attr("size") <= 1){
              doSelect(elem);
            }
          }
        }else if(elem.is(":checkbox")){
          //element is a checkbox
          doCheckbox(elem);
        }else if(elem.is(":radio")){
          //element is a radio
          doRadio(elem);
        }else if(elem.is(":file")){
          //element is a file upload
          doFile(elem);
        }else if(elem.is(":text, :password, input[type='email']")){
          doInput(elem);
        }else if(elem.is("textarea")){
          doTextarea(elem);
        }else if(elem.is("a") || elem.is(":submit") || elem.is(":reset") || elem.is("button") || elem.is("input[type=button]")){
          doButton(elem);
        }
          
      }
    });
  };
})(jQuery);
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("uniform", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

var globalChosen = {};

// Chosen, a Select Box Enhancer for jQuery and Protoype
// by Patrick Filler for Harvest, http://getharvest.com
//
// Version 0.9.8
// Full source at https://github.com/harvesthq/chosen
// Copyright (c) 2011 Harvest http://getharvest.com

// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
// This file is generated by `cake build`, do not edit it by hand.
(function() {
  var SelectParser;

  SelectParser = (function() {

    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    SelectParser.prototype.add_node = function(child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function(group) {
      var group_position, option, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: group.label,
        children: 0,
        disabled: group.disabled
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        if (option.text !== "") {
          if (group_position != null) this.parsed[group_position].children += 1;
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    return SelectParser;

  })();

  SelectParser.select_to_array = function(select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  this.SelectParser = SelectParser;

}).call(globalChosen);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/

(function() {

  var AbstractChosen, root;
  root = this;

  AbstractChosen = (function() {

    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      this.set_default_values();
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.finish_setup();
    }

    AbstractChosen.prototype.set_default_values = function() {
      var _this = this;
      this.click_test_action = function(evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function(evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.result_single_selected = null;
      this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.search_contains = this.options.search_contains || false;
      this.choices = 0;
      this.single_backstroke_delete = this.options.single_backstroke_delete || false;
      return this.max_selected_options = this.options.max_selected_options || Infinity;
    };

    AbstractChosen.prototype.set_default_text = function() {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || "Select Some Options";
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || "Select an Option";
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || "No results match";
    };

    AbstractChosen.prototype.mouse_enter = function() {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function() {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function(evt) {
      var _this = this;
      if (!this.active_field) {
        return setTimeout((function() {
          return _this.container_mousedown();
        }), 50);
      }
    };

    AbstractChosen.prototype.input_blur = function(evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout((function() {
          return _this.blur_test();
        }), 100);
      }
    };

    AbstractChosen.prototype.result_add_option = function(option) {
      var classes, style;
      if (!option.disabled) {
        option.dom_id = this.container_id + "_o_" + option.array_index;
        classes = option.selected && this.is_multiple ? [] : ["active-result"];
        if (option.selected) classes.push("result-selected");
        if (option.group_array_index != null) classes.push("group-option");
        if (option.classes !== "") classes.push(option.classes);
        style = option.style.cssText !== "" ? " style=\"" + option.style + "\"" : "";
        return '<li id="' + option.dom_id + '" class="' + classes.join(' ') + '"' + style + '>' + option.html + '</li>';
      } else {
        return "";
      }
    };

    AbstractChosen.prototype.results_update_field = function() {
      if (!this.is_multiple) this.results_reset_cleanup();
      this.result_clear_highlight();
      this.result_single_selected = null;
      return this.results_build();
    };

    AbstractChosen.prototype.results_toggle = function() {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function(evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) return this.result_select(evt);
          break;
        case 27:
          if (this.results_showing) this.results_hide();
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.generate_field_id = function() {
      var new_id;
      new_id = this.generate_random_id();
      this.form_field.id = new_id;
      return new_id;
    };

    AbstractChosen.prototype.generate_random_char = function() {
      var chars, newchar, rand;
      chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      rand = Math.floor(Math.random() * chars.length);
      return newchar = chars.substring(rand, rand + 1);
    };

    return AbstractChosen;

  })();

  root.AbstractChosen = AbstractChosen;

}).call(globalChosen);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/

(function() {
  var $, Chosen, get_side_border_padding, root,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = this;

  $ = jQuery;

  $.fn.extend({
    chosen: function(options) {
      if ($.browser.msie && ($.browser.version === "6.0" || ($.browser.version === "7.0" && document.documentMode === 7))) {
        return this;
      }
      return this.each(function(input_field) {
        var $this;
        $this = $(this);
        if (!$this.hasClass("chzn-done")) {
          return $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = (function(_super) {

    __extends(Chosen, _super);

    function Chosen() {
      Chosen.__super__.constructor.apply(this, arguments);
    }

    Chosen.prototype.setup = function() {
      this.form_field_jq = $(this.form_field);
      this.current_value = this.form_field_jq.val();
      return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
    };

    Chosen.prototype.finish_setup = function() {
      return this.form_field_jq.addClass("chzn-done");
    };

    Chosen.prototype.set_up_html = function() {
      var container_div, dd_top, dd_width, sf_width;
      this.container_id = this.form_field.id.length ? this.form_field.id.replace(/[^\w]/g, '_') : this.generate_field_id();
      this.container_id += "_chzn";
      this.f_width = this.form_field_jq.outerWidth();
      container_div = $("<div />", {
        id: this.container_id,
        "class": "chzn-container" + (this.is_rtl ? ' chzn-rtl' : ''),
        style: 'width: ' + this.f_width + 'px;'
      });
      if (this.is_multiple) {
        container_div.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop" style="left:-9000px;"><ul class="chzn-results"></ul></div>');
      } else {
        container_div.html('<a href="javascript:void(0)" class="chzn-single chzn-default"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop" style="left:-9000px;"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>');
      }
      this.form_field_jq.hide().after(container_div);
      this.container = $('#' + this.container_id);
      this.container.addClass("chzn-container-" + (this.is_multiple ? "multi" : "single"));
      this.dropdown = this.container.find('div.chzn-drop').first();
      dd_top = this.container.height();
      dd_width = this.f_width - get_side_border_padding(this.dropdown);
      this.dropdown.css({
        "width": dd_width + "px",
        "top": dd_top + "px"
      });
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chzn-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chzn-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chzn-search').first();
        this.selected_item = this.container.find('.chzn-single').first();
        sf_width = dd_width - get_side_border_padding(this.search_container) - get_side_border_padding(this.search_field);
        this.search_field.css({
          "width": sf_width + "px"
        });
      }
      this.results_build();
      this.set_tab_index();
      return this.form_field_jq.trigger("liszt:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function() {
      var _this = this;
      this.container.mousedown(function(evt) {
        return _this.container_mousedown(evt);
      });
      this.container.mouseup(function(evt) {
        return _this.container_mouseup(evt);
      });
      this.container.mouseenter(function(evt) {
        return _this.mouse_enter(evt);
      });
      this.container.mouseleave(function(evt) {
        return _this.mouse_leave(evt);
      });
      this.search_results.mouseup(function(evt) {
        return _this.search_results_mouseup(evt);
      });
      this.search_results.mouseover(function(evt) {
        return _this.search_results_mouseover(evt);
      });
      this.search_results.mouseout(function(evt) {
        return _this.search_results_mouseout(evt);
      });
      this.form_field_jq.bind("liszt:updated", function(evt) {
        return _this.results_update_field(evt);
      });
      this.form_field_jq.bind("liszt:activate", function(evt) {
        return _this.activate_field(evt);
      });
      this.form_field_jq.bind("liszt:open", function(evt) {
        return _this.container_mousedown(evt);
      });
      this.search_field.blur(function(evt) {
        return _this.input_blur(evt);
      });
      this.search_field.keyup(function(evt) {
        return _this.keyup_checker(evt);
      });
      this.search_field.keydown(function(evt) {
        return _this.keydown_checker(evt);
      });
      if (this.is_multiple) {
        this.search_choices.click(function(evt) {
          return _this.choices_click(evt);
        });
        return this.search_field.focus(function(evt) {
          return _this.input_focus(evt);
        });
      } else {
        return this.container.click(function(evt) {
          return evt.preventDefault();
        });
      }
    };

    Chosen.prototype.search_field_disabled = function() {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass('chzn-disabled');
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass('chzn-disabled');
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus", this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function(evt) {
      var target_closelink;
      if (!this.is_disabled) {
        target_closelink = evt != null ? ($(evt.target)).hasClass("search-choice-close") : false;
        if (evt && evt.type === "mousedown" && !this.results_showing) {
          evt.stopPropagation();
        }
        if (!this.pending_destroy_click && !target_closelink) {
          if (!this.active_field) {
            if (this.is_multiple) this.search_field.val("");
            $(document).click(this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chzn-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        } else {
          return this.pending_destroy_click = false;
        }
      }
    };

    Chosen.prototype.container_mouseup = function(evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.blur_test = function(evt) {
      if (!this.active_field && this.container.hasClass("chzn-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function() {
      $(document).unbind("click", this.click_test_action);
      if (!this.is_multiple) {
        this.selected_item.attr("tabindex", this.search_field.attr("tabindex"));
        this.search_field.attr("tabindex", -1);
      }
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chzn-container-active");
      this.winnow_results_clear();
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function() {
      if (!this.is_multiple && !this.active_field) {
        this.search_field.attr("tabindex", this.selected_item.attr("tabindex"));
        this.selected_item.attr("tabindex", -1);
      }
      this.container.addClass("chzn-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function(evt) {
      if ($(evt.target).parents('#' + this.container_id).length) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function() {
      var content, data, _i, _len, _ref;
      this.parsing = true;
      this.results_data = root.SelectParser.select_to_array(this.form_field);
      if (this.is_multiple && this.choices > 0) {
        this.search_choices.find("li.search-choice").remove();
        this.choices = 0;
      } else if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.container.addClass("chzn-container-single-nosearch");
        } else {
          this.container.removeClass("chzn-container-single-nosearch");
        }
      }
      content = '';
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        data = _ref[_i];
        if (data.group) {
          content += this.result_add_group(data);
        } else if (!data.empty) {
          content += this.result_add_option(data);
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.selected_item.removeClass("chzn-default").find("span").text(data.text);
            if (this.allow_single_deselect) this.single_deselect_control_build();
          }
        }
      }
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      this.search_results.html(content);
      return this.parsing = false;
    };

    Chosen.prototype.result_add_group = function(group) {
      if (!group.disabled) {
        group.dom_id = this.container_id + "_g_" + group.array_index;
        return '<li id="' + group.dom_id + '" class="group-result">' + $("<div />").text(group.label).html() + '</li>';
      } else {
        return "";
      }
    };

    Chosen.prototype.result_do_highlight = function(el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function() {
      if (this.result_highlight) this.result_highlight.removeClass("highlighted");
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function() {
      var dd_top;
      if (!this.is_multiple) {
        this.selected_item.addClass("chzn-single-with-drop");
        if (this.result_single_selected) {
          this.result_do_highlight(this.result_single_selected);
        }
      } else if (this.max_selected_options <= this.choices) {
        this.form_field_jq.trigger("liszt:maxselected", {
          chosen: this
        });
        return false;
      }
      dd_top = this.is_multiple ? this.container.height() : this.container.height() - 1;
      this.form_field_jq.trigger("liszt:showing_dropdown", {
        chosen: this
      });
      this.dropdown.css({
        "top": dd_top + "px",
        "left": 0
      });
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      return this.winnow_results();
    };

    Chosen.prototype.results_hide = function() {
      if (!this.is_multiple) {
        this.selected_item.removeClass("chzn-single-with-drop");
      }
      this.result_clear_highlight();
      this.form_field_jq.trigger("liszt:hiding_dropdown", {
        chosen: this
      });
      this.dropdown.css({
        "left": "-9000px"
      });
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function(el) {
      var ti;
      if (this.form_field_jq.attr("tabindex")) {
        ti = this.form_field_jq.attr("tabindex");
        this.form_field_jq.attr("tabindex", -1);
        if (this.is_multiple) {
          return this.search_field.attr("tabindex", ti);
        } else {
          this.selected_item.attr("tabindex", ti);
          return this.search_field.attr("tabindex", -1);
        }
      }
    };

    Chosen.prototype.show_search_field_default = function() {
      if (this.is_multiple && this.choices < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        return this.result_select(evt);
      }
    };

    Chosen.prototype.search_results_mouseover = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) return this.result_do_highlight(target);
    };

    Chosen.prototype.search_results_mouseout = function(evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choices_click = function(evt) {
      evt.preventDefault();
      if (this.active_field && !($(evt.target).hasClass("search-choice" || $(evt.target).parents('.search-choice').first)) && !this.results_showing) {
        return this.results_show();
      }
    };

    Chosen.prototype.choice_build = function(item) {
      var choice_id, html, link,
        _this = this;
      if (this.is_multiple && this.max_selected_options <= this.choices) {
        this.form_field_jq.trigger("liszt:maxselected", {
          chosen: this
        });
        return false;
      }
      choice_id = this.container_id + "_c_" + item.array_index;
      this.choices += 1;
      if (item.disabled) {
        html = '<li class="search-choice search-choice-disabled" id="' + choice_id + '"><span>' + item.html + '</span></li>';
      } else {
        html = '<li class="search-choice" id="' + choice_id + '"><span>' + item.html + '</span><a href="javascript:void(0)" class="search-choice-close" rel="' + item.array_index + '"></a></li>';
      }
      this.search_container.before(html);
      link = $('#' + choice_id).find("a").first();
      return link.click(function(evt) {
        return _this.choice_destroy_link_click(evt);
      });
    };

    Chosen.prototype.choice_destroy_link_click = function(evt) {
      evt.preventDefault();
      if (!this.is_disabled) {
        this.pending_destroy_click = true;
        return this.choice_destroy($(evt.target));
      } else {
        return evt.stopPropagation;
      }
    };

    Chosen.prototype.choice_destroy = function(link) {
      if (this.result_deselect(link.attr("rel"))) {
        this.choices -= 1;
        this.show_search_field_default();
        if (this.is_multiple && this.choices > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        return link.parents('li').first().remove();
      }
    };

    Chosen.prototype.results_reset = function() {
      this.form_field.options[0].selected = true;
      this.selected_item.find("span").text(this.default_text);
      if (!this.is_multiple) this.selected_item.addClass("chzn-default");
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) return this.results_hide();
    };

    Chosen.prototype.results_reset_cleanup = function() {
      this.current_value = this.form_field_jq.val();
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function(evt) {
      var high, high_id, item, position;
      if (this.result_highlight) {
        high = this.result_highlight;
        high_id = high.attr("id");
        this.result_clear_highlight();
        if (this.is_multiple) {
          this.result_deactivate(high);
        } else {
          this.search_results.find(".result-selected").removeClass("result-selected");
          this.result_single_selected = high;
          this.selected_item.removeClass("chzn-default");
        }
        high.addClass("result-selected");
        position = high_id.substr(high_id.lastIndexOf("_") + 1);
        item = this.results_data[position];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.selected_item.find("span").first().text(item.text);
          if (this.allow_single_deselect) this.single_deselect_control_build();
        }
        if (!(evt.metaKey && this.is_multiple)) this.results_hide();
        this.search_field.val("");
        if (this.is_multiple || this.form_field_jq.val() !== this.current_value) {
          this.form_field_jq.trigger("change", {
            'selected': this.form_field.options[item.options_index].value
          });
        }
        this.current_value = this.form_field_jq.val();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.result_activate = function(el) {
      return el.addClass("active-result");
    };

    Chosen.prototype.result_deactivate = function(el) {
      return el.removeClass("active-result");
    };

    Chosen.prototype.result_deselect = function(pos) {
      var result, result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        result = $("#" + this.container_id + "_o_" + pos);
        result.removeClass("result-selected").addClass("active-result").show();
        this.result_clear_highlight();
        this.winnow_results();
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function() {
      if (this.allow_single_deselect && this.selected_item.find("abbr").length < 1) {
        return this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
    };

    Chosen.prototype.winnow_results = function() {
      var found, option, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len2, _ref;
      this.no_results_clear();
      results = 0;
      searchText = this.search_field.val() === this.default_text ? "" : $('<div/>').text($.trim(this.search_field.val())).html();
      regexAnchor = this.search_contains ? "" : "^";
      regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
      zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (!option.disabled && !option.empty) {
          if (option.group) {
            $('#' + option.dom_id).css('display', 'none');
          } else if (!(this.is_multiple && option.selected)) {
            found = false;
            result_id = option.dom_id;
            result = $("#" + result_id);
            if (regex.test(option.html)) {
              found = true;
              results += 1;
            } else if (option.html.indexOf(" ") >= 0 || option.html.indexOf("[") === 0) {
              parts = option.html.replace(/\[|\]/g, "").split(" ");
              if (parts.length) {
                for (_j = 0, _len2 = parts.length; _j < _len2; _j++) {
                  part = parts[_j];
                  if (regex.test(part)) {
                    found = true;
                    results += 1;
                  }
                }
              }
            }
            if (found) {
              if (searchText.length) {
                startpos = option.html.search(zregex);
                text = option.html.substr(0, startpos + searchText.length) + '</em>' + option.html.substr(startpos + searchText.length);
                text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              } else {
                text = option.html;
              }
              result.html(text);
              this.result_activate(result);
              if (option.group_array_index != null) {
                $("#" + this.results_data[option.group_array_index].dom_id).css('display', 'list-item');
              }
            } else {
              if (this.result_highlight && result_id === this.result_highlight.attr('id')) {
                this.result_clear_highlight();
              }
              this.result_deactivate(result);
            }
          }
        }
      }
      if (results < 1 && searchText.length) {
        return this.no_results(searchText);
      } else {
        return this.winnow_results_set_highlight();
      }
    };

    Chosen.prototype.winnow_results_clear = function() {
      var li, lis, _i, _len, _results;
      this.search_field.val("");
      lis = this.search_results.find("li");
      _results = [];
      for (_i = 0, _len = lis.length; _i < _len; _i++) {
        li = lis[_i];
        li = $(li);
        if (li.hasClass("group-result")) {
          _results.push(li.css('display', 'auto'));
        } else if (!this.is_multiple || !li.hasClass("result-selected")) {
          _results.push(this.result_activate(li));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Chosen.prototype.winnow_results_set_highlight = function() {
      var do_high, selected_results;
      if (!this.result_highlight) {
        selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
        do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
        if (do_high != null) return this.result_do_highlight(do_high);
      }
    };

    Chosen.prototype.no_results = function(terms) {
      var no_results_html;
      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      return this.search_results.append(no_results_html);
    };

    Chosen.prototype.no_results_clear = function() {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function() {
      var first_active, next_sib;
      if (!this.result_highlight) {
        first_active = this.search_results.find("li.active-result").first();
        if (first_active) this.result_do_highlight($(first_active));
      } else if (this.results_showing) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) this.result_do_highlight(next_sib);
      }
      if (!this.results_showing) return this.results_show();
    };

    Chosen.prototype.keyup_arrow = function() {
      var prev_sibs;
      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices > 0) this.results_hide();
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function() {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function() {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) this.clear_backstroke();
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) this.result_select(evt);
          this.mouse_on_container = false;
          break;
        case 13:
          evt.preventDefault();
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          this.keydown_arrow();
          break;
      }
    };

    Chosen.prototype.search_field_scale = function() {
      var dd_top, div, h, style, style_block, styles, w, _i, _len;
      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $('<div />', {
          'style': style_block
        });
        div.text(this.search_field.val());
        $('body').append(div);
        w = div.width() + 25;
        div.remove();
        if (w > this.f_width - 10) w = this.f_width - 10;
        this.search_field.css({
          'width': w + 'px'
        });
        dd_top = this.container.height();
        return this.dropdown.css({
          "top": dd_top + "px"
        });
      }
    };

    Chosen.prototype.generate_random_id = function() {
      var string;
      string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
      while ($("#" + string).length > 0) {
        string += this.generate_random_char();
      }
      return string;
    };

    return Chosen;

  })(root.AbstractChosen);

  get_side_border_padding = function(elmt) {
    var side_border_padding;
    return side_border_padding = elmt.outerWidth() - elmt.width();
  };

  root.get_side_border_padding = get_side_border_padding;

  var updateLayout = $.debounce(function(e) {
      var chznWrapper = $('.chzn-container').parent();
      $('.chzn-container').innerWidth(chznWrapper.innerWidth());
      $('.chzn-search input').innerWidth(chznWrapper.innerWidth()-12);
      $('.chzn-drop').innerWidth(chznWrapper.innerWidth()-2);

  }, 500);

  window.addEventListener("resize", updateLayout, false);

}).call(globalChosen);

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("chosen", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*! 
 * jquery.event.drag - v 2.2
 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
 * Open Source MIT License - http://threedubmedia.com/code/license
 */
// Created: 2008-06-04 
// Updated: 2012-05-21
// REQUIRES: jquery 1.7.x

;(function( $ ){

// add the jquery instance method
$.fn.drag = function( str, arg, opts ){
	// figure out the event type
	var type = typeof str == "string" ? str : "",
	// figure out the event handler...
	fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
	// fix the event type
	if ( type.indexOf("drag") !== 0 ) 
		type = "drag"+ type;
	// were options passed
	opts = ( str == fn ? arg : opts ) || {};
	// trigger or bind event handler
	return fn ? this.bind( type, opts, fn ) : this.trigger( type );
};

// local refs (increase compression)
var $event = $.event, 
$special = $event.special,
// configure the drag special event 
drag = $special.drag = {
	
	// these are the default settings
	defaults: {
		which: 1, // mouse button pressed to start drag sequence
		distance: 0, // distance dragged before dragstart
		not: ':input', // selector to suppress dragging on target elements
		handle: null, // selector to match handle target elements
		relative: false, // true to use "position", false to use "offset"
		drop: true, // false to suppress drop events, true or selector to allow
		click: false // false to suppress click events after dragend (no proxy)
	},
	
	// the key name for stored drag data
	datakey: "dragdata",
	
	// prevent bubbling for better performance
	noBubble: true,
	
	// count bound related events
	add: function( obj ){ 
		// read the interaction data
		var data = $.data( this, drag.datakey ),
		// read any passed options 
		opts = obj.data || {};
		// count another realted event
		data.related += 1;
		// extend data options bound with this event
		// don't iterate "opts" in case it is a node 
		$.each( drag.defaults, function( key, def ){
			if ( opts[ key ] !== undefined )
				data[ key ] = opts[ key ];
		});
	},
	
	// forget unbound related events
	remove: function(){
		$.data( this, drag.datakey ).related -= 1;
	},
	
	// configure interaction, capture settings
	setup: function(){
		// check for related events
		if ( $.data( this, drag.datakey ) ) 
			return;
		// initialize the drag data with copied defaults
		var data = $.extend({ related:0 }, drag.defaults );
		// store the interaction data
		$.data( this, drag.datakey, data );
		// bind the mousedown event, which starts drag interactions
		$event.add( this, "touchstart mousedown", drag.init, data );
		// prevent image dragging in IE...
		if ( this.attachEvent ) 
			this.attachEvent("ondragstart", drag.dontstart ); 
	},
	
	// destroy configured interaction
	teardown: function(){
		var data = $.data( this, drag.datakey ) || {};
		// check for related events
		if ( data.related ) 
			return;
		// remove the stored data
		$.removeData( this, drag.datakey );
		// remove the mousedown event
		$event.remove( this, "touchstart mousedown", drag.init );
		// enable text selection
		drag.textselect( true ); 
		// un-prevent image dragging in IE...
		if ( this.detachEvent ) 
			this.detachEvent("ondragstart", drag.dontstart ); 
	},
		
	// initialize the interaction
	init: function( event ){ 
		// sorry, only one touch at a time
		if ( drag.touched ) 
			return;
		// the drag/drop interaction data
		var dd = event.data, results;
		// check the which directive
		if ( event.which != 0 && dd.which > 0 && event.which != dd.which ) 
			return; 
		// check for suppressed selector
		if ( $( event.target ).is( dd.not ) ) 
			return;
		// check for handle selector
		if ( dd.handle && !$( event.target ).closest( dd.handle, event.currentTarget ).length ) 
			return;

		drag.touched = event.type == 'touchstart' ? this : null;
		dd.propagates = 1;
		dd.mousedown = this;
		dd.interactions = [ drag.interaction( this, dd ) ];
		dd.target = event.target;
		dd.pageX = event.pageX;
		dd.pageY = event.pageY;
		dd.dragging = null;
		// handle draginit event... 
		results = drag.hijack( event, "draginit", dd );
		// early cancel
		if ( !dd.propagates )
			return;
		// flatten the result set
		results = drag.flatten( results );
		// insert new interaction elements
		if ( results && results.length ){
			dd.interactions = [];
			$.each( results, function(){
				dd.interactions.push( drag.interaction( this, dd ) );
			});
		}
		// remember how many interactions are propagating
		dd.propagates = dd.interactions.length;
		// locate and init the drop targets
		if ( dd.drop !== false && $special.drop ) 
			$special.drop.handler( event, dd );
		// disable text selection
		drag.textselect( false ); 
		// bind additional events...
		if ( drag.touched )
			$event.add( drag.touched, "touchmove touchend", drag.handler, dd );
		else 
			$event.add( document, "mousemove mouseup", drag.handler, dd );
		// helps prevent text selection or scrolling
		if ( !drag.touched || dd.live )
			return false;
	},	
	
	// returns an interaction object
	interaction: function( elem, dd ){
		var offset = $( elem )[ dd.relative ? "position" : "offset" ]() || { top:0, left:0 };
		return {
			drag: elem, 
			callback: new drag.callback(), 
			droppable: [],
			offset: offset
		};
	},
	
	// handle drag-releatd DOM events
	handler: function( event ){ 
		// read the data before hijacking anything
		var dd = event.data;	
		// handle various events
		switch ( event.type ){
			// mousemove, check distance, start dragging
			case !dd.dragging && 'touchmove': 
				event.preventDefault();
			case !dd.dragging && 'mousemove':
				//  drag tolerance, x� + y� = distance�
				if ( Math.pow(  event.pageX-dd.pageX, 2 ) + Math.pow(  event.pageY-dd.pageY, 2 ) < Math.pow( dd.distance, 2 ) ) 
					break; // distance tolerance not reached
				event.target = dd.target; // force target from "mousedown" event (fix distance issue)
				drag.hijack( event, "dragstart", dd ); // trigger "dragstart"
				if ( dd.propagates ) // "dragstart" not rejected
					dd.dragging = true; // activate interaction
			// mousemove, dragging
			case 'touchmove':
				event.preventDefault();
			case 'mousemove':
				if ( dd.dragging ){
					// trigger "drag"		
					drag.hijack( event, "drag", dd );
					if ( dd.propagates ){
						// manage drop events
						if ( dd.drop !== false && $special.drop )
							$special.drop.handler( event, dd ); // "dropstart", "dropend"							
						break; // "drag" not rejected, stop		
					}
					event.type = "mouseup"; // helps "drop" handler behave
				}
			// mouseup, stop dragging
			case 'touchend': 
			case 'mouseup': 
			default:
				if ( drag.touched )
					$event.remove( drag.touched, "touchmove touchend", drag.handler ); // remove touch events
				else 
					$event.remove( document, "mousemove mouseup", drag.handler ); // remove page events	
				if ( dd.dragging ){
					if ( dd.drop !== false && $special.drop )
						$special.drop.handler( event, dd ); // "drop"
					drag.hijack( event, "dragend", dd ); // trigger "dragend"	
				}
				drag.textselect( true ); // enable text selection
				// if suppressing click events...
				if ( dd.click === false && dd.dragging )
					$.data( dd.mousedown, "suppress.click", new Date().getTime() + 5 );
				dd.dragging = drag.touched = false; // deactivate element	
				break;
		}
	},
		
	// re-use event object for custom events
	hijack: function( event, type, dd, x, elem ){
		// not configured
		if ( !dd ) 
			return;
		// remember the original event and type
		var orig = { event:event.originalEvent, type:event.type },
		// is the event drag related or drog related?
		mode = type.indexOf("drop") ? "drag" : "drop",
		// iteration vars
		result, i = x || 0, ia, $elems, callback,
		len = !isNaN( x ) ? x : dd.interactions.length;
		// modify the event type
		event.type = type;
		// remove the original event
		event.originalEvent = null;
		// initialize the results
		dd.results = [];
		// handle each interacted element
		do if ( ia = dd.interactions[ i ] ){
			// validate the interaction
			if ( type !== "dragend" && ia.cancelled )
				continue;
			// set the dragdrop properties on the event object
			callback = drag.properties( event, dd, ia );
			// prepare for more results
			ia.results = [];
			// handle each element
			$( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){
				// identify drag or drop targets individually
				callback.target = subject;
				// force propagtion of the custom event
				event.isPropagationStopped = function(){ return false; };
				// handle the event	
				result = subject ? $event.dispatch.call( subject, event, callback ) : null;
				// stop the drag interaction for this element
				if ( result === false ){
					if ( mode == "drag" ){
						ia.cancelled = true;
						dd.propagates -= 1;
					}
					if ( type == "drop" ){
						ia[ mode ][p] = null;
					}
				}
				// assign any dropinit elements
				else if ( type == "dropinit" )
					ia.droppable.push( drag.element( result ) || subject );
				// accept a returned proxy element 
				if ( type == "dragstart" )
					ia.proxy = $( drag.element( result ) || ia.drag )[0];
				// remember this result	
				ia.results.push( result );
				// forget the event result, for recycling
				delete event.result;
				// break on cancelled handler
				if ( type !== "dropinit" )
					return result;
			});	
			// flatten the results	
			dd.results[ i ] = drag.flatten( ia.results );	
			// accept a set of valid drop targets
			if ( type == "dropinit" )
				ia.droppable = drag.flatten( ia.droppable );
			// locate drop targets
			if ( type == "dragstart" && !ia.cancelled )
				callback.update(); 
		}
		while ( ++i < len )
		// restore the original event & type
		event.type = orig.type;
		event.originalEvent = orig.event;
		// return all handler results
		return drag.flatten( dd.results );
	},
		
	// extend the callback object with drag/drop properties...
	properties: function( event, dd, ia ){		
		var obj = ia.callback;
		// elements
		obj.drag = ia.drag;
		obj.proxy = ia.proxy || ia.drag;
		// starting mouse position
		obj.startX = dd.pageX;
		obj.startY = dd.pageY;
		// current distance dragged
		obj.deltaX = event.pageX - dd.pageX;
		obj.deltaY = event.pageY - dd.pageY;
		// original element position
		obj.originalX = ia.offset.left;
		obj.originalY = ia.offset.top;
		// adjusted element position
		obj.offsetX = obj.originalX + obj.deltaX; 
		obj.offsetY = obj.originalY + obj.deltaY;
		// assign the drop targets information
		obj.drop = drag.flatten( ( ia.drop || [] ).slice() );
		obj.available = drag.flatten( ( ia.droppable || [] ).slice() );
		return obj;	
	},
	
	// determine is the argument is an element or jquery instance
	element: function( arg ){
		if ( arg && ( arg.jquery || arg.nodeType == 1 ) )
			return arg;
	},
	
	// flatten nested jquery objects and arrays into a single dimension array
	flatten: function( arr ){
		return $.map( arr, function( member ){
			return member && member.jquery ? $.makeArray( member ) : 
				member && member.length ? drag.flatten( member ) : member;
		});
	},
	
	// toggles text selection attributes ON (true) or OFF (false)
	textselect: function( bool ){ 
		$( document )[ bool ? "unbind" : "bind" ]("selectstart", drag.dontstart )
			.css("MozUserSelect", bool ? "" : "none" );
		// .attr("unselectable", bool ? "off" : "on" )
		document.unselectable = bool ? "off" : "on"; 
	},
	
	// suppress "selectstart" and "ondragstart" events
	dontstart: function(){ 
		return false; 
	},
	
	// a callback instance contructor
	callback: function(){}
	
};

// callback methods
drag.callback.prototype = {
	update: function(){
		if ( $special.drop && this.available.length )
			$.each( this.available, function( i ){
				$special.drop.locate( this, i );
			});
	}
};

// patch $.event.$dispatch to allow suppressing clicks
var $dispatch = $event.dispatch;
$event.dispatch = function( event ){
	if ( $.data( this, "suppress."+ event.type ) - new Date().getTime() > 0 ){
		$.removeData( this, "suppress."+ event.type );
		return;
	}
	return $dispatch.apply( this, arguments );
};

// event fix hooks for touch events...
var touchHooks = 
$event.fixHooks.touchstart = 
$event.fixHooks.touchmove = 
$event.fixHooks.touchend =
$event.fixHooks.touchcancel = {
	props: "clientX clientY pageX pageY screenX screenY".split( " " ),
	filter: function( event, orig ) {
		if ( orig ){
			var touched = ( orig.touches && orig.touches[0] )
				|| ( orig.changedTouches && orig.changedTouches[0] )
				|| null; 
			// iOS webkit: touchstart, touchmove, touchend
			if ( touched ) 
				$.each( touchHooks.props, function( i, prop ){
					event[ prop ] = touched[ prop ];
				});
		}
		return event;
	}
};

// share the same special event configuration with related events...
$special.draginit = $special.dragstart = $special.dragend = drag;

})( jQuery );
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("event/drag", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/*!
 * jQuery Mousewheel 3.1.12
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("mousewheel", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/*!
 * jQuery resize event - v1.1 - 3/14/2010
 * http://benalman.com/projects/jquery-resize-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery resize event
//
// *Version: 1.1, Last updated: 3/14/2010*
// 
// Project Home - http://benalman.com/projects/jquery-resize-plugin/
// GitHub       - http://github.com/cowboy/jquery-resize/
// Source       - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.js
// (Minified)   - http://github.com/cowboy/jquery-resize/raw/master/jquery.ba-resize.min.js (1.0kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrates a few
// ways in which this plugin can be used.
// 
// resize event - http://benalman.com/code/projects/jquery-resize/examples/resize/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-resize/unit/
// 
// About: Release History
// 
// 1.1 - (3/14/2010) Fixed a minor bug that was causing the event to trigger
//       immediately after bind in some circumstances. Also changed $.fn.data
//       to $.data to improve performance.
// 1.0 - (2/10/2010) Initial release

  
  // A jQuery object containing all non-window elements to which the resize
  // event is bound.
  var elems = $([]),
    
    // Extend $.resize if it already exists, otherwise create it.
    jq_resize = $.resize = $.extend( $.resize, {} ),
    
    timeout_id,
    
    // Reused strings.
    str_setTimeout = 'setTimeout',
    str_resize = 'resize',
    str_data = str_resize + '-special-event',
    str_delay = 'delay',
    str_throttle = 'throttleWindow';
  
  // Property: jQuery.resize.delay
  // 
  // The numeric interval (in milliseconds) at which the resize event polling
  // loop executes. Defaults to 250.
  
  jq_resize[ str_delay ] = 250;
  
  // Property: jQuery.resize.throttleWindow
  // 
  // Throttle the native window object resize event to fire no more than once
  // every <jQuery.resize.delay> milliseconds. Defaults to true.
  // 
  // Because the window object has its own resize event, it doesn't need to be
  // provided by this plugin, and its execution can be left entirely up to the
  // browser. However, since certain browsers fire the resize event continuously
  // while others do not, enabling this will throttle the window resize event,
  // making event behavior consistent across all elements in all browsers.
  // 
  // While setting this property to false will disable window object resize
  // event throttling, please note that this property must be changed before any
  // window object resize event callbacks are bound.
  
  jq_resize[ str_throttle ] = true;
  
  // Event: resize event
  // 
  // Fired when an element's width or height changes. Because browsers only
  // provide this event for the window element, for other elements a polling
  // loop is initialized, running every <jQuery.resize.delay> milliseconds
  // to see if elements' dimensions have changed. You may bind with either
  // .resize( fn ) or .bind( "resize", fn ), and unbind with .unbind( "resize" ).
  // 
  // Usage:
  // 
  // > jQuery('selector').bind( 'resize', function(e) {
  // >   // element's width or height has changed!
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * The polling loop is not created until at least one callback is actually
  //   bound to the 'resize' event, and this single polling loop is shared
  //   across all elements.
  // 
  // Double firing issue in jQuery 1.3.2:
  // 
  // While this plugin works in jQuery 1.3.2, if an element's event callbacks
  // are manually triggered via .trigger( 'resize' ) or .resize() those
  // callbacks may double-fire, due to limitations in the jQuery 1.3.2 special
  // events system. This is not an issue when using jQuery 1.4+.
  // 
  // > // While this works in jQuery 1.4+
  // > $(elem).css({ width: new_w, height: new_h }).resize();
  // > 
  // > // In jQuery 1.3.2, you need to do this:
  // > var elem = $(elem);
  // > elem.css({ width: new_w, height: new_h });
  // > elem.data( 'resize-special-event', { width: elem.width(), height: elem.height() } );
  // > elem.resize();
      
  $.event.special[ str_resize ] = {
    
    // Called only when the first 'resize' event callback is bound per element.
    setup: function() {
      // Since window has its own native 'resize' event, return false so that
      // jQuery will bind the event using DOM methods. Since only 'window'
      // objects have a .setTimeout method, this should be a sufficient test.
      // Unless, of course, we're throttling the 'resize' event for window.
      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
      
      var elem = $(this);
      
      // Add this element to the list of internal elements to monitor.
      elems = elems.add( elem );
      
      // Initialize data store on the element.
      $.data( this, str_data, { w: elem.width(), h: elem.height() } );
      
      // If this is the first element added, start the polling loop.
      if ( elems.length === 1 ) {
        loopy();
      }
    },
    
    // Called only when the last 'resize' event callback is unbound per element.
    teardown: function() {
      // Since window has its own native 'resize' event, return false so that
      // jQuery will unbind the event using DOM methods. Since only 'window'
      // objects have a .setTimeout method, this should be a sufficient test.
      // Unless, of course, we're throttling the 'resize' event for window.
      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
      
      var elem = $(this);
      
      // Remove this element from the list of internal elements to monitor.
      elems = elems.not( elem );
      
      // Remove any data stored on the element.
      elem.removeData( str_data );
      
      // If this is the last element removed, stop the polling loop.
      if ( !elems.length ) {
        clearTimeout( timeout_id );
      }
    },
    
    // Called every time a 'resize' event callback is bound per element (new in
    // jQuery 1.4).
    add: function( handleObj ) {
      // Since window has its own native 'resize' event, return false so that
      // jQuery doesn't modify the event object. Unless, of course, we're
      // throttling the 'resize' event for window.
      if ( !jq_resize[ str_throttle ] && this[ str_setTimeout ] ) { return false; }
      
      var old_handler;
      
      // The new_handler function is executed every time the event is triggered.
      // This is used to update the internal element data store with the width
      // and height when the event is triggered manually, to avoid double-firing
      // of the event callback. See the "Double firing issue in jQuery 1.3.2"
      // comments above for more information.
      
      function new_handler( e, w, h ) {
        var elem = $(this),
          data = $.data( this, str_data );

        // fix related to https://github.com/cowboy/jquery-resize/issues/1
        if (data == null) {
          data = { w: null, h: null };
        }
        
        // If called from the polling loop, w and h will be passed in as
        // arguments. If called manually, via .trigger( 'resize' ) or .resize(),
        // those values will need to be computed.
        data.w = w !== undefined ? w : elem.width();
        data.h = h !== undefined ? h : elem.height();
        
        old_handler.apply( this, arguments );
      };
      
      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
    
  };
  
  function loopy() {
    
    // Start the polling loop, asynchronously.
    timeout_id = window[ str_setTimeout ](function(){
      
      // Iterate over all elements to which the 'resize' event is bound.
      elems.each(function(){
        var elem = $(this),
          width = elem.width(),
          height = elem.height(),
          data = $.data( this, str_data );
        
        // If element size has changed since the last time, update the element
        // data store and trigger the 'resize' event.
        if ( width !== data.w || height !== data.h ) {
          elem.trigger( str_resize, [ data.w = width, data.h = height ] );
        }
        
      });
      
      // Loop.
      loopy();
      
    }, jq_resize[ str_delay ] );
    
  };
  


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("resize", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

// Expanding Textareas
// https://github.com/bgrins/ExpandingTextareas

    $.expandingTextarea = $.extend({
        autoInitialize: true,
        initialSelector: "textarea.expanding",
        opts: {
            resize: function() { }
        }
    }, $.expandingTextarea || {});
    
    var cloneCSSProperties = [
        'lineHeight', 'textDecoration', 'letterSpacing',
        'fontSize', 'fontFamily', 'fontStyle', 
        'fontWeight', 'textTransform', 'textAlign', 
        'direction', 'wordSpacing', 'fontSizeAdjust', 
        'wordWrap', 'word-break',
        'borderLeftWidth', 'borderRightWidth',
        'borderTopWidth','borderBottomWidth',
        'paddingLeft', 'paddingRight',
        'paddingTop','paddingBottom',
        'marginLeft', 'marginRight',
        'marginTop','marginBottom',
        'boxSizing', 'webkitBoxSizing', 'mozBoxSizing', 'msBoxSizing'
    ];
    
    var textareaCSS = {
        position: "absolute",
        height: "100%",
        resize: "none"
    };
    
    var preCSS = {
        visibility: "hidden",
        border: "0 solid",
        whiteSpace: "pre-wrap" 
    };
    
    var containerCSS = {
        position: "relative"
    };
    
    function resize() {

        var clone = $(this).data("textareaClone");
        clone.find("div").text(this.value.replace(/\r\n/g, "\n") + ' ');
        $(this).trigger("resize.expanding");
    }
    
    $.fn.expandingTextarea = function(o) {
        
        var opts = $.extend({ }, $.expandingTextarea.opts, o);
        
        if (o === "resize") {
            return this.trigger("input.expanding");
        }
        
        if (o === "destroy") {
            this.filter(".expanding-init").each(function() {
                // TODO: Restore container position value
                var textarea = $(this).removeClass('expanding-init');
                textarea
                    .attr('style', textarea.data('expanding-styles') || '')
                    .removeData('expanding-styles');
            });
            
            return this;
        }
        
        this.filter("textarea").not(".expanding-init").addClass("expanding-init").each(function() {

            var textarea  = $(this),
                container = textarea.parent(),
                clone     = $($.parseHTML("<pre class='textareaClone'><div></div></pre>"));

            textarea
                .after(clone)
                .data("textareaClone", clone);

            // Container
            container.css(containerCSS);
            
            // Store the original styles in case of destroying.
            textarea.data('expanding-styles', textarea.attr('style'));
            textarea.css(textareaCSS);

            // Clone
            clone.css(preCSS);
            
            $.each(cloneCSSProperties, function(i, p) {
                var val = textarea.css(p);
                
                // Only set if different to prevent overriding percentage css values.
                if (clone.css(p) !== val) {
                    clone.css(p, val);
                }
            });
            
            textarea.bind("input.expanding propertychange.expanding keyup.expanding", resize);
            resize.apply(this);
            
            if (opts.resize) {
                textarea.bind("resize.expanding", opts.resize);
            }
        });
        
        return this;
    };
    
    $(function () {
        if ($.expandingTextarea.autoInitialize) {
            $($.expandingTextarea.initialSelector).expandingTextarea();
        }
    });


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("expanding", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Core 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4pre",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

$(function(){

	if ($("body > [id=fd].ui").length > 0) return;

	// Create container for #fd-ui
	$(document.createElement("div"))
		.attr("id", "fd")
		.addClass("ui")
		.css({
			position: "absolute",
			top: 0,
			left: 0,
			overflow: "visible",
			width: 0,
			height: 0,
			zIndex: 10002
		})
		.appendTo("body");
});

})( jQuery );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/core", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
$.require() 
 .script("ui/widget") 
 .done(function() { 
var exports = function() { 

/*!
 * jQuery UI Mouse 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.4pre",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event, eventOverride) {
				return that._mouseDown(eventOverride || event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("ui/mouse", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Widget 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/widget", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
$.require() 
 .script("autosize.input","scrollTo") 
 .done(function() { 
var exports = function() { 

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

// Templates
$.template("textboxlist/item", '<div class="textboxlist-item[%== (this.locked) ? " is-locked" : "" %]" data-textboxlist-item><span class="textboxlist-itemContent" data-textboxlist-itemContent>[%== html %]</span><div class="textboxlist-itemRemoveButton" data-textboxlist-itemRemoveButton><i class="fa fa-times"></i></a></div>');
$.template("textboxlist/itemContent", '[%= title %]<input type="hidden" name="[%= name %]" value="[%= id %]"/>');

$.Controller("Textboxlist",
	{
		pluginName: "textboxlist",
		hostname: "textboxlist",

		defaultOptions: {

			view: {
				item: 'textboxlist/item',
				itemContent: 'textboxlist/itemContent'
			},

			plugin: {},

			// Options
			name: "items[]",
			unique: true,
			caseSensitive: false,
			max: null,
			ignoreLocked: false,

			// Events
			filterItem: null,

			"{item}"            : "[data-textboxlist-item]",
			"{itemContent}"     : "[data-textboxlist-itemContent]",
			"{itemRemoveButton}": "[data-textboxlist-itemRemoveButton]",
			"{textField}"       : "[data-textboxlist-textField]"
		}
	},
	function(self) { return {

		init: function() {

			var textField = self.textField();

			// Make textfield expandable
			textField.autosizeInput();

			// Keep the original placeholder text value
			textField.data("placeholderText", textField.attr("placeholder"));

			// Data attribute override options
			var name = textField.data("textboxlistName");
			if (name) {
				self.options.name = name;
			}

			// Go through existing item
			// and reconstruct item data.
			self.item().each(function(){

				var item = $(this),
					itemContent = item.find(self.itemContent.selector);

				self.createItem({

					id: item.data("id") || (function(){
						var id = $.uid("item-");
						item.data("id", id);
						return id;
					})(),

					title: item.data("title") || $.trim(itemContent.text()),

					locked: item.hasClass("is-locked"),

					html: itemContent.html()
				});
			});

			// Determine if there's autocomplete
			if (self.options.plugin.autocomplete || self.element.data("query")) {
				self.addPlugin("autocomplete");
			}

			// Prevent form submission
			self.on("keypress", self.textField(), function(event){
				if (event.keyCode==KEYCODE.ENTER) return event.preventDefault();
			});
		},

		setLayout: function() {

			var textField = self.textField(),
				placeholderText = textField.data("placeholderText");

			// Don't show placeholder if there are items.
			if (self.item().length > 0) {
				placeholderText = "";
			}

			textField
				.attr("placeholder", placeholderText)
				.data("autosizeInputInstance")
				.update();
		},

		enable: function() {
			self.element.removeClass("disabled");
			self.textField().enabled(true);
		},

		disable: function() {
			self.element.addClass("disabled");
			self.textField().disabled(true);
		},

		items: {},

		itemsByTitle: {},

		get: function(title) {

			var key = self.getItemKey(title);

			if (self.itemsByTitle.hasOwnProperty(key)) {
				return self.itemsByTitle[key];
			}
		},

		getItemKey: function(title){

			return (self.options.caseSensitive) ? title : title.toLowerCase();
		},

		filterItem: function(item) {

			var options = self.options;

			// Use custom filter if provided
			var filterItem = options.filterItem;

			if ($.isFunction(filterItem)) {
				item = filterItem.call(self, item);
			}

			var items = self.itemsByTitle;

			// If item is a string,
			if ($.isString(item) && item!=="") {

				var title = item,
					key = self.getItemKey(title);

				item =
					(items.hasOwnProperty(key)) ?

						// Get existing item
						self.itemsByTitle[key] :

						{
							id    : $.uid("item-"),
							title : title,
							key   : self.getItemKey(title),
							locked: false
						}
			}

			// This is for the name attribute for the hidden input
			item.name = item.name || self.options.name;

			// If item content is not created, then make one.
			item.html = item.html || self.view.itemContent(true, item);

			return item;
		},

		createItem: function(item) {

			// Create key for item
			item.key = self.getItemKey(item.title);

			// Store to items object
			self.items[item.id] = item;

			// Store to itemsByTitle object
			self.itemsByTitle[item.key] = item;
		},

		deleteItem: function(id) {

			var item = self.items[id];

			// Remove item from the list
			self.item().filterBy("id", id)
				.remove();

			// Remove from items object
			delete self.items[id];

			// Remove from itemsByTitle object
			var key = (self.options.caseSensitive) ? item.title : item.title.toLowerCase();
			delete self.itemsByTitle[key];
		},

		addItem: function(item, force) {

			// Don't add invalid item
			if (!item) return;

			var options = self.options;

			// If we reached the maximum number of items, skip.
			var max = options.max;
			if (!force &&
				max!==null &&
				(options.ignoreLocked ? self.item(":not(.is-locked)") : self.item()).length>=max) return;

			// Filter item
			item = self.filterItem(item);

			// At this point, if item if not an object, skip.
			if (!$.isPlainObject(item)) return;

			var itemEl,
				existingItemEl = self.item().filterBy("id", item.id);

			// If items should be unique,
			// and this item has already been added to the list
			if (options.unique && existingItemEl.length > 0) {

				// then use existing item.
				itemEl = existingItemEl;
			}

			// Else create a new item
			if (!itemEl) {

				itemEl =
					self.view.item(item)
						.addClass(item.className || "")
						.attr("data-id", item.id);
			}

			self.createItem(item);

			// Locked item always gets added to the beginning
			if (item.locked) {

				var lastLockedItem = self.item(".is-locked:last");

				if (lastLockedItem.length > 0) {
					itemEl.insertAfter(lastLockedItem);
				} else {
					itemEl.prependTo(self.element);
				}

			} else {
				// Add item on to the list
				itemEl.insertBefore(self.textField());
			}

			self.trigger("addItem", [item]);
			self.trigger("listChange");

			return item;
		},

		removeItem: function(id) {

			var item = self.items[id];

			self.deleteItem(id);

			self.trigger("removeItem", [item]);
			self.trigger("listChange");
		},

		clearItems: function() {

			self.item().each(function(){
				self.removeItem($(this).data("id"));
			});
		},

		getAddedItems: function() {

			var addedItems = [];

			self.item().each(function(){

				var item = $(this),
					id = item.data("id");

				addedItems.push(self.items[id]);
			});

			return addedItems;
		},

		"{self} addItem": function() {

			self.setLayout();
		},

		"{self} removeItem": function() {

			self.setLayout();
		},

		"{itemRemoveButton} click": function(button) {

			var item = button.parents(self.item.selector);

			self.removeItem(item.data("id"));
		},

		"{textField} keydown": function(textField, event)
		{
			var keyCode = event.keyCode;

			textField.data("realEnterKey", keyCode==KEYCODE.ENTER);
		},

		"{textField} keypress": function(textField, event)
		{
			var keydownIsEnter = textField.data("realEnterKey"),

				// When a person enters the IME context menu,
				// the keyCode returned during keypress will
				// not be the enter keycode.
				keypressIsEnter = event.keyCode==KEYCODE.ENTER;

			textField.data("realEnterKey", keydownIsEnter && keypressIsEnter);

			var keyword = $.trim(self.textField().val());

			switch (event.keyCode) {

				// Add new item
				case KEYCODE.ENTER:

					if (textField.data("realEnterKey")) {

						var event = self.trigger("useItem", [keyword]),
							item = event.item;

						// If event handler did not decorate item,
						// use keyword as item.
						if (item===undefined) {
							item = keyword;
						}

						// If item was converted into a null/false object,
						// this means the custom keyup event wants to "preventDefault".
						if (item===false || item===null) return;

						self.addItem(item);

						// and clear text field.
						textField.val("");
					}
					break;
			}
		},

		"{textField} keyup": function(textField, event)
		{
			var item = $.trim(self.textField().val());

			// Optimization for compiler
			var canRemoveItemUsingBackspace = "canRemoveItemUsingBackspace";

			switch (event.keyCode) {

				// Remove last added item
				case KEYCODE.BACKSPACE:

					// If the text field is empty
					if (item==="") {

						// If this is the first time pressing the backspace key
						if (!self[canRemoveItemUsingBackspace]) {

							// Allow removal of item for subsequent backspace
							self[canRemoveItemUsingBackspace] = true;

						// If this is the subsequent time pressing the backspace key
						} else {

							// Look for the item before it
							var prevItem = textField.prev(self.item.selector);

							// If the item before it exists,
							if (prevItem.length > 0) {

								var id = prevItem.data("id"),
									item = self.items[id];

								// Remove the item if it is not locked.
								!item.locked && self.removeItem(id);
							}
						}
					}
					break;

				default:
					// Reset backspace removal state
					self[canRemoveItemUsingBackspace] = false;
					break;
			}
		},

		"{self} click": function(el, event) {

			var textField = self.textField();

			if (!textField.is(event.target)) {
				textField.focus();
			}
		},

		"{textField} focusin": function() {

			if (self.activated) return;

			self.activated = true;
			self.trigger("textboxlistActivate");
		},

		"{self} mousedown": function() {
			self.focusing = true;
		},

		"{self} mouseup": function() {
			self.focusing = false;
		},

		"{self} focusout": function() {

			if (self.focusing) return;

			self.activated = false;

			self.deactivateTimer =
				setTimeout(function(){
					if (self.activated) return;
					self.trigger("textboxlistDeactivate");
				}, 1);
		}
	}}
);

$(document)
	.on('click.textboxlist.data-api', '[data-textboxlist]', function(event){
		$(this).addController($.Controller.Textboxlist).textField().focus();
	})
	.on('focus.textboxlist.data-api', '[data-textboxlist] [data-textboxlist-textField]', function(event){
		$(this).parents("[data-textboxlist]").addController($.Controller.Textboxlist);
	});
// Textboxlist ends

// Autocomplete starts
$.template("textboxlist/menu", '<div id="fd" class="textboxlist-autocomplete" data-textboxlist-autocomplete><b><b></b></b><div class="textboxlist-autocomplete-inner" data-textboxlist-autocomplete-viewport><div class="textboxlist-autocomplete-loading" data-textboxlist-autocomplete-loading></div><div class="textboxlist-autocomplete-empty" data-textboxlist-autocomplete-empty></div><ul class="textboxlist-menu" data-textboxlist-menu></ul></div></div>');
$.template("textboxlist/menuItem", '<li class="textboxlist-menuItem" data-textboxlist-menuItem>[%== html %]</li>');
$.template("textboxlist/loadingHint", '<i class="textboxlist-autocomplete-loading-indicator"></i>');
$.template("textboxlist/emptyHint", '<span class="textboxlist-autocomplete-empty-text">No items found.</span>');

$.Controller("Textboxlist.Autocomplete",
{
	defaultOptions: {

		view: {
			menu: "textboxlist/menu",
			menuItem: "textboxlist/menuItem",
			loadingHint: "textboxlist/loadingHint",
			emptyHint: "textboxlist/emptyHint"
		},

		cache: true,
		minLength: 1,
		limit: 10,
		highlight: true,
		caseSensitive: false,
		exclusive: false,

		// Accepts url, function or array of objects.
		// If function, it should return a deferred object.
		query: null,

		position: {
			my: 'left top',
			at: 'left bottom',
			collision: 'none'
		},

		filterItem: null,
		showEmptyHint: false,
		showLoadingHint: false,

		id: "fd",
		component: "",
		modifier: "",
		shadow: false,
		sticky: false,
		animation: false,

		"{menu}": "[data-textboxlist-menu]",
		"{menuItem}": "[data-textboxlist-menuItem]",
		"{viewport}": "[data-textboxlist-autocomplete-viewport]",
		"{loadingHint}": "[data-textboxlist-autocomplete-loading]",
		"{emptyHint}": "[data-textboxlist-autocomplete-empty]"
	}
},
function(self, opts, base) { return {

	init: function() {

		// Destroy controller
		if (!self.element.data(self.Class.fullName)) {

			self.destroy();

			// And reimplement on the context menu we created ourselves
			self.view.menu()
				.attr("id", opts.id)
				.addClass(opts.component)
				.addClass(opts.modifier)
				.addClass(opts.shadow ? 'has-shadow' : '')
				.addClass(opts.animation ? 'has-animation' : '')
				.addClass(opts.sticky ? 'is-sticky' : '')
				// This is legacy
				.addClass(self.textboxlist.options.component)
				.appendTo("body")
				.data(self.Class.fullName, true)
				.addController(self.Class, self.options);

			return;
		}

		var textboxlist = self.textboxlist;

		textboxlist.autocomplete = self;
		textboxlist.pluginInstances["autocomplete"] = self;

		// Set the position to be relative to the textboxlist
		self.options.position.of = self.textboxlist.element;

		self.initQuery();

		// Loading hint
		self.view.loadingHint()
			.appendTo(self.loadingHint());

		// Empty hint
		self.view.emptyHint()
			.appendTo(self.emptyHint());

		// Only reattach element when autocomplete is needed.
		self.element.detach();
	},

	initQuery: function() {

		// Determine query method
		var query = self.options.query || self.textboxlist.element.data("query");

		// TODO: Wrap up query options and pass to query URL & query function.

		// Query URL
		if ($.isUrl(query)) {

			var url = query;

			self.query = function(keyword){
				return $.ajax(url + keyword);
			}

			return;
		}

		// Query function
		if ($.isFunction(query)) {

			var func = query;

			self.query = function(keyword) {
				return func.call(self, keyword);
			}

			return;
		}

		// Query dataset
		if ($.isArray(query)) {

			var dataset = query;

			self.query = function(keyword) {

				var task = $.Deferred(),
					keyword = keyword.toLowerCase();

				// Fork this process
				// so it won't choke on large dataset.
				setTimeout(function(){

					var result = $.grep(dataset, function(item){
						return item.title.toLowerCase().indexOf(keyword) > -1;
					});

					task.resolve(result);

				}, 0);

				return task;
			}

			return;
		}
	},

	setLayout: function() {

		if (!self.hidden) {

			self.element
				.css({
					opacity: 1,
					width: self.textboxlist.element.outerWidth()
				})
				.position(self.options.position);
		}
	},

	"{window} resize": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} scroll": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} dialogTransitionStart": function() {
		self.hidden = true;
		self.element.css("opacity", 0);
	},

	"{window} dialogTransitionEnd": function() {
		self.hidden = false;
		self.setLayout();
	},

	show: function() {

		clearTimeout(self.sleep);

		self.element
			.appendTo("body")
			.show();

		self.hidden = false;

		self.setLayout();
	},

	hide: function() {

		self.element.hide();

		var menuItem = self.menuItem(),
			activeMenuItem = menuItem.filter(".active");

		if (activeMenuItem.length > 0) {
			self.lastItem = {
				keyword: $.trim(self.textboxlist.textField().val()),
				item   : activeMenuItem.data("item")
			};
		}

		menuItem.removeClass("active");

		self.render.reset();

		self.hidden = true;

		// Clear any previous sleep timer first
		clearTimeout(self.sleep);

		// If no activity within 3000 seconds, detach myself.
		self.sleep = setTimeout(function(){
			self.element.detach();
		}, 3000);
	},

	queries: {},

	populated: false,

	populate: function(keyword) {

		self.populated = false;

		// Remove loading class
		var element = self.element,
			options = self.options;

		// Remove both loading & empty class
		element.removeClass("loading empty");

		if (options.showLoadingHint) {
			self.hide();
		}

		// Trigger populate event
		// If the populate event returns a modified keyword, use it.
		var event = self.trigger("populateKeyword", [keyword]);
		if (event.keyword) { keyword = event.keyword };


		var key = (options.caseSensitive) ? keyword : keyword.toLowerCase(),
			query = self.queries[key];

		var newQuery = !$.isDeferred(query) || !self.options.cache,

			runQuery = function(){

				// Show loading hint
				if (options.showLoadingHint) {
					element.addClass("loading");
					self.show();
				}

				// Query the keyword if:
				// - The query hasn't been made.
				// - The query has been rejected.
				if (newQuery || (!newQuery && query.state()=="rejected")) {

					query = self.queries[key] = self.query(keyword);
				}

				// When query is done, render items;
				query
					.done(
						self.render(function(items){
							return [items, keyword];
						})
					)
					.fail(function(){
						self.hide();
					})
					.always(function(){
						element.removeClass("loading");
					});

				// Trigger query event
				self.trigger("queryKeyword", [query, keyword]);
			}

		// If this is a new query
		if (newQuery) {

			// Don't run until we are sure that the user is finished typing
			clearTimeout(self.queryTask);
			self.queryTask = setTimeout(runQuery, 250);

		// Else run it immediately
		} else {
			runQuery();
		}
	},

	populateTask: null,

	populateFromTextField: function() {

		clearTimeout(self.populateTask);

		self.populateTask = setTimeout(function(){

			var textField = self.textboxlist.textField(),
				keyword = $.trim(textField.val());

			// If no keyword given or keyword doesn't meet minimum query length, stop.
			if (keyword==="" || (keyword.length < self.options.minLength)) {

				self.hide();

			// Else populate suggestions.
			} else {

				self.populate(keyword);
			}
		}, 1);
	},

	render: $.Enqueue(function(items, keyword){

		// If items passed in isn't an array,
		// fake an empty array.
		if (!$.isArray(items)) { items = [] };

		// Get textboxlist
		var textboxlist = self.textboxlist,
			autocomplete = self,
			element = self.element,
			options = self.options,
			menu = self.menu();

		// If there are no items, hide menu.
		if (items.length < 1) {

			// If we are supposed to show an empty hint
			if (options.showEmptyHint) {

				// Clear out menu
				menu.empty();

				// Add empty class
				element.addClass("empty");

				// Trigger renderMenu event
				textboxlist.trigger("renderMenu", [menu, autocomplete, textboxlist]);

				// Show menu
				self.show();

			// Just hide straight away
			} else {

				self.hide();
			}

			return;
		}

		// Remove empty class
		element.removeClass("empty");

		// Generate menu items
		if (!options.cache || menu.data("keyword")!==keyword) {

			// Clear out menu items
			menu.empty();

			$.each(items, function(i, item){

				textboxlist.trigger("filterItem", [item, autocomplete, textboxlist]);

				// Deprecated
				var filterItem = options.filterItem;
				if ($.isFunction(filterItem)) {
					item = filterItem.call(self, item, keyword);
				}

				// If the item is not an object,
				// or item should be discarded, stop.
				if (!$.isPlainObject(item) || item.discard) return;

				var html = item.menuHtml || item.title;

				self.view.menuItem({html: html})
					.addClass(item.className || "")
					.data("item", item)
					.appendTo(menu);
			});

			menu.data("keyword", keyword);
		}

		// Get menu Items
		var menuItems = self.menuItem();

		// Trigger filterMenu event
		textboxlist.trigger("filterMenu", [menu, menuItems, autocomplete, textboxlist]);

		// If menu is empty, toggle empty classname
		if (menuItems.filter(":not(.hidden)").length < 1) {

			element.addClass("empty");

			// If we shouldn't show an empty hint
			if (!options.showEmptyHint) {

				// Hide menu straightaway
				return self.hide();
			}
		}

		// If we only allow adding item from suggestions
		if (options.exclusive) {

			// Automatically select the first item
			self.menuItem(":not(.hidden):first").addClass("active");
		}

		// Trigger renderMenu event
		textboxlist.trigger("renderMenu", [menu, autocomplete, textboxlist]);

		self.show();
	}),

	"{textboxlist.textField} keydown": function(textField, event) {

		// Prevent autocomplete from falling asleep.
		clearTimeout(self.sleep);

		// Get active menu item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (activeMenuItem.length < 1) {
			activeMenuItem = false;
		}

		var textField = self.textboxlist.textField();

		switch (event.keyCode) {

			// If up key is pressed
			case KEYCODE.UP:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the last one.
					self.menuItem(":not(.hidden):last").addClass("active");

				// Else find the menu item before it,
				} else {

					// and activate it.
					activeMenuItem.prev(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// Prevent up/down keys from changing textfield cursor position.
				event.preventDefault();
				break;

			// If down key is pressed
			case KEYCODE.DOWN:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the first one.
					self.menuItem(":not(.hidden):first").addClass("active");

				// Else find the menu item after it,
				} else {

					// and activate it.
					activeMenuItem.next(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// Prevent up/down keys from changing textfield cursor position.
				event.preventDefault();
				break;

			// If escape is pressed,
			case KEYCODE.ESCAPE:

				// hide menu.
				self.hide();
				break;

			// Don't do anything when enter is pressed.
			case KEYCODE.ENTER:
				break;

			default:
				self.populateFromTextField();
				break;
		}

		// Get newly activated item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		// If we are reaching the end of the menu cycle,
		// select textfield as a visual indication, else
		// unselect textfield and let the menu item appear selected.
		if (activeMenuItem.length < 1) {
			return;
			// textField.selectAll(); return;
		} else {
			//textField.unselect();
		}

		// Scroll menu viewport if it is out of visible area.
		self.viewport().scrollIntoView(activeMenuItem);
	},

	"{textboxlist} textboxlistActivate": function(textboxlist) {

		self.populateFromTextField();
	},

	"{textboxlist} textboxlistDeactivate": function(textboxlist) {

		// Allow user to select menu first
		setTimeout(function(){
			self.hide();
		}, 150);
	},

	"{textboxlist} destroyed": function() {

		self.element.remove();
	},

	"{textboxlist} useItem": function(textField, event, keyword) {

		// If we only pick items exclusively from menu,
		// set item to false first. This prevents any
		// random keyword from being added to the list.
		var exclusive = self.options.exclusive;

		if (exclusive) event.item = false;

		// If menu is not visible
		if (self.hidden) {

			// and we are in exclusive mode
			// and the last item before we hide the menu
			// matches the current keyword,
			var lastItem = self.lastItem;

			if (exclusive && lastItem && lastItem.keyword==keyword) {

				// then we will automatically use the last
				// item as the item to be added to the list.
				event.item = lastItem.item;
			}

			return;
		}

		// If there are activated items
		var activeMenuItem = self.menuItem(".active");

		if (activeMenuItem.length > 0) {

			// get the item data,
			var item = activeMenuItem.data("item");

			// and return the item data to the textboxlist.
			event.item = item;
		}

		// Hide the menu
		self.hide();
	},

	"{menuItem} mousedown": function() {

		self.textboxlist.focusing = true;
	},

	"{menuItem} mouseup": function() {

		self.textboxlist.focusing = false;
	},

	"{menuItem} click": function(menuItem) {

		// Hide context menu
		self.hide();

		// Add item
		var item = menuItem.data("item");
		self.textboxlist.addItem(item);

		// Get text field & clear text field
		var textField = self.textboxlist.textField().val("");

		// Refocus text field
		setTimeout(function(){

			// Due to event delegation, this needs to be slightly delayed.
			textField.focus();
		}, 150);
	},

	"{menuItem} mouseover": function(menuItem) {

		self.menuItem().removeClass("active");

		menuItem.addClass("active");
	},

	"{menuItem} mouseout": function(menuItem) {

		self.menuItem().removeClass("active");
	}
}}
);
// Autocomplete ends
}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("textboxlist", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

var AutosizeInput = function(input, options) {

    var self = this;

    self.input   = $(input);
    self.options = $.extend(AutosizeInput.defaultOptions, options);
    self.mirror  = $('<span style="position:absolute; top:-999px; left:0; white-space:pre;"/>');

    $.each([
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'letterSpacing',
        'textTransform',
        'wordSpacing',
        'textIndent'
    ], function (i, val) {
        self.mirror[0].style[val] = self.input.css(val);
    });

    $("body").append(self.mirror);

    self.input.bind("keydown keyup input", function(e){
        self.update();
    });

    self.update();
}

AutosizeInput.defaultOptions = {
    space: 30
}

AutosizeInput.validTypes = [
    "text",
    "password",
    "search",
    "url",
    "tel",
    "email"
];

AutosizeInput.prototype.update = function() {

    var self   = this,
        input  = self.input,
        mirror = self.mirror,
        value  = input.val();

    if (!value) {
        value = input.attr("placeholder");
    }

    if (value === mirror.text()) {
        return;
    }

    mirror.text(value);

    var newWidth = mirror.width() + self.options.space;
    input.width(newWidth);
};

$.fn.autosizeInput = function(options) {

    return this.each(function () {
        if(!(this.tagName == "INPUT" && $.inArray(this.type, AutosizeInput.validTypes) > -1)) {
            return;
        }
        var $this = $(this);
        if (!$this.data("autosizeInputInstance")) {
            $this.data("autosizeInputInstance", new AutosizeInput(this, options));
        }
    });
};

$(function () {
    $("input[data-autosize-input]").autosizeInput();
});


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("autosize.input", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery.ScrollTo
 * Copyright (c) 2007-2012 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * Date: 4/09/2012
 *
 * @projectDescription Easy element scrolling using jQuery.
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 * @author Ariel Flesler
 * @version 1.4.3.1
 *
 * @id jQuery.scrollTo
 * @id jQuery.fn.scrollTo
 * @param {String, Number, DOMElement, jQuery, Object} target Where to scroll the matched elements.
 *	  The different options for target are:
 *		- A number position (will be applied to all axes).
 *		- A string position ('44', '100px', '+=90', etc ) will be applied to all axes
 *		- A jQuery/DOM element ( logically, child of the element to scroll )
 *		- A string selector, that will be relative to the element to scroll ( 'li:eq(2)', etc )
 *		- A hash { top:x, left:y }, x and y can be any kind of number/string like above.
 *		- A percentage of the container's dimension/s, for example: 50% to go to the middle.
 *		- The string 'max' for go-to-end. 
 * @param {Number, Function} duration The OVERALL length of the animation, this argument can be the settings object instead.
 * @param {Object,Function} settings Optional set of settings or the onAfter callback.
 *	 @option {String} axis Which axis must be scrolled, use 'x', 'y', 'xy' or 'yx'.
 *	 @option {Number, Function} duration The OVERALL length of the animation.
 *	 @option {String} easing The easing method for the animation.
 *	 @option {Boolean} margin If true, the margin of the target element will be deducted from the final position.
 *	 @option {Object, Number} offset Add/deduct from the end position. One number for both axes or { top:x, left:y }.
 *	 @option {Object, Number} over Add/deduct the height/width multiplied by 'over', can be { top:x, left:y } when using both axes.
 *	 @option {Boolean} queue If true, and both axis are given, the 2nd axis will only be animated after the first one ends.
 *	 @option {Function} onAfter Function to be called after the scrolling ends. 
 *	 @option {Function} onAfterFirst If queuing is activated, this function will be called after the first scrolling ends.
 * @return {jQuery} Returns the same jQuery object, for chaining.
 *
 * @desc Scroll to a fixed position
 * @example $('div').scrollTo( 340 );
 *
 * @desc Scroll relatively to the actual position
 * @example $('div').scrollTo( '+=340px', { axis:'y' } );
 *
 * @desc Scroll using a selector (relative to the scrolled element)
 * @example $('div').scrollTo( 'p.paragraph:eq(2)', 500, { easing:'swing', queue:true, axis:'xy' } );
 *
 * @desc Scroll to a DOM element (same for jQuery object)
 * @example var second_child = document.getElementById('container').firstChild.nextSibling;
 *			$('#container').scrollTo( second_child, { duration:500, axis:'x', onAfter:function(){
 *				alert('scrolled!!');																   
 *			}});
 *
 * @desc Scroll on both axes, to different values
 * @example $('div').scrollTo( { top: 300, left:'+=200' }, { axis:'xy', offset:-20 } );
 */

;(function( $ ){
	
	var $scrollTo = $.scrollTo = function( target, duration, settings ){
		$(window).scrollTo( target, duration, settings );
	};

	$scrollTo.defaults = {
		axis:'xy',
		duration: parseFloat($.fn.jquery) >= 1.3 ? 0 : 1,
		limit:true
	};

	// Returns the element that needs to be animated to scroll the window.
	// Kept for backwards compatibility (specially for localScroll & serialScroll)
	$scrollTo.window = function( scope ){
		return $(window)._scrollable();
	};

	// Hack, hack, hack :)
	// Returns the real elements to scroll (supports window/iframes, documents and regular nodes)
	$.fn._scrollable = function(){
		return this.map(function(){
			var elem = this,
				isWin = !elem.nodeName || $.inArray( elem.nodeName.toLowerCase(), ['iframe','#document','html','body'] ) != -1;

				if( !isWin )
					return elem;

			var doc = (elem.contentWindow || elem).document || elem.ownerDocument || elem;
			
			return /webkit/i.test(navigator.userAgent) || doc.compatMode == 'BackCompat' ?
				doc.body : 
				doc.documentElement;
		});
	};

	$.fn.scrollTo = function( target, duration, settings ){
		if( typeof duration == 'object' ){
			settings = duration;
			duration = 0;
		}
		if( typeof settings == 'function' )
			settings = { onAfter:settings };
			
		if( target == 'max' )
			target = 9e9;
			
		settings = $.extend( {}, $scrollTo.defaults, settings );
		// Speed is still recognized for backwards compatibility
		duration = duration || settings.duration;
		// Make sure the settings are given right
		settings.queue = settings.queue && settings.axis.length > 1;
		
		if( settings.queue )
			// Let's keep the overall duration
			duration /= 2;
		settings.offset = both( settings.offset );
		settings.over = both( settings.over );

		return this._scrollable().each(function(){
			// Null target yields nothing, just like jQuery does
			if (target == null) return;

			var elem = this,
				$elem = $(elem),
				targ = target, toff, attr = {},
				win = $elem.is('html,body');

			switch( typeof targ ){
				// A number will pass the regex
				case 'number':
				case 'string':
					if( /^([+-]=)?\d+(\.\d+)?(px|%)?$/.test(targ) ){
						targ = both( targ );
						// We are done
						break;
					}
					// Relative selector, no break!
					targ = $(targ,this);
					if (!targ.length) return;
				case 'object':
					// DOMElement / jQuery
					if( targ.is || targ.style )
						// Get the real position of the target 
						toff = (targ = $(targ)).offset();
			}
			$.each( settings.axis.split(''), function( i, axis ){
				var Pos	= axis == 'x' ? 'Left' : 'Top',
					pos = Pos.toLowerCase(),
					key = 'scroll' + Pos,
					old = elem[key],
					max = $scrollTo.max(elem, axis);

				if( toff ){// jQuery / DOMElement
					attr[key] = toff[pos] + ( win ? 0 : old - $elem.offset()[pos] );

					// If it's a dom element, reduce the margin
					if( settings.margin ){
						attr[key] -= parseInt(targ.css('margin'+Pos)) || 0;
						attr[key] -= parseInt(targ.css('border'+Pos+'Width')) || 0;
					}
					
					attr[key] += settings.offset[pos] || 0;
					
					if( settings.over[pos] )
						// Scroll to a fraction of its width/height
						attr[key] += targ[axis=='x'?'width':'height']() * settings.over[pos];
				}else{ 
					var val = targ[pos];
					// Handle percentage values
					attr[key] = val.slice && val.slice(-1) == '%' ? 
						parseFloat(val) / 100 * max
						: val;
				}

				// Number or 'number'
				if( settings.limit && /^\d+$/.test(attr[key]) )
					// Check the limits
					attr[key] = attr[key] <= 0 ? 0 : Math.min( attr[key], max );

				// Queueing axes
				if( !i && settings.queue ){
					// Don't waste time animating, if there's no need.
					if( old != attr[key] )
						// Intermediate animation
						animate( settings.onAfterFirst );
					// Don't animate this axis again in the next iteration.
					delete attr[key];
				}
			});

			animate( settings.onAfter );			

			function animate( callback ){
				$elem.animate( attr, duration, settings.easing, callback && function(){
					callback.call(this, target, settings);
				});
			};

		}).end();
	};

	$.fn.scrollIntoView = function(target) {

		// TODO: Add support for X axis.
		// TODO: Add support for passing in custom options.

		var target = $(target);
		if (target.length < 1) return;

		var viewportOffset = this.offset(),
			viewportHeight = this.height(),
			viewportTop    = viewportOffset.top,
			viewportBottom = viewportTop + viewportHeight,

			targetOffset = target.offset(),
			targetHeight = target.height(),
			targetTop    = targetOffset.top,
			targetBottom = targetTop + targetHeight;

		if (targetBottom > viewportBottom) {
			return this.scrollTo(target);
		}

		if (targetTop < viewportTop) {
			return this.scrollTo(target, {offset: (viewportHeight - targetHeight) * -1});
		}
	};	
	
	// Max scrolling position, works on quirks mode
	// It only fails (not too badly) on IE, quirks mode.
	$scrollTo.max = function( elem, axis ){
		var Dim = axis == 'x' ? 'Width' : 'Height',
			scroll = 'scroll'+Dim;
		
		if( !$(elem).is('html,body') )
			return elem[scroll] - $(elem)[Dim.toLowerCase()]();
		
		var size = 'client' + Dim,
			html = elem.ownerDocument.documentElement,
			body = elem.ownerDocument.body;

		return Math.max( html[scroll], body[scroll] ) 
			 - Math.min( html[size]  , body[size]   );
	};

	function both( val ){
		return typeof val == 'object' ? val : { top:val, left:val };
	};

})( jQuery );
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("scrollTo", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/*!
 * Tiny Scrollbar 1.65
 * http://www.baijs.nl/tinyscrollbar/
 *
 * Copyright 2010, Maarten Baijs
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/gpl-2.0.php
 *
 * Date: 10 / 05 / 2011
 * Depends on library: jQuery
 *
 */
var jQuery  = $;

/*
 * Tiny Scrollbar 1.8
 * http://www.baijs.nl/tinyscrollbar/
 *
 * Copyright 2012, Maarten Baijs
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/gpl-2.0.php
 *
 * Date: 26 / 07 / 2012
 * Depends on library: jQuery
 *
 */
( function( $ ) 
{
    $.tiny = $.tiny || { };

    $.tiny.scrollbar = {
        options: {
                axis       : 'y'    // vertical or horizontal scrollbar? ( x || y ).
            ,   wheel      : 40     // how many pixels must the mouswheel scroll at a time.
            ,   scroll     : true   // enable or disable the mousewheel.
            ,   lockscroll : true   // return scrollwheel to browser if there is no more content.
            ,   size       : 'auto' // set the size of the scrollbar to auto or a fixed number.
            ,   sizethumb  : 'auto' // set the size of the thumb to auto or a fixed number.
        }
    };

    $.fn.tinyscrollbar = function( params )
    {
        var options = $.extend( {}, $.tiny.scrollbar.options, params );
        
        this.each( function()
        { 
            $( this ).data('tsb', new Scrollbar( $( this ), options ) ); 
        });

        return this;
    };

    $.fn.tinyscrollbar_update = function(sScroll)
    {
        return $( this ).data( 'tsb' ).update( sScroll ); 
    };

    function Scrollbar( root, options )
    {
        var oSelf       = this
        ,   oWrapper    = root
        ,   oViewport   = { obj: $( '.viewport', root ) }
        ,   oContent    = { obj: $( '.overview', root ) }
        ,   oScrollbar  = { obj: $( '.scrollbar', root ) }
        ,   oTrack      = { obj: $( '.track', oScrollbar.obj ) }
        ,   oThumb      = { obj: $( '.thumb', oScrollbar.obj ) }
        ,   sAxis       = options.axis === 'x'
        ,   sDirection  = sAxis ? 'left' : 'top'
        ,   sSize       = sAxis ? 'Width' : 'Height'
        ,   iScroll     = 0
        ,   iPosition   = { start: 0, now: 0 }
        ,   iMouse      = {}
        ,   touchEvents = ( 'ontouchstart' in document.documentElement ) ? true : false
        ;

        function initialize()
        {
            oSelf.update();
            setEvents();

            return oSelf;
        }

        this.update = function( sScroll )
        {
            oViewport[ options.axis ] = oViewport.obj[0][ 'offset'+ sSize ];
            oContent[ options.axis ]  = oContent.obj[0][ 'scroll'+ sSize ];
            oContent.ratio            = oViewport[ options.axis ] / oContent[ options.axis ];

            oScrollbar.obj.toggleClass( 'disable', oContent.ratio >= 1 );

            oTrack[ options.axis ] = options.size === 'auto' ? oViewport[ options.axis ] : options.size;
            oThumb[ options.axis ] = Math.min( oTrack[ options.axis ], Math.max( 0, ( options.sizethumb === 'auto' ? ( oTrack[ options.axis ] * oContent.ratio ) : options.sizethumb ) ) );
        
            oScrollbar.ratio = options.sizethumb === 'auto' ? ( oContent[ options.axis ] / oTrack[ options.axis ] ) : ( oContent[ options.axis ] - oViewport[ options.axis ] ) / ( oTrack[ options.axis ] - oThumb[ options.axis ] );
            
            iScroll = ( sScroll === 'relative' && oContent.ratio <= 1 ) ? Math.min( ( oContent[ options.axis ] - oViewport[ options.axis ] ), Math.max( 0, iScroll )) : 0;
            iScroll = ( sScroll === 'bottom' && oContent.ratio <= 1 ) ? ( oContent[ options.axis ] - oViewport[ options.axis ] ) : isNaN( parseInt( sScroll, 10 ) ) ? iScroll : parseInt( sScroll, 10 );
            
            setSize();
        };

        function setSize()
        {
            var sCssSize = sSize.toLowerCase();

            oThumb.obj.css( sDirection, iScroll / oScrollbar.ratio );
            oContent.obj.css( sDirection, -iScroll );
            iMouse.start = oThumb.obj.offset()[ sDirection ];

            oScrollbar.obj.css( sCssSize, oTrack[ options.axis ] );
            oTrack.obj.css( sCssSize, oTrack[ options.axis ] );
            oThumb.obj.css( sCssSize, oThumb[ options.axis ] );
        }

        function setEvents()
        {
            if( ! touchEvents )
            {
                oThumb.obj.bind( 'mousedown', start );
                oTrack.obj.bind( 'mouseup', drag );
            }
            else
            {
                oViewport.obj[0].ontouchstart = function( event )
                {   
                    if( 1 === event.touches.length )
                    {
                        start( event.touches[ 0 ] );
                        event.stopPropagation();
                    }
                };
            }

            if( options.scroll && window.addEventListener )
            {
                oWrapper[0].addEventListener( 'DOMMouseScroll', wheel, false );
                oWrapper[0].addEventListener( 'mousewheel', wheel, false );
            }
            else if( options.scroll )
            {
                oWrapper[0].onmousewheel = wheel;
            }
        }

        function start( event )
        {
            var oThumbDir   = parseInt( oThumb.obj.css( sDirection ), 10 );
            iMouse.start    = sAxis ? event.pageX : event.pageY;
            iPosition.start = oThumbDir == 'auto' ? 0 : oThumbDir;
            
            if( ! touchEvents )
            {
                $( document ).bind( 'mousemove', drag );
                $( document ).bind( 'mouseup', end );
                oThumb.obj.bind( 'mouseup', end );
            }
            else
            {
                document.ontouchmove = function( event )
                {
                    event.preventDefault();
                    drag( event.touches[ 0 ] );
                };
                document.ontouchend = end;        
            }
        }

        function wheel( event )
        {
            if( oContent.ratio < 1 )
            {
                var oEvent = event || window.event
                ,   iDelta = oEvent.wheelDelta ? oEvent.wheelDelta / 120 : -oEvent.detail / 3
                ;

                iScroll -= iDelta * options.wheel;
                iScroll = Math.min( ( oContent[ options.axis ] - oViewport[ options.axis ] ), Math.max( 0, iScroll ));

                oThumb.obj.css( sDirection, iScroll / oScrollbar.ratio );
                oContent.obj.css( sDirection, -iScroll );

                if( options.lockscroll || ( iScroll !== ( oContent[ options.axis ] - oViewport[ options.axis ] ) && iScroll !== 0 ) )
                {
                    oEvent = $.event.fix( oEvent );
                    oEvent.preventDefault();
                }
            }
        }

        function drag( event )
        {
            if( oContent.ratio < 1 )
            {
                if( ! touchEvents )
                {
                    iPosition.now = Math.min( ( oTrack[ options.axis ] - oThumb[ options.axis ] ), Math.max( 0, ( iPosition.start + ( ( sAxis ? event.pageX : event.pageY ) - iMouse.start))));
                }
                else
                {
                    iPosition.now = Math.min( ( oTrack[ options.axis ] - oThumb[ options.axis ] ), Math.max( 0, ( iPosition.start + ( iMouse.start - ( sAxis ? event.pageX : event.pageY ) ))));
                }

                iScroll = iPosition.now * oScrollbar.ratio;
                oContent.obj.css( sDirection, -iScroll );
                oThumb.obj.css( sDirection, iPosition.now );
            }
        }
        
        function end()
        {
            $( document ).unbind( 'mousemove', drag );
            $( document ).unbind( 'mouseup', end );
            oThumb.obj.unbind( 'mouseup', end );
            document.ontouchmove = document.ontouchend = null;
        }

        return initialize();
    }

}(jQuery));

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("tinyscrollbar", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/**
 * History.js jQuery Adapter
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

// Closure
(function(window,undefined){
	"use strict";

	// Localise Globals
	var History = window.History = window.History||{};

	// Check Existence
	if ( typeof History.Adapter !== 'undefined' ) {
		throw new Error('History.js Adapter has already been loaded...');
	}

	// Add the Adapter
	History.Adapter = {
		/**
		 * History.Adapter.bind(el,event,callback)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {function} callback
		 * @return {void}
		 */
		bind: function(el,event,callback){
			jQuery(el).bind(event,callback);
		},

		/**
		 * History.Adapter.trigger(el,event)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {void}
		 */
		trigger: function(el,event,extra){
			jQuery(el).trigger(event,extra);
		},

		/**
		 * History.Adapter.extractEventData(key,event,extra)
		 * @param {string} key - key for the event data to extract
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {mixed}
		 */
		extractEventData: function(key,event,extra){
			// jQuery Native then jQuery Custom
			var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;

			// Return
			return result;
		},

		/**
		 * History.Adapter.onDomLoad(callback)
		 * @param {function} callback
		 * @return {void}
		 */
		onDomLoad: function(callback) {
			jQuery(callback);
		}
	};

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);

/**
 * History.js HTML4 Support
 * Depends on the HTML5 Support
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		document = window.document, // Make sure we are using the correct document
		setTimeout = window.setTimeout||setTimeout,
		clearTimeout = window.clearTimeout||clearTimeout,
		setInterval = window.setInterval||setInterval,
		History = window.History = window.History||{}; // Public History Object

	// Check Existence
	if ( typeof History.initHtml4 !== 'undefined' ) {
		throw new Error('History.js HTML4 Support has already been loaded...');
	}


	// ========================================================================
	// Initialise HTML4 Support

	// Initialise HTML4 Support
	History.initHtml4 = function(){
		// Initialise
		if ( typeof History.initHtml4.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initHtml4.initialized = true;
		}


		// ====================================================================
		// Properties

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = true;


		// ====================================================================
		// Hash Storage

		/**
		 * History.savedHashes
		 * Store the hashes in an array
		 */
		History.savedHashes = [];

		/**
		 * History.isLastHash(newHash)
		 * Checks if the hash is the last hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.isLastHash = function(newHash){
			// Prepare
			var oldHash = History.getHashByIndex(),
				isLast;

			// Check
			isLast = newHash === oldHash;

			// Return isLast
			return isLast;
		};

		/**
		 * History.saveHash(newHash)
		 * Push a Hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.saveHash = function(newHash){
			// Check Hash
			if ( History.isLastHash(newHash) ) {
				return false;
			}

			// Push the Hash
			History.savedHashes.push(newHash);

			// Return true
			return true;
		};

		/**
		 * History.getHashByIndex()
		 * Gets a hash by the index
		 * @param {integer} index
		 * @return {string}
		 */
		History.getHashByIndex = function(index){
			// Prepare
			var hash = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				hash = History.savedHashes[History.savedHashes.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				hash = History.savedHashes[History.savedHashes.length+index];
			}
			else {
				// Get from the beginning
				hash = History.savedHashes[index];
			}

			// Return hash
			return hash;
		};


		// ====================================================================
		// Discarded States

		/**
		 * History.discardedHashes
		 * A hashed array of discarded hashes
		 */
		History.discardedHashes = {};

		/**
		 * History.discardedStates
		 * A hashed array of discarded states
		 */
		History.discardedStates = {};

		/**
		 * History.discardState(State)
		 * Discards the state by ignoring it through History
		 * @param {object} State
		 * @return {true}
		 */
		History.discardState = function(discardedState,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Prepare
			var discardedStateHash = History.getHashByState(discardedState),
				discardObject;

			// Create Discard Object
			discardObject = {
				'discardedState': discardedState,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to DiscardedStates
			History.discardedStates[discardedStateHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardHash(hash)
		 * Discards the hash by ignoring it through History
		 * @param {string} hash
		 * @return {true}
		 */
		History.discardHash = function(discardedHash,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Create Discard Object
			var discardObject = {
				'discardedHash': discardedHash,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to discardedHash
			History.discardedHashes[discardedHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardState(State)
		 * Checks to see if the state is discarded
		 * @param {object} State
		 * @return {bool}
		 */
		History.discardedState = function(State){
			// Prepare
			var StateHash = History.getHashByState(State),
				discarded;

			// Check
			discarded = History.discardedStates[StateHash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.discardedHash(hash)
		 * Checks to see if the state is discarded
		 * @param {string} State
		 * @return {bool}
		 */
		History.discardedHash = function(hash){
			// Check
			var discarded = History.discardedHashes[hash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.recycleState(State)
		 * Allows a discarded state to be used again
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {true}
		 */
		History.recycleState = function(State){
			//History.debug('History.recycleState', arguments);
			// Prepare
			var StateHash = History.getHashByState(State);

			// Remove from DiscardedStates
			if ( History.discardedState(State) ) {
				delete History.discardedStates[StateHash];
			}

			// Return true
			return true;
		};


		// ====================================================================
		// HTML4 HashChange Support

		if ( History.emulated.hashChange ) {
			/*
			 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
			 */

			/**
			 * History.hashChangeInit()
			 * Init the HashChange Emulation
			 */
			History.hashChangeInit = function(){
				// Define our Checker Function
				History.checkerFunction = null;

				// Define some variables that will help in our checker function
				var lastDocumentHash = '',
					iframeId, iframe,
					lastIframeHash, checkerRunning;

				// Handle depending on the browser
				if ( History.isInternetExplorer() ) {
					// IE6 and IE7
					// We need to use an iframe to emulate the back and forward buttons

					// Create iFrame
					iframeId = 'historyjs-iframe';
					iframe = document.createElement('iframe');

					// Adjust iFarme
					iframe.setAttribute('id', iframeId);
					iframe.style.display = 'none';

					// Append iFrame
					document.body.appendChild(iframe);

					// Create initial history entry
					iframe.contentWindow.document.open();
					iframe.contentWindow.document.close();

					// Define some variables that will help in our checker function
					lastIframeHash = '';
					checkerRunning = false;

					// Define the checker function
					History.checkerFunction = function(){
						// Check Running
						if ( checkerRunning ) {
							return false;
						}

						// Update Running
						checkerRunning = true;

						// Fetch
						var documentHash = History.getHash()||'',
							iframeHash = History.unescapeHash(iframe.contentWindow.document.location.hash)||'';

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Create a history entry in the iframe
							if ( iframeHash !== documentHash ) {
								//History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);

								// Equalise
								lastIframeHash = iframeHash = documentHash;

								// Create History Entry
								iframe.contentWindow.document.open();
								iframe.contentWindow.document.close();

								// Update the iframe's hash
								iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
							}

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// The iFrame Hash has changed (back button caused)
						else if ( iframeHash !== lastIframeHash ) {
							//History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);

							// Equalise
							lastIframeHash = iframeHash;

							// Update the Hash
							History.setHash(iframeHash,false);
						}

						// Reset Running
						checkerRunning = false;

						// Return true
						return true;
					};
				}
				else {
					// We are not IE
					// Firefox 1 or 2, Opera

					// Define the checker function
					History.checkerFunction = function(){
						// Prepare
						var documentHash = History.getHash();

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// Return true
						return true;
					};
				}

				// Apply the checker function
				History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));

				// Done
				return true;
			}; // History.hashChangeInit

			// Bind hashChangeInit
			History.Adapter.onDomLoad(History.hashChangeInit);

		} // History.emulated.hashChange


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * We must emulate the HTML5 State Management by using HTML4 HashChange
			 */

			/**
			 * History.onHashChange(event)
			 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
			 */
			History.onHashChange = function(event){
				//History.debug('History.onHashChange', arguments);

				// Prepare
				var currentUrl = ((event && event.newURL) || document.location.href),
					currentHash = History.getHashByUrl(currentUrl),
					currentState = null,
					currentStateHash = null,
					currentStateHashExits = null,
					discardObject;

				// Check if we are the same state
				if ( History.isLastHash(currentHash) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onHashChange: no change');
					History.busy(false);
					return false;
				}

				// Reset the double check
				History.doubleCheckComplete();

				// Store our location for use in detecting back/forward direction
				History.saveHash(currentHash);

				// Expand Hash
				if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
					//History.debug('History.onHashChange: traditional anchor', currentHash);
					// Traditional Anchor Hash
					History.Adapter.trigger(window,'anchorchange');
					History.busy(false);
					return false;
				}

				// Create State
				currentState = History.extractState(History.getFullUrl(currentHash||document.location.href,false),true);

				// Check if we are the same state
				if ( History.isLastSavedState(currentState) ) {
					//History.debug('History.onHashChange: no change');
					// There has been no change (just the page's hash has finally propagated)
					History.busy(false);
					return false;
				}

				// Create the state Hash
				currentStateHash = History.getHashByState(currentState);

				// Check if we are DiscardedState
				discardObject = History.discardedState(currentState);
				if ( discardObject ) {
					// Ignore this state as it has been discarded and go back to the state before it
					if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
						// We are going backwards
						//History.debug('History.onHashChange: go backwards');
						History.back(false);
					} else {
						// We are going forwards
						//History.debug('History.onHashChange: go forwards');
						History.forward(false);
					}
					return false;
				}

				// Push the new HTML5 State
				//History.debug('History.onHashChange: success hashchange');
				History.pushState(currentState.data,currentState.title,currentState.url,false);

				// End onHashChange closure
				return true;
			};
			History.Adapter.bind(window,'hashchange',History.onHashChange);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Object
				var newState = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					html4Hash = History.getHash();

				// Store the newState
				History.storeState(newState);
				History.expectedStateId = newState.id;

				// Recycle the State
				History.recycleState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Check if we are the same State
				if ( newStateHash === oldStateHash ) {
					//History.debug('History.pushState: no change', newStateHash);
					History.busy(false);
					return false;
				}

				// Update HTML4 Hash
				if ( newStateHash !== html4Hash && newStateHash !== History.getShortUrl(document.location.href) ) {
					//History.debug('History.pushState: update hash', newStateHash, html4Hash);
					History.setHash(newStateHash,false);
					return false;
				}

				// Update HTML5 State
				History.saveState(newState);

				// Fire HTML5 Event
				//History.debug('History.pushState: trigger popstate');
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Objects
				var newState        = History.createStateObject(data,title,url),
					oldState        = History.getState(false),
					previousState   = History.getStateByIndex(-2);

				// Discard Old State
				History.discardState(oldState,newState,previousState);

				// Alias to PushState
				History.pushState(newState.data,newState.title,newState.url,false);

				// End replaceState closure
				return true;
			};

		} // History.emulated.pushState



		// ====================================================================
		// Initialise

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/**
			 * Ensure initial state is handled correctly
			 */
			if ( History.getHash() && !History.emulated.hashChange ) {
				History.Adapter.onDomLoad(function(){
					History.Adapter.trigger(window,'hashchange');
				});
			}

		} // History.emulated.pushState

	}; // History.initHtml4

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);
/**
 * History.js Core
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		console = window.console||undefined, // Prevent a JSLint complain
		document = window.document, // Make sure we are using the correct document
		navigator = window.navigator, // Make sure we are using the correct navigator
		sessionStorage = window.sessionStorage||false, // sessionStorage
		setTimeout = window.setTimeout,
		clearTimeout = window.clearTimeout,
		setInterval = window.setInterval,
		clearInterval = window.clearInterval,
		JSON = window.JSON,
		alert = window.alert,
		History = window.History = window.History||{}, // Public History Object
		history = window.history; // Old History Object

	// MooTools Compatibility
	JSON.stringify = JSON.stringify||JSON.encode;
	JSON.parse = JSON.parse||JSON.decode;

	// Check Existence
	if ( typeof History.init !== 'undefined' ) {
		throw new Error('History.js Core has already been loaded...');
	}

	// Initialise History
	History.init = function(){
		// Check Load Status of Adapter
		if ( typeof History.Adapter === 'undefined' ) {
			return false;
		}

		// Check Load Status of Core
		if ( typeof History.initCore !== 'undefined' ) {
			History.initCore();
		}

		// Check Load Status of HTML4 Support
		if ( typeof History.initHtml4 !== 'undefined' ) {
			History.initHtml4();
		}

		// Return true
		return true;
	};


	// ========================================================================
	// Initialise Core

	// Initialise Core
	History.initCore = function(){
		// Initialise
		if ( typeof History.initCore.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initCore.initialized = true;
		}


		// ====================================================================
		// Options

		/**
		 * History.options
		 * Configurable options
		 */
		History.options = History.options||{};

		/**
		 * History.options.hashChangeInterval
		 * How long should the interval be before hashchange checks
		 */
		History.options.hashChangeInterval = History.options.hashChangeInterval || 100;

		/**
		 * History.options.safariPollInterval
		 * How long should the interval be before safari poll checks
		 */
		History.options.safariPollInterval = History.options.safariPollInterval || 500;

		/**
		 * History.options.doubleCheckInterval
		 * How long should the interval be before we perform a double check
		 */
		History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;

		/**
		 * History.options.storeInterval
		 * How long should we wait between store calls
		 */
		History.options.storeInterval = History.options.storeInterval || 1000;

		/**
		 * History.options.busyDelay
		 * How long should we wait between busy events
		 */
		History.options.busyDelay = History.options.busyDelay || 250;

		/**
		 * History.options.debug
		 * If true will enable debug messages to be logged
		 */
		History.options.debug = History.options.debug || false;

		/**
		 * History.options.initialTitle
		 * What is the title of the initial state
		 */
		History.options.initialTitle = History.options.initialTitle || document.title;


		// ====================================================================
		// Interval record

		/**
		 * History.intervalList
		 * List of intervals set, to be cleared when document is unloaded.
		 */
		History.intervalList = [];

		/**
		 * History.clearAllIntervals
		 * Clears all setInterval instances.
		 */
		History.clearAllIntervals = function(){
			var i, il = History.intervalList;
			if (typeof il !== "undefined" && il !== null) {
				for (i = 0; i < il.length; i++) {
					clearInterval(il[i]);
				}
				History.intervalList = null;
			}
		};


		// ====================================================================
		// Debug

		/**
		 * History.debug(message,...)
		 * Logs the passed arguments if debug enabled
		 */
		History.debug = function(){
			if ( (History.options.debug||false) ) {
				History.log.apply(History,arguments);
			}
		};

		/**
		 * History.log(message,...)
		 * Logs the passed arguments
		 */
		History.log = function(){
			// Prepare
			var
				consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
				textarea = document.getElementById('log'),
				message,
				i,n,
				args,arg
				;

			// Write to Console
			if ( consoleExists ) {
				args = Array.prototype.slice.call(arguments);
				message = args.shift();
				if ( typeof console.debug !== 'undefined' ) {
					console.debug.apply(console,[message,args]);
				}
				else {
					console.log.apply(console,[message,args]);
				}
			}
			else {
				message = ("\n"+arguments[0]+"\n");
			}

			// Write to log
			for ( i=1,n=arguments.length; i<n; ++i ) {
				arg = arguments[i];
				if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
					try {
						arg = JSON.stringify(arg);
					}
					catch ( Exception ) {
						// Recursive Object
					}
				}
				message += "\n"+arg+"\n";
			}

			// Textarea
			if ( textarea ) {
				textarea.value += message+"\n-----\n";
				textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
			}
			// No Textarea, No Console
			else if ( !consoleExists ) {
				alert(message);
			}

			// Return true
			return true;
		};


		// ====================================================================
		// Emulated Status

		/**
		 * History.getInternetExplorerMajorVersion()
		 * Get's the major version of Internet Explorer
		 * @return {integer}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 * @author James Padolsey <https://gist.github.com/527683>
		 */
		History.getInternetExplorerMajorVersion = function(){
			var result = History.getInternetExplorerMajorVersion.cached =
					(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
				?	History.getInternetExplorerMajorVersion.cached
				:	(function(){
						var v = 3,
								div = document.createElement('div'),
								all = div.getElementsByTagName('i');
						while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
						return (v > 4) ? v : false;
					})()
				;
			return result;
		};

		/**
		 * History.isInternetExplorer()
		 * Are we using Internet Explorer?
		 * @return {boolean}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 */
		History.isInternetExplorer = function(){
			var result =
				History.isInternetExplorer.cached =
				(typeof History.isInternetExplorer.cached !== 'undefined')
					?	History.isInternetExplorer.cached
					:	Boolean(History.getInternetExplorerMajorVersion())
				;
			return result;
		};

		/**
		 * History.emulated
		 * Which features require emulating?
		 */
		History.emulated = {
			pushState: !Boolean(
				window.history && window.history.pushState && window.history.replaceState
				&& !(
					(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
					|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
				)
			),
			hashChange: Boolean(
				!(('onhashchange' in window) || ('onhashchange' in document))
				||
				(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
			)
		};

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = !History.emulated.pushState;

		/**
		 * History.bugs
		 * Which bugs are present
		 */
		History.bugs = {
			/**
			 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
			 * https://bugs.webkit.org/show_bug.cgi?id=56249
			 */
			setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
			 * https://bugs.webkit.org/show_bug.cgi?id=42940
			 */
			safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
			 */
			ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),

			/**
			 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
			 */
			hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
		};

		/**
		 * History.isEmptyObject(obj)
		 * Checks to see if the Object is Empty
		 * @param {Object} obj
		 * @return {boolean}
		 */
		History.isEmptyObject = function(obj) {
			for ( var name in obj ) {
				return false;
			}
			return true;
		};

		/**
		 * History.cloneObject(obj)
		 * Clones a object and eliminate all references to the original contexts
		 * @param {Object} obj
		 * @return {Object}
		 */
		History.cloneObject = function(obj) {
			var hash,newObj;
			if ( obj ) {
				hash = JSON.stringify(obj);
				newObj = JSON.parse(hash);
			}
			else {
				newObj = {};
			}
			return newObj;
		};


		// ====================================================================
		// URL Helpers

		/**
		 * History.getRootUrl()
		 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
		 * @return {String} rootUrl
		 */
		History.getRootUrl = function(){
			// Create
			var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
			if ( document.location.port||false ) {
				rootUrl += ':'+document.location.port;
			}
			rootUrl += '/';

			// Return
			return rootUrl;
		};

		/**
		 * History.getBaseHref()
		 * Fetches the `href` attribute of the `<base href="...">` element if it exists
		 * @return {String} baseHref
		 */
		History.getBaseHref = function(){
			// Create
			var
				baseElements = document.getElementsByTagName('base'),
				baseElement = null,
				baseHref = '';

			// Test for Base Element
			if ( baseElements.length === 1 ) {
				// Prepare for Base Element
				baseElement = baseElements[0];
				baseHref = baseElement.href.replace(/[^\/]+$/,'');
			}

			// Adjust trailing slash
			baseHref = baseHref.replace(/\/+$/,'');
			if ( baseHref ) baseHref += '/';

			// Return
			return baseHref;
		};

		/**
		 * History.getBaseUrl()
		 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
		 * @return {String} baseUrl
		 */
		History.getBaseUrl = function(){
			// Create
			var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();

			// Return
			return baseUrl;
		};

		/**
		 * History.getPageUrl()
		 * Fetches the URL of the current page
		 * @return {String} pageUrl
		 */
		History.getPageUrl = function(){
			// Fetch
			var
				State = History.getState(false,false),
				stateUrl = (State||{}).url||document.location.href,
				pageUrl;

			// Create
			pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/\./).test(part) ? part : part+'/';
			});

			// Return
			return pageUrl;
		};

		/**
		 * History.getBasePageUrl()
		 * Fetches the Url of the directory of the current page
		 * @return {String} basePageUrl
		 */
		History.getBasePageUrl = function(){
			// Create
			var basePageUrl = document.location.href.replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/[^\/]$/).test(part) ? '' : part;
			}).replace(/\/+$/,'')+'/';

			// Return
			return basePageUrl;
		};

		/**
		 * History.getFullUrl(url)
		 * Ensures that we have an absolute URL and not a relative URL
		 * @param {string} url
		 * @param {Boolean} allowBaseHref
		 * @return {string} fullUrl
		 */
		History.getFullUrl = function(url,allowBaseHref){
			// Prepare
			var fullUrl = url, firstChar = url.substring(0,1);
			allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;

			// Check
			if ( /[a-z]+\:\/\//.test(url) ) {
				// Full URL
			}
			else if ( firstChar === '/' ) {
				// Root URL
				fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
			}
			else if ( firstChar === '#' ) {
				// Anchor URL
				fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
			}
			else if ( firstChar === '?' ) {
				// Query URL
				fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
			}
			else {
				// Relative URL
				if ( allowBaseHref ) {
					fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
				} else {
					fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
				}
				// We have an if condition above as we do not want hashes
				// which are relative to the baseHref in our URLs
				// as if the baseHref changes, then all our bookmarks
				// would now point to different locations
				// whereas the basePageUrl will always stay the same
			}

			// Return
			return fullUrl.replace(/\#$/,'');
		};

		/**
		 * History.getShortUrl(url)
		 * Ensures that we have a relative URL and not a absolute URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getShortUrl = function(url){
			// Prepare
			var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();

			// Trim baseUrl
			if ( History.emulated.pushState ) {
				// We are in a if statement as when pushState is not emulated
				// The actual url these short urls are relative to can change
				// So within the same session, we the url may end up somewhere different
				shortUrl = shortUrl.replace(baseUrl,'');
			}

			// Trim rootUrl
			shortUrl = shortUrl.replace(rootUrl,'/');

			// Ensure we can still detect it as a state
			if ( History.isTraditionalAnchor(shortUrl) ) {
				shortUrl = './'+shortUrl;
			}

			// Clean It
			shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');

			// Return
			return shortUrl;
		};


		// ====================================================================
		// State Storage

		/**
		 * History.store
		 * The store for all session specific data
		 */
		History.store = {};

		/**
		 * History.idToState
		 * 1-1: State ID to State Object
		 */
		History.idToState = History.idToState||{};

		/**
		 * History.stateToId
		 * 1-1: State String to State ID
		 */
		History.stateToId = History.stateToId||{};

		/**
		 * History.urlToId
		 * 1-1: State URL to State ID
		 */
		History.urlToId = History.urlToId||{};

		/**
		 * History.storedStates
		 * Store the states in an array
		 */
		History.storedStates = History.storedStates||[];

		/**
		 * History.savedStates
		 * Saved the states in an array
		 */
		History.savedStates = History.savedStates||[];

		/**
		 * History.noramlizeStore()
		 * Noramlize the store by adding necessary values
		 */
		History.normalizeStore = function(){
			History.store.idToState = History.store.idToState||{};
			History.store.urlToId = History.store.urlToId||{};
			History.store.stateToId = History.store.stateToId||{};
		};

		/**
		 * History.getState()
		 * Get an object containing the data, title and url of the current state
		 * @param {Boolean} friendly
		 * @param {Boolean} create
		 * @return {Object} State
		 */
		History.getState = function(friendly,create){
			// Prepare
			if ( typeof friendly === 'undefined' ) { friendly = true; }
			if ( typeof create === 'undefined' ) { create = true; }

			// Fetch
			var State = History.getLastSavedState();

			// Create
			if ( !State && create ) {
				State = History.createStateObject();
			}

			// Adjust
			if ( friendly ) {
				State = History.cloneObject(State);
				State.url = State.cleanUrl||State.url;
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByState(State)
		 * Gets a ID for a State
		 * @param {State} newState
		 * @return {String} id
		 */
		History.getIdByState = function(newState){

			// Fetch ID
			var id = History.extractId(newState.url),
				str;
			
			if ( !id ) {
				// Find ID via State String
				str = History.getStateString(newState);
				if ( typeof History.stateToId[str] !== 'undefined' ) {
					id = History.stateToId[str];
				}
				else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
					id = History.store.stateToId[str];
				}
				else {
					// Generate a new ID
					while ( true ) {
						id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
						if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
							break;
						}
					}

					// Apply the new State to the ID
					History.stateToId[str] = id;
					History.idToState[id] = newState;
				}
			}

			// Return ID
			return id;
		};

		/**
		 * History.normalizeState(State)
		 * Expands a State Object
		 * @param {object} State
		 * @return {object}
		 */
		History.normalizeState = function(oldState){
			// Variables
			var newState, dataNotEmpty;

			// Prepare
			if ( !oldState || (typeof oldState !== 'object') ) {
				oldState = {};
			}

			// Check
			if ( typeof oldState.normalized !== 'undefined' ) {
				return oldState;
			}

			// Adjust
			if ( !oldState.data || (typeof oldState.data !== 'object') ) {
				oldState.data = {};
			}

			// ----------------------------------------------------------------

			// Create
			newState = {};
			newState.normalized = true;
			newState.title = oldState.title||'';
			newState.url = History.getFullUrl(History.unescapeString(oldState.url||document.location.href));
			newState.hash = History.getShortUrl(newState.url);
			newState.data = History.cloneObject(oldState.data);

			// Fetch ID
			newState.id = History.getIdByState(newState);

			// ----------------------------------------------------------------

			// Clean the URL
			newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
			newState.url = newState.cleanUrl;

			// Check to see if we have more than just a url
			dataNotEmpty = !History.isEmptyObject(newState.data);

			// Apply
			if ( newState.title || dataNotEmpty ) {
				// Add ID to Hash
				newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
				if ( !/\?/.test(newState.hash) ) {
					newState.hash += '?';
				}
				newState.hash += '&_suid='+newState.id;
			}

			// Create the Hashed URL
			newState.hashedUrl = History.getFullUrl(newState.hash);

			// ----------------------------------------------------------------

			// Update the URL if we have a duplicate
			if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
				newState.url = newState.hashedUrl;
			}

			// ----------------------------------------------------------------

			// Return
			return newState;
		};

		/**
		 * History.createStateObject(data,title,url)
		 * Creates a object based on the data, title and url state params
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {object}
		 */
		History.createStateObject = function(data,title,url){
			// Hashify
			var State = {
				'data': data,
				'title': title,
				'url': url
			};

			// Expand the State
			State = History.normalizeState(State);

			// Return object
			return State;
		};

		/**
		 * History.getStateById(id)
		 * Get a state by it's UID
		 * @param {String} id
		 */
		History.getStateById = function(id){
			// Prepare
			id = String(id);

			// Retrieve
			var State = History.idToState[id] || History.store.idToState[id] || undefined;

			// Return State
			return State;
		};

		/**
		 * Get a State's String
		 * @param {State} passedState
		 */
		History.getStateString = function(passedState){
			// Prepare
			var State, cleanedState, str;

			// Fetch
			State = History.normalizeState(passedState);

			// Clean
			cleanedState = {
				data: State.data,
				title: passedState.title,
				url: passedState.url
			};

			// Fetch
			str = JSON.stringify(cleanedState);

			// Return
			return str;
		};

		/**
		 * Get a State's ID
		 * @param {State} passedState
		 * @return {String} id
		 */
		History.getStateId = function(passedState){
			// Prepare
			var State, id;
			
			// Fetch
			State = History.normalizeState(passedState);

			// Fetch
			id = State.id;

			// Return
			return id;
		};

		/**
		 * History.getHashByState(State)
		 * Creates a Hash for the State Object
		 * @param {State} passedState
		 * @return {String} hash
		 */
		History.getHashByState = function(passedState){
			// Prepare
			var State, hash;
			
			// Fetch
			State = History.normalizeState(passedState);

			// Hash
			hash = State.hash;

			// Return
			return hash;
		};

		/**
		 * History.extractId(url_or_hash)
		 * Get a State ID by it's URL or Hash
		 * @param {string} url_or_hash
		 * @return {string} id
		 */
		History.extractId = function ( url_or_hash ) {
			// Prepare
			var id,parts,url;

			// Extract
			parts = /(.*)\&_suid=([0-9]+)$/.exec(url_or_hash);
			url = parts ? (parts[1]||url_or_hash) : url_or_hash;
			id = parts ? String(parts[2]||'') : '';

			// Return
			return id||false;
		};

		/**
		 * History.isTraditionalAnchor
		 * Checks to see if the url is a traditional anchor or not
		 * @param {String} url_or_hash
		 * @return {Boolean}
		 */
		History.isTraditionalAnchor = function(url_or_hash){
			// Check
			var isTraditional = !(/[\/\?\.]/.test(url_or_hash));

			// Return
			return isTraditional;
		};

		/**
		 * History.extractState
		 * Get a State by it's URL or Hash
		 * @param {String} url_or_hash
		 * @return {State|null}
		 */
		History.extractState = function(url_or_hash,create){
			// Prepare
			var State = null, id, url;
			create = create||false;

			// Fetch SUID
			id = History.extractId(url_or_hash);
			if ( id ) {
				State = History.getStateById(id);
			}

			// Fetch SUID returned no State
			if ( !State ) {
				// Fetch URL
				url = History.getFullUrl(url_or_hash);

				// Check URL
				id = History.getIdByUrl(url)||false;
				if ( id ) {
					State = History.getStateById(id);
				}

				// Create State
				if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
					State = History.createStateObject(null,null,url);
				}
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByUrl()
		 * Get a State ID by a State URL
		 */
		History.getIdByUrl = function(url){
			// Fetch
			var id = History.urlToId[url] || History.store.urlToId[url] || undefined;

			// Return
			return id;
		};

		/**
		 * History.getLastSavedState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastSavedState = function(){
			return History.savedStates[History.savedStates.length-1]||undefined;
		};

		/**
		 * History.getLastStoredState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastStoredState = function(){
			return History.storedStates[History.storedStates.length-1]||undefined;
		};

		/**
		 * History.hasUrlDuplicate
		 * Checks if a Url will have a url conflict
		 * @param {Object} newState
		 * @return {Boolean} hasDuplicate
		 */
		History.hasUrlDuplicate = function(newState) {
			// Prepare
			var hasDuplicate = false,
				oldState;

			// Fetch
			oldState = History.extractState(newState.url);

			// Check
			hasDuplicate = oldState && oldState.id !== newState.id;

			// Return
			return hasDuplicate;
		};

		/**
		 * History.storeState
		 * Store a State
		 * @param {Object} newState
		 * @return {Object} newState
		 */
		History.storeState = function(newState){
			// Store the State
			History.urlToId[newState.url] = newState.id;

			// Push the State
			History.storedStates.push(History.cloneObject(newState));

			// Return newState
			return newState;
		};

		/**
		 * History.isLastSavedState(newState)
		 * Tests to see if the state is the last state
		 * @param {Object} newState
		 * @return {boolean} isLast
		 */
		History.isLastSavedState = function(newState){
			// Prepare
			var isLast = false,
				newId, oldState, oldId;

			// Check
			if ( History.savedStates.length ) {
				newId = newState.id;
				oldState = History.getLastSavedState();
				oldId = oldState.id;

				// Check
				isLast = (newId === oldId);
			}

			// Return
			return isLast;
		};

		/**
		 * History.saveState
		 * Push a State
		 * @param {Object} newState
		 * @return {boolean} changed
		 */
		History.saveState = function(newState){
			// Check Hash
			if ( History.isLastSavedState(newState) ) {
				return false;
			}

			// Push the State
			History.savedStates.push(History.cloneObject(newState));

			// Return true
			return true;
		};

		/**
		 * History.getStateByIndex()
		 * Gets a state by the index
		 * @param {integer} index
		 * @return {Object}
		 */
		History.getStateByIndex = function(index){
			// Prepare
			var State = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				State = History.savedStates[History.savedStates.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				State = History.savedStates[History.savedStates.length+index];
			}
			else {
				// Get from the beginning
				State = History.savedStates[index];
			}

			// Return State
			return State;
		};


		// ====================================================================
		// Hash Helpers

		/**
		 * History.getHash()
		 * Gets the current document hash
		 * @return {string}
		 */
		History.getHash = function(){
			var hash = History.unescapeHash(document.location.hash);
			return hash;
		};

		/**
		 * History.unescapeString()
		 * Unescape a string
		 * @param {String} str
		 * @return {string}
		 */
		History.unescapeString = function(str){
			// Prepare
			var result = str,
				tmp;

			// Unescape hash
			while ( true ) {
				tmp = window.unescape(result);
				if ( tmp === result ) {
					break;
				}
				result = tmp;
			}

			// Return result
			return result;
		};

		/**
		 * History.unescapeHash()
		 * normalize and Unescape a Hash
		 * @param {String} hash
		 * @return {string}
		 */
		History.unescapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Unescape hash
			result = History.unescapeString(result);

			// Return result
			return result;
		};

		/**
		 * History.normalizeHash()
		 * normalize a hash across browsers
		 * @return {string}
		 */
		History.normalizeHash = function(hash){
			// Prepare
			var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');

			// Return result
			return result;
		};

		/**
		 * History.setHash(hash)
		 * Sets the document hash
		 * @param {string} hash
		 * @return {History}
		 */
		History.setHash = function(hash,queue){
			// Prepare
			var adjustedHash, State, pageUrl;

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.setHash: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.setHash,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Log
			//History.debug('History.setHash: called',hash);

			// Prepare
			adjustedHash = History.escapeHash(hash);

			// Make Busy + Continue
			History.busy(true);

			// Check if hash is a state
			State = History.extractState(hash,true);
			if ( State && !History.emulated.pushState ) {
				// Hash is a state so skip the setHash
				//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);

				// PushState
				History.pushState(State.data,State.title,State.url,false);
			}
			else if ( document.location.hash !== adjustedHash ) {
				// Hash is a proper hash, so apply it

				// Handle browser bugs
				if ( History.bugs.setHash ) {
					// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249

					// Fetch the base page
					pageUrl = History.getPageUrl();

					// Safari hash apply
					History.pushState(null,null,pageUrl+'#'+adjustedHash,false);
				}
				else {
					// Normal hash apply
					document.location.hash = adjustedHash;
				}
			}

			// Chain
			return History;
		};

		/**
		 * History.escape()
		 * normalize and Escape a Hash
		 * @return {string}
		 */
		History.escapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Escape hash
			result = window.escape(result);

			// IE6 Escape Bug
			if ( !History.bugs.hashEscape ) {
				// Restore common parts
				result = result
					.replace(/\%21/g,'!')
					.replace(/\%26/g,'&')
					.replace(/\%3D/g,'=')
					.replace(/\%3F/g,'?');
			}

			// Return result
			return result;
		};

		/**
		 * History.getHashByUrl(url)
		 * Extracts the Hash from a URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getHashByUrl = function(url){
			// Extract the hash
			var hash = String(url)
				.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
				;

			// Unescape hash
			hash = History.unescapeHash(hash);

			// Return hash
			return hash;
		};

		/**
		 * History.setTitle(title)
		 * Applies the title to the document
		 * @param {State} newState
		 * @return {Boolean}
		 */
		History.setTitle = function(newState){
			// Prepare
			var title = newState.title,
				firstState;

			// Initial
			if ( !title ) {
				firstState = History.getStateByIndex(0);
				if ( firstState && firstState.url === newState.url ) {
					title = firstState.title||History.options.initialTitle;
				}
			}

			// Apply
			try {
				document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
			}
			catch ( Exception ) { }
			document.title = title;

			// Chain
			return History;
		};


		// ====================================================================
		// Queueing

		/**
		 * History.queues
		 * The list of queues to use
		 * First In, First Out
		 */
		History.queues = [];

		/**
		 * History.busy(value)
		 * @param {boolean} value [optional]
		 * @return {boolean} busy
		 */
		History.busy = function(value){
			// Apply
			if ( typeof value !== 'undefined' ) {
				//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
				History.busy.flag = value;
			}
			// Default
			else if ( typeof History.busy.flag === 'undefined' ) {
				History.busy.flag = false;
			}

			// Queue
			if ( !History.busy.flag ) {
				// Execute the next item in the queue
				clearTimeout(History.busy.timeout);
				var fireNext = function(){
					var i, queue, item;
					if ( History.busy.flag ) return;
					for ( i=History.queues.length-1; i >= 0; --i ) {
						queue = History.queues[i];
						if ( queue.length === 0 ) continue;
						item = queue.shift();
						History.fireQueueItem(item);
						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
					}
				};
				History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
			}

			// Return
			return History.busy.flag;
		};

		/**
		 * History.busy.flag
		 */
		History.busy.flag = false;

		/**
		 * History.fireQueueItem(item)
		 * Fire a Queue Item
		 * @param {Object} item
		 * @return {Mixed} result
		 */
		History.fireQueueItem = function(item){
			return item.callback.apply(item.scope||History,item.args||[]);
		};

		/**
		 * History.pushQueue(callback,args)
		 * Add an item to the queue
		 * @param {Object} item [scope,callback,args,queue]
		 */
		History.pushQueue = function(item){
			// Prepare the queue
			History.queues[item.queue||0] = History.queues[item.queue||0]||[];

			// Add to the queue
			History.queues[item.queue||0].push(item);

			// Chain
			return History;
		};

		/**
		 * History.queue (item,queue), (func,queue), (func), (item)
		 * Either firs the item now if not busy, or adds it to the queue
		 */
		History.queue = function(item,queue){
			// Prepare
			if ( typeof item === 'function' ) {
				item = {
					callback: item
				};
			}
			if ( typeof queue !== 'undefined' ) {
				item.queue = queue;
			}

			// Handle
			if ( History.busy() ) {
				History.pushQueue(item);
			} else {
				History.fireQueueItem(item);
			}

			// Chain
			return History;
		};

		/**
		 * History.clearQueue()
		 * Clears the Queue
		 */
		History.clearQueue = function(){
			History.busy.flag = false;
			History.queues = [];
			return History;
		};


		// ====================================================================
		// IE Bug Fix

		/**
		 * History.stateChanged
		 * States whether or not the state has changed since the last double check was initialised
		 */
		History.stateChanged = false;

		/**
		 * History.doubleChecker
		 * Contains the timeout used for the double checks
		 */
		History.doubleChecker = false;

		/**
		 * History.doubleCheckComplete()
		 * Complete a double check
		 * @return {History}
		 */
		History.doubleCheckComplete = function(){
			// Update
			History.stateChanged = true;

			// Clear
			History.doubleCheckClear();

			// Chain
			return History;
		};

		/**
		 * History.doubleCheckClear()
		 * Clear a double check
		 * @return {History}
		 */
		History.doubleCheckClear = function(){
			// Clear
			if ( History.doubleChecker ) {
				clearTimeout(History.doubleChecker);
				History.doubleChecker = false;
			}

			// Chain
			return History;
		};

		/**
		 * History.doubleCheck()
		 * Create a double check
		 * @return {History}
		 */
		History.doubleCheck = function(tryAgain){
			// Reset
			History.stateChanged = false;
			History.doubleCheckClear();

			// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
			// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
			if ( History.bugs.ieDoubleCheck ) {
				// Apply Check
				History.doubleChecker = setTimeout(
					function(){
						History.doubleCheckClear();
						if ( !History.stateChanged ) {
							//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
							// Re-Attempt
							tryAgain();
						}
						return true;
					},
					History.options.doubleCheckInterval
				);
			}

			// Chain
			return History;
		};


		// ====================================================================
		// Safari Bug Fix

		/**
		 * History.safariStatePoll()
		 * Poll the current state
		 * @return {History}
		 */
		History.safariStatePoll = function(){
			// Poll the URL

			// Get the Last State which has the new URL
			var
				urlState = History.extractState(document.location.href),
				newState;

			// Check for a difference
			if ( !History.isLastSavedState(urlState) ) {
				newState = urlState;
			}
			else {
				return;
			}

			// Check if we have a state with that url
			// If not create it
			if ( !newState ) {
				//History.debug('History.safariStatePoll: new');
				newState = History.createStateObject();
			}

			// Apply the New State
			//History.debug('History.safariStatePoll: trigger');
			History.Adapter.trigger(window,'popstate');

			// Chain
			return History;
		};


		// ====================================================================
		// State Aliases

		/**
		 * History.back(queue)
		 * Send the browser history back one item
		 * @param {Integer} queue [optional]
		 */
		History.back = function(queue){
			//History.debug('History.back: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.back: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.back,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.back(false);
			});

			// Go back
			history.go(-1);

			// End back closure
			return true;
		};

		/**
		 * History.forward(queue)
		 * Send the browser history forward one item
		 * @param {Integer} queue [optional]
		 */
		History.forward = function(queue){
			//History.debug('History.forward: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.forward: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.forward,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.forward(false);
			});

			// Go forward
			history.go(1);

			// End forward closure
			return true;
		};

		/**
		 * History.go(index,queue)
		 * Send the browser history back or forward index times
		 * @param {Integer} queue [optional]
		 */
		History.go = function(index,queue){
			//History.debug('History.go: called', arguments);

			// Prepare
			var i;

			// Handle
			if ( index > 0 ) {
				// Forward
				for ( i=1; i<=index; ++i ) {
					History.forward(queue);
				}
			}
			else if ( index < 0 ) {
				// Backward
				for ( i=-1; i>=index; --i ) {
					History.back(queue);
				}
			}
			else {
				throw new Error('History.go: History.go requires a positive or negative integer passed.');
			}

			// Chain
			return History;
		};


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * Provide Skeleton for HTML4 Browsers
			 */

			// Prepare
			var emptyFunction = function(){};
			History.pushState = History.pushState||emptyFunction;
			History.replaceState = History.replaceState||emptyFunction;
		} // History.emulated.pushState

		// Native pushState Implementation
		else {
			/*
			 * Use native HTML5 History API Implementation
			 */

			/**
			 * History.onPopState(event,extra)
			 * Refresh the Current State
			 */
			History.onPopState = function(event,extra){
				// Prepare
				var stateId = false, newState = false, currentHash, currentState;

				// Reset the double check
				History.doubleCheckComplete();

				// Check for a Hash, and handle apporiatly
				currentHash	= History.getHash();
				if ( currentHash ) {
					// Expand Hash
					currentState = History.extractState(currentHash||document.location.href,true);
					if ( currentState ) {
						// We were able to parse it, it must be a State!
						// Let's forward to replaceState
						//History.debug('History.onPopState: state anchor', currentHash, currentState);
						History.replaceState(currentState.data, currentState.title, currentState.url, false);
					}
					else {
						// Traditional Anchor
						//History.debug('History.onPopState: traditional anchor', currentHash);
						History.Adapter.trigger(window,'anchorchange');
						History.busy(false);
					}

					// We don't care for hashes
					History.expectedStateId = false;
					return false;
				}

				// Ensure
				stateId = History.Adapter.extractEventData('state',event,extra) || false;

				// Fetch State
				if ( stateId ) {
					// Vanilla: Back/forward button was used
					newState = History.getStateById(stateId);
				}
				else if ( History.expectedStateId ) {
					// Vanilla: A new state was pushed, and popstate was called manually
					newState = History.getStateById(History.expectedStateId);
				}
				else {
					// Initial State
					newState = History.extractState(document.location.href);
				}

				// The State did not exist in our store
				if ( !newState ) {
					// Regenerate the State
					newState = History.createStateObject(null,null,document.location.href);
				}

				// Clean
				History.expectedStateId = false;

				// Check if we are the same state
				if ( History.isLastSavedState(newState) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onPopState: no change', newState, History.savedStates);
					History.busy(false);
					return false;
				}

				// Store the State
				History.storeState(newState);
				History.saveState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Fire Our Event
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// Return true
				return true;
			};
			History.Adapter.bind(window,'popstate',History.onPopState);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.pushState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.replaceState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End replaceState closure
				return true;
			};

		} // !History.emulated.pushState


		// ====================================================================
		// Initialise

		/**
		 * Load the Store
		 */
		if ( sessionStorage ) {
			// Fetch
			try {
				History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
			}
			catch ( err ) {
				History.store = {};
			}

			// Normalize
			History.normalizeStore();
		}
		else {
			// Default Load
			History.store = {};
			History.normalizeStore();
		}

		/**
		 * Clear Intervals on exit to prevent memory leaks
		 */
		History.Adapter.bind(window,"beforeunload",History.clearAllIntervals);
		History.Adapter.bind(window,"unload",History.clearAllIntervals);

		/**
		 * Create the initial State
		 */
		History.saveState(History.storeState(History.extractState(document.location.href,true)));

		/**
		 * Bind for Saving Store
		 */
		if ( sessionStorage ) {
			// When the page is closed
			History.onUnload = function(){
				// Prepare
				var	currentStore, item;

				// Fetch
				try {
					currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
				}
				catch ( err ) {
					currentStore = {};
				}

				// Ensure
				currentStore.idToState = currentStore.idToState || {};
				currentStore.urlToId = currentStore.urlToId || {};
				currentStore.stateToId = currentStore.stateToId || {};

				// Sync
				for ( item in History.idToState ) {
					if ( !History.idToState.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.idToState[item] = History.idToState[item];
				}
				for ( item in History.urlToId ) {
					if ( !History.urlToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.urlToId[item] = History.urlToId[item];
				}
				for ( item in History.stateToId ) {
					if ( !History.stateToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.stateToId[item] = History.stateToId[item];
				}

				// Update
				History.store = currentStore;
				History.normalizeStore();

				// Store
				sessionStorage.setItem('History.store',JSON.stringify(currentStore));
			};

			// For Internet Explorer
			History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));
			
			// For Other Browsers
			History.Adapter.bind(window,'beforeunload',History.onUnload);
			History.Adapter.bind(window,'unload',History.onUnload);
			
			// Both are enabled for consistency
		}

		// Non-Native pushState Implementation
		if ( !History.emulated.pushState ) {
			// Be aware, the following is only for native pushState implementations
			// If you are wanting to include something for all browsers
			// Then include it above this if block

			/**
			 * Setup Safari Fix
			 */
			if ( History.bugs.safariPoll ) {
				History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
			}

			/**
			 * Ensure Cross Browser Compatibility
			 */
			if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
				/**
				 * Fix Safari HashChange Issue
				 */

				// Setup Alias
				History.Adapter.bind(window,'hashchange',function(){
					History.Adapter.trigger(window,'popstate');
				});

				// Initialise Alias
				if ( History.getHash() ) {
					History.Adapter.onDomLoad(function(){
						History.Adapter.trigger(window,'hashchange');
					});
				}
			}

		} // !History.emulated.pushState


	}; // History.initCore

	// Try and Initialise History
	History.init();

})(window);
var timestamps = []; // Array of unique timestamps.

$.fn.route = function(options) {

	if (this.is("a")) {

        var title = this.attr('title'),
            appendTitle = $.joomla.appendTitle;

        if (appendTitle==="before") {
            title = $.joomla.sitename + ((title) ? " - " + title : "");
        }

        if (appendTitle==="after") {
            title = ((title) ? title + " - " : "") + $.joomla.sitename;
        }

        // Creating a unique timestamp that will be associated with the state.
        var t = new Date().getTime();
        timestamps[t] = t;

		History.pushState($.extend({timestamp: t, refresh: true}, options), title , this.attr("href"));
	}

	return this;
}

History.Adapter.bind(window,'statechange',function(){

    var state = History.getState();

    // Fixed back button not refreshing when
    // state is in the first state in navigation history.
    if (state.id===History.savedStates[0].id) {
        window.location = state.url;
    }

    if(state.data.timestamp in timestamps) {
        // Deleting the unique timestamp associated with the state
        delete timestamps[state.data.timestamp];
    }
    else{
    	if (state.data.refresh) {
    		window.location = state.url;
    	}
    }
});
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("history", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * Masonry PACKAGED v3.1.5
 * Cascading grid layout library
 * http://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

/**
 * Bridget makes jQuery widgets
 * v1.0.1
 */

( function( window ) {

// Nullify define
var define = null;

// -------------------------- utils -------------------------- //

var slice = Array.prototype.slice;

function noop() {}

// -------------------------- definition -------------------------- //

function defineBridget( $ ) {

  // bail if no jQuery
  if ( !$ ) {
    return;
  }

  // -------------------------- addOptionMethod -------------------------- //

  /**
   * adds option method -> $().plugin('option', {...})
   * @param {Function} PluginClass - constructor class
   */
  function addOptionMethod( PluginClass ) {
    // don't overwrite original option method
    if ( PluginClass.prototype.option ) {
      return;
    }

    // option setter
    PluginClass.prototype.option = function( opts ) {
      // bail out if not an object
      if ( !$.isPlainObject( opts ) ){
        return;
      }
      this.options = $.extend( true, this.options, opts );
    };
  }


  // -------------------------- plugin bridge -------------------------- //

  // helper function for logging errors
  // $.error breaks jQuery chaining
  var logError = typeof console === 'undefined' ? noop :
    function( message ) {
      console.error( message );
    };

  /**
   * jQuery plugin bridge, access methods like $elem.plugin('method')
   * @param {String} namespace - plugin name
   * @param {Function} PluginClass - constructor class
   */
  function bridge( namespace, PluginClass ) {
    // add to jQuery fn namespace
    $.fn[ namespace ] = function( options ) {
      if ( typeof options === 'string' ) {
        // call plugin method when first argument is a string
        // get arguments for method
        var args = slice.call( arguments, 1 );

        for ( var i=0, len = this.length; i < len; i++ ) {
          var elem = this[i];
          var instance = $.data( elem, namespace );
          if ( !instance ) {
            logError( "cannot call methods on " + namespace + " prior to initialization; " +
              "attempted to call '" + options + "'" );
            continue;
          }
          if ( !$.isFunction( instance[options] ) || options.charAt(0) === '_' ) {
            logError( "no such method '" + options + "' for " + namespace + " instance" );
            continue;
          }

          // trigger method with arguments
          var returnValue = instance[ options ].apply( instance, args );

          // break look and return first value if provided
          if ( returnValue !== undefined ) {
            return returnValue;
          }
        }
        // return this if no return value
        return this;
      } else {
        return this.each( function() {
          var instance = $.data( this, namespace );
          if ( instance ) {
            // apply options & init
            instance.option( options );
            instance._init();
          } else {
            // initialize new instance
            instance = new PluginClass( this, options );
            $.data( this, namespace, instance );
          }
        });
      }
    };

  }

  // -------------------------- bridget -------------------------- //

  /**
   * converts a Prototypical class into a proper jQuery plugin
   *   the class must have a ._init method
   * @param {String} namespace - plugin name, used in $().pluginName
   * @param {Function} PluginClass - constructor class
   */
  $.bridget = function( namespace, PluginClass ) {

    addOptionMethod( PluginClass );
    bridge( namespace, PluginClass );
  };

  return $.bridget;

}

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( 'jquery-bridget/jquery.bridget',[ 'jquery' ], defineBridget );
} else {
  // get jquery from browser global
  defineBridget($);
}

})( window );

/*!
 * eventie v1.0.5
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false, module: false */

( function( window ) {



var docElem = document.documentElement;

var bind = function() {};

function getIEEvent( obj ) {
  var event = window.event;
  // add event.target
  event.target = event.target || event.srcElement || obj;
  return event;
}

if ( docElem.addEventListener ) {
  bind = function( obj, type, fn ) {
    obj.addEventListener( type, fn, false );
  };
} else if ( docElem.attachEvent ) {
  bind = function( obj, type, fn ) {
    obj[ type + fn ] = fn.handleEvent ?
      function() {
        var event = getIEEvent( obj );
        fn.handleEvent.call( fn, event );
      } :
      function() {
        var event = getIEEvent( obj );
        fn.call( obj, event );
      };
    obj.attachEvent( "on" + type, obj[ type + fn ] );
  };
}

var unbind = function() {};

if ( docElem.removeEventListener ) {
  unbind = function( obj, type, fn ) {
    obj.removeEventListener( type, fn, false );
  };
} else if ( docElem.detachEvent ) {
  unbind = function( obj, type, fn ) {
    obj.detachEvent( "on" + type, obj[ type + fn ] );
    try {
      delete obj[ type + fn ];
    } catch ( err ) {
      // can't delete window object properties
      obj[ type + fn ] = undefined;
    }
  };
}

var eventie = {
  bind: bind,
  unbind: unbind
};

// ----- module definition ----- //

if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( 'eventie/eventie',eventie );
} else if ( typeof exports === 'object' ) {
  // CommonJS
  module.exports = eventie;
} else {
  // browser global
  window.eventie = eventie;
}

})( this );

/*!
 * docReady
 * Cross browser DOMContentLoaded event emitter
 */

/*jshint browser: true, strict: true, undef: true, unused: true*/
/*global define: false */

( function( window ) {



var document = window.document;
// collection of functions to be triggered on ready
var queue = [];

function docReady( fn ) {
  // throw out non-functions
  if ( typeof fn !== 'function' ) {
    return;
  }

  if ( docReady.isReady ) {
    // ready now, hit it
    fn();
  } else {
    // queue function when ready
    queue.push( fn );
  }
}

docReady.isReady = false;

// triggered on various doc ready events
function init( event ) {
  // bail if IE8 document is not ready just yet
  var isIE8NotReady = event.type === 'readystatechange' && document.readyState !== 'complete';
  if ( docReady.isReady || isIE8NotReady ) {
    return;
  }
  docReady.isReady = true;

  // process queue
  for ( var i=0, len = queue.length; i < len; i++ ) {
    var fn = queue[i];
    fn();
  }
}

function defineDocReady( eventie ) {
  eventie.bind( document, 'DOMContentLoaded', init );
  eventie.bind( document, 'readystatechange', init );
  eventie.bind( window, 'load', init );

  return docReady;
}

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  // if RequireJS, then doc is already ready
  docReady.isReady = typeof requirejs === 'function';
  define( 'doc-ready/doc-ready',[ 'eventie/eventie' ], defineDocReady );
} else {
  // browser global
  window.docReady = defineDocReady( window.eventie );
}

})( this );

/*!
 * EventEmitter v4.2.7 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function () {


    /**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */
    function EventEmitter() {}

    // Shortcuts to improve speed and size
    var proto = EventEmitter.prototype;
    var exports = this;
    var originalGlobalValue = exports.EventEmitter;

    /**
     * Finds the index of the listener for the event in it's storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */
    function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
            if (listeners[i].listener === listener) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */
    function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }

    /**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */
    proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;

        // Return a concatenated array of all matching events if
        // the selector is a regular expression.
        if (evt instanceof RegExp) {
            response = {};
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                }
            }
        }
        else {
            response = events[evt] || (events[evt] = []);
        }

        return response;
    };

    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */
    proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;

        for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
        }

        return flatListeners;
    };

    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */
    proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;

        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }

        return response || listeners;
    };

    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListener = function addListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === 'object';
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                listeners[key].push(listenerIsWrapped ? listener : {
                    listener: listener,
                    once: false
                });
            }
        }

        return this;
    };

    /**
     * Alias of addListener
     */
    proto.on = alias('addListener');

    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after it's first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };

    /**
     * Alias of addOnceListener.
     */
    proto.once = alias('addOnceListener');

    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };

    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
        }
        return this;
    };

    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                index = indexOfListener(listeners[key], listener);

                if (index !== -1) {
                    listeners[key].splice(index, 1);
                }
            }
        }

        return this;
    };

    /**
     * Alias of removeListener
     */
    proto.off = alias('removeListener');

    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListeners = function addListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(false, evt, listeners);
    };

    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListeners = function removeListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(true, evt, listeners);
    };

    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;

        // If evt is an object then pass each of it's properties to this method
        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
                if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    // Pass the single listener straight through to the singular method
                    if (typeof value === 'function') {
                        single.call(this, i, value);
                    }
                    else {
                        // Otherwise pass back to the multiple function
                        multiple.call(this, i, value);
                    }
                }
            }
        }
        else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;
            while (i--) {
                single.call(this, evt, listeners[i]);
            }
        }

        return this;
    };

    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;

        // Remove different things depending on the state of evt
        if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt];
        }
        else if (evt instanceof RegExp) {
            // Remove all events matching the regex.
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                }
            }
        }
        else {
            // Remove all listeners in all events
            delete this._events;
        }

        return this;
    };

    /**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */
    proto.removeAllListeners = alias('removeEvent');

    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emitEvent = function emitEvent(evt, args) {
        var listeners = this.getListenersAsObject(evt);
        var listener;
        var i;
        var key;
        var response;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                i = listeners[key].length;

                while (i--) {
                    // If the listener returns true then it shall be removed from the event
                    // The function is executed either with a basic call or an apply if there is an args array
                    listener = listeners[key][i];

                    if (listener.once === true) {
                        this.removeListener(evt, listener.listener);
                    }

                    response = listener.listener.apply(this, args || []);

                    if (response === this._getOnceReturnValue()) {
                        this.removeListener(evt, listener.listener);
                    }
                }
            }
        }

        return this;
    };

    /**
     * Alias of emitEvent
     */
    proto.trigger = alias('emitEvent');

    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };

    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };

    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */
    proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue;
        }
        else {
            return true;
        }
    };

    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */
    proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };

    /**
     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
     *
     * @return {Function} Non conflicting EventEmitter class.
     */
    EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
    };

    // Expose the class either via AMD, CommonJS or the global object
    if (typeof define === 'function' && define.amd) {
        define('eventEmitter/EventEmitter',[],function () {
            return EventEmitter;
        });
    }
    else if (typeof module === 'object' && module.exports){
        module.exports = EventEmitter;
    }
    else {
        this.EventEmitter = EventEmitter;
    }
}.call(this));

/*!
 * getStyleProperty v1.0.3
 * original by kangax
 * http://perfectionkills.com/feature-testing-css-properties/
 */

/*jshint browser: true, strict: true, undef: true */
/*global define: false, exports: false, module: false */

( function( window ) {



var prefixes = 'Webkit Moz ms Ms O'.split(' ');
var docElemStyle = document.documentElement.style;

function getStyleProperty( propName ) {
  if ( !propName ) {
    return;
  }

  // test standard property first
  if ( typeof docElemStyle[ propName ] === 'string' ) {
    return propName;
  }

  // capitalize
  propName = propName.charAt(0).toUpperCase() + propName.slice(1);

  // test vendor specific properties
  var prefixed;
  for ( var i=0, len = prefixes.length; i < len; i++ ) {
    prefixed = prefixes[i] + propName;
    if ( typeof docElemStyle[ prefixed ] === 'string' ) {
      return prefixed;
    }
  }
}

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( 'get-style-property/get-style-property',[],function() {
    return getStyleProperty;
  });
} else if ( typeof exports === 'object' ) {
  // CommonJS for Component
  module.exports = getStyleProperty;
} else {
  // browser global
  window.getStyleProperty = getStyleProperty;
}

})( window );

/**
 * getSize v1.1.7
 * measure size of elements
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, exports: false, require: false, module: false */

( function( window, undefined ) {



// -------------------------- helpers -------------------------- //

var getComputedStyle = window.getComputedStyle;
var getStyle = getComputedStyle ?
  function( elem ) {
    return getComputedStyle( elem, null );
  } :
  function( elem ) {
    return elem.currentStyle;
  };

// get a number from a string, not a percentage
function getStyleSize( value ) {
  var num = parseFloat( value );
  // not a percent like '100%', and a number
  var isValid = value.indexOf('%') === -1 && !isNaN( num );
  return isValid && num;
}

// -------------------------- measurements -------------------------- //

var measurements = [
  'paddingLeft',
  'paddingRight',
  'paddingTop',
  'paddingBottom',
  'marginLeft',
  'marginRight',
  'marginTop',
  'marginBottom',
  'borderLeftWidth',
  'borderRightWidth',
  'borderTopWidth',
  'borderBottomWidth'
];

function getZeroSize() {
  var size = {
    width: 0,
    height: 0,
    innerWidth: 0,
    innerHeight: 0,
    outerWidth: 0,
    outerHeight: 0
  };
  for ( var i=0, len = measurements.length; i < len; i++ ) {
    var measurement = measurements[i];
    size[ measurement ] = 0;
  }
  return size;
}



function defineGetSize( getStyleProperty ) {

// -------------------------- box sizing -------------------------- //

var boxSizingProp = getStyleProperty('boxSizing');
var isBoxSizeOuter;

/**
 * WebKit measures the outer-width on style.width on border-box elems
 * IE & Firefox measures the inner-width
 */
( function() {
  if ( !boxSizingProp ) {
    return;
  }

  var div = document.createElement('div');
  div.style.width = '200px';
  div.style.padding = '1px 2px 3px 4px';
  div.style.borderStyle = 'solid';
  div.style.borderWidth = '1px 2px 3px 4px';
  div.style[ boxSizingProp ] = 'border-box';

  var body = document.body || document.documentElement;
  body.appendChild( div );
  var style = getStyle( div );

  isBoxSizeOuter = getStyleSize( style.width ) === 200;
  body.removeChild( div );
})();


// -------------------------- getSize -------------------------- //

function getSize( elem ) {
  // use querySeletor if elem is string
  if ( typeof elem === 'string' ) {
    elem = document.querySelector( elem );
  }

  // do not proceed on non-objects
  if ( !elem || typeof elem !== 'object' || !elem.nodeType ) {
    return;
  }

  var style = getStyle( elem );

  // if hidden, everything is 0
  if ( style.display === 'none' ) {
    return getZeroSize();
  }

  var size = {};
  size.width = elem.offsetWidth;
  size.height = elem.offsetHeight;

  var isBorderBox = size.isBorderBox = !!( boxSizingProp &&
    style[ boxSizingProp ] && style[ boxSizingProp ] === 'border-box' );

  // get all measurements
  for ( var i=0, len = measurements.length; i < len; i++ ) {
    var measurement = measurements[i];
    var value = style[ measurement ];
    value = mungeNonPixel( elem, value );
    var num = parseFloat( value );
    // any 'auto', 'medium' value will be 0
    size[ measurement ] = !isNaN( num ) ? num : 0;
  }

  var paddingWidth = size.paddingLeft + size.paddingRight;
  var paddingHeight = size.paddingTop + size.paddingBottom;
  var marginWidth = size.marginLeft + size.marginRight;
  var marginHeight = size.marginTop + size.marginBottom;
  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
  var borderHeight = size.borderTopWidth + size.borderBottomWidth;

  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

  // overwrite width and height if we can get it from style
  var styleWidth = getStyleSize( style.width );
  if ( styleWidth !== false ) {
    size.width = styleWidth +
      // add padding and border unless it's already including it
      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
  }

  var styleHeight = getStyleSize( style.height );
  if ( styleHeight !== false ) {
    size.height = styleHeight +
      // add padding and border unless it's already including it
      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
  }

  size.innerWidth = size.width - ( paddingWidth + borderWidth );
  size.innerHeight = size.height - ( paddingHeight + borderHeight );

  size.outerWidth = size.width + marginWidth;
  size.outerHeight = size.height + marginHeight;

  return size;
}

// IE8 returns percent values, not pixels
// taken from jQuery's curCSS
function mungeNonPixel( elem, value ) {
  // IE8 and has percent value
  if ( getComputedStyle || value.indexOf('%') === -1 ) {
    return value;
  }
  var style = elem.style;
  // Remember the original values
  var left = style.left;
  var rs = elem.runtimeStyle;
  var rsLeft = rs && rs.left;

  // Put in the new values to get a computed value out
  if ( rsLeft ) {
    rs.left = elem.currentStyle.left;
  }
  style.left = value;
  value = style.pixelLeft;

  // Revert the changed values
  style.left = left;
  if ( rsLeft ) {
    rs.left = rsLeft;
  }

  return value;
}

return getSize;

}

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD for RequireJS
  define( 'get-size/get-size',[ 'get-style-property/get-style-property' ], defineGetSize );
} else if ( typeof exports === 'object' ) {
  // CommonJS for Component
  module.exports = defineGetSize( require('get-style-property') );
} else {
  // browser global
  window.getSize = defineGetSize( window.getStyleProperty );
}

})( window );

/**
 * matchesSelector helper v1.0.1
 *
 * @name matchesSelector
 *   @param {Element} elem
 *   @param {String} selector
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false */

( function( global, ElemProto ) {



  var matchesMethod = ( function() {
    // check un-prefixed
    if ( ElemProto.matchesSelector ) {
      return 'matchesSelector';
    }
    // check vendor prefixes
    var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];

    for ( var i=0, len = prefixes.length; i < len; i++ ) {
      var prefix = prefixes[i];
      var method = prefix + 'MatchesSelector';
      if ( ElemProto[ method ] ) {
        return method;
      }
    }
  })();

  // ----- match ----- //

  function match( elem, selector ) {
    return elem[ matchesMethod ]( selector );
  }

  // ----- appendToFragment ----- //

  function checkParent( elem ) {
    // not needed if already has parent
    if ( elem.parentNode ) {
      return;
    }
    var fragment = document.createDocumentFragment();
    fragment.appendChild( elem );
  }

  // ----- query ----- //

  // fall back to using QSA
  // thx @jonathantneal https://gist.github.com/3062955
  function query( elem, selector ) {
    // append to fragment if no parent
    checkParent( elem );

    // match elem with all selected elems of parent
    var elems = elem.parentNode.querySelectorAll( selector );
    for ( var i=0, len = elems.length; i < len; i++ ) {
      // return true if match
      if ( elems[i] === elem ) {
        return true;
      }
    }
    // otherwise return false
    return false;
  }

  // ----- matchChild ----- //

  function matchChild( elem, selector ) {
    checkParent( elem );
    return match( elem, selector );
  }

  // ----- matchesSelector ----- //

  var matchesSelector;

  if ( matchesMethod ) {
    // IE9 supports matchesSelector, but doesn't work on orphaned elems
    // check for that
    var div = document.createElement('div');
    var supportsOrphans = match( div, 'div' );
    matchesSelector = supportsOrphans ? match : matchChild;
  } else {
    matchesSelector = query;
  }

  // transport
  if ( typeof define === 'function' && define.amd ) {
    // AMD
    define( 'matches-selector/matches-selector',[],function() {
      return matchesSelector;
    });
  } else {
    // browser global
    window.matchesSelector = matchesSelector;
  }

})( this, Element.prototype );

/**
 * Outlayer Item
 */

( function( window ) {



// ----- get style ----- //

var getComputedStyle = window.getComputedStyle;
var getStyle = getComputedStyle ?
  function( elem ) {
    return getComputedStyle( elem, null );
  } :
  function( elem ) {
    return elem.currentStyle;
  };


// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

function isEmptyObj( obj ) {
  for ( var prop in obj ) {
    return false;
  }
  prop = null;
  return true;
}

// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
function toDash( str ) {
  return str.replace( /([A-Z])/g, function( $1 ){
    return '-' + $1.toLowerCase();
  });
}

// -------------------------- Outlayer definition -------------------------- //

function outlayerItemDefinition( EventEmitter, getSize, getStyleProperty ) {

// -------------------------- CSS3 support -------------------------- //

var transitionProperty = getStyleProperty('transition');
var transformProperty = getStyleProperty('transform');
var supportsCSS3 = transitionProperty && transformProperty;
var is3d = !!getStyleProperty('perspective');

var transitionEndEvent = {
  WebkitTransition: 'webkitTransitionEnd',
  MozTransition: 'transitionend',
  OTransition: 'otransitionend',
  transition: 'transitionend'
}[ transitionProperty ];

// properties that could have vendor prefix
var prefixableProperties = [
  'transform',
  'transition',
  'transitionDuration',
  'transitionProperty'
];

// cache all vendor properties
var vendorProperties = ( function() {
  var cache = {};
  for ( var i=0, len = prefixableProperties.length; i < len; i++ ) {
    var prop = prefixableProperties[i];
    var supportedProp = getStyleProperty( prop );
    if ( supportedProp && supportedProp !== prop ) {
      cache[ prop ] = supportedProp;
    }
  }
  return cache;
})();

// -------------------------- Item -------------------------- //

function Item( element, layout ) {
  if ( !element ) {
    return;
  }

  this.element = element;
  // parent layout class, i.e. Masonry, Isotope, or Packery
  this.layout = layout;
  this.position = {
    x: 0,
    y: 0
  };

  this._create();
}

// inherit EventEmitter
extend( Item.prototype, EventEmitter.prototype );

Item.prototype._create = function() {
  // transition objects
  this._transn = {
    ingProperties: {},
    clean: {},
    onEnd: {}
  };

  this.css({
    position: 'absolute'
  });
};

// trigger specified handler for event type
Item.prototype.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

Item.prototype.getSize = function() {
  this.size = getSize( this.element );
};

/**
 * apply CSS styles to element
 * @param {Object} style
 */
Item.prototype.css = function( style ) {
  var elemStyle = this.element.style;

  for ( var prop in style ) {
    // use vendor property if available
    var supportedProp = vendorProperties[ prop ] || prop;
    elemStyle[ supportedProp ] = style[ prop ];
  }
};

 // measure position, and sets it
Item.prototype.getPosition = function() {
  var style = getStyle( this.element );
  var layoutOptions = this.layout.options;
  var isOriginLeft = layoutOptions.isOriginLeft;
  var isOriginTop = layoutOptions.isOriginTop;
  var x = parseInt( style[ isOriginLeft ? 'left' : 'right' ], 10 );
  var y = parseInt( style[ isOriginTop ? 'top' : 'bottom' ], 10 );

  // clean up 'auto' or other non-integer values
  x = isNaN( x ) ? 0 : x;
  y = isNaN( y ) ? 0 : y;
  // remove padding from measurement
  var layoutSize = this.layout.size;
  x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
  y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

  this.position.x = x;
  this.position.y = y;
};

// set settled position, apply padding
Item.prototype.layoutPosition = function() {
  var layoutSize = this.layout.size;
  var layoutOptions = this.layout.options;
  var style = {};

  if ( layoutOptions.isOriginLeft ) {
    style.left = ( this.position.x + layoutSize.paddingLeft ) + 'px';
    // reset other property
    style.right = '';
  } else {
    style.right = ( this.position.x + layoutSize.paddingRight ) + 'px';
    style.left = '';
  }

  if ( layoutOptions.isOriginTop ) {
    style.top = ( this.position.y + layoutSize.paddingTop ) + 'px';
    style.bottom = '';
  } else {
    style.bottom = ( this.position.y + layoutSize.paddingBottom ) + 'px';
    style.top = '';
  }

  this.css( style );
  this.emitEvent( 'layout', [ this ] );
};


// transform translate function
var translate = is3d ?
  function( x, y ) {
    return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
  } :
  function( x, y ) {
    return 'translate(' + x + 'px, ' + y + 'px)';
  };


Item.prototype._transitionTo = function( x, y ) {
  this.getPosition();
  // get current x & y from top/left
  var curX = this.position.x;
  var curY = this.position.y;

  var compareX = parseInt( x, 10 );
  var compareY = parseInt( y, 10 );
  var didNotMove = compareX === this.position.x && compareY === this.position.y;

  // save end position
  this.setPosition( x, y );

  // if did not move and not transitioning, just go to layout
  if ( didNotMove && !this.isTransitioning ) {
    this.layoutPosition();
    return;
  }

  var transX = x - curX;
  var transY = y - curY;
  var transitionStyle = {};
  // flip cooridinates if origin on right or bottom
  var layoutOptions = this.layout.options;
  transX = layoutOptions.isOriginLeft ? transX : -transX;
  transY = layoutOptions.isOriginTop ? transY : -transY;
  transitionStyle.transform = translate( transX, transY );

  this.transition({
    to: transitionStyle,
    onTransitionEnd: {
      transform: this.layoutPosition
    },
    isCleaning: true
  });
};

// non transition + transform support
Item.prototype.goTo = function( x, y ) {
  this.setPosition( x, y );
  this.layoutPosition();
};

// use transition and transforms if supported
Item.prototype.moveTo = supportsCSS3 ?
  Item.prototype._transitionTo : Item.prototype.goTo;

Item.prototype.setPosition = function( x, y ) {
  this.position.x = parseInt( x, 10 );
  this.position.y = parseInt( y, 10 );
};

// ----- transition ----- //

/**
 * @param {Object} style - CSS
 * @param {Function} onTransitionEnd
 */

// non transition, just trigger callback
Item.prototype._nonTransition = function( args ) {
  this.css( args.to );
  if ( args.isCleaning ) {
    this._removeStyles( args.to );
  }
  for ( var prop in args.onTransitionEnd ) {
    args.onTransitionEnd[ prop ].call( this );
  }
};

/**
 * proper transition
 * @param {Object} args - arguments
 *   @param {Object} to - style to transition to
 *   @param {Object} from - style to start transition from
 *   @param {Boolean} isCleaning - removes transition styles after transition
 *   @param {Function} onTransitionEnd - callback
 */
Item.prototype._transition = function( args ) {
  // redirect to nonTransition if no transition duration
  if ( !parseFloat( this.layout.options.transitionDuration ) ) {
    this._nonTransition( args );
    return;
  }

  var _transition = this._transn;
  // keep track of onTransitionEnd callback by css property
  for ( var prop in args.onTransitionEnd ) {
    _transition.onEnd[ prop ] = args.onTransitionEnd[ prop ];
  }
  // keep track of properties that are transitioning
  for ( prop in args.to ) {
    _transition.ingProperties[ prop ] = true;
    // keep track of properties to clean up when transition is done
    if ( args.isCleaning ) {
      _transition.clean[ prop ] = true;
    }
  }

  // set from styles
  if ( args.from ) {
    this.css( args.from );
    // force redraw. http://blog.alexmaccaw.com/css-transitions
    var h = this.element.offsetHeight;
    // hack for JSHint to hush about unused var
    h = null;
  }
  // enable transition
  this.enableTransition( args.to );
  // set styles that are transitioning
  this.css( args.to );

  this.isTransitioning = true;

};

var itemTransitionProperties = transformProperty && ( toDash( transformProperty ) +
  ',opacity' );

Item.prototype.enableTransition = function(/* style */) {
  // only enable if not already transitioning
  // bug in IE10 were re-setting transition style will prevent
  // transitionend event from triggering
  if ( this.isTransitioning ) {
    return;
  }

  // make transition: foo, bar, baz from style object
  // TODO uncomment this bit when IE10 bug is resolved
  // var transitionValue = [];
  // for ( var prop in style ) {
  //   // dash-ify camelCased properties like WebkitTransition
  //   transitionValue.push( toDash( prop ) );
  // }
  // enable transition styles
  // HACK always enable transform,opacity for IE10
  this.css({
    transitionProperty: itemTransitionProperties,
    transitionDuration: this.layout.options.transitionDuration
  });
  // listen for transition end event
  this.element.addEventListener( transitionEndEvent, this, false );
};

Item.prototype.transition = Item.prototype[ transitionProperty ? '_transition' : '_nonTransition' ];

// ----- events ----- //

Item.prototype.onwebkitTransitionEnd = function( event ) {
  this.ontransitionend( event );
};

Item.prototype.onotransitionend = function( event ) {
  this.ontransitionend( event );
};

// properties that I munge to make my life easier
var dashedVendorProperties = {
  '-webkit-transform': 'transform',
  '-moz-transform': 'transform',
  '-o-transform': 'transform'
};

Item.prototype.ontransitionend = function( event ) {
  // disregard bubbled events from children
  if ( event.target !== this.element ) {
    return;
  }
  var _transition = this._transn;
  // get property name of transitioned property, convert to prefix-free
  var propertyName = dashedVendorProperties[ event.propertyName ] || event.propertyName;

  // remove property that has completed transitioning
  delete _transition.ingProperties[ propertyName ];
  // check if any properties are still transitioning
  if ( isEmptyObj( _transition.ingProperties ) ) {
    // all properties have completed transitioning
    this.disableTransition();
  }
  // clean style
  if ( propertyName in _transition.clean ) {
    // clean up style
    this.element.style[ event.propertyName ] = '';
    delete _transition.clean[ propertyName ];
  }
  // trigger onTransitionEnd callback
  if ( propertyName in _transition.onEnd ) {
    var onTransitionEnd = _transition.onEnd[ propertyName ];
    onTransitionEnd.call( this );
    delete _transition.onEnd[ propertyName ];
  }

  this.emitEvent( 'transitionEnd', [ this ] );
};

Item.prototype.disableTransition = function() {
  this.removeTransitionStyles();
  this.element.removeEventListener( transitionEndEvent, this, false );
  this.isTransitioning = false;
};

/**
 * removes style property from element
 * @param {Object} style
**/
Item.prototype._removeStyles = function( style ) {
  // clean up transition styles
  var cleanStyle = {};
  for ( var prop in style ) {
    cleanStyle[ prop ] = '';
  }
  this.css( cleanStyle );
};

var cleanTransitionStyle = {
  transitionProperty: '',
  transitionDuration: ''
};

Item.prototype.removeTransitionStyles = function() {
  // remove transition
  this.css( cleanTransitionStyle );
};

// ----- show/hide/remove ----- //

// remove element from DOM
Item.prototype.removeElem = function() {
  this.element.parentNode.removeChild( this.element );
  this.emitEvent( 'remove', [ this ] );
};

Item.prototype.remove = function() {
  // just remove element if no transition support or no transition
  if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {
    this.removeElem();
    return;
  }

  // start transition
  var _this = this;
  this.on( 'transitionEnd', function() {
    _this.removeElem();
    return true; // bind once
  });
  this.hide();
};

Item.prototype.reveal = function() {
  delete this.isHidden;
  // remove display: none
  this.css({ display: '' });

  var options = this.layout.options;
  this.transition({
    from: options.hiddenStyle,
    to: options.visibleStyle,
    isCleaning: true
  });
};

Item.prototype.hide = function() {
  // set flag
  this.isHidden = true;
  // remove display: none
  this.css({ display: '' });

  var options = this.layout.options;
  this.transition({
    from: options.visibleStyle,
    to: options.hiddenStyle,
    // keep hidden stuff hidden
    isCleaning: true,
    onTransitionEnd: {
      opacity: function() {
        // check if still hidden
        // during transition, item may have been un-hidden
        if ( this.isHidden ) {
          this.css({ display: 'none' });
        }
      }
    }
  });
};

Item.prototype.destroy = function() {
  this.css({
    position: '',
    left: '',
    right: '',
    top: '',
    bottom: '',
    transition: '',
    transform: ''
  });
};

return Item;

}

// -------------------------- transport -------------------------- //

if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( 'outlayer/item',[
      'eventEmitter/EventEmitter',
      'get-size/get-size',
      'get-style-property/get-style-property'
    ],
    outlayerItemDefinition );
} else {
  // browser global
  window.Outlayer = {};
  window.Outlayer.Item = outlayerItemDefinition(
    window.EventEmitter,
    window.getSize,
    window.getStyleProperty
  );
}

})( window );

/*!
 * Outlayer v1.2.0
 * the brains and guts of a layout library
 * MIT license
 */

( function( window ) {



// ----- vars ----- //

var document = window.document;
var console = window.console;

var noop = function() {};

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}


var objToString = Object.prototype.toString;
function isArray( obj ) {
  return objToString.call( obj ) === '[object Array]';
}

// turn element or nodeList into an array
function makeArray( obj ) {
  var ary = [];
  if ( isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( obj && typeof obj.length === 'number' ) {
    // convert nodeList to array
    for ( var i=0, len = obj.length; i < len; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
}

// http://stackoverflow.com/a/384380/182183
var isElement = ( typeof HTMLElement === 'object' ) ?
  function isElementDOM2( obj ) {
    return obj instanceof HTMLElement;
  } :
  function isElementQuirky( obj ) {
    return obj && typeof obj === 'object' &&
      obj.nodeType === 1 && typeof obj.nodeName === 'string';
  };

// index of helper cause IE8
var indexOf = Array.prototype.indexOf ? function( ary, obj ) {
    return ary.indexOf( obj );
  } : function( ary, obj ) {
    for ( var i=0, len = ary.length; i < len; i++ ) {
      if ( ary[i] === obj ) {
        return i;
      }
    }
    return -1;
  };

function removeFrom( obj, ary ) {
  var index = indexOf( ary, obj );
  if ( index !== -1 ) {
    ary.splice( index, 1 );
  }
}

// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
function toDashed( str ) {
  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
    return $1 + '-' + $2;
  }).toLowerCase();
}


function outlayerDefinition( eventie, docReady, EventEmitter, getSize, matchesSelector, Item ) {

// -------------------------- Outlayer -------------------------- //

// globally unique identifiers
var GUID = 0;
// internal store of all Outlayer intances
var instances = {};


/**
 * @param {Element, String} element
 * @param {Object} options
 * @constructor
 */
function Outlayer( element, options ) {
  // use element as selector string
  if ( typeof element === 'string' ) {
    element = document.querySelector( element );
  }

  // bail out if not proper element
  if ( !element || !isElement( element ) ) {
    if ( console ) {
      console.error( 'Bad ' + this.constructor.namespace + ' element: ' + element );
    }
    return;
  }

  this.element = element;

  // options
  this.options = extend( {}, this.constructor.defaults );
  this.option( options );

  // add id for Outlayer.getFromElement
  var id = ++GUID;
  this.element.outlayerGUID = id; // expando
  instances[ id ] = this; // associate via id

  // kick it off
  this._create();

  if ( this.options.isInitLayout ) {
    this.layout();
  }
}

// settings are for internal use only
Outlayer.namespace = 'outlayer';
Outlayer.Item = Item;

// default options
Outlayer.defaults = {
  containerStyle: {
    position: 'relative'
  },
  isInitLayout: true,
  isOriginLeft: true,
  isOriginTop: true,
  isResizeBound: true,
  isResizingContainer: true,
  // item options
  transitionDuration: '0.4s',
  hiddenStyle: {
    opacity: 0,
    transform: 'scale(0.001)'
  },
  visibleStyle: {
    opacity: 1,
    transform: 'scale(1)'
  }
};

// inherit EventEmitter
extend( Outlayer.prototype, EventEmitter.prototype );

/**
 * set options
 * @param {Object} opts
 */
Outlayer.prototype.option = function( opts ) {
  extend( this.options, opts );
};

Outlayer.prototype._create = function() {
  // get items from children
  this.reloadItems();
  // elements that affect layout, but are not laid out
  this.stamps = [];
  this.stamp( this.options.stamp );
  // set container style
  extend( this.element.style, this.options.containerStyle );

  // bind resize method
  if ( this.options.isResizeBound ) {
    this.bindResize();
  }
};

// goes through all children again and gets bricks in proper order
Outlayer.prototype.reloadItems = function() {
  // collection of item elements
  this.items = this._itemize( this.element.children );
};

/**
 * turn elements into Outlayer.Items to be used in layout
 * @param {Array or NodeList or HTMLElement} elems
 * @returns {Array} items - collection of new Outlayer Items
 */
Outlayer.prototype._itemize = function( elems ) {

  var itemElems = this._filterFindItemElements( elems );
  var Item = this.constructor.Item;

  // create new Outlayer Items for collection
  var items = [];
  for ( var i=0, len = itemElems.length; i < len; i++ ) {
    var elem = itemElems[i];
    var item = new Item( elem, this );
    items.push( item );
  }

  return items;
};

/**
 * get item elements to be used in layout
 * @param {Array or NodeList or HTMLElement} elems
 * @returns {Array} items - item elements
 */
Outlayer.prototype._filterFindItemElements = function( elems ) {
  // make array of elems
  elems = makeArray( elems );
  var itemSelector = this.options.itemSelector;
  var itemElems = [];

  for ( var i=0, len = elems.length; i < len; i++ ) {
    var elem = elems[i];
    // check that elem is an actual element
    if ( !isElement( elem ) ) {
      continue;
    }
    // filter & find items if we have an item selector
    if ( itemSelector ) {
      // filter siblings
      if ( matchesSelector( elem, itemSelector ) ) {
        itemElems.push( elem );
      }
      // find children
      var childElems = elem.querySelectorAll( itemSelector );
      // concat childElems to filterFound array
      for ( var j=0, jLen = childElems.length; j < jLen; j++ ) {
        itemElems.push( childElems[j] );
      }
    } else {
      itemElems.push( elem );
    }
  }

  return itemElems;
};

/**
 * getter method for getting item elements
 * @returns {Array} elems - collection of item elements
 */
Outlayer.prototype.getItemElements = function() {
  var elems = [];
  for ( var i=0, len = this.items.length; i < len; i++ ) {
    elems.push( this.items[i].element );
  }
  return elems;
};

// ----- init & layout ----- //

/**
 * lays out all items
 */
Outlayer.prototype.layout = function() {
  this._resetLayout();
  this._manageStamps();

  // don't animate first layout
  var isInstant = this.options.isLayoutInstant !== undefined ?
    this.options.isLayoutInstant : !this._isLayoutInited;
  this.layoutItems( this.items, isInstant );

  // flag for initalized
  this._isLayoutInited = true;
};

// _init is alias for layout
Outlayer.prototype._init = Outlayer.prototype.layout;

/**
 * logic before any new layout
 */
Outlayer.prototype._resetLayout = function() {
  this.getSize();
};


Outlayer.prototype.getSize = function() {
  this.size = getSize( this.element );
};

/**
 * get measurement from option, for columnWidth, rowHeight, gutter
 * if option is String -> get element from selector string, & get size of element
 * if option is Element -> get size of element
 * else use option as a number
 *
 * @param {String} measurement
 * @param {String} size - width or height
 * @private
 */
Outlayer.prototype._getMeasurement = function( measurement, size ) {
  var option = this.options[ measurement ];
  var elem;
  if ( !option ) {
    // default to 0
    this[ measurement ] = 0;
  } else {
    // use option as an element
    if ( typeof option === 'string' ) {
      elem = this.element.querySelector( option );
    } else if ( isElement( option ) ) {
      elem = option;
    }
    // use size of element, if element
    this[ measurement ] = elem ? getSize( elem )[ size ] : option;
  }
};

/**
 * layout a collection of item elements
 * @api public
 */
Outlayer.prototype.layoutItems = function( items, isInstant ) {
  items = this._getItemsForLayout( items );

  this._layoutItems( items, isInstant );

  this._postLayout();
};

/**
 * get the items to be laid out
 * you may want to skip over some items
 * @param {Array} items
 * @returns {Array} items
 */
Outlayer.prototype._getItemsForLayout = function( items ) {
  var layoutItems = [];
  for ( var i=0, len = items.length; i < len; i++ ) {
    var item = items[i];
    if ( !item.isIgnored ) {
      layoutItems.push( item );
    }
  }
  return layoutItems;
};

/**
 * layout items
 * @param {Array} items
 * @param {Boolean} isInstant
 */
Outlayer.prototype._layoutItems = function( items, isInstant ) {
  var _this = this;
  function onItemsLayout() {
    _this.emitEvent( 'layoutComplete', [ _this, items ] );
  }

  if ( !items || !items.length ) {
    // no items, emit event with empty array
    onItemsLayout();
    return;
  }

  // emit layoutComplete when done
  this._itemsOn( items, 'layout', onItemsLayout );

  var queue = [];

  for ( var i=0, len = items.length; i < len; i++ ) {
    var item = items[i];
    // get x/y object from method
    var position = this._getItemLayoutPosition( item );
    // enqueue
    position.item = item;
    position.isInstant = isInstant || item.isLayoutInstant;
    queue.push( position );
  }

  this._processLayoutQueue( queue );
};

/**
 * get item layout position
 * @param {Outlayer.Item} item
 * @returns {Object} x and y position
 */
Outlayer.prototype._getItemLayoutPosition = function( /* item */ ) {
  return {
    x: 0,
    y: 0
  };
};

/**
 * iterate over array and position each item
 * Reason being - separating this logic prevents 'layout invalidation'
 * thx @paul_irish
 * @param {Array} queue
 */
Outlayer.prototype._processLayoutQueue = function( queue ) {
  for ( var i=0, len = queue.length; i < len; i++ ) {
    var obj = queue[i];
    this._positionItem( obj.item, obj.x, obj.y, obj.isInstant );
  }
};

/**
 * Sets position of item in DOM
 * @param {Outlayer.Item} item
 * @param {Number} x - horizontal position
 * @param {Number} y - vertical position
 * @param {Boolean} isInstant - disables transitions
 */
Outlayer.prototype._positionItem = function( item, x, y, isInstant ) {
  if ( isInstant ) {
    // if not transition, just set CSS
    item.goTo( x, y );
  } else {
    item.moveTo( x, y );
  }
};

/**
 * Any logic you want to do after each layout,
 * i.e. size the container
 */
Outlayer.prototype._postLayout = function() {
  this.resizeContainer();
};

Outlayer.prototype.resizeContainer = function() {
  if ( !this.options.isResizingContainer ) {
    return;
  }
  var size = this._getContainerSize();
  if ( size ) {
    this._setContainerMeasure( size.width, true );
    this._setContainerMeasure( size.height, false );
  }
};

/**
 * Sets width or height of container if returned
 * @returns {Object} size
 *   @param {Number} width
 *   @param {Number} height
 */
Outlayer.prototype._getContainerSize = noop;

/**
 * @param {Number} measure - size of width or height
 * @param {Boolean} isWidth
 */
Outlayer.prototype._setContainerMeasure = function( measure, isWidth ) {
  if ( measure === undefined ) {
    return;
  }

  var elemSize = this.size;
  // add padding and border width if border box
  if ( elemSize.isBorderBox ) {
    measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
      elemSize.borderLeftWidth + elemSize.borderRightWidth :
      elemSize.paddingBottom + elemSize.paddingTop +
      elemSize.borderTopWidth + elemSize.borderBottomWidth;
  }

  measure = Math.max( measure, 0 );
  this.element.style[ isWidth ? 'width' : 'height' ] = measure + 'px';
};

/**
 * trigger a callback for a collection of items events
 * @param {Array} items - Outlayer.Items
 * @param {String} eventName
 * @param {Function} callback
 */
Outlayer.prototype._itemsOn = function( items, eventName, callback ) {
  var doneCount = 0;
  var count = items.length;
  // event callback
  var _this = this;
  function tick() {
    doneCount++;
    if ( doneCount === count ) {
      callback.call( _this );
    }
    return true; // bind once
  }
  // bind callback
  for ( var i=0, len = items.length; i < len; i++ ) {
    var item = items[i];
    item.on( eventName, tick );
  }
};

// -------------------------- ignore & stamps -------------------------- //


/**
 * keep item in collection, but do not lay it out
 * ignored items do not get skipped in layout
 * @param {Element} elem
 */
Outlayer.prototype.ignore = function( elem ) {
  var item = this.getItem( elem );
  if ( item ) {
    item.isIgnored = true;
  }
};

/**
 * return item to layout collection
 * @param {Element} elem
 */
Outlayer.prototype.unignore = function( elem ) {
  var item = this.getItem( elem );
  if ( item ) {
    delete item.isIgnored;
  }
};

/**
 * adds elements to stamps
 * @param {NodeList, Array, Element, or String} elems
 */
Outlayer.prototype.stamp = function( elems ) {
  elems = this._find( elems );
  if ( !elems ) {
    return;
  }

  this.stamps = this.stamps.concat( elems );
  // ignore
  for ( var i=0, len = elems.length; i < len; i++ ) {
    var elem = elems[i];
    this.ignore( elem );
  }
};

/**
 * removes elements to stamps
 * @param {NodeList, Array, or Element} elems
 */
Outlayer.prototype.unstamp = function( elems ) {
  elems = this._find( elems );
  if ( !elems ){
    return;
  }

  for ( var i=0, len = elems.length; i < len; i++ ) {
    var elem = elems[i];
    // filter out removed stamp elements
    removeFrom( elem, this.stamps );
    this.unignore( elem );
  }

};

/**
 * finds child elements
 * @param {NodeList, Array, Element, or String} elems
 * @returns {Array} elems
 */
Outlayer.prototype._find = function( elems ) {
  if ( !elems ) {
    return;
  }
  // if string, use argument as selector string
  if ( typeof elems === 'string' ) {
    elems = this.element.querySelectorAll( elems );
  }
  elems = makeArray( elems );
  return elems;
};

Outlayer.prototype._manageStamps = function() {
  if ( !this.stamps || !this.stamps.length ) {
    return;
  }

  this._getBoundingRect();

  for ( var i=0, len = this.stamps.length; i < len; i++ ) {
    var stamp = this.stamps[i];
    this._manageStamp( stamp );
  }
};

// update boundingLeft / Top
Outlayer.prototype._getBoundingRect = function() {
  // get bounding rect for container element
  var boundingRect = this.element.getBoundingClientRect();
  var size = this.size;
  this._boundingRect = {
    left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
    top: boundingRect.top + size.paddingTop + size.borderTopWidth,
    right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),
    bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )
  };
};

/**
 * @param {Element} stamp
**/
Outlayer.prototype._manageStamp = noop;

/**
 * get x/y position of element relative to container element
 * @param {Element} elem
 * @returns {Object} offset - has left, top, right, bottom
 */
Outlayer.prototype._getElementOffset = function( elem ) {
  var boundingRect = elem.getBoundingClientRect();
  var thisRect = this._boundingRect;
  var size = getSize( elem );
  var offset = {
    left: boundingRect.left - thisRect.left - size.marginLeft,
    top: boundingRect.top - thisRect.top - size.marginTop,
    right: thisRect.right - boundingRect.right - size.marginRight,
    bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
  };
  return offset;
};

// -------------------------- resize -------------------------- //

// enable event handlers for listeners
// i.e. resize -> onresize
Outlayer.prototype.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

/**
 * Bind layout to window resizing
 */
Outlayer.prototype.bindResize = function() {
  // bind just one listener
  if ( this.isResizeBound ) {
    return;
  }
  eventie.bind( window, 'resize', this );
  this.isResizeBound = true;
};

/**
 * Unbind layout to window resizing
 */
Outlayer.prototype.unbindResize = function() {
  if ( this.isResizeBound ) {
    eventie.unbind( window, 'resize', this );
  }
  this.isResizeBound = false;
};

// original debounce by John Hann
// http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/

// this fires every resize
Outlayer.prototype.onresize = function() {
  if ( this.resizeTimeout ) {
    clearTimeout( this.resizeTimeout );
  }

  var _this = this;
  function delayed() {
    _this.resize();
    delete _this.resizeTimeout;
  }

  this.resizeTimeout = setTimeout( delayed, 100 );
};

// debounced, layout on resize
Outlayer.prototype.resize = function() {
  // don't trigger if size did not change
  // or if resize was unbound. See #9

  if ( !this.isResizeBound || !this.needsResizeLayout() ) {
    return;
  }

  this.layout();
};

/**
 * check if layout is needed post layout
 * @returns Boolean
 */
Outlayer.prototype.needsResizeLayout = function() {
  var size = getSize( this.element );
  // check that this.size and size are there
  // IE8 triggers resize on body size change, so they might not be
  var hasSizes = this.size && size;
  return hasSizes && size.innerWidth !== this.size.innerWidth;
};

// -------------------------- methods -------------------------- //

/**
 * add items to Outlayer instance
 * @param {Array or NodeList or Element} elems
 * @returns {Array} items - Outlayer.Items
**/
Outlayer.prototype.addItems = function( elems ) {
  var items = this._itemize( elems );
  // add items to collection
  if ( items.length ) {
    this.items = this.items.concat( items );
  }
  return items;
};

/**
 * Layout newly-appended item elements
 * @param {Array or NodeList or Element} elems
 */
Outlayer.prototype.appended = function( elems ) {
  var items = this.addItems( elems );
  if ( !items.length ) {
    return;
  }
  // layout and reveal just the new items
  this.layoutItems( items, true );
  this.reveal( items );
};

/**
 * Layout prepended elements
 * @param {Array or NodeList or Element} elems
 */
Outlayer.prototype.prepended = function( elems ) {
  var items = this._itemize( elems );
  if ( !items.length ) {
    return;
  }
  // add items to beginning of collection
  var previousItems = this.items.slice(0);
  this.items = items.concat( previousItems );
  // start new layout
  this._resetLayout();
  this._manageStamps();
  // layout new stuff without transition
  this.layoutItems( items, true );
  this.reveal( items );
  // layout previous items
  this.layoutItems( previousItems );
};

/**
 * reveal a collection of items
 * @param {Array of Outlayer.Items} items
 */
Outlayer.prototype.reveal = function( items ) {
  var len = items && items.length;
  if ( !len ) {
    return;
  }
  for ( var i=0; i < len; i++ ) {
    var item = items[i];
    item.reveal();
  }
};

/**
 * hide a collection of items
 * @param {Array of Outlayer.Items} items
 */
Outlayer.prototype.hide = function( items ) {
  var len = items && items.length;
  if ( !len ) {
    return;
  }
  for ( var i=0; i < len; i++ ) {
    var item = items[i];
    item.hide();
  }
};

/**
 * get Outlayer.Item, given an Element
 * @param {Element} elem
 * @param {Function} callback
 * @returns {Outlayer.Item} item
 */
Outlayer.prototype.getItem = function( elem ) {
  // loop through items to get the one that matches
  for ( var i=0, len = this.items.length; i < len; i++ ) {
    var item = this.items[i];
    if ( item.element === elem ) {
      // return item
      return item;
    }
  }
};

/**
 * get collection of Outlayer.Items, given Elements
 * @param {Array} elems
 * @returns {Array} items - Outlayer.Items
 */
Outlayer.prototype.getItems = function( elems ) {
  if ( !elems || !elems.length ) {
    return;
  }
  var items = [];
  for ( var i=0, len = elems.length; i < len; i++ ) {
    var elem = elems[i];
    var item = this.getItem( elem );
    if ( item ) {
      items.push( item );
    }
  }

  return items;
};

/**
 * remove element(s) from instance and DOM
 * @param {Array or NodeList or Element} elems
 */
Outlayer.prototype.remove = function( elems ) {
  elems = makeArray( elems );

  var removeItems = this.getItems( elems );
  // bail if no items to remove
  if ( !removeItems || !removeItems.length ) {
    return;
  }

  this._itemsOn( removeItems, 'remove', function() {
    this.emitEvent( 'removeComplete', [ this, removeItems ] );
  });

  for ( var i=0, len = removeItems.length; i < len; i++ ) {
    var item = removeItems[i];
    item.remove();
    // remove item from collection
    removeFrom( item, this.items );
  }
};

// ----- destroy ----- //

// remove and disable Outlayer instance
Outlayer.prototype.destroy = function() {
  // clean up dynamic styles
  var style = this.element.style;
  style.height = '';
  style.position = '';
  style.width = '';
  // destroy items
  for ( var i=0, len = this.items.length; i < len; i++ ) {
    var item = this.items[i];
    item.destroy();
  }

  this.unbindResize();

  delete this.element.outlayerGUID;
  // remove data for jQuery
  if ( jQuery ) {
    jQuery.removeData( this.element, this.constructor.namespace );
  }

};

// -------------------------- data -------------------------- //

/**
 * get Outlayer instance from element
 * @param {Element} elem
 * @returns {Outlayer}
 */
Outlayer.data = function( elem ) {
  var id = elem && elem.outlayerGUID;
  return id && instances[ id ];
};


// -------------------------- create Outlayer class -------------------------- //

/**
 * create a layout class
 * @param {String} namespace
 */
Outlayer.create = function( namespace, options ) {
  // sub-class Outlayer
  function Layout() {
    Outlayer.apply( this, arguments );
  }
  // inherit Outlayer prototype, use Object.create if there
  if ( Object.create ) {
    Layout.prototype = Object.create( Outlayer.prototype );
  } else {
    extend( Layout.prototype, Outlayer.prototype );
  }
  // set contructor, used for namespace and Item
  Layout.prototype.constructor = Layout;

  Layout.defaults = extend( {}, Outlayer.defaults );
  // apply new options
  extend( Layout.defaults, options );
  // keep prototype.settings for backwards compatibility (Packery v1.2.0)
  Layout.prototype.settings = {};

  Layout.namespace = namespace;

  Layout.data = Outlayer.data;

  // sub-class Item
  Layout.Item = function LayoutItem() {
    Item.apply( this, arguments );
  };

  Layout.Item.prototype = new Item();

  // -------------------------- declarative -------------------------- //

  /**
   * allow user to initialize Outlayer via .js-namespace class
   * options are parsed from data-namespace-option attribute
   */
  docReady( function() {
    var dashedNamespace = toDashed( namespace );
    var elems = document.querySelectorAll( '.js-' + dashedNamespace );
    var dataAttr = 'data-' + dashedNamespace + '-options';

    for ( var i=0, len = elems.length; i < len; i++ ) {
      var elem = elems[i];
      var attr = elem.getAttribute( dataAttr );
      var options;
      try {
        options = attr && JSON.parse( attr );
      } catch ( error ) {
        // log error, do not initialize
        if ( console ) {
          console.error( 'Error parsing ' + dataAttr + ' on ' +
            elem.nodeName.toLowerCase() + ( elem.id ? '#' + elem.id : '' ) + ': ' +
            error );
        }
        continue;
      }
      // initialize
      var instance = new Layout( elem, options );
      // make available via $().data('layoutname')
      if ( jQuery ) {
        jQuery.data( elem, namespace, instance );
      }
    }
  });

  // -------------------------- jQuery bridge -------------------------- //

  // make into jQuery plugin
  if ( jQuery && jQuery.bridget ) {
    jQuery.bridget( namespace, Layout );
  }

  return Layout;
};

// ----- fin ----- //

// back in global
Outlayer.Item = Item;

return Outlayer;

}

// -------------------------- transport -------------------------- //

if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( 'outlayer/outlayer',[
      'eventie/eventie',
      'doc-ready/doc-ready',
      'eventEmitter/EventEmitter',
      'get-size/get-size',
      'matches-selector/matches-selector',
      './item'
    ],
    outlayerDefinition );
} else {
  // browser global
  window.Outlayer = outlayerDefinition(
    window.eventie,
    window.docReady,
    window.EventEmitter,
    window.getSize,
    window.matchesSelector,
    window.Outlayer.Item
  );
}

})( window );

/*!
 * Masonry v3.1.5
 * Cascading grid layout library
 * http://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

( function( window ) {



// -------------------------- helpers -------------------------- //

var indexOf = Array.prototype.indexOf ?
  function( items, value ) {
    return items.indexOf( value );
  } :
  function ( items, value ) {
    for ( var i=0, len = items.length; i < len; i++ ) {
      var item = items[i];
      if ( item === value ) {
        return i;
      }
    }
    return -1;
  };

// -------------------------- masonryDefinition -------------------------- //

// used for AMD definition and requires
function masonryDefinition( Outlayer, getSize ) {
  // create an Outlayer layout class
  var Masonry = Outlayer.create('masonry');

  Masonry.prototype._resetLayout = function() {
    this.getSize();
    this._getMeasurement( 'columnWidth', 'outerWidth' );
    this._getMeasurement( 'gutter', 'outerWidth' );
    this.measureColumns();

    // reset column Y
    var i = this.cols;
    this.colYs = [];
    while (i--) {
      this.colYs.push( 0 );
    }

    this.maxY = 0;
  };

  Masonry.prototype.measureColumns = function() {
    this.getContainerWidth();
    // if columnWidth is 0, default to outerWidth of first item
    if ( !this.columnWidth ) {
      var firstItem = this.items[0];
      var firstItemElem = firstItem && firstItem.element;
      // columnWidth fall back to item of first element
      this.columnWidth = firstItemElem && getSize( firstItemElem ).outerWidth ||
        // if first elem has no width, default to size of container
        this.containerWidth;
    }

    this.columnWidth += this.gutter;

    this.cols = Math.floor( ( this.containerWidth + this.gutter ) / this.columnWidth );
    this.cols = Math.max( this.cols, 1 );
  };

  Masonry.prototype.getContainerWidth = function() {
    // container is parent if fit width
    var container = this.options.isFitWidth ? this.element.parentNode : this.element;
    // check that this.size and size are there
    // IE8 triggers resize on body size change, so they might not be
    var size = getSize( container );
    this.containerWidth = size && size.innerWidth;
  };

  Masonry.prototype._getItemLayoutPosition = function( item ) {
    item.getSize();
    // how many columns does this brick span
    var remainder = item.size.outerWidth % this.columnWidth;
    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
    // round if off by 1 pixel, otherwise use ceil
    var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );
    colSpan = Math.min( colSpan, this.cols );

    var colGroup = this._getColGroup( colSpan );
    // get the minimum Y value from the columns
    var minimumY = Math.min.apply( Math, colGroup );
    var shortColIndex = indexOf( colGroup, minimumY );

    // position the brick
    var position = {
      x: this.columnWidth * shortColIndex,
      y: minimumY
    };

    // apply setHeight to necessary columns
    var setHeight = minimumY + item.size.outerHeight;
    var setSpan = this.cols + 1 - colGroup.length;
    for ( var i = 0; i < setSpan; i++ ) {
      this.colYs[ shortColIndex + i ] = setHeight;
    }

    return position;
  };

  /**
   * @param {Number} colSpan - number of columns the element spans
   * @returns {Array} colGroup
   */
  Masonry.prototype._getColGroup = function( colSpan ) {
    if ( colSpan < 2 ) {
      // if brick spans only one column, use all the column Ys
      return this.colYs;
    }

    var colGroup = [];
    // how many different places could this brick fit horizontally
    var groupCount = this.cols + 1 - colSpan;
    // for each group potential horizontal position
    for ( var i = 0; i < groupCount; i++ ) {
      // make an array of colY values for that one group
      var groupColYs = this.colYs.slice( i, i + colSpan );
      // and get the max value of the array
      colGroup[i] = Math.max.apply( Math, groupColYs );
    }
    return colGroup;
  };

  Masonry.prototype._manageStamp = function( stamp ) {
    var stampSize = getSize( stamp );
    var offset = this._getElementOffset( stamp );
    // get the columns that this stamp affects
    var firstX = this.options.isOriginLeft ? offset.left : offset.right;
    var lastX = firstX + stampSize.outerWidth;
    var firstCol = Math.floor( firstX / this.columnWidth );
    firstCol = Math.max( 0, firstCol );
    var lastCol = Math.floor( lastX / this.columnWidth );
    // lastCol should not go over if multiple of columnWidth #425
    lastCol -= lastX % this.columnWidth ? 0 : 1;
    lastCol = Math.min( this.cols - 1, lastCol );
    // set colYs to bottom of the stamp
    var stampMaxY = ( this.options.isOriginTop ? offset.top : offset.bottom ) +
      stampSize.outerHeight;
    for ( var i = firstCol; i <= lastCol; i++ ) {
      this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );
    }
  };

  Masonry.prototype._getContainerSize = function() {
    this.maxY = Math.max.apply( Math, this.colYs );
    var size = {
      height: this.maxY
    };

    if ( this.options.isFitWidth ) {
      size.width = this._getContainerFitWidth();
    }

    return size;
  };

  Masonry.prototype._getContainerFitWidth = function() {
    var unusedCols = 0;
    // count unused columns
    var i = this.cols;
    while ( --i ) {
      if ( this.colYs[i] !== 0 ) {
        break;
      }
      unusedCols++;
    }
    // fit container to columns that have been used
    return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;
  };

  Masonry.prototype.needsResizeLayout = function() {
    var previousWidth = this.containerWidth;
    this.getContainerWidth();
    return previousWidth !== this.containerWidth;
  };

  return Masonry;
}

// -------------------------- transport -------------------------- //

if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( [
      'outlayer/outlayer',
      'get-size/get-size'
    ],
    masonryDefinition );
} else {
  // browser global
  window.Masonry3 = masonryDefinition(
    window.Outlayer,
    window.getSize
  );
}

})( window );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("masonry", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
$.require() 
 .script("moment") 
 .done(function() { 
var exports = function() { 

/*
Version 3.0.0
=========================================================
bootstrap-datetimepicker.js
https://github.com/Eonasdan/bootstrap-datetimepicker
=========================================================
The MIT License (MIT)

Copyright (c) 2014 Jonathan Peterson

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

    var dpgId = 0,

    pMoment = $.moment,

// ReSharper disable once InconsistentNaming
    DateTimePicker = function (element, options) {
        var defaults = {
            pickDate: true,
            pickTime: true,
            useMinutes: true,
            useSeconds: false,
            useCurrent: true,
            minuteStepping: 1,
            minDate: new pMoment({ y: 1900 }),
            maxDate: new pMoment().add(100, "y"),
            showToday: true,
            collapse: true,
            language: "en",
            defaultDate: "",
            disabledDates: false,
            enabledDates: false,
            icons: {},
            useStrict: false,
            direction: "auto",
            sideBySide: false,
            daysOfWeekDisabled: false,
            component: "",
            dow: 0
        },

        icons = {
            time  : 'fa fa-clock-o',
            date  : 'fa fa-calendar',
            up    : 'fa fa-chevron-up',
            down  : 'fa fa-chevron-down'
        },

        picker = this,

        init = function () {

            var icon = false, i, dDate, longDateFormat;
            picker.options = $.extend({}, defaults, options);
            picker.options.icons = $.extend({}, icons, picker.options.icons);

            picker.element = $(element);

            dataToOptions();

            if (!(picker.options.pickTime || picker.options.pickDate))
                throw new Error('Must choose at least one picker');

            picker.id = dpgId++;
            pMoment.lang(picker.options.language);
            picker.date = pMoment();
            picker.unset = false;
            picker.isInput = picker.element.is('input');
            picker.component = false;

            // jasonrey@stackideas.com
            // Set the start of week
            pMoment()._lang._week.dow = picker.options.dow;

            if (picker.element.hasClass('input-group')) {
                if (picker.element.find('.datepickerbutton').size() == 0) {//in case there is more then one 'input-group-addon' Issue #48
                    picker.component = picker.element.find("[class^='input-group-']");
                }
                else {
                    picker.component = picker.element.find('.datepickerbutton');
                }
            }
            picker.format = picker.options.format;

            longDateFormat = pMoment()._lang._longDateFormat;

            if (!picker.format) {
                picker.format = (picker.options.pickDate ? longDateFormat.L : '');
                if (picker.options.pickDate && picker.options.pickTime) picker.format += ' ';
                picker.format += (picker.options.pickTime ? longDateFormat.LT : '');
                if (picker.options.useSeconds) {
                    if (~longDateFormat.LT.indexOf(' A')) {
                        picker.format = picker.format.split(" A")[0] + ":ss A";
                    }
                    else {
                        picker.format += ':ss';
                    }
                }
            }
            picker.use24hours = picker.format.toLowerCase().indexOf("a") < 1;

            if (picker.component) icon = picker.component.find('span');

            if (picker.options.pickTime) {
                if (icon) icon.addClass(picker.options.icons.time);
            }
            if (picker.options.pickDate) {
                if (icon) {
                    icon.removeClass(picker.options.icons.time);
                    icon.addClass(picker.options.icons.date);
                }
            }

            picker.widget = $(getTemplate()).appendTo('body');

            if (picker.options.useSeconds && !picker.use24hours) {
                picker.widget.width(300);
            }

            picker.minViewMode = picker.options.minViewMode || 0;
            if (typeof picker.minViewMode === 'string') {
                switch (picker.minViewMode) {
                    case 'months':
                        picker.minViewMode = 1;
                        break;
                    case 'years':
                        picker.minViewMode = 2;
                        break;
                    default:
                        picker.minViewMode = 0;
                        break;
                }
            }
            picker.viewMode = picker.options.viewMode || 0;
            if (typeof picker.viewMode === 'string') {
                switch (picker.viewMode) {
                    case 'months':
                        picker.viewMode = 1;
                        break;
                    case 'years':
                        picker.viewMode = 2;
                        break;
                    default:
                        picker.viewMode = 0;
                        break;
                }
            }

            picker.options.disabledDates = indexGivenDates(picker.options.disabledDates);
            picker.options.enabledDates = indexGivenDates(picker.options.enabledDates);

            picker.startViewMode = picker.viewMode;
            picker.setMinDate(picker.options.minDate);
            picker.setMaxDate(picker.options.maxDate);
            fillDow();
            fillMonths();
            fillHours();
            fillMinutes();
            fillSeconds();
            update();
            showMode();
            attachDatePickerEvents();
            if (picker.options.defaultDate !== "" && getPickerInput().val() == "") picker.setValue(picker.options.defaultDate);
            if (picker.options.minuteStepping !== 1) {
                var rInterval = picker.options.minuteStepping;
                picker.date.minutes((Math.round(picker.date.minutes() / rInterval) * rInterval) % 60).seconds(0);
            }
        },

        getPickerInput = function () {
            if (picker.isInput) {
                return picker.element;
            } else {
                return dateStr = picker.element.find('input');
            }
        },

        dataToOptions = function () {
            var eData
            if (picker.element.is('input')) {
                eData = picker.element.data();
            }
            else {
                eData = picker.element.data();
            }
            if (eData.dateFormat !== undefined) picker.options.format = eData.dateFormat;
            if (eData.datePickdate !== undefined) picker.options.pickDate = eData.datePickdate;
            if (eData.datePicktime !== undefined) picker.options.pickTime = eData.datePicktime;
            if (eData.dateUseminutes !== undefined) picker.options.useMinutes = eData.dateUseminutes;
            if (eData.dateUseseconds !== undefined) picker.options.useSeconds = eData.dateUseseconds;
            if (eData.dateUsecurrent !== undefined) picker.options.useCurrent = eData.dateUsecurrent;
            if (eData.dateMinutestepping !== undefined) picker.options.minuteStepping = eData.dateMinutestepping;
            if (eData.dateMindate !== undefined) picker.options.minDate = eData.dateMindate;
            if (eData.dateMaxdate !== undefined) picker.options.maxDate = eData.dateMaxdate;
            if (eData.dateShowtoday !== undefined) picker.options.showToday = eData.dateShowtoday;
            if (eData.dateCollapse !== undefined) picker.options.collapse = eData.dateCollapse;
            if (eData.dateLanguage !== undefined) picker.options.language = eData.dateLanguage;
            if (eData.dateDefaultdate !== undefined) picker.options.defaultDate = eData.dateDefaultdate;
            if (eData.dateDisableddates !== undefined) picker.options.disabledDates = eData.dateDisableddates;
            if (eData.dateEnableddates !== undefined) picker.options.enabledDates = eData.dateEnableddates;
            if (eData.dateIcons !== undefined) picker.options.icons = eData.dateIcons;
            if (eData.dateUsestrict !== undefined) picker.options.useStrict = eData.dateUsestrict;
            if (eData.dateDirection !== undefined) picker.options.direction = eData.dateDirection;
            if (eData.dateSidebyside !== undefined) picker.options.sideBySide = eData.dateSidebyside;
        },

        place = function () {
            var position = 'absolute',
            offset = picker.component ? picker.component.offset() : picker.element.offset(), $window = $(window);
            picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
            offset.top = offset.top + picker.element.outerHeight();

            var placePosition;
            if (picker.options.direction === 'up') {
                placePosition = 'top'
            } else if (picker.options.direction === 'bottom') {
                placePosition = 'bottom'
            } else if (picker.options.direction === 'auto') {
                if (offset.top + picker.widget.height() > $window.height() + $window.scrollTop() && picker.widget.height() + picker.element.outerHeight() < offset.top) {
                    placePosition = 'top';
                } else {
                    placePosition = 'bottom';
                }
            };
            if (placePosition === 'top') {
                offset.top -= picker.widget.height() + picker.element.outerHeight() + 15;
                picker.widget.addClass('top').removeClass('bottom');
            } else {
                offset.top += 1;
                picker.widget.addClass('bottom').removeClass('top');
            }

            if (picker.options.width !== undefined) {
                picker.widget.width(picker.options.width);
            }

            if (picker.options.orientation === 'left') {
                picker.widget.addClass('left-oriented');
                offset.left = offset.left - picker.widget.width() + 20;
            }

            if (isInFixed()) {
                position = 'fixed';
                offset.top -= $window.scrollTop();
                offset.left -= $window.scrollLeft();
            }

            if ($window.width() < offset.left + picker.widget.outerWidth()) {
                offset.right = $window.width() - offset.left - picker.width;
                offset.left = 'auto';
                picker.widget.addClass('pull-right');
            } else {
                offset.right = 'auto';
                picker.widget.removeClass('pull-right');
            }

            picker.widget.css({
                position: position,
                top: offset.top,
                left: offset.left,
                right: offset.right
            });
        },

        notifyChange = function (oldDate, eventType) {
            if (pMoment(picker.date).isSame(pMoment(oldDate))) return;
            picker.element.trigger({
                type: 'dp.change',
                date: pMoment(picker.date),
                oldDate: pMoment(oldDate)
            });

            if (eventType !== 'change')
                picker.element.change();
        },

        notifyError = function (date) {
            picker.element.trigger({
                type: 'dp.error',
                date: pMoment(date)
            });
        },

        update = function (newDate) {
            pMoment.lang(picker.options.language);
            var dateStr = newDate;
            if (!dateStr) {
                dateStr = getPickerInput().val()
                if (dateStr) picker.date = pMoment(dateStr, picker.format, picker.options.useStrict);
                if (!picker.date) picker.date = pMoment();
            }
            picker.viewDate = pMoment(picker.date).startOf("month");
            fillDate();
            fillTime();
        },

        fillDow = function () {
            pMoment.lang(picker.options.language);
            var html = $('<tr>'), weekdaysMin = pMoment.weekdaysMin(), i;

            // jasonrey@stackideas.com
            // Reconstruct weekdays structure by start day of the week
            var spliced = weekdaysMin.splice(pMoment()._lang._week.dow);
            weekdaysMin = spliced.concat(weekdaysMin);

            $.each(weekdaysMin, function(i, w) {
                html.append('<th class="dow">' + w + '</th>');
            });

            // if (pMoment()._lang._week.dow == 0) { // starts on Sunday
            //     for (i = 0; i < 7; i++) {
            //         html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
            //     }
            // } else {
            //     for (i = 1; i < 8; i++) {
            //         if (i == 7) {
            //             html.append('<th class="dow">' + weekdaysMin[0] + '</th>');
            //         } else {
            //             html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
            //         }
            //     }
            // }
            picker.widget.find('.datepicker-days thead').append(html);
        },

        fillMonths = function () {
            pMoment.lang(picker.options.language);
            var html = '', i = 0, monthsShort = pMoment.monthsShort();
            while (i < 12) {
                html += '<span class="month">' + monthsShort[i++] + '</span>';
            }
            picker.widget.find('.datepicker-months td').append(html);
        },

        fillDate = function () {
            pMoment.lang(picker.options.language);
            var year = picker.viewDate.year(),
                month = picker.viewDate.month(),
                startYear = picker.options.minDate.year(),
                startMonth = picker.options.minDate.month(),
                endYear = picker.options.maxDate.year(),
                endMonth = picker.options.maxDate.month(),
                currentDate,
                prevMonth, nextMonth, html = [], row, clsName, i, days, yearCont, currentYear, months = pMoment.months();

            picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
            picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
            picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');

            picker.widget.find('.datepicker-days th:eq(1)').text(
                months[month] + ' ' + year);

            prevMonth = pMoment(picker.viewDate).subtract("months", 1);
            days = prevMonth.daysInMonth();
            prevMonth.date(days).startOf('week');
            if ((year == startYear && month <= startMonth) || year < startYear) {
                picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
            }
            if ((year == endYear && month >= endMonth) || year > endYear) {
                picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
            }

            nextMonth = pMoment(prevMonth).add(42, "d");
            while (prevMonth.isBefore(nextMonth)) {
                if (prevMonth.weekday() === pMoment().startOf('week').weekday()) {
                    row = $('<tr>');
                    html.push(row);
                }
                clsName = '';
                if (prevMonth.year() < year || (prevMonth.year() == year && prevMonth.month() < month)) {
                    clsName += ' old';
                } else if (prevMonth.year() > year || (prevMonth.year() == year && prevMonth.month() > month)) {
                    clsName += ' new';
                }
                if (prevMonth.isSame(pMoment({ y: picker.date.year(), M: picker.date.month(), d: picker.date.date() }))) {
                    clsName += ' active';
                }
                if (isInDisableDates(prevMonth) || !isInEnableDates(prevMonth)) {
                    clsName += ' disabled';
                }
                if (picker.options.showToday === true) {
                    if (prevMonth.isSame(pMoment(), 'day')) {
                        clsName += ' today';
                    }
                }
                if (picker.options.daysOfWeekDisabled) {
                    for (i in picker.options.daysOfWeekDisabled) {
                        if (prevMonth.day() == picker.options.daysOfWeekDisabled[i]) {
                            clsName += ' disabled';
                            break;
                        }
                    }
                }
                row.append('<td class="day' + clsName + '">' + prevMonth.date() + '</td>');

                currentDate = prevMonth.date();
                prevMonth.add(1, "d");

                if (currentDate == prevMonth.date()) {
                  prevMonth.add(1, "d");
                }
            }
            picker.widget.find('.datepicker-days tbody').empty().append(html);
            currentYear = picker.date.year(), months = picker.widget.find('.datepicker-months')
                .find('th:eq(1)').text(year).end().find('span').removeClass('active');
            if (currentYear === year) {
                months.eq(picker.date.month()).addClass('active');
            }
            if (currentYear - 1 < startYear) {
                picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
            }
            if (currentYear + 1 > endYear) {
                picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
            }
            for (i = 0; i < 12; i++) {
                if ((year == startYear && startMonth > i) || (year < startYear)) {
                    $(months[i]).addClass('disabled');
                } else if ((year == endYear && endMonth < i) || (year > endYear)) {
                    $(months[i]).addClass('disabled');
                }
            }

            html = '';
            year = parseInt(year / 10, 10) * 10;
            yearCont = picker.widget.find('.datepicker-years').find(
                'th:eq(1)').text(year + '-' + (year + 9)).end().find('td');
            picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
            if (startYear > year) {
                picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
            }
            if (endYear < year + 9) {
                picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
            }
            year -= 1;
            for (i = -1; i < 11; i++) {
                html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
                year += 1;
            }
            yearCont.html(html);
        },

        fillHours = function () {
            pMoment.lang(picker.options.language);
            var table = picker.widget.find('.timepicker .timepicker-hours table'), html = '', current, i, j;
            table.parent().hide();
            if (picker.use24hours) {
                current = 0;
                for (i = 0; i < 6; i += 1) {
                    html += '<tr>';
                    for (j = 0; j < 4; j += 1) {
                        html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
                        current++;
                    }
                    html += '</tr>';
                }
            }
            else {
                current = 1;
                for (i = 0; i < 3; i += 1) {
                    html += '<tr>';
                    for (j = 0; j < 4; j += 1) {
                        html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
                        current++;
                    }
                    html += '</tr>';
                }
            }
            table.html(html);
        },

        fillMinutes = function () {
            var table = picker.widget.find('.timepicker .timepicker-minutes table'), html = '', current = 0, i, j, step = picker.options.minuteStepping;
            table.parent().hide();
            if (step == 1) step = 5;
            for (i = 0; i < Math.ceil(60 / step / 4) ; i++) {
                html += '<tr>';
                for (j = 0; j < 4; j += 1) {
                    if (current < 60) {
                        html += '<td class="minute">' + padLeft(current.toString()) + '</td>';
                        current += step;
                    } else {
                        html += '<td></td>';
                    }
                }
                html += '</tr>';
            }
            table.html(html);
        },

        fillSeconds = function () {
            var table = picker.widget.find('.timepicker .timepicker-seconds table'), html = '', current = 0, i, j;
            table.parent().hide();
            for (i = 0; i < 3; i++) {
                html += '<tr>';
                for (j = 0; j < 4; j += 1) {
                    html += '<td class="second">' + padLeft(current.toString()) + '</td>';
                    current += 5;
                }
                html += '</tr>';
            }
            table.html(html);
        },

        fillTime = function () {
            if (!picker.date) return;
            var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
            hour = picker.date.hours(),
            period = 'AM';
            if (!picker.use24hours) {
                if (hour >= 12) period = 'PM';
                if (hour === 0) hour = 12;
                else if (hour != 12) hour = hour % 12;
                picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
            }
            timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
            timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
            timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
        },

        click = function (e) {
            e.stopPropagation();
            e.preventDefault();
            picker.unset = false;
            var target = $(e.target).closest('span, td, th'), month, year, step, day, oldDate = pMoment(picker.date);
            if (target.length === 1) {
                if (!target.is('.disabled')) {
                    switch (target[0].nodeName.toLowerCase()) {
                        case 'th':
                            switch (target[0].className) {
                                case 'switch':
                                    showMode(1);
                                    break;
                                case 'prev':
                                case 'next':
                                    step = dpGlobal.modes[picker.viewMode].navStep;
                                    if (target[0].className === 'prev') step = step * -1;
                                    picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
                                    fillDate();
                                    break;
                            }
                            break;
                        case 'span':
                            if (target.is('.month')) {
                                month = target.parent().find('span').index(target);
                                picker.viewDate.month(month);
                            } else {
                                year = parseInt(target.text(), 10) || 0;
                                picker.viewDate.year(year);
                            }
                            if (picker.viewMode === picker.minViewMode) {
                                picker.date = pMoment({
                                    y: picker.viewDate.year(),
                                    M: picker.viewDate.month(),
                                    d: picker.viewDate.date(),
                                    h: picker.date.hours(),
                                    m: picker.date.minutes(),
                                    s: picker.date.seconds()
                                });
                                notifyChange(oldDate, e.type);
                                set();
                            }
                            showMode(-1);
                            fillDate();
                            break;
                        case 'td':
                            if (target.is('.day')) {
                                day = parseInt(target.text(), 10) || 1;
                                month = picker.viewDate.month();
                                year = picker.viewDate.year();
                                if (target.is('.old')) {
                                    if (month === 0) {
                                        month = 11;
                                        year -= 1;
                                    } else {
                                        month -= 1;
                                    }
                                } else if (target.is('.new')) {
                                    if (month == 11) {
                                        month = 0;
                                        year += 1;
                                    } else {
                                        month += 1;
                                    }
                                }
                                picker.date = pMoment({
                                    y: year,
                                    M: month,
                                    d: day,
                                    h: picker.date.hours(),
                                    m: picker.date.minutes(),
                                    s: picker.date.seconds()
                                }
                                );
                                picker.viewDate = pMoment({
                                    y: year, M: month, d: Math.min(28, day)
                                });
                                fillDate();
                                set();
                                notifyChange(oldDate, e.type);
                            }
                            break;
                    }
                }
            }
        },

        actions = {
            incrementHours: function () {
                checkDate("add", "hours", 1);
            },

            incrementMinutes: function () {
                checkDate("add", "minutes", picker.options.minuteStepping);
            },

            incrementSeconds: function () {
                checkDate("add", "seconds", 1);
            },

            decrementHours: function () {
                checkDate("subtract", "hours", 1);
            },

            decrementMinutes: function () {
                checkDate("subtract", "minutes", picker.options.minuteStepping);
            },

            decrementSeconds: function () {
                checkDate("subtract", "seconds", 1);
            },

            togglePeriod: function () {
                var hour = picker.date.hours();
                if (hour >= 12) hour -= 12;
                else hour += 12;
                picker.date.hours(hour);
            },

            showPicker: function () {
                picker.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
                picker.widget.find('.timepicker .timepicker-picker').show();
            },

            showHours: function () {
                picker.widget.find('.timepicker .timepicker-picker').hide();
                picker.widget.find('.timepicker .timepicker-hours').show();
            },

            showMinutes: function () {
                picker.widget.find('.timepicker .timepicker-picker').hide();
                picker.widget.find('.timepicker .timepicker-minutes').show();
            },

            showSeconds: function () {
                picker.widget.find('.timepicker .timepicker-picker').hide();
                picker.widget.find('.timepicker .timepicker-seconds').show();
            },

            selectHour: function (e) {
                var period = picker.widget.find('.timepicker [data-action=togglePeriod]').text(), hour = parseInt($(e.target).text(), 10);
                if (period == "PM") hour += 12
                picker.date.hours(hour);
                actions.showPicker.call(picker);
            },

            selectMinute: function (e) {
                picker.date.minutes(parseInt($(e.target).text(), 10));
                actions.showPicker.call(picker);
            },

            selectSecond: function (e) {
                picker.date.seconds(parseInt($(e.target).text(), 10));
                actions.showPicker.call(picker);
            }
        },

        doAction = function (e) {
            var oldDate = pMoment(picker.date), action = $(e.currentTarget).data('action'), rv = actions[action].apply(picker, arguments);
            stopEvent(e);
            if (!picker.date) picker.date = pMoment({ y: 1970 });
            set();
            fillTime();
            notifyChange(oldDate, e.type);
            return rv;
        },

        stopEvent = function (e) {
            e.stopPropagation();
            e.preventDefault();
        },

        change = function (e) {
            pMoment.lang(picker.options.language);
            var input = $(e.target), oldDate = pMoment(picker.date), newDate = pMoment(input.val(), picker.format, picker.options.useStrict);
            if (newDate.isValid() && !isInDisableDates(newDate) && isInEnableDates(newDate)) {
                update();
                picker.setValue(newDate);
                notifyChange(oldDate, e.type);
                set();
            }
            else {
                picker.viewDate = oldDate;
                notifyChange(oldDate, e.type);
                notifyError(newDate);
                picker.unset = true;
            }
        },

        showMode = function (dir) {
            if (dir) {
                picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
            }
            var f = dpGlobal.modes[picker.viewMode].clsName;
            picker.widget.find('.datepicker > div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
        },

        attachDatePickerEvents = function () {
            var $this, $parent, expanded, closed, collapseData;
            picker.widget.on('click', '.datepicker *', $.proxy(click, this)); // this handles date picker clicks
            picker.widget.on('click', '[data-action]', $.proxy(doAction, this)); // this handles time picker clicks
            picker.widget.on('mousedown', $.proxy(stopEvent, this));
            if (picker.options.pickDate && picker.options.pickTime) {
                picker.widget.on('click.togglePicker', '.accordion-toggle', function (e) {
                    e.stopPropagation();
                    $this = $(this);
                    $parent = $this.closest('ul');
                    expanded = $parent.find('.in');
                    closed = $parent.find('.collapse:not(.in)');

                    if (expanded && expanded.length) {
                        collapseData = expanded.data('collapse');
                        if (collapseData && collapseData.date - transitioning) return;
                        expanded.collapse('hide');
                        closed.collapse('show');
                        $this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                        picker.element.find('.input-group-addon span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                    }
                });
            }
            if (picker.isInput) {
                picker.element.on({
                    'focus': $.proxy(picker.show, this),
                    'change': $.proxy(change, this),
                    'blur': $.proxy(picker.hide, this)
                });
            } else {
                picker.element.on({
                    'change': $.proxy(change, this)
                }, 'input');
                if (picker.component) {
                    picker.component.on('click', $.proxy(picker.show, this));
                } else {
                    picker.element.on('click', $.proxy(picker.show, this));
                }
            }
        },

        attachDatePickerGlobalEvents = function () {
            $(window).on(
                'resize.datetimepicker' + picker.id, $.proxy(place, this));
            if (!picker.isInput) {
                $(document).on(
                    'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
            }
        },

        detachDatePickerEvents = function () {
            picker.widget.off('click', '.datepicker *', picker.click);
            picker.widget.off('click', '[data-action]');
            picker.widget.off('mousedown', picker.stopEvent);
            if (picker.options.pickDate && picker.options.pickTime) {
                picker.widget.off('click.togglePicker');
            }
            if (picker.isInput) {
                picker.element.off({
                    'focus': picker.show,
                    'change': picker.change
                });
            } else {
                picker.element.off({
                    'change': picker.change
                }, 'input');
                if (picker.component) {
                    picker.component.off('click', picker.show);
                } else {
                    picker.element.off('click', picker.show);
                }
            }
        },

        detachDatePickerGlobalEvents = function () {
            $(window).off('resize.datetimepicker' + picker.id);
            if (!picker.isInput) {
                $(document).off('mousedown.datetimepicker' + picker.id);
            }
        },

        isInFixed = function () {
            if (picker.element) {
                var parents = picker.element.parents(), inFixed = false, i;
                for (i = 0; i < parents.length; i++) {
                    if ($(parents[i]).css('position') == 'fixed') {
                        inFixed = true;
                        break;
                    }
                }
                ;
                return inFixed;
            } else {
                return false;
            }
        },

        set = function () {
            pMoment.lang(picker.options.language);
            var formatted = '', input;
            if (!picker.unset) formatted = pMoment(picker.date).format(picker.format);
            getPickerInput().val(formatted);
            picker.element.data('date', formatted);
            if (!picker.options.pickTime) picker.hide();
        },

        checkDate = function (direction, unit, amount) {
            pMoment.lang(picker.options.language);
            var newDate;
            if (direction == "add") {
                newDate = pMoment(picker.date);
                if (newDate.hours() == 23) newDate.add(amount, unit);
                newDate.add(amount, unit);
            }
            else {
                newDate = pMoment(picker.date).subtract(amount, unit);
            }
            if (isInDisableDates(pMoment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
                notifyError(newDate.format(picker.format));
                return;
            }

            if (direction == "add") {
                picker.date.add(amount, unit);
            }
            else {
                picker.date.subtract(amount, unit);
            }
            picker.unset = false;
        },

        isInDisableDates = function (date) {
            pMoment.lang(picker.options.language);
            if (date.isAfter(picker.options.maxDate) || date.isBefore(picker.options.minDate)) return true;
            if (picker.options.disabledDates === false) {
                return false;
            }
            return picker.options.disabledDates[pMoment(date).format("YYYY-MM-DD")] === true;
        },
        isInEnableDates = function (date) {
            pMoment.lang(picker.options.language);
            if (picker.options.enabledDates === false) {
                return true;
            }
            return picker.options.enabledDates[pMoment(date).format("YYYY-MM-DD")] === true;
        },

        indexGivenDates = function (givenDatesArray) {
            // Store given enabledDates and disabledDates as keys.
            // This way we can check their existence in O(1) time instead of looping through whole array.
            // (for example: picker.options.enabledDates['2014-02-27'] === true)
            var givenDatesIndexed = {};
            var givenDatesCount = 0;
            for (i = 0; i < givenDatesArray.length; i++) {
                dDate = pMoment(givenDatesArray[i]);
                if (dDate.isValid()) {
                    givenDatesIndexed[dDate.format("YYYY-MM-DD")] = true;
                    givenDatesCount++;
                }
            }
            if (givenDatesCount > 0) {
                return givenDatesIndexed;
            }
            return false;
        },

        padLeft = function (string) {
            string = string.toString();
            if (string.length >= 2) return string;
            else return '0' + string;
        },

        getTemplate = function () {
            if (picker.options.pickDate && picker.options.pickTime) {
                var ret = '';
                ret = '<div id="fd" class="bootstrap-datetimepicker-widget' + (picker.options.sideBySide ? ' timepicker-sbs' : '') + ' ' + (picker.options.component) + '" style="z-index:9999 !important;">';
                if (picker.options.sideBySide) {
                    ret += '<div class="row">' +
                       '<div class="col-sm-6 datepicker">' + dpGlobal.template + '</div>' +
                       '<div class="col-sm-6 timepicker">' + tpGlobal.getTemplate() + '</div>' +
                     '</div>';
                } else {
                    ret += '<ul class="list-unstyled">' +
                        '<li' + (picker.options.collapse ? ' class="collapse in"' : '') + '>' +
                            '<div class="datepicker">' + dpGlobal.template + '</div>' +
                        '</li>' +
                        '<li class="picker-switch accordion-toggle"><a class="btn btn-primary" style="width:100%"><span class="' + picker.options.icons.time + '"></span></a></li>' +
                        '<li' + (picker.options.collapse ? ' class="collapse"' : '') + '>' +
                            '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
                        '</li>' +
                   '</ul>';

                   // Reserved in case if topdown layout is needed
                   //  ret += '<ul class="list-unstyled">' +
                   //      '<li>' +
                   //          '<div class="datepicker">' + dpGlobal.template + '</div>' +
                   //      '</li>' +
                   //      '<li>' +
                   //          '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
                   //      '</li>' +
                   // '</ul>';
                }
                ret += '</div>';
                return ret;
            } else if (picker.options.pickTime) {
                return (
                    '<div id="fd" class="bootstrap-datetimepicker-widget">' +
                        '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
                    '</div>'
                );
            } else {
                return (
                    '<div id="fd" class="bootstrap-datetimepicker-widget">' +
                        '<div class="datepicker">' + dpGlobal.template + '</div>' +
                    '</div>'
                );
            }
        },

        dpGlobal = {
            modes: [
                {
                    clsName: 'days',
                    navFnc: 'month',
                    navStep: 1
                },
                {
                    clsName: 'months',
                    navFnc: 'year',
                    navStep: 1
                },
                {
                    clsName: 'years',
                    navFnc: 'year',
                    navStep: 10
                }],
            headTemplate:
                    '<thead>' +
                        '<tr>' +
                            '<th class="prev">&lsaquo;</th><th colspan="5" class="switch"></th><th class="next">&rsaquo;</th>' +
                        '</tr>' +
                    '</thead>',
            contTemplate:
        '<tbody><tr><td colspan="7"></td></tr></tbody>'
        },

        tpGlobal = {
            hourTemplate: '<span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"></span>',
            minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
            secondTemplate: '<span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"></span>'
        };

        dpGlobal.template =
            '<div class="datepicker-days">' +
                '<table class="table-condensed">' + dpGlobal.headTemplate + '<tbody></tbody></table>' +
            '</div>' +
            '<div class="datepicker-months">' +
                '<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
            '</div>' +
            '<div class="datepicker-years">' +
                '<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
            '</div>';

        tpGlobal.getTemplate = function () {
            return (
                '<div class="timepicker-picker">' +
                    '<table class="table-condensed">' +
                        '<tr>' +
                            '<td><a href="#" class="btn" data-action="incrementHours"><i class="' + picker.options.icons.up + '"></i></a></td>' +
                            '<td class="separator"></td>' +
                            '<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="incrementMinutes"><i class="' + picker.options.icons.up + '"></i></a>' : '') + '</td>' +
                            (picker.options.useSeconds ?
                                '<td class="separator"></td><td><a href="#" class="btn" data-action="incrementSeconds"><i class="' + picker.options.icons.up + '"></i></a></td>' : '') +
                            (picker.use24hours ? '' : '<td class="separator"></td>') +
                        '</tr>' +
                        '<tr>' +
                            '<td>' + tpGlobal.hourTemplate + '</td> ' +
                            '<td class="separator">:</td>' +
                            '<td>' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '<span class="timepicker-minute">00</span>') + '</td> ' +
                            (picker.options.useSeconds ?
                                '<td class="separator">:</td><td>' + tpGlobal.secondTemplate + '</td>' : '') +
                            (picker.use24hours ? '' : '<td class="separator"></td>' +
                            '<td><button type="button" class="btn btn-primary" data-action="togglePeriod"></button></td>') +
                        '</tr>' +
                        '<tr>' +
                            '<td><a href="#" class="btn" data-action="decrementHours"><i class="' + picker.options.icons.down + '"></i></a></td>' +
                            '<td class="separator"></td>' +
                            '<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="decrementMinutes"><i class="' + picker.options.icons.down + '"></i></a>' : '') + '</td>' +
                            (picker.options.useSeconds ?
                                '<td class="separator"></td><td><a href="#" class="btn" data-action="decrementSeconds"><i class="' + picker.options.icons.down + '"></i></a></td>' : '') +
                            (picker.use24hours ? '' : '<td class="separator"></td>') +
                        '</tr>' +
                    '</table>' +
                '</div>' +
                '<div class="timepicker-hours" data-action="selectHour">' +
                    '<table class="table-condensed"></table>' +
                '</div>' +
                '<div class="timepicker-minutes" data-action="selectMinute">' +
                    '<table class="table-condensed"></table>' +
                '</div>' +
                (picker.options.useSeconds ?
                    '<div class="timepicker-seconds" data-action="selectSecond"><table class="table-condensed"></table></div>' : '')
            );
        };

        picker.destroy = function () {
            detachDatePickerEvents();
            detachDatePickerGlobalEvents();
            picker.widget.remove();
            picker.element.removeData('DateTimePicker');
            if (picker.component)
                picker.component.removeData('DateTimePicker');
        };

        picker.show = function (e) {
            if (picker.options.useCurrent) {
                if (getPickerInput().val() == '') {
                    if (picker.options.minuteStepping !== 1) {
                        var mDate = pMoment(),
                        rInterval = picker.options.minuteStepping;
                        mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60)
                            .seconds(0);
                        picker.setValue(mDate.format(picker.format))
                    } else {
                        picker.setValue(pMoment().format(picker.format))
                    }
                };
            }
            if (picker.widget.hasClass("picker-open")) {
                picker.widget.hide();
                picker.widget.removeClass("picker-open");
            }
            else {
                picker.widget.show();
                picker.widget.addClass("picker-open");
            }
            picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
            place();
            picker.element.trigger({
                type: 'dp.show',
                date: pMoment(picker.date)
            });
            attachDatePickerGlobalEvents();
            if (e) {
                stopEvent(e);
            }
        },

        picker.disable = function () {
            var input = picker.element.find('input');
            if (input.prop('disabled')) return;

            input.prop('disabled', true);
            detachDatePickerEvents();
        },

        picker.enable = function () {
            var input = picker.element.find('input');
            if (!input.prop('disabled')) return;

            input.prop('disabled', false);
            attachDatePickerEvents();
        },

        picker.hide = function (event) {
            if (event && $(event.target).is(picker.element.attr("id")))
                return;
            // Ignore event if in the middle of a picker transition
            var collapse = picker.widget.find('.collapse'), i, collapseData;
            for (i = 0; i < collapse.length; i++) {
                collapseData = collapse.eq(i).data('collapse');
                if (collapseData && collapseData.date - transitioning)
                    return;
            }
            picker.widget.hide();
            picker.widget.removeClass("picker-open");
            picker.viewMode = picker.startViewMode;
            showMode();
            picker.element.trigger({
                type: 'dp.hide',
                date: pMoment(picker.date)
            });
            detachDatePickerGlobalEvents();
        },

        picker.setValue = function (newDate) {
            pMoment.lang(picker.options.language);
            if (!newDate) {
                picker.unset = true;
                set();
            } else {
                picker.unset = false;
            }
            if (!pMoment.isMoment(newDate)) newDate = pMoment(newDate, picker.format);
            if (newDate.isValid()) {
                picker.date = newDate;
                set();
                picker.viewDate = pMoment({ y: picker.date.year(), M: picker.date.month() });
                fillDate();
                fillTime();
            }
            else {
                notifyError(newDate);
            }
        },

        picker.getDate = function () {
            if (picker.unset) return null;
            return picker.date;
        },

        picker.setDate = function (date) {
            var oldDate = pMoment(picker.date);
            if (!date) {
                picker.setValue(null);
            } else {
                picker.setValue(date);
            }
            notifyChange(oldDate, "function");
        },

        picker.setDisabledDates = function (dates) {
            picker.options.disabledDates = indexGivenDates(dates);
            if (picker.viewDate) update();
        },
        picker.setEnabledDates = function (dates) {
            picker.options.enabledDates = indexGivenDates(dates);
            if (picker.viewDate) update();
        },

        picker.setMaxDate = function (date) {
            if (date == undefined) return;
            picker.options.maxDate = pMoment(date);
            if (picker.viewDate) update();
        },

        picker.setMinDate = function (date) {
            if (date == undefined) return;
            picker.options.minDate = pMoment(date);
            if (picker.viewDate) update();
        };

        init();
    };

    $.fn._datetimepicker = function (options) {
        return this.each(function () {
            var $this = $(this), data = $this.data('DateTimePicker');
            if (!data) $this.data('DateTimePicker', new DateTimePicker(this, options));
        });
    };

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("datetimepicker", moduleFactory);

}());

(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
$.require() 
 .script("ui/position") 
 .done(function() { 
var exports = function() { 

/*
<div
	data-popbox="module://popbox/options/exporter"
	data-popbox-class="profile"
	data-popbox-position="bottom-left"></div>

<div class="popbox" data-popbox-tooltip>
<div class="arrow"></div>
<div class="popbox-content">
</div>
</div>
*/

$.fn.popbox = function(options) {

	// Creating or updating popbox options
	if ($.isPlainObject(options)) {

		this.each(function(){

			var button = $(this),
				popbox = Popbox.get(button);

			// Update popbox options
			if (popbox) {
				popbox.update(options);

			// Or create a new popbox
			} else {

				popbox = new Popbox(button, options);
			}
		});

		return this;
	}

	// Calling a method in popbox
	if ($.isString(options)) {

		var button = $(this[0]),

			// Create new popbox instance if
			// it hasn't been created yet
			popbox = Popbox.get(button) || new Popbox(button),

			method = popbox[options],

			ret;

		if ($.isFunction(method)) {

			ret = method.apply(popbox, $.makeArray(arguments).slice(1));
		}

		return ret || this;
	}

	return this;
}

var Popbox = function(button, options) {

	var popbox = this;

	// Store popbox instance within button
	button.data("popbox", popbox);

	// Normalize arguments
	if ($.isString(options)) {
		options = {content: options}
	}

	if (!options) {
		options = {};
	}

	// Popbox button that is placed in a
	// fixed position needs special handling.
	button.parentsUntil("body").addBack()
		.each(function(){
			var parent = $(this);
			if (parent.css("position")==="fixed") {
				options.fixed = true;
				return false;
			}
		});

	// Gather element options
	var elementOptions = {},
		// Takes content from data-popbox attribute, else take it from inline content.
		content = button.attr("data-popbox") || button.find("[data-popbox-content]").html() || $(button.attr("data-popbox-target")).html();
		if (content) elementOptions.content = content;

	$(["id", "component", "type", "toggle", "position", "collision"])
		.each(function(i, key){
			var val = button.attr("data-popbox-" + key);
			elementOptions[key] = val;
		});

	// Quick Hack
	if (button.attr("data-popbox-offset")!==undefined) {
		elementOptions["offset"] = parseInt(button.attr("data-popbox-offset"));
	}

	// If popbox was set up via jQuery, the element may not
	// have the data-popbox attribute. We need this attribute
	// for click and hover events to work (and keep things DRY).
	if (content===undefined) button.attr("data-popbox", "");

	// Build final options
	popbox.update(
		$.extend(true,
			{},
			Popbox.defaultOptions,
			{
				tooltip: $(),
				loader : $('<div id="fd" class="popbox loading" data-popbox-tooltip><div class="arrow"></div></div>'),
				uid    : $.uid(),
				button : button
			},
			elementOptions,
			options
		)
	);
};

// Default options
Popbox.defaultOptions = {
	content: "",
	id: null,
	type: "",
	enabled: false,
	wait: false,
	locked: false,
	exclusive: false,
	hideTimer: null,
	hideDelay: 50,
	toggle: "hover",
	position: "bottom",
	collision: "flip",
	cache: true,
	fixed: false,
	offset: 10
};

Popbox.get = function(el) {

	var popbox = $(el).data("popbox");

	if (popbox instanceof Popbox) return popbox;
}

Popbox.toggleEvent = navigator.userAgent.match(/iPhone|iPad|iPod/i) ? "touchstart" : "click";

$.extend(Popbox.prototype, {

	positions: "top top-left top-right top-center bottom bottom-left bottom-right bottom-center left left-top left-bottom left-center right right-top right-bottom right-center",

	update: function(options) {

		var popbox = this;

		// Update popbox options
		$.extend(true, popbox, options);

		// If popbox content is a module
		if ($.isModule(popbox.content)) {

			// Don't let anything happen until module is resolved.
			popbox.wait = true;

			$.module(popbox.content)
				.done(function(options){

					// Popbox options
					if ($.isPlainObject(options)) {
						popbox.update(options);
					}

					// Callback that returns customized popbox options
					if ($.isFunction(options)) {

						popbox.update({
							content: options
						});
					}
				})
				.fail(function(){

					popbox.update({
						content: "Unable to load tooltip content."
					});
				})
				.always(function(){
					popbox.wait = false;
				});

			return;
		}

		// If popbox content is a string,
		// we'll just rewrap it in deferred.
		if ($.isString(popbox.content)) {
			popbox.content = $.Deferred().resolve(popbox.content);
		}

		var position = popbox.position;

		if ($.isString(position)) {

			// Determine position
			var pos = position.split("-"),
				x1, y1, x2, y2;

			switch (pos[0]) {

				case "top":
				case "bottom":
					x1 = x2 = pos[1] || "center";
					// y1 = pos[0]=="top" ? "bottom-10" : "top+10";
					y1 = pos[0]=="top" ? "bottom" : "top";
					y2 = pos[0]=="top" ? "top"    : "bottom";
					break;

				case "left":
				case "right":
					y1 = y2 = pos[1] || "center";
					// x1 = pos[0]=="left" ? "right-10" : "left+10";
					x1 = pos[0]=="left" ? "right" : "left";
					x2 = pos[0]=="left" ? "left"  : "right";
					break;
			}

			popbox.position = {
				classname: position,
				my: x1 + " " + y1,
				at: x2 + " " + y2,
				using: function(coords, feedback) {

					var tooltip   = $(this),
						classname = popbox.position.classname,
						top       = coords.top,
						left      = coords.left,
						offset    = popbox.offset,
						buttonOffset = popbox.button.offset();

					switch (pos[0]) {

						case "top":
						case "bottom":
							var vertical = feedback.vertical;
							if (vertical==pos[0]) {
								classname = classname.replace(/top|bottom/gi, (vertical=="top") ? "bottom" : "top");
							}
							top = (vertical=="top") ? top + offset : top - offset;

							if (pos[1]=="left" && (left < Math.floor(buttonOffset.left))) {
								classname = classname.replace(/left|right/gi, (pos[1]=="left") ? "right" : "left");
							}
							break;

						case "left":
						case "right":
							var horizontal = feedback.horizontal;
							if (feedback.horizontal==pos[0]) {
								classname = classname.replace(/left|right/gi, (feedback.horizontal=="left") ? "right" : "left");
							}
							left = (horizontal=="left") ? left + offset : left - offset;
							break;
					}

					tooltip
						.css({
							top : top  + 'px',
							left: left + 'px'
						})
						.removeClass(popbox.positions)
						.addClass(classname);
				}
			};
		}

		$.extend(popbox.position, {
			of: popbox.button,
			collision: popbox.collision
		});

		// Popbox loader
		popbox.loader
			.attr({
				"id": popbox.id,
				"data-popbox-tooltip": popbox.type,
				"style": popbox.fixed ? 'position: fixed' : ''
			})
			.addClass(popbox.component)
			.addClass("popbox-" + popbox.type);

		// If popbox is enabled, show tooltip with new options.
		if (popbox.enabled) {
			popbox.show();
		}
	},

	trigger: function(event, args) {

		var popbox = this;

		this.tooltip.trigger(event, args);
		this.button.trigger(event, args);
	},

	show: function() {

		var popbox = this;

		// Enable popbox
		popbox.enabled = true;

		// If we're waiting for module to resolve, stop.
		if (popbox.wait) return;

		// Stop any task that hides popover
		clearTimeout(popbox.hideTimer);

		// If this popbox can only be shown exclusively,
		// then hide other popbox.
		if (popbox.exclusive) {

			$("[data-popbox-tooltip]").each(function(){

				var popbox = Popbox.get($(this));

				if (!popbox) return;

				popbox.hide();
			});
		}

		// Insert active for button
		popbox.button.addClass("active");

		// Hide when popbox is blurred
		if (popbox.toggle=="click") {

			var doc = $(document),
				hideOnClick = Popbox.toggleEvent + ".popbox." + popbox.uid;

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					// Don't hide popbox is popbox button or tooltip is one of those elements.
					if (targets.filter(popbox.button).length  > 0 ||
						targets.filter(popbox.tooltip).length > 0) return;

					// Unbind hiding
					doc.off(hideOnClick);

					popbox.hide();
				});
		}

		// Reposition popbox when browser resized or zoomed
		var win = $(window),
			repositionOnResize = "resize.popbox" + popbox.uid;

		win
			.off(repositionOnResize)
			.on(repositionOnResize, function(){

				// Reposition popbox
				if (popbox.tooltip.length > 0) {
					popbox.tooltip
						.position(popbox.position);
				}
			});

		// If tooltip exists, just show tootip
		if (popbox.tooltip.length > 0) {

			popbox.tooltip
				.appendTo("body")
				.position(popbox.position);

			// Trigger popboxActivate event
			popbox.trigger("popboxActivate", [popbox]);

			return;
		}

		// If popbox content is a function,
		if ($.isFunction(popbox.content)) {

			// Execute the function and to get popbox options
			var options = popbox.content(popbox);

			// Update popbox with the new options
			popbox.update(options);

			// If updating popbox causes it to fall into wait mode, stop.
			if (popbox.wait) return;
		}

		// If at this point, popbox is not a deferred object,
		// then we don't have any tooltip to show.
		if (!$.isDeferred(popbox.content)) return;

		// If the popbox content is still loading,
		// show loading indicator.
		if (popbox.content.state()=="pending") {

			popbox.loader
				.appendTo("body")
				.position(popbox.position);

			// Trigger popboxLoading event
			popbox.trigger("popboxLoading", [popbox]);
		}

		popbox.content
			.always(function(){

				popbox.wait = false;
			})
			.done(function(html){

				// If popbox already has a tooltip, stop.
				if (popbox.tooltip.length > 0) return;

				// If popbox is disabled, don't show it.
				if (!popbox.enabled) return;

				// Remove loading indicator
				popbox.loader.detach();

				var tooltip = $.buildHTML(html);

				if (tooltip.filter("[data-popbox-tooltip]").length < 1) {

					var content = tooltip;

					tooltip =
						// Create wrapper and
						$('<div id="fd" class="popbox" data-popbox-tooltip><div class="arrow"></div><div class="popbox-content" data-popbox-content></div></div>')
							.attr({
								"id": popbox.id,
								"data-popbox-tooltip": popbox.type,
								"style": popbox.fixed ? 'position: fixed' : ''
							})
							.addClass(popbox.component)
							.addClass("popbox-" + popbox.type)
							// append to body first because
							.appendTo("body");

					// We want any possible scripts within the tooltip
					// content to execute when it is visible in DOM.
					tooltip
						.find('[data-popbox-content]')
						.append(content);

				} else {

					tooltip =
						// This tooltip might be an array of elements, e.g.
						// tooltip div, scripts and text nodes.
						tooltip
							// we append to body first to
							// let the scripts execute
							.appendTo("body")
							// then filter out the popbox tooltip
							// to assign it back as our variable
							.filter("[data-popbox-tooltip]");
				}

				// Store tooltip property in popbox
				popbox.tooltip =
					tooltip
						// and let tooltip has a reference back to popbox
						.data("popbox", popbox)
						// reposition tooltip
						.position(popbox.position);

				// Trigger popboxActivate event
				popbox.trigger("popboxActivate", [popbox]);
			})
			.fail(function(){

				popbox.update({
					content: "Unable to load tooltip content."
				});
			});
	},

	hide: function(force) {

		var popbox = this;

		// Disable popbox
		popbox.enabled = false;

		// Stop any previous hide timer
		clearTimeout(popbox.hideTimer);

		// Detach popbox loader
		popbox.loader.detach();

		var hide = function(){

			if (popbox.locked && !force) return;

			// Detach tooltip
			popbox.tooltip
				.detach();

			// Detach repositionOnResize
			$(window).off("resize.popbox" + popbox.uid);

			// Trigger popboxDeactivate event
			popbox.trigger("popboxDeactivate", [popbox]);

			if (!popbox.cache) {
				popbox.destroy();
			}
		}

		// Removed active for button
		popbox.button.removeClass("active");

		popbox.hideTimer = setTimeout(hide, popbox.hideDelay);
	},

	destroy: function() {

		this.button.removeData("popbox");
	},

	widget: function() {

		return this;
	}
});

// Data API
$(document)
	.on(Popbox.toggleEvent + '.popbox', '[data-popbox]', function(){

		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover") return;

		if (popbox.enabled) {
			popbox.hide();
		} else {
			popbox.show();
		}
	})
	.on('mouseover.popbox', '[data-popbox]', function(){

		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover" && !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) popbox.show();
	})
	.on('mouseout.popbox', '[data-popbox]', function(){

		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover") popbox.hide();
	})
	.on('mouseover.popbox.tooltip', '[data-popbox-tooltip]', function(){

		var popbox = Popbox.get(this);

		if (!popbox) return;

		if (popbox.toggle!=="hover") return;

		// Lock popbox
		popbox.locked = true;

		clearTimeout(popbox.hideTimer);
	})
	.on('mouseout.popbox.tooltip', '[data-popbox-tooltip]', function(){

		var popbox = Popbox.get(this);

		if (!popbox) return;

		if (popbox.toggle!=="hover") return;

		// Unlock popbox
		popbox.locked = false;

		// Hide popbox
		popbox.hide();
 	})
 	.on('click.popbox.close', '[data-popbox-close]', function(){

 		var popbox = Popbox.get($(this).parents('[data-popbox-tooltip]'));

 		if (!popbox) return;

 		popbox.hide();
 	});
}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("popbox", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Position 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/position", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;

var callbackId = $.callback(function(){/*!
 * GMaps.js v0.3.1
 * http://hpneo.github.com/gmaps/
 *
 * Copyright 2012, Gustavo Leon
 * Released under the MIT License.
 */

  if(!window.google && !window.google.maps){
    module.reject("Google Maps API is required. Please register the following JavaScript library http://maps.google.com/maps/api/js?sensor=true.");
  }

  var GMaps = (function(global) {
    "use strict";

    var doc = document;
    var getElementById = function(id, context) {
      return $("#"+id.replace('#', ''), context)[0];
    };

    var GMaps = function(options) {
      var self = this;

      var events_that_hide_context_menu = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'idle', 'maptypeid_changed', 'projection_changed', 'resize', 'tilesloaded', 'zoom_changed'];
      var events_that_doesnt_hide_context_menu = ['mousemove', 'mouseout', 'mouseover'];

      window.context_menu = {};

      if (typeof(options.el) === 'string' || typeof(options.div) === 'string') {
        this.el = getElementById(options.el || options.div, options.context);
      } else {
        this.el = options.el || options.div;
      };

      if (typeof(this.el) === 'undefined' || this.el === null) {
        throw 'No element defined.';
      }

      this.el.style.width = options.width || this.el.scrollWidth || this.el.offsetWidth;
      this.el.style.height = options.height || this.el.scrollHeight || this.el.offsetHeight;

      this.controls = [];
      this.overlays = [];
      this.layers = []; // array with kml and ft layers, can be as many
      this.singleLayers = {}; // object with the other layers, only one per layer
      this.markers = [];
      this.polylines = [];
      this.routes = [];
      this.polygons = [];
      this.infoWindow = null;
      this.overlay_el = null;
      this.zoom = options.zoom || 15;
      this.registered_events = {};

      var markerClusterer = options.markerClusterer;

      //'Hybrid', 'Roadmap', 'Satellite' or 'Terrain'
      var mapType;

      if (options.mapType) {
        mapType = google.maps.MapTypeId[options.mapType.toUpperCase()];
      }
      else {
        mapType = google.maps.MapTypeId.ROADMAP;
      }

      var map_center = new google.maps.LatLng(options.lat, options.lng);

      delete options.el;
      delete options.lat;
      delete options.lng;
      delete options.mapType;
      delete options.width;
      delete options.height;
      delete options.markerClusterer;

      var zoomControlOpt = options.zoomControlOpt || {
        style: 'DEFAULT',
        position: 'TOP_LEFT'
      };

      var zoomControl = options.zoomControl || true,
          zoomControlStyle = zoomControlOpt.style || 'DEFAULT',
          zoomControlPosition = zoomControlOpt.position || 'TOP_LEFT',
          panControl = options.panControl || true,
          mapTypeControl = options.mapTypeControl || true,
          scaleControl = options.scaleControl || true,
          streetViewControl = options.streetViewControl || true,
          overviewMapControl = overviewMapControl || true;

      var map_options = {};

      var map_base_options = {
        zoom: this.zoom,
        center: map_center,
        mapTypeId: mapType
      };

      var map_controls_options = {
        panControl: panControl,
        zoomControl: zoomControl,
        zoomControlOptions: {
          style: google.maps.ZoomControlStyle[zoomControlStyle], // DEFAULT LARGE SMALL
          position: google.maps.ControlPosition[zoomControlPosition]
        },
        mapTypeControl: mapTypeControl,
        scaleControl: scaleControl,
        streetViewControl: streetViewControl,
        overviewMapControl: overviewMapControl
      }

      if(options.disableDefaultUI != true)
        map_base_options = extend_object(map_base_options, map_controls_options);

      map_options = extend_object(map_base_options, options);

      for(var i = 0; i < events_that_hide_context_menu.length; i++) {
        delete map_options[events_that_hide_context_menu[i]];
      }

      for(var i = 0; i < events_that_doesnt_hide_context_menu.length; i++) {
        delete map_options[events_that_doesnt_hide_context_menu[i]];
      }

      this.map = new google.maps.Map(this.el, map_options);

      if(markerClusterer) {
        this.markerClusterer = markerClusterer.apply(this, [this.map]);
      }

      // finds absolute position of an element
      var findAbsolutePosition = function(obj)  {
        var curleft = 0;
        var curtop = 0;
        if (obj.offsetParent) {
          do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
          } while (obj = obj.offsetParent);
        }
        return [curleft,curtop];
      //returns an array
      }


      // Context menus
      var buildContextMenuHTML = function(control, e) {
        var html = '';
        var options = window.context_menu[control];
        for (var i in options){
          if (options.hasOwnProperty(i)){
            var option = options[i];
            html += '<li><a id="' + control + '_' + i + '" href="#">' +
              option.title + '</a></li>';
          }
        }

        if(!getElementById('gmaps_context_menu')) return;

        var context_menu_element = getElementById('gmaps_context_menu');
        context_menu_element.innerHTML = html;

        var context_menu_items = context_menu_element.getElementsByTagName('a');

        var context_menu_items_count = context_menu_items.length;

        for(var i = 0; i < context_menu_items_count; i++){
          var context_menu_item = context_menu_items[i];

          var assign_menu_item_action = function(ev){
            ev.preventDefault();

            options[this.id.replace(control + '_', '')].action.apply(self, [e]);
            self.hideContextMenu();
          };

          google.maps.event.clearListeners(context_menu_item, 'click');
          google.maps.event.addDomListenerOnce(context_menu_item, 'click', assign_menu_item_action, false);
        }

        var position = findAbsolutePosition.apply(this, [self.el]);
        var left = position[0] + e.pixel.x - 15;
        var top = position[1] + e.pixel.y- 15;

        context_menu_element.style.left = left + "px";
        context_menu_element.style.top = top + "px";

        context_menu_element.style.display = 'block';
      };

      var buildContextMenu = function(control, e) {
        if (control === 'marker') {
          e.pixel = {};
          var overlay = new google.maps.OverlayView();
          overlay.setMap(self.map);
          overlay.draw = function() {
            var projection = overlay.getProjection();
            var position = e.marker.getPosition();
            e.pixel = projection.fromLatLngToContainerPixel(position);

            buildContextMenuHTML(control, e);
          };
        }
        else {
          buildContextMenuHTML(control, e);
        }
      };

      this.setContextMenu = function(options) {
        window.context_menu[options.control] = {};

        for (var i in options.options){
          if (options.options.hasOwnProperty(i)){
            var option = options.options[i];
            window.context_menu[options.control][option.name] = {
              title: option.title,
              action: option.action
            };
          }
        }

        var ul = doc.createElement('ul');

        ul.id = 'gmaps_context_menu';
        ul.style.display = 'none';
        ul.style.position = 'absolute';
        ul.style.minWidth = '100px';
        ul.style.background = 'white';
        ul.style.listStyle = 'none';
        ul.style.padding = '8px';
        ul.style.boxShadow = '2px 2px 6px #ccc';

        doc.body.appendChild(ul);

        var context_menu_element = getElementById('gmaps_context_menu');

        google.maps.event.addDomListener(context_menu_element, 'mouseout', function(ev) {
          if(!ev.relatedTarget || !this.contains(ev.relatedTarget)){
            window.setTimeout(function(){
              context_menu_element.style.display = 'none';
            }, 400);
          }
        }, false);
      };

      this.hideContextMenu = function() {
        var context_menu_element = getElementById('gmaps_context_menu');
        if(context_menu_element)
          context_menu_element.style.display = 'none';
      };

      //Events

      var setupListener = function(object, name) {
        google.maps.event.addListener(object, name, function(e){
          if(e == undefined) {
            e = this;
          }

          options[name].apply(this, [e]);

          self.hideContextMenu();
        });
      }

      for (var ev = 0; ev < events_that_hide_context_menu.length; ev++) {
        var name = events_that_hide_context_menu[ev];

        if (name in options) {
          setupListener(this.map, name);
        }
      }

      for (var ev = 0; ev < events_that_doesnt_hide_context_menu.length; ev++) {
        var name = events_that_doesnt_hide_context_menu[ev];

        if (name in options) {
          setupListener(this.map, name);
        }
      }

      google.maps.event.addListener(this.map, 'rightclick', function(e) {
        if (options.rightclick) {
          options.rightclick.apply(this, [e]);
        }

        if(window.context_menu['map'] != undefined) {
          buildContextMenu('map', e);
        }
      });

      this.refresh = function() {
        google.maps.event.trigger(this.map, 'resize');
      };

      this.fitZoom = function() {
        var latLngs = [];
        var markers_length = this.markers.length;

        for(var i=0; i < markers_length; i++) {
          latLngs.push(this.markers[i].getPosition());
        }

        this.fitLatLngBounds(latLngs);
      };

      this.fitLatLngBounds = function(latLngs) {
        var total = latLngs.length;
        var bounds = new google.maps.LatLngBounds();

        for(var i=0; i < total; i++) {
          bounds.extend(latLngs[i]);
        }

        this.map.fitBounds(bounds);
      };

      // Map methods
      this.setCenter = function(lat, lng, callback) {
        this.map.panTo(new google.maps.LatLng(lat, lng));
        if (callback) {
          callback();
        }
      };

      this.getElement = function() {
        return this.el;
      };

      this.zoomIn = function(value) {
        value = value || 1;
        this.zoom = this.map.getZoom() + value;
        this.map.setZoom(this.zoom);
      };

      this.zoomOut = function(value) {
        value = value || 1;
        this.zoom = this.map.getZoom() - value;
        this.map.setZoom(this.zoom);
      };

      var native_methods = [];

      for(var method in this.map){
        if(typeof(this.map[method]) == 'function' && !this[method]){
          native_methods.push(method);
        }
      }

      for(var i=0; i < native_methods.length; i++){
        (function(gmaps, scope, method_name) {
          gmaps[method_name] = function(){
            return scope[method_name].apply(scope, arguments);
          };
        })(this, this.map, native_methods[i]);
      }

      this.createControl = function(options) {
        var control = doc.createElement('div');

        control.style.cursor = 'pointer';
        control.style.fontFamily = 'Arial, sans-serif';
        control.style.fontSize = '13px';
        control.style.boxShadow = 'rgba(0, 0, 0, 0.398438) 0px 2px 4px';

        for(var option in options.style)
          control.style[option] = options.style[option];

        if(options.id) {
          control.id = options.id;
        }

        if(options.classes) {
          control.className = options.classes;
        }

        if(options.content) {
          control.innerHTML = options.content;
        }

        for (var ev in options.events) {
          (function(object, name) {
            google.maps.event.addDomListener(object, name, function(){
              options.events[name].apply(this, [this]);
            });
          })(control, ev);
        }

        control.index = 1;

        return control;
      };

      this.addControl = function(options) {
        var position = google.maps.ControlPosition[options.position.toUpperCase()];

        delete options.position;

        var control = this.createControl(options);
        this.controls.push(control);
        this.map.controls[position].push(control);

        return control;
      };

      // Markers
      this.createMarker = function(options) {
        if ((options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) || options.position) {
          var self = this;
          var details = options.details;
          var fences = options.fences;
          var outside = options.outside;

          var base_options = {
            position: new google.maps.LatLng(options.lat, options.lng),
            map: null
          };

          delete options.lat;
          delete options.lng;
          delete options.fences;
          delete options.outside;

          var marker_options = extend_object(base_options, options);

          var marker = new google.maps.Marker(marker_options);

          marker.fences = fences;

          if (options.infoWindow) {
            marker.infoWindow = new google.maps.InfoWindow(options.infoWindow);

            var info_window_events = ['closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'];

            for (var ev = 0; ev < info_window_events.length; ev++) {
              (function(object, name) {
                if (options.infoWindow[name]) {
                  google.maps.event.addListener(object, name, function(e){
                    options.infoWindow[name].apply(this, [e]);
                  });
                }
              })(marker.infoWindow, info_window_events[ev]);
            }
          }

          var marker_events = ['animation_changed', 'clickable_changed', 'cursor_changed', 'draggable_changed', 'flat_changed', 'icon_changed', 'position_changed', 'shadow_changed', 'shape_changed', 'title_changed', 'visible_changed', 'zindex_changed'];

          var marker_events_with_mouse = ['dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];

          for (var ev = 0; ev < marker_events.length; ev++) {
            (function(object, name) {
              if (options[name]) {
                google.maps.event.addListener(object, name, function(){
                  options[name].apply(this, [this]);
                });
              }
            })(marker, marker_events[ev]);
          }

          for (var ev = 0; ev < marker_events_with_mouse.length; ev++) {
            (function(map, object, name) {
              if (options[name]) {
                google.maps.event.addListener(object, name, function(me){
                  if(!me.pixel){
                    me.pixel = map.getProjection().fromLatLngToPoint(me.latLng)
                  }

                  options[name].apply(this, [me]);
                });
              }
            })(this.map, marker, marker_events_with_mouse[ev]);
          }

          google.maps.event.addListener(marker, 'click', function() {
            this.details = details;

            if (options.click) {
              options.click.apply(this, [this]);
            }

            if (marker.infoWindow) {
              self.hideInfoWindows();
              marker.infoWindow.open(self.map, marker);
            }
          });

          google.maps.event.addListener(marker, 'rightclick', function(e) {
            e.marker = this;

            if (options.rightclick) {
              options.rightclick.apply(this, [e]);
            }

            if (window.context_menu['marker'] != undefined) {
              buildContextMenu('marker', e);
            }
          });

          if (marker.fences) {
            google.maps.event.addListener(marker, 'dragend', function() {
              self.checkMarkerGeofence(marker, function(m, f) {
                outside(m, f);
              });
            });
          }

          return marker;
        }
        else {
          throw 'No latitude or longitude defined.';
        }
      };

      this.addMarker = function(options) {
        var marker;
        if(options.hasOwnProperty('gm_accessors_')) {
          // Native google.maps.Marker object
          marker = options;
        }
        else {
          if ((options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) || options.position) {
            marker = this.createMarker(options);
          }
          else {
            throw 'No latitude or longitude defined.';
          }
        }

        marker.setMap(this.map);

        if(this.markerClusterer) {
          this.markerClusterer.addMarker(marker);
        }

        this.markers.push(marker);

        GMaps.fire('marker_added', marker, this);

        return marker;
      };

      this.addMarkers = function(array) {
        for (var i=0, marker; marker=array[i]; i++) {
          this.addMarker(marker);
        }
        return this.markers;
      };

      this.hideInfoWindows = function() {
        for (var i=0, marker; marker=this.markers[i]; i++){
          if (marker.infoWindow){
            marker.infoWindow.close();
          }
        }
      };

      this.removeMarker = function(marker) {
        for(var i = 0; i < this.markers.length; i++) {
          if(this.markers[i] === marker) {
            this.markers[i].setMap(null);
            this.markers.splice(i, 1);

            GMaps.fire('marker_removed', marker, this);

            break;
          }
        }

        return marker;
      };

      this.removeMarkers = function(collection) {
        var collection = (collection || this.markers);

        for(var i=0;i < this.markers.length; i++){
          if(this.markers[i] === collection[i])
            this.markers[i].setMap(null);
        }

        var new_markers = [];

        for(var i=0;i < this.markers.length; i++){
          if(this.markers[i].getMap() != null)
            new_markers.push(this.markers[i]);
        }

        this.markers = new_markers;
      };

      // Overlays

      this.drawOverlay = function(options) {
        var overlay = new google.maps.OverlayView();
        overlay.setMap(self.map);

        var auto_show = true;

        if(options.auto_show != null)
          auto_show = options.auto_show;

        overlay.onAdd = function() {
          var el = doc.createElement('div');
          el.style.borderStyle = "none";
          el.style.borderWidth = "0px";
          el.style.position = "absolute";
          el.style.zIndex = 100;
          el.innerHTML = options.content;

          overlay.el = el;

          var panes = this.getPanes();
          if (!options.layer) {
            options.layer = 'overlayLayer';
          }
          var overlayLayer = panes[options.layer];
          overlayLayer.appendChild(el);

          var stop_overlay_events = ['contextmenu', 'DOMMouseScroll', 'dblclick', 'mousedown'];

          for (var ev = 0; ev < stop_overlay_events.length; ev++) {
            (function(object, name) {
              google.maps.event.addDomListener(object, name, function(e){
                if(navigator.userAgent.toLowerCase().indexOf('msie') != -1 && document.all) {
                  e.cancelBubble = true;
                  e.returnValue = false;
                }
                else {
                  e.stopPropagation();
                }
              });
            })(el, stop_overlay_events[ev]);
          }

          google.maps.event.trigger(this, 'ready');
        };

        overlay.draw = function() {
          var projection = this.getProjection();
          var pixel = projection.fromLatLngToDivPixel(new google.maps.LatLng(options.lat, options.lng));

          options.horizontalOffset = options.horizontalOffset || 0;
          options.verticalOffset = options.verticalOffset || 0;

          var el = overlay.el;
          var content = el.children[0];

          var content_height = content.clientHeight;
          var content_width = content.clientWidth;

          switch (options.verticalAlign) {
            case 'top':
              el.style.top = (pixel.y - content_height + options.verticalOffset) + 'px';
              break;
            default:
            case 'middle':
              el.style.top = (pixel.y - (content_height / 2) + options.verticalOffset) + 'px';
              break;
            case 'bottom':
              el.style.top = (pixel.y + options.verticalOffset) + 'px';
              break;
          }

          switch (options.horizontalAlign) {
            case 'left':
              el.style.left = (pixel.x - content_width + options.horizontalOffset) + 'px';
              break;
            default:
            case 'center':
              el.style.left = (pixel.x - (content_width / 2) + options.horizontalOffset) + 'px';
              break;
            case 'right':
              el.style.left = (pixel.x + options.horizontalOffset) + 'px';
              break;
          }

          el.style.display = auto_show ? 'block' : 'none';

          if(!auto_show){
            options.show.apply(this, [el]);
          }
        };

        overlay.onRemove = function() {
          var el = overlay.el;

          if(options.remove){
            options.remove.apply(this, [el]);
          }
          else {
            overlay.el.parentNode.removeChild(overlay.el);
            overlay.el = null;
          }
        };

        self.overlays.push(overlay);
        return overlay;
      };

      this.removeOverlay = function(overlay) {
        for(var i = 0; i < this.overlays.length; i++) {
          if(this.overlays[i] === overlay) {
            this.overlays[i].setMap(null);
            this.overlays.splice(i, 1);

            break;
          }
        }
      };

      this.removeOverlays = function() {
        for (var i=0, item; item=self.overlays[i]; i++){
          item.setMap(null);
        }
        self.overlays = [];
      };

      // Geometry

      this.drawPolyline = function(options) {
        var path = [];
        var points = options.path;

        if (points.length){
          if (points[0][0] === undefined){
            path = points;
          }
          else {
            for (var i=0, latlng; latlng=points[i]; i++){
              path.push(new google.maps.LatLng(latlng[0], latlng[1]));
            }
          }
        }

        var polyline_options = {
          map: this.map,
          path: path,
          strokeColor: options.strokeColor,
          strokeOpacity: options.strokeOpacity,
          strokeWeight: options.strokeWeight,
          geodesic: options.geodesic,
          clickable: true,
          editable: false,
          visible: true
        };

        if(options.hasOwnProperty("clickable"))
          polyline_options.clickable = options.clickable;

        if(options.hasOwnProperty("editable"))
          polyline_options.editable = options.editable;

        if(options.hasOwnProperty("icons"))
          polyline_options.icons = options.icons;

        if(options.hasOwnProperty("zIndex"))
          polyline_options.zIndex = options.zIndex;

        var polyline = new google.maps.Polyline(polyline_options);

        var polyline_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

        for (var ev = 0; ev < polyline_events.length; ev++) {
          (function(object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function(e){
                options[name].apply(this, [e]);
              });
            }
          })(polyline, polyline_events[ev]);
        }

        this.polylines.push(polyline);

        GMaps.fire('polyline_added', polyline, this);

        return polyline;
      };

      this.removePolyline = function(polyline) {
        for(var i = 0; i < this.polylines.length; i++) {
          if(this.polylines[i] === polyline) {
            this.polylines[i].setMap(null);
            this.polylines.splice(i, 1);

            GMaps.fire('polyline_removed', polyline, this);

            break;
          }
        }
      };

      this.removePolylines = function() {
        for (var i=0, item; item=self.polylines[i]; i++){
          item.setMap(null);
        }
        self.polylines = [];
      };

      this.drawCircle = function(options) {
        options =  extend_object({
          map: this.map,
          center: new google.maps.LatLng(options.lat, options.lng)
        }, options);

        delete options.lat;
        delete options.lng;
        var polygon = new google.maps.Circle(options);

        var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

        for (var ev = 0; ev < polygon_events.length; ev++) {
          (function(object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function(e){
                options[name].apply(this, [e]);
              });
            }
          })(polygon, polygon_events[ev]);
        }

        this.polygons.push(polygon);

        return polygon;
      };

      this.drawRectangle = function(options) {
        options = extend_object({
          map: this.map
        }, options);

        var latLngBounds = new google.maps.LatLngBounds(
          new google.maps.LatLng(options.bounds[0][0], options.bounds[0][1]),
          new google.maps.LatLng(options.bounds[1][0], options.bounds[1][1])
        );

        options.bounds = latLngBounds;

        var polygon = new google.maps.Rectangle(options);

        var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

        for (var ev = 0; ev < polygon_events.length; ev++) {
          (function(object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function(e){
                options[name].apply(this, [e]);
              });
            }
          })(polygon, polygon_events[ev]);
        }

        this.polygons.push(polygon);

        return polygon;
      };

      this.drawPolygon = function(options) {
        var useGeoJSON = false;
        if(options.hasOwnProperty("useGeoJSON"))
          useGeoJSON = options.useGeoJSON;

        delete options.useGeoJSON;

        options = extend_object({
          map: this.map
        }, options);

        if(useGeoJSON == false)
          options.paths = [options.paths.slice(0)];

        if(options.paths.length > 0) {
          if(options.paths[0].length > 0) {
            options.paths = array_flat(array_map(options.paths, arrayToLatLng, useGeoJSON));
          }
        }

        var polygon = new google.maps.Polygon(options);

        var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

        for (var ev = 0; ev < polygon_events.length; ev++) {
          (function(object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function(e){
                options[name].apply(this, [e]);
              });
            }
          })(polygon, polygon_events[ev]);
        }

        this.polygons.push(polygon);

        GMaps.fire('polygon_added', polygon, this);

        return polygon;
      };

      this.removePolygon = function(polygon) {
        for(var i = 0; i < this.polygons.length; i++) {
          if(this.polygons[i] === polygon) {
            this.polygons[i].setMap(null);
            this.polygons.splice(i, 1);

            GMaps.fire('polygon_removed', polygon, this);

            break;
          }
        }
      };

      this.removePolygons = function() {
        for (var i=0, item; item=self.polygons[i]; i++){
          item.setMap(null);
        }
        self.polygons = [];
      };

      // Fusion Tables

      this.getFromFusionTables = function(options) {
        var events = options.events;

        delete options.events;

        var fusion_tables_options = options;

        var layer = new google.maps.FusionTablesLayer(fusion_tables_options);

        for (var ev in events) {
          (function(object, name) {
            google.maps.event.addListener(object, name, function(e){
              events[name].apply(this, [e]);
            });
          })(layer, ev);
        }

        this.layers.push(layer);

        return layer;
      };

      this.loadFromFusionTables = function(options) {
        var layer = this.getFromFusionTables(options);
        layer.setMap(this.map);

        return layer;
      };

      // KML

      this.getFromKML = function(options) {
        var url = options.url;
        var events = options.events;

        delete options.url;
        delete options.events;

        var kml_options = options;

        var layer = new google.maps.KmlLayer(url, kml_options);

        for (var ev in events) {
          (function(object, name) {
            google.maps.event.addListener(object, name, function(e){
              events[name].apply(this, [e]);
            });
          })(layer, ev);
        }

        this.layers.push(layer);

        return layer;
      };

      this.loadFromKML = function(options) {
        var layer = this.getFromKML(options);
        layer.setMap(this.map);

        return layer;
      };

      // Routes

      var travelMode, unitSystem;
      this.getRoutes = function(options) {
        switch (options.travelMode) {
        case 'bicycling':
          travelMode = google.maps.TravelMode.BICYCLING;
          break;
        case 'transit':
          travelMode = google.maps.TravelMode.TRANSIT;
          break;
        case 'driving':
          travelMode = google.maps.TravelMode.DRIVING;
          break;
        // case 'walking':
        default:
          travelMode = google.maps.TravelMode.WALKING;
          break;
        }

        if (options.unitSystem === 'imperial') {
          unitSystem = google.maps.UnitSystem.IMPERIAL;
        }
        else {
          unitSystem = google.maps.UnitSystem.METRIC;
        }

        var base_options = {
          avoidHighways: false,
          avoidTolls: false,
          optimizeWaypoints: false,
          waypoints: []
        };

        var request_options =  extend_object(base_options, options);

        request_options.origin = /string/.test(typeof options.origin) ? options.origin : new google.maps.LatLng(options.origin[0], options.origin[1]);
        request_options.destination = new google.maps.LatLng(options.destination[0], options.destination[1]);
        request_options.travelMode = travelMode;
        request_options.unitSystem = unitSystem;

        delete request_options.callback;

        var self = this;
        var service = new google.maps.DirectionsService();

        service.route(request_options, function(result, status) {
          if (status === google.maps.DirectionsStatus.OK) {
            for (var r in result.routes) {
              if (result.routes.hasOwnProperty(r)) {
                self.routes.push(result.routes[r]);
              }
            }
          }
          if (options.callback) {
            options.callback(self.routes);
          }
        });
      };

      this.removeRoutes = function() {
        this.routes = [];
      };

      this.getElevations = function(options) {
        options = extend_object({
          locations: [],
          path : false,
          samples : 256
        }, options);

        if(options.locations.length > 0) {
          if(options.locations[0].length > 0) {
            options.locations = array_flat(array_map([options.locations], arrayToLatLng,  false));
          }
        }

        var callback = options.callback;
        delete options.callback;

        var service = new google.maps.ElevationService();

        //location request
        if (!options.path) {
          delete options.path;
          delete options.samples;
          service.getElevationForLocations(options, function(result, status){
            if (callback && typeof(callback) === "function") {
              callback(result, status);
            }
          });
        //path request
        } else {
          var pathRequest = {
            path : options.locations,
            samples : options.samples
          };

          service.getElevationAlongPath(pathRequest, function(result, status){
           if (callback && typeof(callback) === "function") {
              callback(result, status);
            }
          });
        }
      };

      // Alias for the method "drawRoute"
      this.cleanRoute = this.removePolylines;

      this.drawRoute = function(options) {
        var self = this;
        this.getRoutes({
          origin: options.origin,
          destination: options.destination,
          travelMode: options.travelMode,
          waypoints: options.waypoints,
          unitSystem: options.unitSystem,
          callback: function(e) {
            if (e.length > 0) {
              self.drawPolyline({
                path: e[e.length - 1].overview_path,
                strokeColor: options.strokeColor,
                strokeOpacity: options.strokeOpacity,
                strokeWeight: options.strokeWeight
              });
              if (options.callback) {
                options.callback(e[e.length - 1]);
              }
            }
          }
        });
      };

      this.travelRoute = function(options) {
        if (options.origin && options.destination) {
          this.getRoutes({
            origin: options.origin,
            destination: options.destination,
            travelMode: options.travelMode,
            waypoints : options.waypoints,
            callback: function(e) {
              //start callback
              if (e.length > 0 && options.start) {
                options.start(e[e.length - 1]);
              }

              //step callback
              if (e.length > 0 && options.step) {
                var route = e[e.length - 1];
                if (route.legs.length > 0) {
                  var steps = route.legs[0].steps;
                  for (var i=0, step; step=steps[i]; i++) {
                    step.step_number = i;
                    options.step(step, (route.legs[0].steps.length - 1));
                  }
                }
              }

              //end callback
              if (e.length > 0 && options.end) {
                 options.end(e[e.length - 1]);
              }
            }
          });
        }
        else if (options.route) {
          if (options.route.legs.length > 0) {
            var steps = options.route.legs[0].steps;
            for (var i=0, step; step=steps[i]; i++) {
              step.step_number = i;
              options.step(step);
            }
          }
        }
      };

      this.drawSteppedRoute = function(options) {
        if (options.origin && options.destination) {
          this.getRoutes({
            origin: options.origin,
            destination: options.destination,
            travelMode: options.travelMode,
            waypoints : options.waypoints,
            callback: function(e) {
              //start callback
              if (e.length > 0 && options.start) {
                options.start(e[e.length - 1]);
              }

              //step callback
              if (e.length > 0 && options.step) {
                var route = e[e.length - 1];
                if (route.legs.length > 0) {
                  var steps = route.legs[0].steps;
                  for (var i=0, step; step=steps[i]; i++) {
                    step.step_number = i;
                    self.drawPolyline({
                      path: step.path,
                      strokeColor: options.strokeColor,
                      strokeOpacity: options.strokeOpacity,
                      strokeWeight: options.strokeWeight
                    });
                    options.step(step, (route.legs[0].steps.length - 1));
                  }
                }
              }

              //end callback
              if (e.length > 0 && options.end) {
                 options.end(e[e.length - 1]);
              }
            }
          });
        }
        else if (options.route) {
          if (options.route.legs.length > 0) {
            var steps = options.route.legs[0].steps;
            for (var i=0, step; step=steps[i]; i++) {
              step.step_number = i;
              self.drawPolyline({
                path: step.path,
                strokeColor: options.strokeColor,
                strokeOpacity: options.strokeOpacity,
                strokeWeight: options.strokeWeight
              });
              options.step(step);
            }
          }
        }
      };

      // Geofence

      this.checkGeofence = function(lat, lng, fence) {
        return fence.containsLatLng(new google.maps.LatLng(lat, lng));
      };

      this.checkMarkerGeofence = function(marker, outside_callback) {
        if (marker.fences) {
          for (var i=0, fence; fence=marker.fences[i]; i++) {
            var pos = marker.getPosition();
            if (!self.checkGeofence(pos.lat(), pos.lng(), fence)) {
              outside_callback(marker, fence);
            }
          }
        }
      };

      // Layers

      this.addLayer = function(layerName, options) {
        //var default_layers = ['weather', 'clouds', 'traffic', 'transit', 'bicycling', 'panoramio', 'places'];
        options = options || {};
        var layer;

        switch(layerName) {
          case 'weather': this.singleLayers.weather = layer = new google.maps.weather.WeatherLayer();
            break;
          case 'clouds': this.singleLayers.clouds = layer = new google.maps.weather.CloudLayer();
            break;
          case 'traffic': this.singleLayers.traffic = layer = new google.maps.TrafficLayer();
            break;
          case 'transit': this.singleLayers.transit = layer = new google.maps.TransitLayer();
            break;
          case 'bicycling': this.singleLayers.bicycling = layer = new google.maps.BicyclingLayer();
            break;
          case 'panoramio':
              this.singleLayers.panoramio = layer = new google.maps.panoramio.PanoramioLayer();
              layer.setTag(options.filter);
              delete options.filter;

              //click event
              if(options.click) {
                google.maps.event.addListener(layer, 'click', function(event) {
                  options.click(event);
                  delete options.click;
                });
              }
            break;
            case 'places':
              this.singleLayers.places = layer = new google.maps.places.PlacesService(this.map);

              //search and  nearbySearch callback, Both are the same
              if(options.search || options.nearbySearch) {
                var placeSearchRequest  = {
                  bounds : options.bounds || null,
                  keyword : options.keyword || null,
                  location : options.location || null,
                  name : options.name || null,
                  radius : options.radius || null,
                  rankBy : options.rankBy || null,
                  types : options.types || null
                };

                if(options.search) {
                  layer.search(placeSearchRequest, options.search);
                }

                if(options.nearbySearch) {
                  layer.nearbySearch(placeSearchRequest, options.nearbySearch);
                }
              }

              //textSearch callback
              if(options.textSearch) {
                var textSearchRequest  = {
                  bounds : options.bounds || null,
                  location : options.location || null,
                  query : options.query || null,
                  radius : options.radius || null
                };

                layer.textSearch(textSearchRequest, options.textSearch);
              }
            break;
        }

        if(layer !== undefined) {
          if(typeof layer.setOptions == 'function') {
            layer.setOptions(options);
          }
          if(typeof layer.setMap == 'function') {
            layer.setMap(this.map);
          }

          return layer;
        }
      };

      this.removeLayer = function(layerName) {
        if(this.singleLayers[layerName] !== undefined) {
           this.singleLayers[layerName].setMap(null);
           delete this.singleLayers[layerName];
        }
      };

      // Static Maps

      this.toImage = function(options) {
        var options = options || {};
        var static_map_options = {};
        static_map_options['size'] = options['size'] || [this.el.clientWidth, this.el.clientHeight];
        static_map_options['lat'] = this.getCenter().lat();
        static_map_options['lng'] = this.getCenter().lng();

        if(this.markers.length > 0) {
          static_map_options['markers'] = [];
          for(var i=0; i < this.markers.length; i++) {
            static_map_options['markers'].push({
              lat: this.markers[i].getPosition().lat(),
              lng: this.markers[i].getPosition().lng()
            });
          }
        }

        if(this.polylines.length > 0) {
          var polyline = this.polylines[0];
          static_map_options['polyline'] = {};
          static_map_options['polyline']['path'] = google.maps.geometry.encoding.encodePath(polyline.getPath());
          static_map_options['polyline']['strokeColor'] = polyline.strokeColor
          static_map_options['polyline']['strokeOpacity'] = polyline.strokeOpacity
          static_map_options['polyline']['strokeWeight'] = polyline.strokeWeight
        }

        return GMaps.staticMapURL(static_map_options);
      };

      // Map Types

      this.addMapType = function(mapTypeId, options) {
        if(options.hasOwnProperty("getTileUrl") && typeof(options["getTileUrl"]) == "function") {
          options.tileSize = options.tileSize || new google.maps.Size(256, 256);

          var mapType = new google.maps.ImageMapType(options);

          this.map.mapTypes.set(mapTypeId, mapType);
        }
        else {
          throw "'getTileUrl' function required.";
        }
      };

      this.addOverlayMapType = function(options) {
        if(options.hasOwnProperty("getTile") && typeof(options["getTile"]) == "function") {
          var overlayMapTypeIndex = options.index;

          delete options.index;

          this.map.overlayMapTypes.insertAt(overlayMapTypeIndex, options);
        }
        else {
          throw "'getTile' function required.";
        }
      };

      this.removeOverlayMapType = function(overlayMapTypeIndex) {
        this.map.overlayMapTypes.removeAt(overlayMapTypeIndex);
      };

      // Styles

      this.addStyle = function(options) {
        var styledMapType = new google.maps.StyledMapType(options.styles, options.styledMapName);

        this.map.mapTypes.set(options.mapTypeId, styledMapType);
      };

      this.setStyle = function(mapTypeId) {
        this.map.setMapTypeId(mapTypeId);
      };

      // StreetView

      this.createPanorama = function(streetview_options) {
        if (!streetview_options.hasOwnProperty('lat') || !streetview_options.hasOwnProperty('lng')) {
          streetview_options.lat = this.getCenter().lat();
          streetview_options.lng = this.getCenter().lng();
        }

        this.panorama = GMaps.createPanorama(streetview_options);

        this.map.setStreetView(this.panorama);

        return this.panorama;
      };

      // Events

      this.on = function(event_name, handler) {
        return GMaps.on(event_name, this, handler);
      };

      this.off = function(event_name) {
        GMaps.off(event_name, this);
      };
    };

    GMaps.createPanorama = function(options) {
      var el = getElementById(options.el, options.context);

      options.position = new google.maps.LatLng(options.lat, options.lng);

      delete options.el;
      delete options.context;
      delete options.lat;
      delete options.lng;

      var streetview_events = ['closeclick', 'links_changed', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'visible_changed'];

      var streetview_options = extend_object({visible : true}, options);

      for(var i = 0; i < streetview_events.length; i++) {
        delete streetview_options[streetview_events[i]];
      }

      var panorama = new google.maps.StreetViewPanorama(el, streetview_options);

      for(var i = 0; i < streetview_events.length; i++) {
        (function(object, name) {
          if (options[name]) {
            google.maps.event.addListener(object, name, function(){
              options[name].apply(this);
            });
          }
        })(panorama, streetview_events[i]);
      }

      return panorama;
    };

    GMaps.Route = function(options) {
      this.map = options.map;
      this.route = options.route;
      this.step_count = 0;
      this.steps = this.route.legs[0].steps;
      this.steps_length = this.steps.length;

      this.polyline = this.map.drawPolyline({
        path: new google.maps.MVCArray(),
        strokeColor: options.strokeColor,
        strokeOpacity: options.strokeOpacity,
        strokeWeight: options.strokeWeight
      }).getPath();

      this.back = function() {
        if (this.step_count > 0) {
          this.step_count--;
          var path = this.route.legs[0].steps[this.step_count].path;
          for (var p in path){
            if (path.hasOwnProperty(p)){
              this.polyline.pop();
            }
          }
        }
      };

      this.forward = function() {
        if (this.step_count < this.steps_length) {
          var path = this.route.legs[0].steps[this.step_count].path;
          for (var p in path){
            if (path.hasOwnProperty(p)){
              this.polyline.push(path[p]);
            }
          }
          this.step_count++;
        }
      };
    };

    // Geolocation (Modern browsers only)

    GMaps.geolocate = function(options) {
      var complete_callback = options.always || options.complete;

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
          options.success(position);

          if (complete_callback) {
            complete_callback();
          }
        }, function(error) {
          options.error(error);

          if (complete_callback) {
            complete_callback();
          }
        }, options.options);
      }
      else {
        options.not_supported();

        if (complete_callback) {
          complete_callback();
        }
      }
    };

    // Geocoding

    GMaps.geocode = function(options) {
      this.geocoder = new google.maps.Geocoder();
      var callback = options.callback;
      if (options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) {
        options.latLng = new google.maps.LatLng(options.lat, options.lng);
      }

      delete options.lat;
      delete options.lng;
      delete options.callback;
      this.geocoder.geocode(options, function(results, status) {
        callback(results, status);
      });
    };

    // Static maps

    GMaps.staticMapURL = function(options){
      var parameters = [];
      var data;

      var static_root = 'https://maps.googleapis.com/maps/api/staticmap';
      if (options.url){
        static_root = options.url;
        delete options.url;
      }
      static_root += '?';

      var markers = options.markers;
      delete options.markers;
      if (!markers && options.marker){
        markers = [options.marker];
        delete options.marker;
      }

      var polyline = options.polyline;
      delete options.polyline;

      /** Map options **/
      if (options.center){
        parameters.push('center=' + options.center);
        delete options.center;
      }
      else if (options.address){
        parameters.push('center=' + options.address);
        delete options.address;
      }
      else if (options.lat){
        parameters.push(['center=', options.lat, ',', options.lng].join(''));
        delete options.lat;
        delete options.lng;
      }
      else if (options.visible){
        var visible = encodeURI(options.visible.join('|'));
        parameters.push('visible=' + visible);
      }

      var size = options.size;
      if (size){
        if (size.join){
          size = size.join('x');
        }
        delete options.size;
      }
      else {
        size = '630x300';
      }
      parameters.push('size=' + size);

      if (!options.zoom){
        options.zoom = 15;
      }

      var sensor = options.hasOwnProperty('sensor') ? !!options.sensor : true;
      delete options.sensor;
      parameters.push('sensor=' + sensor);

      for (var param in options){
        if (options.hasOwnProperty(param)){
          parameters.push(param + '=' + options[param]);
        }
      }

      /** Markers **/
      if (markers){
        var marker, loc;

        for (var i=0; data=markers[i]; i++){
          marker = [];

          if (data.size && data.size !== 'normal'){
            marker.push('size:' + data.size);
          }
          else if (data.icon){
            marker.push('icon:' + encodeURI(data.icon));
          }

          if (data.color){
            marker.push('color:' + data.color.replace('#', '0x'));
          }

          if (data.label){
            marker.push('label:' + data.label[0].toUpperCase());
          }

          loc = (data.address ? data.address : data.lat + ',' + data.lng);

          if (marker.length || i === 0){
            marker.push(loc);
            marker = marker.join('|');
            parameters.push('markers=' + encodeURI(marker));
          }
          // New marker without styles
          else {
            marker = parameters.pop() + encodeURI('|' + loc);
            parameters.push(marker);
          }
        }
      }

      /** Polylines **/
      function parseColor(color, opacity){
        if (color[0] === '#'){
          color = color.replace('#', '0x');

          if (opacity){
            opacity = parseFloat(opacity);
            opacity = Math.min(1, Math.max(opacity, 0));
            if (opacity === 0){
              return '0x00000000';
            }
            opacity = (opacity * 255).toString(16);
            if (opacity.length === 1){
              opacity += opacity;
            }

            color = color.slice(0,8) + opacity;
          }
        }
        return color;
      }

      if (polyline){
        data = polyline;
        polyline = [];

        if (data.strokeWeight){
          polyline.push('weight:' + parseInt(data.strokeWeight, 10));
        }

        if (data.strokeColor){
          var color = parseColor(data.strokeColor, data.strokeOpacity);
          polyline.push('color:' + color);
        }

        if (data.fillColor){
          var fillcolor = parseColor(data.fillColor, data.fillOpacity);
          polyline.push('fillcolor:' + fillcolor);
        }

        var path = data.path;
        if (path.join){
          for (var j=0, pos; pos=path[j]; j++){
            polyline.push(pos.join(','));
          }
        }
        else {
          polyline.push('enc:' + path);
        }

        polyline = polyline.join('|');
        parameters.push('path=' + encodeURI(polyline));
      }

      parameters = parameters.join('&');
      return static_root + parameters;
    };

    // Events

    GMaps.custom_events = ['marker_added', 'marker_removed', 'polyline_added', 'polyline_removed', 'polygon_added', 'polygon_removed', 'geolocated', 'geolocation_failed'];

    GMaps.on = function(event_name, object, handler) {
      if (GMaps.custom_events.indexOf(event_name) == -1) {
        return google.maps.event.addListener(object, event_name, handler);
      }
      else {
        var registered_event = {
          handler : handler,
          eventName : event_name
        };

        object.registered_events[event_name] = object.registered_events[event_name] || [];
        object.registered_events[event_name].push(registered_event);

        return registered_event;
      }
    };

    GMaps.off = function(event_name, object) {
      if (GMaps.custom_events.indexOf(event_name) == -1) {
        google.maps.event.clearListeners(object, event_name);
      }
      else {
        object.registered_events[event_name] = [];
      }
    };

    GMaps.fire = function(event_name, object, scope) {
      if (GMaps.custom_events.indexOf(event_name) == -1) {
        google.maps.event.trigger(object, event_name, Array.prototype.slice.apply(arguments).slice(2));
      }
      else {
        if(event_name in scope.registered_events) {
          var firing_events = scope.registered_events[event_name];

          for(var i = 0; i < firing_events.length; i++) {
            (function(handler, scope, object) {
              handler.apply(scope, [object]);
            })(firing_events[i]['handler'], scope, object);
          }
        }
      }
    };

    //==========================
    // Polygon containsLatLng
    // https://github.com/tparkin/Google-Maps-Point-in-Polygon
    // Poygon getBounds extension - google-maps-extensions
    // http://code.google.com/p/google-maps-extensions/source/browse/google.maps.Polygon.getBounds.js
    if (!google.maps.Polygon.prototype.getBounds) {
      google.maps.Polygon.prototype.getBounds = function(latLng) {
        var bounds = new google.maps.LatLngBounds();
        var paths = this.getPaths();
        var path;

        for (var p = 0; p < paths.getLength(); p++) {
          path = paths.getAt(p);
          for (var i = 0; i < path.getLength(); i++) {
            bounds.extend(path.getAt(i));
          }
        }

        return bounds;
      };
    }

    if (!google.maps.Polygon.prototype.containsLatLng) {
      // Polygon containsLatLng - method to determine if a latLng is within a polygon
      google.maps.Polygon.prototype.containsLatLng = function(latLng) {
        // Exclude points outside of bounds as there is no way they are in the poly
        var bounds = this.getBounds();

        if (bounds !== null && !bounds.contains(latLng)) {
          return false;
        }

        // Raycast point in polygon method
        var inPoly = false;

        var numPaths = this.getPaths().getLength();
        for (var p = 0; p < numPaths; p++) {
          var path = this.getPaths().getAt(p);
          var numPoints = path.getLength();
          var j = numPoints - 1;

          for (var i = 0; i < numPoints; i++) {
            var vertex1 = path.getAt(i);
            var vertex2 = path.getAt(j);

            if (vertex1.lng() < latLng.lng() && vertex2.lng() >= latLng.lng() || vertex2.lng() < latLng.lng() && vertex1.lng() >= latLng.lng()) {
              if (vertex1.lat() + (latLng.lng() - vertex1.lng()) / (vertex2.lng() - vertex1.lng()) * (vertex2.lat() - vertex1.lat()) < latLng.lat()) {
                inPoly = !inPoly;
              }
            }

            j = i;
          }
        }

        return inPoly;
      };
    }

    google.maps.LatLngBounds.prototype.containsLatLng = function(latLng) {
      return this.contains(latLng);
    };

    google.maps.Marker.prototype.setFences = function(fences) {
      this.fences = fences;
    };

    google.maps.Marker.prototype.addFence = function(fence) {
      this.fences.push(fence);
    };

    return GMaps;
  }(this));

  var coordsToLatLngs = function(coords, useGeoJSON) {
    var first_coord = coords[0];
    var second_coord = coords[1];

    if(useGeoJSON) {
      first_coord = coords[1];
      second_coord = coords[0];
    }

    return new google.maps.LatLng(first_coord, second_coord);
  };

  var arrayToLatLng = function(coords, useGeoJSON) {
    for(var i=0; i < coords.length; i++) {
      if(coords[i].length > 0 && typeof(coords[i][0]) != "number") {
        coords[i] = arrayToLatLng(coords[i], useGeoJSON);
      }
      else {
        coords[i] = coordsToLatLngs(coords[i], useGeoJSON);
      }
    }

    return coords;
  };

  var extend_object = function(obj, new_obj) {
    if(obj === new_obj) return obj;

    for(var name in new_obj) {
      obj[name] = new_obj[name];
    }

    return obj;
  };

  var replace_object = function(obj, replace) {
    if(obj === replace) return obj;

    for(var name in replace) {
      if(obj[name] != undefined)
        obj[name] = replace[name];
    }

    return obj;
  };

  var array_map = function(array, callback) {
    var original_callback_params = Array.prototype.slice.call(arguments, 2);

    if (Array.prototype.map && array.map === Array.prototype.map) {
      return Array.prototype.map.call(array, function(item) {
        callback_params = original_callback_params;
        callback_params.splice(0, 0, item);

        return callback.apply(this, callback_params);
      });
    }
    else {
      var array_return = [];
      var array_length = array.length;

      for(var i = 0; i < array_length; i++) {
        callback_params = original_callback_params;
        callback_params = callback_params.splice(0, 0, array[i]);
        array_return.push(callback.apply(this, callback_params));
      }

      return array_return;
    }
  };

  var array_flat = function(array) {
    new_array = [];

    for(var i=0; i < array.length; i++) {
      new_array = new_array.concat(array[i]);
    }

    return new_array;
  };
// Class
$.GMaps = GMaps;

$.GMaps.mapEvents = [
  "bounds_changed",
  "center_changed",
  "click",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "heading_changed",
  "idle",
  "maptypeid_changed",
  "mousemove",
  "mouseout",
  "mouseover",
  "projection_changed",
  "resize",
  "rightclick",
  "tilesloaded",
  "tilt_changed",
  "zoom_changed"
];

// jQuery Plugin
$.fn.gmaps = function(options) {

  // No element found, skip.
  if (this.length < 1) return;

  // Only the first element
  var el          = $(this[0]),
      map         = el.data("gmaps"),
      newInstance = (map===undefined),
      autodetect  = (options===undefined);

  // Normalize options
  if ($.isString(options)) {
    options = {
      address: options
    };
  }

  // New instance
  if (newInstance) {

    var id = $.uid("gmaps-"),

        defaultOptions = {
          lat: 0,
          lng: 0
        };

    if ($.isPlainObject(options)) {
      options = $.extend({}, defaultOptions, options);
    }

    // Set id
    el.attr("id", id);
    options.div = '#' + id;

    // Override events
    $.each($.GMaps.mapEvents, function(i, eventName){

      var originalEvent =
            ($.isFunction(options[eventName])) ?
              options[eventName] :
              $.noop;

      options[eventName] = function(){

        var args = $.makeArray(arguments);

        // Trigger original event
        originalEvent.apply(map, arguments);

        // Trigger jQuery event
        el.trigger.apply(el, ["map_" + eventName].concat(args));
      }
    });

    // Instantiate gmaps
    map = new GMaps(options);
    el.data("gmaps", map);

    // Extend with go method
    map.go = function(lat, lng) {
      map.setCenter(lat, lng);
      map.addMarker({lat: lat, lng: lng});
    }

    // Auto-detect location
    if (autodetect) {
      GMaps.geolocate({
        success: function(position) {
          map.go(position.coords.latitude, position.coords.longitude);
        }
      });
    }

    return map;

  // Existing instance
  } else {

    var lat = options.lat,
        lng = options.lng;

    // Update location
    if ($.isNumber(lat) || $.isNumber(lng)) {
      map.go(lat, lng);
    }

    return map;
  }

  // Resolve lat/lng from address
  if (options.address) {

    GMaps.geocode({
      address: options.address,
      callback: function(results, status) {
        if (status=="OK") {
          var coords = results[0].geometry.location;
          map.go(coords.lat(), coords.lng());
        }
      }
    });

    return map;
  }
};

  module.resolveWith(GMaps);

});

var language = $('meta[name="foundry:location:language"]').attr("content") || 'en';

if (window.google && window.google.maps){
    window[callbackId]();
} else {
    // Load google maps api
    $.require()
      .script($.uri(window.location).protocol() + "://maps.google.com/maps/api/js?sensor=true&callback=" + callbackId + "&language=" + language)
      .done();
}


};
// module factory: end

FD40.module("gmaps", moduleFactory);

}());

(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*! http://mths.be/placeholder v2.0.7 by @mathias */
;(function(window, document, $) {

	var isInputSupported = 'placeholder' in document.createElement('input'),
	    isTextareaSupported = 'placeholder' in document.createElement('textarea'),
	    prototype = $.fn,
	    valHooks = $.valHooks,
	    hooks,
	    placeholder;

	if (isInputSupported && isTextareaSupported) {

		placeholder = prototype.placeholder = function() {
			return this;
		};

		placeholder.input = placeholder.textarea = true;

	} else {

		placeholder = prototype.placeholder = function() {
			var $this = this;
			$this
				.filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
				.not('.placeholder')
				.bind({
					'focus.placeholder': clearPlaceholder,
					'blur.placeholder': setPlaceholder
				})
				.data('placeholder-enabled', true)
				.trigger('blur.placeholder');
			return $this;
		};

		placeholder.input = isInputSupported;
		placeholder.textarea = isTextareaSupported;

		hooks = {
			'get': function(element) {
				var $element = $(element);
				return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
			},
			'set': function(element, value) {
				var $element = $(element);
				if (!$element.data('placeholder-enabled')) {
					return element.value = value;
				}
				if (value == '') {
					element.value = value;
					// Issue #56: Setting the placeholder causes problems if the element continues to have focus.
					if (element != document.activeElement) {
						// We can't use `triggerHandler` here because of dummy text/password inputs :(
						setPlaceholder.call(element);
					}
				} else if ($element.hasClass('placeholder')) {
					clearPlaceholder.call(element, true, value) || (element.value = value);
				} else {
					element.value = value;
				}
				// `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
				return $element;
			}
		};

		isInputSupported || (valHooks.input = hooks);
		isTextareaSupported || (valHooks.textarea = hooks);

		$(function() {
			// Look for forms
			$(document).delegate('form', 'submit.placeholder', function() {
				// Clear the placeholder values so they don't get submitted
				var $inputs = $('.placeholder', this).each(clearPlaceholder);
				setTimeout(function() {
					$inputs.each(setPlaceholder);
				}, 10);
			});
		});

		// Clear placeholder values upon page reload
		$(window).bind('beforeunload.placeholder', function() {
			$('.placeholder').each(function() {
				this.value = '';
			});
		});

	}

	function args(elem) {
		// Return an object of element attributes
		var newAttrs = {},
		    rinlinejQuery = /^jQuery\d+$/;
		$.each(elem.attributes, function(i, attr) {
			if (attr.specified && !rinlinejQuery.test(attr.name)) {
				newAttrs[attr.name] = attr.value;
			}
		});
		return newAttrs;
	}

	function clearPlaceholder(event, value) {
		var input = this,
		    $input = $(input);
		if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
			if ($input.data('placeholder-password')) {
				$input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
				// If `clearPlaceholder` was called from `$.valHooks.input.set`
				if (event === true) {
					return $input[0].value = value;
				}
				$input.focus();
			} else {
				input.value = '';
				$input.removeClass('placeholder');
				input == document.activeElement && input.select();
			}
		}
	}

	function setPlaceholder() {
		var $replacement,
		    input = this,
		    $input = $(input),
		    $origInput = $input,
		    id = this.id;
		if (input.value == '') {
			if (input.type == 'password') {
				if (!$input.data('placeholder-textinput')) {
					try {
						$replacement = $input.clone().attr({ 'type': 'text' });
					} catch(e) {
						$replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
					}
					$replacement
						.removeAttr('name')
						.data({
							'placeholder-password': true,
							'placeholder-id': id
						})
						.bind('focus.placeholder', clearPlaceholder);
					$input
						.data({
							'placeholder-textinput': $replacement,
							'placeholder-id': id
						})
						.before($replacement);
				}
				$input = $input.removeAttr('id').hide().prev().attr('id', id).show();
				// Note: `$input[0] != input` now!
			}
			$input.addClass('placeholder');
			$input[0].value = $input.attr('placeholder');
		} else {
			$input.removeClass('placeholder');
		}
	}

}(window, document, jQuery));

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("placeholder", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/**
* jquery.Image
* Image helper for jQuery.
* https://github.com/jstonne/jquery.Image
*
* Copyright (c) 2012 Jensen Tonne
* www.jstonne.com
*
* Dual licensed under the MIT and GPL licenses:
* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html
*
*/

$.fn.image = function(method) {
	var method = $.Image[method];
	return method && method.apply(this[0], $.makeArray(arguments).slice(1));
}

$.Image = {

	get: function(url) {

		var existingImage = this.nodeName==="IMG";

		var image = $(existingImage ? this : new Image()),
			imageLoader = $.Deferred();

		image
			.load(function() {

				var w, h, r, o;

				if (!existingImage) { image.appendTo("body"); }

				var data = {
					width: w = image.width(),
					height: h = image.height(),
					aspectRatio: r = w / h,
					orientation: o = (r===1) ? "square" : (r<1) ? "tall" : "wide"
				}	

				image
					.css({
						position: "absolute",
						left: "-99999px"
					})
					.data(data)
					.addClass("orientation-" + o)
					.removeAttr("style");

				if (!existingImage) {
					image.detach();
				}

				imageLoader.resolve(image, data);
			})
			.error(function(){

				imageLoader.reject();
			})
			.attr("src", url);

		return imageLoader;
	},

	aspectRatio: function(width, height) {

		// Normalize values
		if ($.isPlainObject(width)) {
			width  = width.width;
			height = width.height;
		}

		return width / height;
	},

	orientation: function(width, height) {

		// Normalize values
		if ($.isPlainObject(width)) {
			width  = width.width;
			height = width.height;
		}

		if (width===height) return "square";

		if (width > height) return "wide";

		return "tall";
	},

	resizeProportionate: function(sourceWidth, sourceHeight, maxWidth, maxHeight, mode) {

		var targetWidth = sourceWidth,
			targetHeight = sourceHeight;

		// Resize the width first
		var ratio        = maxWidth / sourceWidth;
			targetWidth  = sourceWidth  * ratio;
			targetHeight = sourceHeight * ratio;


		// inner resize (default)
		var condition = targetHeight > maxHeight;

		// outer resize
		if (mode=="outer") {
			condition = targetHeight < maxHeight;
		}

		if (condition) {
			ratio        = maxHeight / sourceHeight;
			targetWidth  = sourceWidth  * ratio;
			targetHeight = sourceHeight * ratio;
		}

		return {
			top   : (maxHeight - targetHeight) / 2,
			left  : (maxWidth - targetWidth) / 2,
			width : targetWidth,
			height: targetHeight
		};
	},

	resizeWithin: function(sourceWidth, sourceHeight, maxWidth, maxHeight) {

		return $.Image.resizeProportionate(
			sourceWidth,
			sourceHeight,
			maxWidth,
			maxHeight,
			"inner"
		);
	},

	resizeToFill: function(sourceWidth, sourceHeight, maxWidth, maxHeight) {

		return $.Image.resizeProportionate(
			sourceWidth,
			sourceHeight,
			maxWidth,
			maxHeight,
			"outer"
		);
	}
};

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("image", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*
 * imgAreaSelect jQuery plugin
 * version 0.9.9
 *
 * Copyright (c) 2008-2011 Michal Wojciechowski (odyniec.net)
 *
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * http://odyniec.net/projects/imgareaselect/
 *
 */

(function($) {

/*
 * Math functions will be used extensively, so it's convenient to make a few
 * shortcuts
 */
var abs = Math.abs,
    max = Math.max,
    min = Math.min,
    round = Math.round;

/**
 * Create a new HTML div element
 *
 * @return A jQuery object representing the new element
 */
function div() {
    return $('<div/>');
}

/**
 * imgAreaSelect initialization
 *
 * @param img
 *            A HTML image element to attach the plugin to
 * @param options
 *            An options object
 */
$.imgAreaSelect = function (img, options) {
    var
        /* jQuery object representing the image */
        $img = $(img),

        /* Has the image finished loading? */
        imgLoaded,

        /* Plugin elements */

        /* Container box */
        $box = div(),
        /* Selection area */
        $area = div(),
        /* Border (four divs) */
        $border = div().add(div()).add(div()).add(div()),
        /* Outer area (four divs) */
        $outer = div().add(div()).add(div()).add(div()),
        /* Handles (empty by default, initialized in setOptions()) */
        $handles = $([]),

        /*
         * Additional element to work around a cursor problem in Opera
         * (explained later)
         */
        $areaOpera,

        /* Image position (relative to viewport) */
        left, top,

        /* Image offset (as returned by .offset()) */
        imgOfs = { left: 0, top: 0 },

        /* Image dimensions (as returned by .width() and .height()) */
        imgWidth, imgHeight,

        /*
         * jQuery object representing the parent element that the plugin
         * elements are appended to
         */
        $parent,

        /* Parent element offset (as returned by .offset()) */
        parOfs = { left: 0, top: 0 },

        /* Base z-index for plugin elements */
        zIndex = 0,

        /* Plugin elements position */
        position = 'absolute',

        /* X/Y coordinates of the starting point for move/resize operations */
        startX, startY,

        /* Horizontal and vertical scaling factors */
        scaleX, scaleY,

        /* Current resize mode ("nw", "se", etc.) */
        resize,

        /* Selection area constraints */
        minWidth, minHeight, maxWidth, maxHeight,

        /* Aspect ratio to maintain (floating point number) */
        aspectRatio,

        /* Are the plugin elements currently displayed? */
        shown,

        /* Current selection (relative to parent element) */
        x1, y1, x2, y2,

        /* Current selection (relative to scaled image) */
        selection = { x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 },

        /* Document element */
        docElem = document.documentElement,

        /* Various helper variables used throughout the code */
        $p, d, i, o, w, h, adjusted;

    /*
     * Translate selection coordinates (relative to scaled image) to viewport
     * coordinates (relative to parent element)
     */

    /**
     * Translate selection X to viewport X
     *
     * @param x
     *            Selection X
     * @return Viewport X
     */
    function viewX(x) {
        return x + imgOfs.left - parOfs.left;
    }

    /**
     * Translate selection Y to viewport Y
     *
     * @param y
     *            Selection Y
     * @return Viewport Y
     */
    function viewY(y) {
        return y + imgOfs.top - parOfs.top;
    }

    /*
     * Translate viewport coordinates to selection coordinates
     */

    /**
     * Translate viewport X to selection X
     *
     * @param x
     *            Viewport X
     * @return Selection X
     */
    function selX(x) {
        return x - imgOfs.left + parOfs.left;
    }

    /**
     * Translate viewport Y to selection Y
     *
     * @param y
     *            Viewport Y
     * @return Selection Y
     */
    function selY(y) {
        return y - imgOfs.top + parOfs.top;
    }

    /*
     * Translate event coordinates (relative to document) to viewport
     * coordinates
     */

    /**
     * Get event X and translate it to viewport X
     *
     * @param event
     *            The event object
     * @return Viewport X
     */
    function evX(event) {
        return event.pageX - parOfs.left;
    }

    /**
     * Get event Y and translate it to viewport Y
     *
     * @param event
     *            The event object
     * @return Viewport Y
     */
    function evY(event) {
        return event.pageY - parOfs.top;
    }

    /**
     * Get the current selection
     *
     * @param noScale
     *            If set to <code>true</code>, scaling is not applied to the
     *            returned selection
     * @return Selection object
     */
    function getSelection(noScale) {
        var sx = noScale || scaleX, sy = noScale || scaleY;

        return { x1: round(selection.x1 * sx),
            y1: round(selection.y1 * sy),
            x2: round(selection.x2 * sx),
            y2: round(selection.y2 * sy),
            width: round(selection.x2 * sx) - round(selection.x1 * sx),
            height: round(selection.y2 * sy) - round(selection.y1 * sy) };
    }

    /**
     * Set the current selection
     *
     * @param x1
     *            X coordinate of the upper left corner of the selection area
     * @param y1
     *            Y coordinate of the upper left corner of the selection area
     * @param x2
     *            X coordinate of the lower right corner of the selection area
     * @param y2
     *            Y coordinate of the lower right corner of the selection area
     * @param noScale
     *            If set to <code>true</code>, scaling is not applied to the
     *            new selection
     */
    function setSelection(x1, y1, x2, y2, noScale) {
        var sx = noScale || scaleX, sy = noScale || scaleY;

        selection = {
            x1: round(x1 / sx || 0),
            y1: round(y1 / sy || 0),
            x2: round(x2 / sx || 0),
            y2: round(y2 / sy || 0)
        };

        selection.width = selection.x2 - selection.x1;
        selection.height = selection.y2 - selection.y1;
    }

    /**
     * Recalculate image and parent offsets
     */
    function adjust() {
        /*
         * Do not adjust if image width is not a positive number. This might
         * happen when imgAreaSelect is put on a parent element which is then
         * hidden.
         */
        if (!$img.width())
            return;

        /*
         * Get image offset. The .offset() method returns float values, so they
         * need to be rounded.
         */
        imgOfs = { left: round($img.offset().left), top: round($img.offset().top) };

        /* Get image dimensions */
        imgWidth = $img.innerWidth();
        imgHeight = $img.innerHeight();

        imgOfs.top += ($img.outerHeight() - imgHeight) >> 1;
        imgOfs.left += ($img.outerWidth() - imgWidth) >> 1;

        /* Set minimum and maximum selection area dimensions */
        minWidth = round(options.minWidth / scaleX) || 0;
        minHeight = round(options.minHeight / scaleY) || 0;
        maxWidth = round(min(options.maxWidth / scaleX || 1<<24, imgWidth));
        maxHeight = round(min(options.maxHeight / scaleY || 1<<24, imgHeight));

        /*
         * Workaround for jQuery 1.3.2 incorrect offset calculation, originally
         * observed in Safari 3. Firefox 2 is also affected.
         */
        if ($().jquery == '1.3.2' && position == 'fixed' &&
            !docElem['getBoundingClientRect'])
        {
            imgOfs.top += max(document.body.scrollTop, docElem.scrollTop);
            imgOfs.left += max(document.body.scrollLeft, docElem.scrollLeft);
        }

        /* Determine parent element offset */
        parOfs = /absolute|relative/.test($parent.css('position')) ?
            { left: round($parent.offset().left) - $parent.scrollLeft(),
                top: round($parent.offset().top) - $parent.scrollTop() } :
            position == 'fixed' ?
                { left: $(document).scrollLeft(), top: $(document).scrollTop() } :
                { left: 0, top: 0 };

        left = viewX(0);
        top = viewY(0);

        /*
         * Check if selection area is within image boundaries, adjust if
         * necessary
         */
        if (selection.x2 > imgWidth || selection.y2 > imgHeight)
            doResize();
    }

    /**
     * Update plugin elements
     *
     * @param resetKeyPress
     *            If set to <code>false</code>, this instance's keypress
     *            event handler is not activated
     */
    function update(resetKeyPress) {
        /* If plugin elements are hidden, do nothing */
        if (!shown) return;

        /*
         * Set the position and size of the container box and the selection area
         * inside it
         */
        $box.css({ left: viewX(selection.x1), top: viewY(selection.y1) })
            .add($area).width(w = selection.width).height(h = selection.height);

        /*
         * Reset the position of selection area, borders, and handles (IE6/IE7
         * position them incorrectly if we don't do this)
         */
        $area.add($border).add($handles).css({ left: 0, top: 0 });

        /* Set border dimensions */
        $border
            .width(max(w - $border.outerWidth() + $border.innerWidth(), 0))
            .height(max(h - $border.outerHeight() + $border.innerHeight(), 0));

        /* Arrange the outer area elements */
        $($outer[0]).css({ left: left, top: top,
            width: selection.x1, height: imgHeight });
        $($outer[1]).css({ left: left + selection.x1, top: top,
            width: w, height: selection.y1 });
        $($outer[2]).css({ left: left + selection.x2, top: top,
            width: imgWidth - selection.x2, height: imgHeight });
        $($outer[3]).css({ left: left + selection.x1, top: top + selection.y2,
            width: w, height: imgHeight - selection.y2 });

        w -= $handles.outerWidth();
        h -= $handles.outerHeight();

        /* Arrange handles */
        switch ($handles.length) {
        case 8:
            $($handles[4]).css({ left: w >> 1 });
            $($handles[5]).css({ left: w, top: h >> 1 });
            $($handles[6]).css({ left: w >> 1, top: h });
            $($handles[7]).css({ top: h >> 1 });
        case 4:
            $handles.slice(1,3).css({ left: w });
            $handles.slice(2,4).css({ top: h });
        }

        if (resetKeyPress !== false) {
            /*
             * Need to reset the document keypress event handler -- unbind the
             * current handler
             */
            if ($.imgAreaSelect.keyPress != docKeyPress)
                $(document).unbind($.imgAreaSelect.keyPress,
                    $.imgAreaSelect.onKeyPress);

            if (options.keys)
                /*
                 * Set the document keypress event handler to this instance's
                 * docKeyPress() function
                 */
                $(document)[$.imgAreaSelect.keyPress](
                    $.imgAreaSelect.onKeyPress = docKeyPress);
        }

        /*
         * Internet Explorer displays 1px-wide dashed borders incorrectly by
         * filling the spaces between dashes with white. Toggling the margin
         * property between 0 and "auto" fixes this in IE6 and IE7 (IE8 is still
         * broken). This workaround is not perfect, as it requires setTimeout()
         * and thus causes the border to flicker a bit, but I haven't found a
         * better solution.
         *
         * Note: This only happens with CSS borders, set with the borderWidth,
         * borderOpacity, borderColor1, and borderColor2 options (which are now
         * deprecated). Borders created with GIF background images are fine.
         */
        if ($.browser.msie && $border.outerWidth() - $border.innerWidth() == 2) {
            $border.css('margin', 0);
            setTimeout(function () { $border.css('margin', 'auto'); }, 0);
        }
    }

    /**
     * Do the complete update sequence: recalculate offsets, update the
     * elements, and set the correct values of x1, y1, x2, and y2.
     *
     * @param resetKeyPress
     *            If set to <code>false</code>, this instance's keypress
     *            event handler is not activated
     */
    function doUpdate(resetKeyPress) {
        adjust();
        update(resetKeyPress);
        x1 = viewX(selection.x1); y1 = viewY(selection.y1);
        x2 = viewX(selection.x2); y2 = viewY(selection.y2);
    }

    /**
     * Hide or fade out an element (or multiple elements)
     *
     * @param $elem
     *            A jQuery object containing the element(s) to hide/fade out
     * @param fn
     *            Callback function to be called when fadeOut() completes
     */
    function hide($elem, fn) {
        options.fadeSpeed ? $elem.fadeOut(options.fadeSpeed, fn) : $elem.hide();
    }

    /**
     * Selection area mousemove event handler
     *
     * @param event
     *            The event object
     */
    function areaMouseMove(event) {
        var x = selX(evX(event)) - selection.x1,
            y = selY(evY(event)) - selection.y1;

        if (!adjusted) {
            adjust();
            adjusted = true;

            $box.one('mouseout', function () { adjusted = false; });
        }

        /* Clear the resize mode */
        resize = '';

        if (options.resizable) {
            /*
             * Check if the mouse pointer is over the resize margin area and set
             * the resize mode accordingly
             */
            if (y <= options.resizeMargin)
                resize = 'n';
            else if (y >= selection.height - options.resizeMargin)
                resize = 's';
            if (x <= options.resizeMargin)
                resize += 'w';
            else if (x >= selection.width - options.resizeMargin)
                resize += 'e';
        }

        $box.css('cursor', resize ? resize + '-resize' :
            options.movable ? 'move' : '');
        if ($areaOpera)
            $areaOpera.toggle();
    }

    /**
     * Document mouseup event handler
     *
     * @param event
     *            The event object
     */
    function docMouseUp(event) {
        /* Set back the default cursor */
        $('body').css('cursor', '');
        /*
         * If autoHide is enabled, or if the selection has zero width/height,
         * hide the selection and the outer area
         */
        if (options.autoHide || selection.width * selection.height == 0)
            hide($box.add($outer), function () { $(this).hide(); });

        $(document).unbind('mousemove', selectingMouseMove);
        $box.mousemove(areaMouseMove);

        options.onSelectEnd(img, getSelection());
    }

    /**
     * Selection area mousedown event handler
     *
     * @param event
     *            The event object
     * @return false
     */
    function areaMouseDown(event) {
        if (event.which != 1) return false;

        adjust();

        if (resize) {
            /* Resize mode is in effect */
            $('body').css('cursor', resize + '-resize');

            x1 = viewX(selection[/w/.test(resize) ? 'x2' : 'x1']);
            y1 = viewY(selection[/n/.test(resize) ? 'y2' : 'y1']);

            $(document).mousemove(selectingMouseMove)
                .one('mouseup', docMouseUp);
            $box.unbind('mousemove', areaMouseMove);
        }
        else if (options.movable) {
            startX = left + selection.x1 - evX(event);
            startY = top + selection.y1 - evY(event);

            $box.unbind('mousemove', areaMouseMove);

            $(document).mousemove(movingMouseMove)
                .one('mouseup', function () {
                    options.onSelectEnd(img, getSelection());

                    $(document).unbind('mousemove', movingMouseMove);
                    $box.mousemove(areaMouseMove);
                });
        }
        else
            $img.mousedown(event);

        return false;
    }

    /**
     * Adjust the x2/y2 coordinates to maintain aspect ratio (if defined)
     *
     * @param xFirst
     *            If set to <code>true</code>, calculate x2 first. Otherwise,
     *            calculate y2 first.
     */
    function fixAspectRatio(xFirst) {
        if (aspectRatio)
            if (xFirst) {
                x2 = max(left, min(left + imgWidth,
                    x1 + abs(y2 - y1) * aspectRatio * (x2 > x1 || -1)));
                y2 = round(max(top, min(top + imgHeight,
                    y1 + abs(x2 - x1) / aspectRatio * (y2 > y1 || -1))));
                x2 = round(x2);
            }
            else {
                y2 = max(top, min(top + imgHeight,
                    y1 + abs(x2 - x1) / aspectRatio * (y2 > y1 || -1)));
                x2 = round(max(left, min(left + imgWidth,
                    x1 + abs(y2 - y1) * aspectRatio * (x2 > x1 || -1))));
                y2 = round(y2);
            }
    }

    /**
     * Resize the selection area respecting the minimum/maximum dimensions and
     * aspect ratio
     */
    function doResize() {
        /*
         * Make sure the top left corner of the selection area stays within
         * image boundaries (it might not if the image source was dynamically
         * changed).
         */
        x1 = min(x1, left + imgWidth);
        y1 = min(y1, top + imgHeight);

        if (abs(x2 - x1) < minWidth) {
            /* Selection width is smaller than minWidth */
            x2 = x1 - minWidth * (x2 < x1 || -1);

            if (x2 < left)
                x1 = left + minWidth;
            else if (x2 > left + imgWidth)
                x1 = left + imgWidth - minWidth;
        }

        if (abs(y2 - y1) < minHeight) {
            /* Selection height is smaller than minHeight */
            y2 = y1 - minHeight * (y2 < y1 || -1);

            if (y2 < top)
                y1 = top + minHeight;
            else if (y2 > top + imgHeight)
                y1 = top + imgHeight - minHeight;
        }

        x2 = max(left, min(x2, left + imgWidth));
        y2 = max(top, min(y2, top + imgHeight));

        fixAspectRatio(abs(x2 - x1) < abs(y2 - y1) * aspectRatio);

        if (abs(x2 - x1) > maxWidth) {
            /* Selection width is greater than maxWidth */
            x2 = x1 - maxWidth * (x2 < x1 || -1);
            fixAspectRatio();
        }

        if (abs(y2 - y1) > maxHeight) {
            /* Selection height is greater than maxHeight */
            y2 = y1 - maxHeight * (y2 < y1 || -1);
            fixAspectRatio(true);
        }

        selection = { x1: selX(min(x1, x2)), x2: selX(max(x1, x2)),
            y1: selY(min(y1, y2)), y2: selY(max(y1, y2)),
            width: abs(x2 - x1), height: abs(y2 - y1) };

        update();

        options.onSelectChange(img, getSelection());
    }

    /**
     * Mousemove event handler triggered when the user is selecting an area
     *
     * @param event
     *            The event object
     * @return false
     */
    function selectingMouseMove(event) {
        x2 = /w|e|^$/.test(resize) || aspectRatio ? evX(event) : viewX(selection.x2);
        y2 = /n|s|^$/.test(resize) || aspectRatio ? evY(event) : viewY(selection.y2);

        doResize();

        return false;
    }

    /**
     * Move the selection area
     *
     * @param newX1
     *            New viewport X1
     * @param newY1
     *            New viewport Y1
     */
    function doMove(newX1, newY1) {
        x2 = (x1 = newX1) + selection.width;
        y2 = (y1 = newY1) + selection.height;

        $.extend(selection, { x1: selX(x1), y1: selY(y1), x2: selX(x2),
            y2: selY(y2) });

        update();

        options.onSelectChange(img, getSelection());
    }

    /**
     * Mousemove event handler triggered when the selection area is being moved
     *
     * @param event
     *            The event object
     * @return false
     */
    function movingMouseMove(event) {
        x1 = max(left, min(startX + evX(event), left + imgWidth - selection.width));
        y1 = max(top, min(startY + evY(event), top + imgHeight - selection.height));

        doMove(x1, y1);

        event.preventDefault();
        return false;
    }

    /**
     * Start selection
     */
    function startSelection() {
        $(document).unbind('mousemove', startSelection);
        adjust();

        x2 = x1;
        y2 = y1;
        doResize();

        resize = '';

        if (!$outer.is(':visible'))
            /* Show the plugin elements */
            $box.add($outer).hide().fadeIn(options.fadeSpeed||0);

        shown = true;

        $(document).unbind('mouseup', cancelSelection)
            .mousemove(selectingMouseMove).one('mouseup', docMouseUp);
        $box.unbind('mousemove', areaMouseMove);

        options.onSelectStart(img, getSelection());
    }

    /**
     * Cancel selection
     */
    function cancelSelection() {
        $(document).unbind('mousemove', startSelection)
            .unbind('mouseup', cancelSelection);
        hide($box.add($outer));

        setSelection(selX(x1), selY(y1), selX(x1), selY(y1));

        /* If this is an API call, callback functions should not be triggered */
        if (!(this instanceof $.imgAreaSelect)) {
            options.onSelectChange(img, getSelection());
            options.onSelectEnd(img, getSelection());
        }
    }

    /**
     * Image mousedown event handler
     *
     * @param event
     *            The event object
     * @return false
     */
    function imgMouseDown(event) {
        /* Ignore the event if animation is in progress */
        if (event.which != 1 || $outer.is(':animated')) return false;

        adjust();
        startX = x1 = evX(event);
        startY = y1 = evY(event);

        /* Selection will start when the mouse is moved */
        $(document).mousemove(startSelection).mouseup(cancelSelection);

        return false;
    }

    /**
     * Window resize event handler
     */
    function windowResize() {
        doUpdate(false);
    }

    /**
     * Image load event handler. This is the final part of the initialization
     * process.
     */
    function imgLoad() {
        imgLoaded = true;

        /* Set options */
        setOptions(options = $.extend({
            classPrefix: 'imgareaselect',
            movable: true,
            parent: 'body',
            resizable: true,
            resizeMargin: 10,
            onInit: function () {},
            onSelectStart: function () {},
            onSelectChange: function () {},
            onSelectEnd: function () {}
        }, options));

        $box.add($outer).css({ visibility: '' });

        if (options.show) {
            shown = true;
            adjust();
            update();
            $box.add($outer).hide().fadeIn(options.fadeSpeed||0);
        }

        /*
         * Call the onInit callback. The setTimeout() call is used to ensure
         * that the plugin has been fully initialized and the object instance is
         * available (so that it can be obtained in the callback).
         */
        setTimeout(function () { options.onInit(img, getSelection()); }, 0);
    }

    /**
     * Document keypress event handler
     *
     * @param event
     *            The event object
     * @return false
     */
    var docKeyPress = function(event) {
        var k = options.keys, d, t, key = event.keyCode;

        d = !isNaN(k.alt) && (event.altKey || event.originalEvent.altKey) ? k.alt :
            !isNaN(k.ctrl) && event.ctrlKey ? k.ctrl :
            !isNaN(k.shift) && event.shiftKey ? k.shift :
            !isNaN(k.arrows) ? k.arrows : 10;

        if (k.arrows == 'resize' || (k.shift == 'resize' && event.shiftKey) ||
            (k.ctrl == 'resize' && event.ctrlKey) ||
            (k.alt == 'resize' && (event.altKey || event.originalEvent.altKey)))
        {
            /* Resize selection */

            switch (key) {
            case 37:
                /* Left */
                d = -d;
            case 39:
                /* Right */
                t = max(x1, x2);
                x1 = min(x1, x2);
                x2 = max(t + d, x1);
                fixAspectRatio();
                break;
            case 38:
                /* Up */
                d = -d;
            case 40:
                /* Down */
                t = max(y1, y2);
                y1 = min(y1, y2);
                y2 = max(t + d, y1);
                fixAspectRatio(true);
                break;
            default:
                return;
            }

            doResize();
        }
        else {
            /* Move selection */

            x1 = min(x1, x2);
            y1 = min(y1, y2);

            switch (key) {
            case 37:
                /* Left */
                doMove(max(x1 - d, left), y1);
                break;
            case 38:
                /* Up */
                doMove(x1, max(y1 - d, top));
                break;
            case 39:
                /* Right */
                doMove(x1 + min(d, imgWidth - selX(x2)), y1);
                break;
            case 40:
                /* Down */
                doMove(x1, y1 + min(d, imgHeight - selY(y2)));
                break;
            default:
                return;
            }
        }

        return false;
    };

    /**
     * Apply style options to plugin element (or multiple elements)
     *
     * @param $elem
     *            A jQuery object representing the element(s) to style
     * @param props
     *            An object that maps option names to corresponding CSS
     *            properties
     */
    function styleOptions($elem, props) {
        for (var option in props)
            if (options[option] !== undefined)
                $elem.css(props[option], options[option]);
    }

    /**
     * Set plugin options
     *
     * @param newOptions
     *            The new options object
     */
    function setOptions(newOptions) {
        if (newOptions.parent)
            ($parent = $(newOptions.parent)).append($box.add($outer));

        /* Merge the new options with the existing ones */
        $.extend(options, newOptions);

        adjust();

        if (newOptions.handles != null) {
            /* Recreate selection area handles */
            $handles.remove();
            $handles = $([]);

            i = newOptions.handles ? newOptions.handles == 'corners' ? 4 : 8 : 0;

            while (i--)
                $handles = $handles.add(div());

            /* Add a class to handles and set the CSS properties */
            $handles.addClass(options.classPrefix + '-handle').css({
                position: 'absolute',
                /*
                 * The font-size property needs to be set to zero, otherwise
                 * Internet Explorer makes the handles too large
                 */
                fontSize: 0,
                zIndex: zIndex + 1 || 1
            });

            /*
             * If handle width/height has not been set with CSS rules, set the
             * default 5px
             */
            if (!parseInt($handles.css('width')) >= 0)
                $handles.width(5).height(5);

            /*
             * If the borderWidth option is in use, add a solid border to
             * handles
             */
            if (o = options.borderWidth)
                $handles.css({ borderWidth: o, borderStyle: 'solid' });

            /* Apply other style options */
            styleOptions($handles, { borderColor1: 'border-color',
                borderColor2: 'background-color',
                borderOpacity: 'opacity' });
        }

        /* Calculate scale factors */
        scaleX = options.imageWidth / imgWidth || 1;
        scaleY = options.imageHeight / imgHeight || 1;

        /* Set selection */
        if (newOptions.x1 != null) {
            setSelection(newOptions.x1, newOptions.y1, newOptions.x2,
                newOptions.y2);
            newOptions.show = !newOptions.hide;
        }

        if (newOptions.keys)
            /* Enable keyboard support */
            options.keys = $.extend({ shift: 1, ctrl: 'resize' },
                newOptions.keys);

        /* Add classes to plugin elements */
        $outer.addClass(options.classPrefix + '-outer');
        $area.addClass(options.classPrefix + '-selection');
        for (i = 0; i++ < 4;)
            $($border[i-1]).addClass(options.classPrefix + '-border' + i);

        /* Apply style options */
        styleOptions($area, { selectionColor: 'background-color',
            selectionOpacity: 'opacity' });
        styleOptions($border, { borderOpacity: 'opacity',
            borderWidth: 'border-width' });
        styleOptions($outer, { outerColor: 'background-color',
            outerOpacity: 'opacity' });
        if (o = options.borderColor1)
            $($border[0]).css({ borderStyle: 'solid', borderColor: o });
        if (o = options.borderColor2)
            $($border[1]).css({ borderStyle: 'dashed', borderColor: o });

        /* Append all the selection area elements to the container box */
        $box.append($area.add($border).add($areaOpera).add($handles));

        if ($.browser.msie) {
            if (o = ($outer.css('filter') || "").match(/opacity=(\d+)/))
                $outer.css('opacity', o[1]/100);
            if (o = ($border.css('filter') || "").match(/opacity=(\d+)/))
                $border.css('opacity', o[1]/100);
        }

        if (newOptions.hide)
            hide($box.add($outer));
        else if (newOptions.show && imgLoaded) {
            shown = true;
            $box.add($outer).fadeIn(options.fadeSpeed||0);
            doUpdate();
        }

        /* Calculate the aspect ratio factor */
        aspectRatio = (d = (options.aspectRatio || '').split(/:/))[0] / d[1];

        $img.add($outer).unbind('mousedown', imgMouseDown);

        if (options.disable || options.enable === false) {
            /* Disable the plugin */
            $box.unbind('mousemove', areaMouseMove).unbind('mousedown', areaMouseDown);
            $(window).unbind('resize', windowResize);
        }
        else {
            if (options.enable || options.disable === false) {
                /* Enable the plugin */
                if (options.resizable || options.movable)
                    $box.mousemove(areaMouseMove).mousedown(areaMouseDown);

                $(window).resize(windowResize);
            }

            if (!options.persistent)
                $img.add($outer).mousedown(imgMouseDown);
        }

        options.enable = options.disable = undefined;
    }

    /**
     * Remove plugin completely
     */
    this.remove = function () {
        /*
         * Call setOptions with { disable: true } to unbind the event handlers
         */
        setOptions({ disable: true });
        $box.add($outer).remove();
    };

    /*
     * Public API
     */

    /**
     * Get current options
     *
     * @return An object containing the set of options currently in use
     */
    this.getOptions = function () { return options; };

    /**
     * Set plugin options
     *
     * @param newOptions
     *            The new options object
     */
    this.setOptions = setOptions;

    /**
     * Get the current selection
     *
     * @param noScale
     *            If set to <code>true</code>, scaling is not applied to the
     *            returned selection
     * @return Selection object
     */
    this.getSelection = getSelection;

    /**
     * Set the current selection
     *
     * @param x1
     *            X coordinate of the upper left corner of the selection area
     * @param y1
     *            Y coordinate of the upper left corner of the selection area
     * @param x2
     *            X coordinate of the lower right corner of the selection area
     * @param y2
     *            Y coordinate of the lower right corner of the selection area
     * @param noScale
     *            If set to <code>true</code>, scaling is not applied to the
     *            new selection
     */
    this.setSelection = setSelection;

    /**
     * Cancel selection
     */
    this.cancelSelection = cancelSelection;

    /**
     * Update plugin elements
     *
     * @param resetKeyPress
     *            If set to <code>false</code>, this instance's keypress
     *            event handler is not activated
     */
    this.update = doUpdate;

    /*
     * Traverse the image's parent elements (up to <body>) and find the
     * highest z-index
     */
    $p = $img;

    while ($p.length) {
        zIndex = max(zIndex,
            !isNaN($p.css('z-index')) ? $p.css('z-index') : zIndex);
        /* Also check if any of the ancestor elements has fixed position */
        if ($p.css('position') == 'fixed')
            position = 'fixed';

        $p = $p.parent(':not(body)');
    }

    /*
     * If z-index is given as an option, it overrides the one found by the
     * above loop
     */
    zIndex = options.zIndex || zIndex;

    if ($.browser.msie)
        $img.attr('unselectable', 'on');

    /*
     * In MSIE and WebKit, we need to use the keydown event instead of keypress
     */
    $.imgAreaSelect.keyPress = $.browser.msie ||
        $.browser.safari ? 'keydown' : 'keypress';

    /*
     * There is a bug affecting the CSS cursor property in Opera (observed in
     * versions up to 10.00) that prevents the cursor from being updated unless
     * the mouse leaves and enters the element again. To trigger the mouseover
     * event, we're adding an additional div to $box and we're going to toggle
     * it when mouse moves inside the selection area.
     */
    if ($.browser.opera)
        $areaOpera = div().css({ width: '100%', height: '100%',
            position: 'absolute', zIndex: zIndex + 2 || 2 });

    /*
     * We initially set visibility to "hidden" as a workaround for a weird
     * behaviour observed in Google Chrome 1.0.154.53 (on Windows XP). Normally
     * we would just set display to "none", but, for some reason, if we do so
     * then Chrome refuses to later display the element with .show() or
     * .fadeIn().
     */
    $box.add($outer).css({ visibility: 'hidden', position: position,
        overflow: 'hidden', zIndex: zIndex || '0' });
    $box.css({ zIndex: zIndex + 2 || 2 });
    $area.add($border).css({ position: 'absolute', fontSize: 0 });

    /*
     * If the image has been fully loaded, or if it is not really an image (eg.
     * a div), call imgLoad() immediately; otherwise, bind it to be called once
     * on image load event.
     */
    img.complete || img.readyState == 'complete' || !$img.is('img') ?
        imgLoad() : $img.one('load', imgLoad);

    /*
     * MSIE 9.0 doesn't always fire the image load event -- resetting the src
     * attribute seems to trigger it. The check is for version 7 and above to
     * accommodate for MSIE 9 running in compatibility mode.
     */
   if (!imgLoaded && $.browser.msie && $.browser.version >= 7)
        img.src = img.src;
};

/**
 * Invoke imgAreaSelect on a jQuery object containing the image(s)
 *
 * @param options
 *            Options object
 * @return The jQuery object or a reference to imgAreaSelect instance (if the
 *         <code>instance</code> option was specified)
 */
$.fn.imgAreaSelect = function (options) {
    options = options || {};

    this.each(function () {
        /* Is there already an imgAreaSelect instance bound to this element? */
        if ($(this).data('imgAreaSelect')) {
            /* Yes there is -- is it supposed to be removed? */
            if (options.remove) {
                /* Remove the plugin */
                $(this).data('imgAreaSelect').remove();
                $(this).removeData('imgAreaSelect');
            }
            else
                /* Reset options */
                $(this).data('imgAreaSelect').setOptions(options);
        }
        else if (!options.remove) {
            /* No exising instance -- create a new one */

            /*
             * If neither the "enable" nor the "disable" option is present, add
             * "enable" as the default
             */
            if (options.enable === undefined && options.disable === undefined)
                options.enable = true;

            $(this).data('imgAreaSelect', new $.imgAreaSelect(this, options));
        }
    });

    if (options.instance)
        /*
         * Return the imgAreaSelect instance bound to the first element in the
         * set
         */
        return $(this).data('imgAreaSelect');

    return this;
};

})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("imgareaselect", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/*
 * Password Strength (0.1.2)
 * by Sagie Maoz (n0nick.net)
 * n0nick@php.net
 *
 * This plugin will check the value of a password field and evaluate the
 * strength of the typed password. This is done by checking for
 * the diversity of character types: numbers, lowercase and uppercase
 * letters and special characters.
 *
 * Copyright (c) 2010 Sagie Maoz <n0nick@php.net>
 * Licensed under the GPL license, see http://www.gnu.org/licenses/gpl-3.0.html
 *
 *
 * NOTE: This script requires jQuery to work.  Download jQuery at www.jquery.com
 *
 */

var passwordStrength = new function()
{
	this.countRegexp = function(val, rex)
	{
		var match = val.match(rex);
		return match ? match.length : 0;
	};

	this.getStrength = function(val, minLength)
	{
		var len = val.length;

		// too short =(
		if (len < minLength)
		{
			return 0;
		}

		var nums = this.countRegexp(val, /\d/g),
			lowers = this.countRegexp(val, /[a-z]/g),
			uppers = this.countRegexp(val, /[A-Z]/g),
			specials = len - nums - lowers - uppers;

		// just one type of characters =(
		if (nums == len || lowers == len || uppers == len || specials == len)
		{
			return 1;
		}

		var strength = 0;
		if (nums)	{ strength+= 2; }
		if (lowers)	{ strength+= uppers? 4 : 3; }
		if (uppers)	{ strength+= lowers? 4 : 3; }
		if (specials) { strength+= 5; }
		if (len > 10) { strength+= 1; }

		return strength;
	};

	this.getStrengthLevel = function(val, minLength)
	{
		var strength = this.getStrength(val, minLength),
				val = 1;
		if (strength <= 0) {
			val = 1;
		} else if (strength > 0 && strength <= 4) {
			val = 2;
		} else if (strength > 4 && strength <= 8) {
			val = 3;
		} else if (strength > 8 && strength <= 12) {
			val = 4;
		} else if (strength > 12) {
			val = 5;
		}

		return val;
	};
};

$.fn.password_strength = function(options)
{
	var settings = $.extend({
		'container' : null,
		'minLength' : 6,
		'texts' : {
			1 : 'Too weak',
			2 : 'Weak password',
			3 : 'Normal strength',
			4 : 'Strong password',
			5 : 'Very strong password'
		},
		'onCheck': null
	}, options);

	return this.each(function()
	{
		var container = null;
		if (settings.container)
		{
			container = $(settings.container);
		}
		else
		{
			container = $('<span/>').attr('class', 'password_strength');
			$(this).after(container);
		}

		$(this).keyup(function()
		{
			var val = $(this).val(),
					level = passwordStrength.getStrengthLevel(val, settings.minLength);

			if (val.length > 0)
			{
				var _class = 'password_strength_' + level;

				if (!container.hasClass(_class) && level in settings.texts)
				{
					container.text(settings.texts[level]).attr('class', 'password_strength ' + _class);
				}
			}
			else
			{
				container.text('').attr('class', 'password_strength');
			}
			if (settings.onCheck) {
				settings.onCheck.call(this, level);
			}
		});
	});
};
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("passwordstrength", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var exports = function() {

/**
 * jquery.mentions.
 * Textarea with ability to highlight text blocks
 * Includes built-in autogrow and autocomplete
 * and a inspector utility for debugging purposes.
 *
 * Customizable trigger keys allows you to create
 * mentions, hashtags and nything else that fit your needs.
 *
 * Copyright (c) 2013 Jensen Tonne
 * http://www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Trigger configuration:
 *
 * type
 *   Name for the trigger type.
 *
 * wrap
 *   Whether or not hitting a trigger key before existing
 *   characters will wrap these characters into the block
 *   marker until a stop character is found. Space will
 *   always be a stop character whether or not it is
 *   specified in allowSpace or stop option. (default: false)
 *
 * stop
 *   A string of characters that will end the block. (default: "")
 *
 * allowSpace
 *   If true, hitting on a space in a block marker
 *   will not end the block marker until a consecutive
 *   space is pressed. (default: false)
 *
 * query
 *   Accepts a url string, an array of objects or
 *   a function that returns a deferred object that
 *   resolves with an array of objects. Also accept a
 *   query configuration object (advanced users only!).
 *
 * finalize
 *    If true, after selecting an item from the
 *    autocomplete menu, the block marker is finalized
 *    and any further changes to within the block marker
 *    will simply destroy the entire marker. (default: false)
 *
 * triggers: {
 *     "@": {
 *         type: "entity",
 *         wrap: false,
 *         stop: "",
 *         allowSpace: true,
 *         query: http://json/rest/api?q=
 *     },
 *     "#": {
 *         type: "hashtag",
 *         wrap: true,
 *         stop: " #",
 *         allowSpace: false
 *     }
 * }
 *
 */var _backspace = "",
    _space     = " ",
    _nbsp      = "\u00a0",
    _newline   = "\n",
    _typeAttr  = "data-type",
    _valueAttr = "data-value",
    KEYCODE = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        ENTER: 13,
        ESCAPE: 27,
        LEFT: 37,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    };

// TODO: Put this elsewhere
$.fn.caret = function(start, end) {

    if (this.length == 0) {
        return;
    }

    if (typeof start == 'number') {

        end = (typeof end == 'number') ? end : start;

        return this.each(function() {

            if (this.setSelectionRange) {
                var obj = this;

                // window.setTimout is a walkaround to address the chrome bug.
                window.setTimeout(function() {
                    obj.setSelectionRange(start, end);
                }, 0);

            } else if (this.createTextRange) {
                var range = this.createTextRange();
                range.collapse(true);
                range.moveEnd('character', end);
                range.moveStart('character', start);
                try { range.select(); } catch (ex) { }
            }
        });

    } else {
        if (this[0].setSelectionRange)
        {
            start = this[0].selectionStart;
            end = this[0].selectionEnd;
        } else if (document.selection && document.selection.createRange)
        {
            var range = document.selection.createRange();
            start = 0 - range.duplicate().moveStart('character', -100000);
            end = start + range.text.length;
        }
        return { start: start, end: end };
    }
};
var Marker = function(options) {
    $.extend(this, options);
}

$.extend(Marker.prototype, {

    val: function(str) {

        var marker = this;

        if (str===undefined) {
            return marker.text.nodeValue;
        }

        // Update text value
        marker.text.nodeValue = str;

        // Update end & length
        marker.end = marker.start + (marker.length = str.length);

        return marker;
    },

    nextSibling: function(node) {

        var next = node.nextSibling;

        while (next && next.nodeType===1 && next.hasAttribute("data-ignore")) {
            next = next.nextSibling;
        }

        return next;
    },

    insert: function(str, start, end) {

        // Marker
        var marker     = this,
            block      = marker.block,
            text       = marker.text,
            parent     = marker.parent,
            br         = marker.br,
            val        = marker.val(),
            length     = marker.length,

            // Character flags
            newline    = str==_newline,
            space      = str==_space,
            backspace  = str==_backspace,

            // Trigger
            trigger = marker.trigger || {},
            finalize = trigger.finalize,
            finalized = marker.finalized,

            // Spaces
            // We need to insert space in a spawned marker when:
            //  - space is not allowed in block marker
            //  - space is allowed in block marker
            //    but there's already a trailing space.
            trailingSpace = val.charCodeAt(start - 1)==32,
            allowSpace    = trigger.allowSpace || marker.allowSpace,
            spawnSpace    = space && (!allowSpace || (allowSpace && trailingSpace));

        // If no start position was given,
        // assume want to insert at the end of the text.
        if (start===undefined) start = length;

        // If no end position was given,
        // assume we want to insert in a single position.
        if (end===undefined) end = start;

        // If this block marker already has a trailing space
        // but the block marker hasn't been finalized yet.
        if (block && allowSpace && trailingSpace && !finalized) {

            // Reverse the insertion on textarea
            if (space) {

                var $textarea = $(marker.textarea),
                    wholeText = $textarea.val(),
                    pos       = $textarea.caret().end - 1,
                    offset    = marker.start + start;

                $textarea
                    .val(wholeText.substring(0, offset) + wholeText.slice(offset + 1))
                    .caret(pos);
            }

            // Convert to text marker
            marker.toTextMarker();

            // TODO: Refactor this
            if (space) {
                // Trigger marker for post processing
                $(parent).trigger("markerInsert", [marker, nodes, str, start, end]);
                return marker;
            // For other characters, restart text insertion process.
            } else {
                return marker.insert(str, start, end);
            }
        }

        // If we are at the end of a block marker OR this is a newline block marker,
        // space & newline should be added to beginning of the next marker.
        if (block && end==length && !backspace && (spawnSpace || newline || br || finalized)) {
            var spawn = marker.spawn().insert(str, 0);
            $(parent).trigger("markerExit", [marker, nodes, spawn, str, start, end]);
            return spawn;
        }

        // Quick monkey patch for typing before a block marker
        // in the beginning of the textarea.
        if (block && marker.index===0 && end===0 && str.length===1) {

            var textnode = document.createTextNode(str);
            parent.insertBefore(textnode, block);

            var newMarker = new Marker({
                index: 0,
                start: 0,
                end: str.length,
                text: textnode,
                parent: parent,
                textarea: marker.textarea,
                allowSpace: true,
            });

            // Trigger marker for post processing
            $(parent).trigger("markerInsert", [newMarker, nodes, str, start, end]);

            return newMarker;
        }

        // Nodes
        var next   = block ? block.nextSibling : text.nextSibling,

            // Text
            prefix = val.substring(0, start),
            suffix = val.slice(end),

            // Chunks
            // Replace double space with one space and one nbsp to ensure
            // overlay is rendered proper spacing + identical word-wrap.
            chunks = str.replace(/  /g, " " + _nbsp).split(_newline),
            nodes  = [],
            node   = block || text,
            i      = chunks.length;

        // Add the prefix/suffix to the first/last chunk.
        // If this is a single chunk, the suffix is
        // actually added to the same chunk. :)
        chunks[0] = prefix + chunks[0];
        chunks[i-1] += suffix;

        // If this is a single chunk, this loop won't execute
        // but we still benefit from having the correct index. :)
        while (--i) {

            var node = document.createTextNode(chunks[i]),
                br = document.createElement("BR");

            nodes.push(parent.insertBefore(node, next));
            nodes.push(parent.insertBefore(br, node));

            next = br;
        }

        // Update the text value in the current marker
        marker.val(chunks[i]);

        // Trigger marker for post processing
        $(parent).trigger("markerInsert", [marker, nodes, str, start, end]);

        return marker;
    },

    remove: function() {

        var marker = this,
            parent = marker.parent,
            block = marker.block,
            text = marker.text;

        if (block) $(block).trigger("triggerDestroy", [marker]);

        parent.removeChild(block || text);

        marker.removed = true;

        $(parent).trigger("markerRemove", [marker]);

        return marker;
    },

    toTextMarker: function() {

        var marker = this,
            block  = marker.block,
            parent = marker.parent;

        if (!block) return marker;

        // Create a copy of the old marker
        var old = marker.clone();

        if (block) $(block).trigger("triggerDestroy", [marker]);

        // Move the text node out and
        // place it before the next marker.
        // Note: This doesn't need marker.nextSibling();
        parent.insertBefore(marker.text, block.nextSibling);

        // Remove the block node
        parent.removeChild(block);
        delete marker.block;
        delete marker.trigger;

        $(marker.parent).trigger("markerConvert", [marker, old, "text"]);

        return marker;
    },

    toBlockMarker: function(normalize) {

        var marker = this;

        // If this is a block marker, skip.
        if (marker.block) return;

        var old = marker.clone(),
            parent = marker.parent,
            block = marker.block = document.createElement("SPAN"),
            text  = marker.text;

        // Insert block before the next marker
        // Note: This doesn't need marker.nextSibling();
        parent.insertBefore(block, text.nextSibling);

        // Move text inside block marker
        block.appendChild(text);

        // Create empty marker data
        $(block).data("marker", {});

        $(marker.parent).trigger("markerConvert", [marker, old, "block"]);

        return marker;
    },

    spawn: function(start, end) {

        var marker = this,
            text   = marker.text,
            parent = marker.parent,
            block  = marker.block,
            // Note: This doesn't need marker.nextSibling();
            next   = block ? block.nextSibling : text.nextSibling;

        // If not start and end position was given, assume that
        // we're spawning an empty marker next to the current marker.
        // [hello] --> [hello[]
        if (start===undefined) {
            start = end = marker.length;
        }

        // If we're spawning in text in the middle,
        // split out the end marker and insert it before the next marker.
        // [he*ll*o] --> [he*ll*][o]
        if (end < marker.length) {
            next = parent.insertBefore(text.splitText(end), next);
        }

        // Split out the text
        // [he*ll*][o] --> [he][ll][o]
        text = parent.insertBefore(text.splitText(start), next);

        // Create marker object from new text object
        var spawn = new Marker({
            index     : marker.index + 1,
            start     : (start = marker.start + start),
            end       : (end = marker.start + end),
            length    : end - start,
            text      : text,
            parent    : parent,
            textarea  : marker.textarea,
            before    : marker,
            after     : marker.after,
            br        : false,
            allowSpace: true,
            finalized : false
        });

        // Update current marker
        marker.end    = start,
        marker.length = marker.end - marker.start;
        marker.after  = spawn;

        return spawn;
    },

    clone: function() {

        return new Marker(
            $.pick(this, "index,start,end,length,text,parent,textarea,before,after,br,allowSpace,trigger,value,finalized".split(","))
        );
    },

    finalize: function(value) {

        var marker = this,
            block = marker.block;

        // Text marker cannot be finalized
        if (!block) return;

        var data = $(block).data("marker");
            data.value = value;
            data.finalized = true;

        $.extend(marker, data);
    }
});$.Controller("Mentions",
{
    pluginName: "mentions",
    hostname: "mentions",

    defaultOptions: {

        cssCloneProps: [
            'lineHeight', 'textDecoration', 'letterSpacing',
            'fontSize', 'fontFamily', 'fontStyle',
            'fontWeight', 'textTransform', 'textAlign',
            'direction', 'wordSpacing', 'fontSizeAdjust'
        ],

        triggers: {},

        inspector: false,

        "{textarea}": "[data-mentions-textarea]",
        "{overlay}" : "[data-mentions-overlay]",
        "{block}"   : "[data-mentions-overlay] > span"
    }
},
function(self){ return {

    init: function() {

        // Speed up access to overlay
        self._overlay  = self.overlay()[0];
        self._textarea = self.textarea()[0];

        // Put this in a non-blocking thread
        setTimeout(function(){
            self.cloneLayout();
        }, 15);

        if (self.options.inspector) {
            self.inspect();
        }

        self.addPlugin("autocomplete");

        self.initialCaret = self.textarea().data("initial") || 0;
    },

    inspect: function() {
        self.inspector = self.addPlugin("inspector");
        self.inspector.showInspector();
    },

    setLayout: function() {

        self.normalize();
    },

    cloneLayout: function() {

        var $overlay = self.overlay(),
            overlay = $overlay.detach()[0],
            textarea = self.textarea(),
            props = self.options.cssCloneProps,
            i = 0;

        while (prop = props[i++]) {
            overlay.style[prop] = textarea.css(prop);
        }

        overlay.style.opacity = 1;

        $overlay.insertBefore(textarea);

        self.setLayout();
    },

    reset: function() {

        // Overlay
        var overlay = self.overlay(),
            overlayDefault = overlay.data("default");

        if (overlayDefault !== undefined) {
            // TODO: Use $.toHTML() in the future
            // after all is on 3.1.11.
            overlay.html($('<div>').html(overlayDefault).html());
        } else {
            overlay.empty();
        }

        // Textarea
        var textarea = self.textarea(),
            textareaDefault = textarea.data("default");

        if (textareaDefault !== undefined) {
            textarea.val($('<div>').html(textareaDefault).text());
        } else {
            textarea.val("");
        }

        self.caretBefore = self.caretAfter = {start: 0, end: 0};
        self.previousMarker = null;

        self.normalize();

        self.initialFocus = true;

        self.trigger("triggerClear");
    },

    //--- Triggers ----//

    getTrigger: function(key) {

        var triggers = self.options.triggers;
        if (triggers.hasOwnProperty(key)) {
            var trigger = triggers[key];
            trigger.key = key;
            return trigger;
        }
    },

    getTriggerFromType: function(type) {

        var triggers = self.options.triggers,
            found;

        $.each(triggers, function(key, trigger) {
            if (trigger.type===type) {
                found = trigger;
                return false;
            }
        });

        return found;
    },

    getStopIndex: function(str, stop) {

        var i = stop.length,
            idx = str.length;

        // Find the first earliest stop character, that's where the string ends
        while (i--) {
            var chr = stop.substr(i, 1),
                pos = str.indexOf(chr);
            idx = (pos < 0) ? idx : Math.min(idx, pos);
        }

        return idx;
    },

    //--- Marker traversal ----//

    getMarkers: function(callback) {

        var textarea = self._textarea,
            overlay = self._overlay,
            nodes = $.makeArray(overlay.childNodes),
            node,
            i = 0,
            start = 0,
            before = null,
            skip = false,
            results = [],
            iterator = function(marker) {

                var ret;

                // Execute callback while passing in marker object
                if (callback) ret = callback.apply(marker, [marker]);

                // If callback returned:
                // false     - stop the loop
                // null      - don't add anything to the result list
                // undefined - add the same marker object to the result list
                // value     - add the value to the result list
                if (ret!==null && ret!==false) results.push(ret!==undefined ? ret : marker);

                return ret; // if ret is false, the parent loop will stop
            };

        // Filter out nodes to ignore
        $.remove(nodes, function(node){
            return node.nodeType===1 && node.hasAttribute('data-ignore');
        });

        while (node = nodes[i++]) {

            // Nodes
            var nodeType = node.nodeType,
                nodeName = node.nodeName,
                text, block = null,

                // Marker positions
                end, length,

                // Marker behaviour
                br = false, allowSpace = false;

            // If this is a text node, assign this node as marker text
            if (nodeType==3) {
                text = node;
                allowSpace = true;
            // else assign this node as marker block,
            // then test if node is <br/>, create a detached text node contaning a line break,
            } else if ((block = node) && nodeName=="BR") {
                text = document.createTextNode(_newline);
                br = true;
            // if this is an invalid node, e.g. node not element, node not span, span has no text child node,
            // remove code from overlay and skip this loop.
            } else if (nodeType!==1 || nodeName!=="SPAN" || !(text = node.childNodes[0]) || text.nodeType!==3) {
                overlay.removeChild(node);
                continue;
            }

            // Create marker props
            var props = {
                index     : i - 1,
                start     : start,
                end       : (end = start + (length = text.length)),
                length    : length,
                text      : text,
                block     : block,
                parent    : overlay,
                textarea  : textarea,
                before    : before,
                br        : br,
                allowSpace: allowSpace,
                finalized : false
            };

            // Create marker data
            if (block) {
                var $node = $(node), data = $node.data("marker");
                if (!data) (data = {}) && $node.data("marker", data);

                // Restore trigger from data attribute
                if (node.hasAttribute(_typeAttr)) {

                    var type = $node.attr(_typeAttr),
                        trigger = self.getTriggerFromType(type);

                    if (trigger) data.trigger = trigger;
                    $node.removeAttr(_typeAttr);
                }

                // Restore value from data attribute
                if (node.hasAttribute(_valueAttr)) {

                    data.value = $node.attr(_valueAttr);
                    data.finalized = true;
                    $node.removeAttr(_valueAttr);
                }

                $.extend(props, data);
            }

            // Create marker
            var marker = new Marker(props);

            // If this is the second iteration, decorate the marker the after property
            // of the marker before this with the current marker.
            if (i > 1) {
                before.after = marker;
                // Execute iterator for the marker before this
                // If iterator returned false, stop the loop.
                if (skip = (iterator(before)===false)) break;
            }

            // Else reset start position and
            // continue with next child node.
            start = end;
            before = marker;
        }

        // Execute iterator one more time for the last marker
        if (!skip) iterator(before);

        return results;
    },

    getMarkerAt: function(pos) {

        if (pos===undefined) return;

        var marker;

        self.getMarkers(function(){

            // If position is inside current node,
            // stop and return marker.
            if (pos >= this.start && pos <= this.end) {
                marker = this;
                return false;
            }
        });

        return marker;
    },

    getMarkersBetween: function(start, end) {

        if (start===undefined) return;

        return self.getMarkers(function(){

            return (this.start > end) ? false : (this.end < start) ? null : this;
        });
    },

    toArray: function(stringify, asc) {

        var results = self.getMarkers(function(){

            var marker = this;

            if (!marker.block || marker.br) return null;

            // If there's no trigger, try to find it.
            if (!marker.trigger) {

                // Identify the trigger being used
                var wholeText = marker.text.nodeValue,
                    key = wholeText.slice(0, 1),
                    trigger = self.getTrigger(key);

                if (!trigger) return null;

                marker.trigger = trigger;
                marker.value = wholeText.slice(1);
            }

            var data = {
                start  : marker.start,
                length : marker.length,
                type   : marker.trigger.type,
                value  : marker.value
            };

            return (stringify) ? JSON.stringify(data) : data;
        });

        return (asc) ? results : results.reverse();
    },

    //--- Marker/overlay/text manipulation ---//

    insert: function(str, start, end) {

        var marker, offset;

        // If we are inserting character(s)
        if (start===end || end===undefined) {

            // Get marker & offset
            marker = self.getMarkerAt(start);
            offset = marker.start;

            // Insert character
            marker.insert(str, start - offset, end - offset);

        } else {

            // If we are replacing character(s)

            // Identify affected markers
            var markers = self.getMarkersBetween(start, end),
                length = markers.length;

            // If there are no marker, stop.
            if (length < 1) return;

            // If we're modifying a single marker
            // e.g. he*llo* --> he*y*
            if (length==1) {

                // Get marker & offset
                marker = markers[0];
                offset = marker.start;

                // Insert character
                marker.insert(str, start - offset, end - offset);
            } else {

                // If we're modifying multiple markers
                // e.g. he*llo [john] [do*e] --> he*xxx*e

                // Deal with markers in reverse
                var i = length - 1,
                    marker = markers[i];

                // Convert block marker into text marker
                // [doe] --> doe
                // hello [john] [doe] --> hello [john] doe
                if (marker.block && end > marker.start) marker.toTextMarker();

                // Remove characters from text marker
                // doe --> e
                // hello [john] doe --> hello [john] e

                // Do not perform this operation if it does
                // not changes the value of the marker.
                if ((end - marker.start) > 0) {
                    marker.insert("", 0, end - marker.start);
                }

                // Remove all markers in between
                // [john] --> (removed)
                // hello [john] --> hello
                while ((marker = markers[--i]) && i > 0) {
                    marker.remove();
                }

                // If we're in the beginning of the textarea,
                // convert block into text marker.
                if (marker.block && marker.index===0 && start===0) marker.toTextMarker();

                // Insert characters in the first marker
                // hello -> hexxxe
                marker.insert(str, start - marker.start, marker.length);

                // Special case for handling br tag in the beginning of the textarea
                if (start===0 && marker.br) {
                    marker.remove();
                }
            }
        }

        // Normalize all text markers
        self.normalize();

        return marker;
    },

    textareaInsert: function(str, start, end) {

        var textarea = self._textarea,
            val = textarea.value;

        return textarea.value = val.substring(0, start) + str + val.slice(end);
    },

    normalize: function() {

        var overlay = self._overlay,
            textarea = self._textarea;

        // This clean up empty text nodes in the beginning and
        // the end of the overlay and join disjointed text nodes
        // that are supposed to be a single text node.
        overlay.normalize();

        // This is a double-edged workaround.
        // - When there is no child element (empty textarea),
        //   an empty text node ensure overlay has a minimum
        //   single line-height.
        // - If there is a newline at the end of the overlay,
        //   an empty text node ensure overlay accomodates
        //   the height of the newline.
        var first = overlay.firstChild,
            last = overlay.lastChild,
            textNode = document.createTextNode("");

        if (!last || last.nodeName==="BR") {
            overlay.appendChild(textNode);
        }

        if (last && last==first && last.nodeType===1 && last.hasAttribute("data-ignore")) {
            overlay.insertBefore(textNode, last);
        }

        // Chrome, Opera & IE doesn't accomodate height of
        // newline after an empty text node, so reset the
        // overlay height to auto, and retrieve the textarea
        // scrollHeight again.
        overlay.style.height = "auto";
        overlay.style.height = textarea.scrollHeight + "px";

        // IE & Opera textarea's scrollTop may jump position
        // from time to time so we need to reset it back.
        textarea.scrollTop = 0;

        // Remember the current textarea length.
        // We do it here instead of keydown event
        // because Opera returns the length of the
        // textarea after it has been changed.
        self.lengthBefore = textarea.value.length;

        // console.log("after", overlay.childNodes);
    },

    //--- Key events & caret handling ---//

    /*
    List of input patterns to test:

    0. Meta-characters via alt + shift + (any key).

    1. Holding arrow key + pressing another character.

    2. Select a range of characters (covering single/multiple marker)
       - and press any key
       - and press enter
       - and press backspace

    3. Repeat step 2 with range starting at a block marker where caret is at:
       - the beginning
       - the middle
       - the end
       of the block marker and also when block marker is at:
       - the beginning
       - the middle
       - the end
       of the textarea.

    4. Typing accented character.
       Hold a key until candidate window shows up, then:
       - Press a number
       - Release key, then press a number
       - Navigate using arrow keys
       - Press enter to select a character
       - Click on a candidate to select a character
       - Press backspace until candidate window dissappears

    5. Typing romanized-to-unicode (Chinese/Japanese/Arabian/etc) characters.
       Type multiple characters in the candidate window, then proceed with
       the next course of action at test no. 4.

    6. Pressing enter continously to create multiple newlines:
       - at the beginning of the textarea
       - at the middle of marker/text
       - at the end of textarea
       then:
       - enter a key at the newline
       - press backspace to remove those newlines
       - select a range of newlines, then proceed with
         the next course of action at test no. 2.
    */

    lengthBefore: 0,
    caretBefore: {start: 0, end: 0},
    caretAfter: {start: 0, end: 0},
    skipKeydown: false,
    previousMarker: null,

    initialFocus: true,

    "{textarea} focus": function() {

        if (self.initialFocus) {
            self.textarea().caret(self.initialCaret || 0);
        }
    },

    "{textarea} keydown": function(textarea, event) {

        self.initialFocus = false;

        // If keydown event has been fired multiple times
        // this might mean the user has entered candidate
        // window and we should not do anything.
        if (self.skipKeydown) return;

        var caret = self.caretBefore = textarea.caret();

        if (event.keyCode===8 && $.IE < 10) {
            self.overlay().css('opacity', 0);
        }

        // console.log("keydown", event.which, caret);

        self.skipKeydown = true;
    },

    // Keypress event will not trigger when meta keys are pressed,
    // it will trigger on well-formed characters.
    "{textarea} keypress": function(textarea, event) {

        // console.log("keypress");

        // This will help on situations where user
        // holds an arrow key + presses another character.
        self.caretBefore = textarea.caret();

        // FF fires keypress on backspace, while Chrome & IE doesn't.
        // We normalize this behaviour by not doing anything on backspace.
        if (event.keyCode===8) return;
    },

    "{textarea} input": function(textarea) {

        self.reflect();

        // Extra precaution in case overlay goes wrong,
        // user can start all over again by reseting mentions.
        if (textarea.val().length < 1) {
            self.reset();
        }
    },

    "{textarea} keyup": function(textarea, event) {

        self.skipKeydown = false;

        // Listen to backspace during keydown because
        // it is not fired on input/keypress on IE9.
        if (event.keyCode===8 && $.IE < 10) {

            var caretBefore = self.caretBefore,
                caretAfter  = self.caretAfter = self.textarea().caret();

            self.insert("", caretAfter.end, caretBefore.end);

            self.caretBefore = caretAfter;

            self.overlay().css('opacity', 1);
        }

        // console.log("keyup", caretBefore, caretAfter);
    },

    reflect: function() {

        var textarea = self._textarea,

            wholeText = textarea.value,

            // Caret position retrieved on previous input event
            // is the position before the character is inserted
            caretBefore = self.caretBefore,

            // Caret position retrieved on current input event
            // is the position after the character is inserted.
            caretAfter = self.caretAfter = $(textarea).caret(),

            // Determine if user is on Opera + candidate window.
            operaCandidateWindow = ($.browser.opera && caretAfter.end > caretAfter.start),

            marker = self.getMarkerAt(caretBefore.start),

            diff = self.lengthBefore - wholeText.length,

            replace = false;

        // Ensure Opera follows the caretBefore behaviour of other
        // browsers when typing inside the candidate window.
        if (operaCandidateWindow) {
            if (caretBefore.start!==caretBefore.end) {
                caretBefore.end += diff;
            }
        }

        // In case there was an issue retrieving marker.
        // TODO: Figure out the pattern, usually when typed too early.
        if (!marker) return;

        var previousMarker = self.previousMarker,
            block = marker.block;

        // If the previous marker hasn't been finalized, convert back to text block.
        if (previousMarker) {

            var previousBlock = previousMarker.block,
                finalize = (previousMarker.trigger || {}).finalize;

            if (previousBlock && finalize && !previousMarker.finalized && previousBlock!==block) {
                try {
                    previousMarker.toTextMarker();
                } catch(e) {
                    self.previousMarker = null;
                }
            }
        }

        // console.log("caretBefore", caretBefore.start, caretBefore.end);
        // console.log("caretAfter" , caretAfter.start , caretAfter.end);

        // If there is a change in the text content but the length of the
        // text content is the same length as before, it is impossible to
        // tell what has changed, so we replace the entire text in the marker
        // where the caret is at. This happens when:
        // - User holds a character + presses a number to select a
        //   character from the candidate window.
        // - User navigates between characters using arrow keys
        //   within the candidate window.
        //
        // The caretAfter could be earlier than the caretBefore when:
        // - User enters backspace to remove a character.
        // - User finalizes a selection from the candidate window where characters
        //   are shorter than being typed, e.g. "ni hao" --> "你好".
        if (!marker.br && (diff===0 || caretAfter.end < caretBefore.start)) {

            var textStart  = marker.start,
                textEnd    = marker.end - diff,
                rangeStart = caretAfter.end,
                rangeEnd   = caretBefore.start,
                replace    = textStart!==textEnd;

         // If user is inserting text as usual.
        } else {

            // In Chrome, the caretAfter has a range if the user is typing within the
            // candidate window. The characters may change due to fuzzy logic suggestions.
            // You can test this by using Chinese pinyin input and typing "a" then
            // "asdasdasd" one at a time slowly until you see the difference.

            // So, we give prefential treatment to start positions which are earlier
            // whether it is coming from caretBefore or caretAfter.
            var rangeStart = textStart = Math.min(caretBefore.start, caretAfter.start),
                rangeEnd   = caretBefore.end,
                textEnd    = caretAfter.end;
        }

        // Extract text from the given start and end position
        var text = wholeText.substring(textStart, textEnd);

        // If the strategy is to replace a single marker
        if (replace) {

            // If text being replaced is not identical on
            // a finalized marker, then convert to text marker.
            if (marker.val()!==text && marker.finalized) {
                marker.toTextMarker();
            }

            marker.val(text);

            // Emulate markerInsert event
            self.overlay().trigger("markerInsert", marker, [], text, textStart, textEnd);

            self.normalize();

        // If the strategy is to insert chracters onto single/multiple markers
        } else {
            self.insert(text, rangeStart, rangeEnd);
        }

        // console.log("range", rangeStart, rangeEnd);
        // console.log("text" , textStart, textEnd, text);

        // Ensure Opera follows the caretAfter behaviour of other
        // browsers when typing inside the candidate window.
        if (operaCandidateWindow) {
            caretAfter.start = caretAfter.end;
        }

        // Set caretBefore as current caret
        // This is used to track text range when exiting candidate window.
        self.caretBefore = self.caretAfter;
    },

    //--- Marker Events ----//

    "{overlay} markerInsert": function(overlay, event, marker, nodes, str, start, end) {

        var text = marker.text,
            wholeText = text.nodeValue,
            trigger;

        self.previousMarker = null;

        // If a trigger key was entered
        if (trigger = self.getTrigger(str)) {

            // Ensure the character before is a space, e.g.
            // we don't want to listen to @ in an email address.
            // or a # that is not intended to be a hashtag.
            var charBefore = wholeText.charCodeAt(start - 1),
                brBefore = marker.before && marker.before.br;

            if (marker.index===0 || (charBefore===32 || brBefore)) {

                // Extract the remaining string after the trigger key
                // coding #js --> #js
                var remainingText = wholeText.slice(start),
                    content = remainingText.slice(1);

                // If this trigger allows wrapping and
                // there are remaining characters to wrap.
                // *#js and*    --> *#js* and
                // *#js#foobar* --> *#js*#foobar
                if (trigger.wrap && remainingText.length > 1) {

                    // Get stop position, add start offset and trigger key offset.
                    end = self.getStopIndex(content, trigger.stop) + start + 1;

                // If trigger does not allow wrapping
                // *@foobar* --> *@*foobar
                } else {
                    end = start + 1;
                }

                // Spawn a new marker from this string
                // and convert this marker into a block marker
                // *#*          --> [#]
                // *#js* and    --> [#js] and
                // *#js*#foobar --> [#js]#foobar
                // *@*foobar    --> [@]foobar
                var spawn = marker.spawn(start, end).toBlockMarker(),
                    content = spawn.val().slice(1);

                // Update data
                var data = $(spawn.block).data("marker");
                    data.value = content;
                    data.trigger = trigger;

                self.previousMarker = spawn;

                // Trigger triggerCreate event
                self.trigger("triggerCreate", [spawn, trigger, content]);
            }
        }

        // If we're inside an existing block marker,
        // determine if we need to mutate the block.
        if (marker.block && !marker.br) {

            // If this marker is finalized, any changes to the
            // text content will convert it to a text marker.
            // [Jensen *#*Tonne] --> Jensen #Tonne
            // [Jensen Tonn`e`]  --> Jensen Tonn
            if (marker.finalized) {

                var length = marker.length;

                if (end < length - 1) marker.toTextMarker();

            } else {

                // Identify the trigger being used
                var key = wholeText.slice(0, 1),
                    trigger = self.getTrigger(key);

                // If we could not identify the trigger, skip.
                if (!trigger) return;

                // Check for occurence of stop character
                var content = wholeText.slice(1),
                    start = self.getStopIndex(content, trigger.stop) + 1,
                    end = wholeText.length,
                    spawn = false;

                // If the end position is shorter than content length
                if (start < end) {

                    // Spawn out a new marker containing
                    // the remaining text after the block marker.
                    // [#foo* *bar] --> [#foo] bar
                    spawn = marker.spawn(start, end);
                }

                // Trigger triggerChange event
                content = marker.val().slice(1);

                // Update data
                var data = $(marker.block).data("marker");
                    data.value = content;
                    data.trigger = trigger;

                self.previousMarker = marker;

                self.trigger("triggerChange", [marker, spawn, trigger, content]);
            }
        }
    },

    "{overlay} markerExit": function(overlay, event, marker, nodes, spawn, str, start, end) {

        var trigger = marker.trigger;

        if (!trigger) return;

        var allowSpace = trigger.allowSpace || marker.allowSpace,
            content = marker.val();

        if (!allowSpace && marker.val()===trigger.key) {
            marker.toTextMarker();
        }

        self.trigger("triggerExit", [marker, spawn, trigger, content]);
    }

    // Events available for use
    // "{overlay} markerRemove": function(overlay, event, marker) {},
    // "{overlay} markerConvert": function(overlay, event, marker, type) {},
    // "{overlay} markerExit": function(overlay, event, marker, nodes, str, start, end) {},
    // "{self} triggerCreate": function(el, event, marker, trigger, content) {},
    // "{self} triggerDestroy": function(el, event, marker) {},
    // "{self} triggerChange": function(el, event, marker, spawn, trigger) {},

    // TODO: Better support for cut & paste
    // "{textarea} beforecut": function() { console.log("BEFORECUT", arguments); },
    // "{textarea} beforepaste": function() { console.log("BEFOREPASTE", arguments); },
    // "{textarea} cut": function(el, event) { console.log("CUT", arguments); },
    // "{textarea} paste": function() { console.log("PASTE", arguments); }
}});
$.template("mentions/menu", '<div class="mentions-autocomplete" data-mentions-autocomplete><b><b></b></b><div class="mentions-autocomplete-inner" data-mentions-autocomplete-viewport><div class="mentions-autocomplete-loading" data-mentions-autocomplete-loading data-mentions-autocomplete-close></div><div class="mentions-autocomplete-empty" data-mentions-autocomplete-empty></div><div class="mentions-autocomplete-search" data-mentions-autocomplete-search></div><ul class="mentions-menu" data-mentions-menu></ul></div></div>');
$.template("mentions/menuItem", '<li class="mentions-menuItem" data-mentions-menuItem>[%== html %]</li>');
$.template("mentions/loadingHint", '<i class="mentions-autocomplete-loading-indicator"></i>');
$.template("mentions/searchHint", '<span class="mentions-autocomplete-search-hint">Type a keyword to begin.</span>');
$.template("mentions/emptyHint", '<span class="mentions-autocomplete-empty-text">No items found.</span>');
/*
<div class="mentions-autocomplete" data-mentions-autocomplete>
	<b><b></b></b>
	<div class="mentions-autocomplete-inner" data-mentions-autocomplete-viewport>
		<div class="mentions-autocomplete-loading" data-mentions-autocomplete-loading></div>
		<div class="mentions-autocomplete-empty" data-mentions-autocomplete-empty></div>
		<div class="mentions-autocomplete-search" data-mentions-autocomplete-search></div>
		<ul class="mentions-menu" data-mentions-menu></ul>
	</div>
</div>
*/

$.Controller("Mentions.Autocomplete",
{
    defaultOptions: {

		view: {
			menu: "mentions/menu",
			menuItem: "mentions/menuItem",
			searchHint: "mentions/searchHint",
			loadingHint: "mentions/loadingHint",
			emptyHint: "mentions/emptyHint"
		},

		id: "",
		component: "",
		modifier: "",
		shadow: false,
		sticky: false,
		animation: false,

		// This is the default query options
		// applied to all triggers unless
		// trigger override them.
		query: {
			data: null,
			cache: true,
			minLength: 1,
			limit: 10,
			highlight: true,
			caseSensitive: false,
			exclusive: false,
			searchHint: false,
			loadingHint: false,
			emptyHint: false
		},

		position: {
			my: 'left top',
			at: 'left bottom',
			collision: 'none'
		},

        size: {
            width: "auto",
            height: "auto"
        },

		"{menu}": "[data-mentions-menu]",
		"{menuItem}": "[data-mentions-menuItem]",
		"{viewport}": "[data-mentions-autocomplete-viewport]",
		"{loadingHint}": "[data-mentions-autocomplete-loading]",
		"{emptyHint}": "[data-mentions-autocomplete-empty]",
		"{searchHint}": "[data-mentions-autocomplete-search]",
		"{closeButton}": "[data-mentions-autocomplete-close]"
    }
},
function(self, opts, base){ return {

    init: function() {

        // This doesn't need to be immediately initialized.
        // Shaves off about 20ms.
        setTimeout(function(){

		// Destroy controller
		if (!self.element.data(self.Class.fullName)) {

			self.destroy();

			// And reimplement on the context menu we created ourselves
			var menu =
			self.view.menu()
				.attr("id", opts.id)
				.addClass(opts.component)
				.addClass(opts.modifier)
				.addClass(opts.shadow ? 'has-shadow' : '')
				.addClass(opts.animation ? 'has-animation' : '')
				.addClass(opts.sticky ? 'is-sticky' : '')
				.appendTo("body")
				.data(self.Class.fullName, true)
				.addController(self.Class, opts);

			return;
		}

		var mentions = self.mentions;

		self.uid = $.uid();

		mentions.autocomplete = self;
		mentions.pluginInstances["autocomplete"] = self;

		// Set the position to be relative to the mentions
		if (!opts.position.of) {
			opts.position.of = self.mentions.element;
		}

		// Prepare this in advance to speed things up
		self.defaultSearchHint  = self.view.searchHint().toHTML();
		self.defaultEmptyHint   = self.view.emptyHint().toHTML();
		self.defaultLoadingHint = self.view.loadingHint().toHTML();

		// Only reattach element when autocomplete is needed.
		self.element.detach();

		}, 50);
    },

	setLayout: function() {

		if (!self.hidden) {

            var options = self.options,
                size = options.size,
                width = self.mentions.element.outerWidth(),
                height = "auto";

            if ($.isFunction(size.width)) {
                width = size.width(width);
            }

            if ($.isFunction(size.height)) {
                height = size.height(height);
            }

			self.element
				.css({
					opacity: 1,
					width: width
				})
				.position(self.options.position);

			setTimeout(function(){
				self.viewport()
					.addClass("active");
			}, 1);
		}
	},

	"{window} resize": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} scroll": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} dialogTransitionStart": function() {
		self.hidden = true;
		self.element.css("opacity", 0);
	},

	"{window} dialogTransitionEnd": function() {
		self.hidden = false;
		self.setLayout();
	},

	currentMarker: null,

	"{mentions} triggerCreate": function(el, event, marker, trigger, content) {

		self.populate(marker, trigger, content);

		self.currentMarker = marker;
	},

	"{mentions} triggerChange": function(el, event, marker, spawn, trigger, content) {

		self.populate(marker, trigger, content);

		self.currentMarker = marker;
	},

	"{mentions} triggerExit": function(el, event, marker, spawn, trigger, content) {

		// Abort any running query
		var query = self.activeQuery;
		if (query) {
			query.aborted = true;
		}

		self.hide();
	},

	"{mentions.block} triggerDestroy": function(el, event, marker) {

		self.hide();
	},

	"{mentions} triggerClear": function() {

		self.hide();
	},

	hidden: true,

	show: function(duration) {

		clearTimeout(self.sleep);

		self.element
			.appendTo("body")
			.show();

		self.hidden = false;

		self.viewport().removeClass("active");

		self.setLayout();

		// Hide autocomplete on click.
		var doc = $(document),
			hideOnClick = "click.mentions." + self.uid;

		doc
			.off(hideOnClick)
			.on(hideOnClick, function(event){

				// Collect list of bubbled elements
				var targets = $(event.target).parents().andSelf();

				// Don't hide autocomplete if user is clicking on itself
				if (targets.filter(base).length > 0) return;

				// Unbind hiding
				doc.off(hideOnClick);

				self.hide();
			});

		if (duration) {

			self.sleep = setTimeout(function(){

				self.hide();

			}, duration);
		}
	},

	hide: function() {

		self.element.hide();

		var menuItem = self.menuItem(),
			activeMenuItem = menuItem.filter(".active");

		if (activeMenuItem.length > 0) {
			self.lastItem = {
				// keyword: $.trim(self.textboxlist.textField().val()),
				keyword: "", // TODO: Port this
				item   : activeMenuItem.data("item")
			};
		}

		self.viewport().removeClass("active");

		menuItem.removeClass("active");

		self.render.reset();

		self.hidden = true;

		// Clear any previous sleep timer first
		clearTimeout(self.sleep);

		// If no activity within 3000 seconds, detach myself.
		self.sleep = setTimeout(function(){
			self.element.detach();
		}, 3000);
	},

	query: function(options) {

		if (!options) return;

		// If options passed in is not an object
		var query = $.extend(
				{},
				self.options.query,
				($.isPlainObject(options) ? options : {data: options})
			),
			data = query.data;

		if (!data) return;

		// Query URL
		if ($.isUrl(data)) {
			var url = data;
			query.lookup = function() {
				return $.ajax(url + query.keyword);
			}
		}

		// Query function
		if ($.isFunction(data)) {
			var func = data;
			query.lookup = function() {
				return func.call(self, query.keyword);
			}
		}

		// Query dataset
		if ($.isArray(data)) {

			var dataset = data;
			query.lookup = function() {

				var task = $.Deferred(),
					keyword = query.keyword.toLowerCase();

				// Fork this process
				// so it won't choke on large dataset.
				setTimeout(function(){
					var result = $.grep(dataset, function(item){
						return item.title.toLowerCase().indexOf(keyword) > -1;
					});
					task.resolve(result);
				}, 0);

				return task;
			}
		}

		return query;
	},

	tasks: {},

	delayTask: null,

	activeQuery: null,

	populate: function(marker, trigger, keyword) {

		// Abort any running query
		var query = self.activeQuery;
		if (query) {
			query.aborted = true;
		}

		// Create query object
		var query = self.query(trigger.query);

		if (!query) return;

		// Set current query as active query
		self.activeQuery = query;

		// Store data in query
		query.keyword = keyword;
		query.trigger = trigger;
		query.marker  = marker;

		// Trigger queryPrepare event
		// for event handlers to modify the query object.
		self.trigger("queryPrepare", [query]);

		// If no keyword given or keyword doesn't meet minimum query length, stop.
		var keyword = query.keyword;

		if (keyword==="" || (keyword.length < query.minLength)) {

			var searchHint = query.searchHint;

			if (searchHint) {

				self.searchHint()
					.html(
						// If searchHint is a html string
						$.isString(searchHint) ?
							// use query-specific searchHint
							searchHint :
							// else use default searchHint
							self.defaultSearchHint
					);

				self.element.addClass("search");

				self.show();
			} else {
				self.hide();
			}
			return;
		}

		// Create a query id for this task based on the keyword
		// and retrieve existing query task for this keyword.
		var id    = query.id = trigger.key + "|" + (query.caseSensitive) ? keyword : keyword.toLowerCase(),
			tasks = self.tasks,
			task  = query.task = tasks[id],

			// Determine if this is a new or existing query task
			// If query caching is disabled, it will always be a new task.
			newTask = !$.isDeferred(task) || !query.cache,

			// This function runs the query task
			// We wrap it in a function because we may
			// want to debounce running of this task.
			runTask = function(){

				// Trigger keywordBeforeQuery event
				// If the event was prevented, don't query the keyword.
				var event = self.trigger("queryBeforeStart", [query]);
				if (event.isDefaultPrevented()) return;

				// Query the keyword if:
				// - The query hasn't been made.
				// - The query has been rejected.
				if (newTask || (!newTask && task.state()=="rejected")) {
					task = tasks[id] = query.task = query.lookup();
				}

				// When query lookup is done, render items;
				task.done(
					self.render(function(items){
						return [items, query];
					})
				);

				// Trigger query event
				self.trigger("queryStart", [query]);
			};

		// If this is a new query task
		// Don't run until we are sure that user has finished typing
		if (newTask) {

			clearTimeout(self.delayTask);
			self.delayTask = setTimeout(runTask, 250);

		// Else run it immediately
		} else {
			runTask();
		}
	},

	"{self} queryPrepare": function(el, event, query) {

		// Remove both loading & empty class
		el.removeClass("loading empty search");

		if (query.loadingHint) {
			self.hide();
		}
	},

	"{self} queryBeforeStart": function(el, event, query) {

		var loadingHint = query.loadingHint;

		// Show loading hint
		if (loadingHint) {

			self.loadingHint()
				.html(
					// If searchHint is a html string
					$.isString(loadingHint) ?
						// use query-specific loadingHint
						loadingHint :
						// else use default loadingHint
						self.defaultLoadingHint
				);

			el.addClass("loading");
			self.show();
		}
	},

	"{self} queryStart": function(el, event, query) {

		query.task
			.fail(function(){
				self.hide();
			})
			.always(function(){
				el.removeClass("loading");
			});
	},

	render: $.Enqueue(function(items, query){

		// If query has been aborted, hide menu and stop.
		if (query.aborted) {
			self.hide();
			return;
		}

		// If items passed in isn't an array,
		// fake an empty array.
		if (!$.isArray(items)) { items = [] };

		// Get mentions
		var mentions = self.mentions,
			autocomplete = self,
			element = self.element,
			menu = self.menu(),
			keyword = query.keyword;

		// If there are no items, hide menu.
		if (items.length < 1) {

			var emptyHint = query.emptyHint;

			// If we are supposed to show an empty hint
			if (emptyHint) {

				self.emptyHint()
					.html(
						// If searchHint is a html string
						$.isString(emptyHint) ?
							// use query-specific emptyHint
							emptyHint :
							// else use default emptyHint
							self.defaultEmptyHint
					);

				// Clear out menu
				menu.empty();

				// Add empty class
				element.addClass("empty");

				// Show menu for only 2 seconds
				self.show(2000);

			// Just hide straight away
			} else {

				self.hide();
			}

			// Trigger menuRender event
			mentions.trigger("menuRender", [menu, query, autocomplete, mentions]);

			return;
		}

		// Remove empty class
		element.removeClass("empty");

		// Generate menu items
		if (!query.cache || menu.data("keyword")!==keyword) {

			// Clear out menu items
			menu.empty();

			$.each(items, function(i, item){

				// Trigger menuCreateItem
				mentions.trigger("menuCreateItem", [item, query, autocomplete, mentions]);

				// If the item is not an object,
				// or item should be discarded, stop.
				if (!$.isPlainObject(item) || item.discard) return;

				var html = item.menuHtml || item.title;

				self.view.menuItem({html: html})
					.data("item", item)
					.appendTo(menu);
			});

			menu.data("keyword", keyword);
		}

		// Get menu Items
		var menuItems = self.menuItem();

		// Trigger menuCreate event
		mentions.trigger("menuCreate", [menu, menuItems, query, autocomplete, mentions]);

		// If menu is empty, toggle empty classname
		if (menuItems.filter(":not(.hidden)").length < 1) {

			element.addClass("empty");

			// If we shouldn't show an empty hint
			if (!query.emptyHint) {

				// Hide menu straightaway
				return self.hide();
			}
		}

		// If we only allow adding item from suggestions
		if (query.exclusive) {

			// Automatically select the first item
			self.menuItem(":not(.hidden):first").addClass("active");
		}

		// Trigger renderMenu event
		mentions.trigger("renderMenu", [menu, query, autocomplete, mentions]);

		self.show();
	}),

	"{mentions.textarea} keydown": function(textarea, event) {

		// Prevent autocomplete from falling asleep.
		clearTimeout(self.sleep);

		// Get active menu item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (activeMenuItem.length < 1) {
			activeMenuItem = false;
		}

		switch (event.keyCode) {

			// If up key is pressed
			case KEYCODE.UP:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the last one.
					self.menuItem(":not(.hidden):last").addClass("active");

				// Else find the menu item before it,
				} else {

					// and activate it.
					activeMenuItem.prev(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// Prevent up/down keys from changing textfield cursor position.
				if (!self.hidden) {
					event.preventDefault();
				}
				break;

			// If down key is pressed
			case KEYCODE.DOWN:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the first one.
					self.menuItem(":not(.hidden):first").addClass("active");

				// Else find the menu item after it,
				} else {

					// and activate it.
					activeMenuItem.next(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// Prevent up/down keys from changing textfield cursor position.
				if (!self.hidden) {
					event.preventDefault();
				}
				break;

			// If escape is pressed,
			case KEYCODE.ESCAPE:

				// hide menu.
				self.hide();
				break;

			// If enter is pressed, use item
			case KEYCODE.ENTER:

				if (!self.hidden && activeMenuItem) {
					var item = activeMenuItem.data("item");
					self.use(item);
					event.preventDefault();
				}
				break;
		}

		// Get newly activated item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (!self.hidden) {
			// Scroll menu viewport if it is out of visible area.
			self.viewport().scrollIntoView(activeMenuItem);
		}
	},

	"{menuItem} mouseup": function(menuItem) {

		// Hide context menu
		self.hide();

		// Add item
		var item = menuItem.data("item");

		self.use(item);

		// Refocus textarea
		setTimeout(function(){

			// Due to event delegation, this needs to be slightly delayed.
			self.mentions.textarea().focus();
		}, 150);
	},

	use: function(item) {

		// Get active query
		var query = self.activeQuery;

		// If there are no active query, stop.
		if (!query) return;

		var marker = query.marker,
			title = item.title;

		// Replace marker text
		marker.text.nodeValue = title;

		delete item["menuHtml"];

		var value = item;

		if (query.use) {
			value = query.use(item);
		}

		// Finalize marker
		marker.finalize(value);

		// Replace textarea text
		self.mentions.textareaInsert(title, marker.start, marker.end);

		// Set caret position
		self.mentions.textarea().caret(marker.start + title.length);

		// Normalize is required so self.lengthBefore is correct.
		// Marker may run off when a user creates a block marker from
		// autocomplete, changes the cursor before/at the beginning of the
		// block marker, and presses backspace.
		self.mentions.normalize();

		// Quick hack to prevent repopulation
		self.hidden = true;

		self.hide();
	},

	"{menuItem} mouseover": function(menuItem) {

		self.menuItem().removeClass("active");

		menuItem.addClass("active");
	},

	"{menuItem} mouseout": function(menuItem) {

		self.menuItem().removeClass("active");
	},

	"{closeButton} click": function() {

		self.hide();
	},

	"{mentions} destroyed": function() {

		self.element.remove();
	}
}});
$.template("mentions/inspector", '<div class="mentions-inspector" data-mentions-inspector><fieldset><b>Selection</b><hr/><label>Start</label><input type="text" data-mentions-selection-start/><hr/><label>End</label><input type="text" data-mentions-selection-end/><hr/><label>Length</label><input type="text" data-mentions-selection-length/><hr/></fieldset><fieldset><b>Trigger</b><hr/><label>Key</label><input type="text" data-mentions-trigger-key/><hr/><label>Type</label><input type="text" data-mentions-trigger-type/><hr/><label>Buffer</label><input type="text" data-mentions-trigger-buffer/><hr/></fieldset><hr/> <fieldset><b>Marker</b><hr/><label>Index</label><input type="text" data-mentions-marker-index/><hr/><label>Start</label><input type="text" data-mentions-marker-start/><hr/><label>End</label><input type="text" data-mentions-marker-end/><hr/><label>Length</label><input type="text" data-mentions-marker-length/><hr/><label>Text</label><input type="text" data-mentions-marker-text/><hr/></fieldset><fieldset><b>Block</b><hr/><label>Html</label><input type="text" data-mentions-block-html/><hr/><label>Text</label><input type="text" data-mentions-block-text/><hr/><label>Type</label><input type="text" data-mentions-block-type/><hr/><label>Value</label><input type="text" data-mentions-block-value/><hr/></fieldset></div>');

/*
<div class="mentions-inspector" data-mentions-inspector>
    <fieldset>
        <b>Selection</b>
        <hr/>
        <label>Start</label>
        <input type="text" data-mentions-selection-start/>
        <hr/>
        <label>End</label>
        <input type="text" data-mentions-selection-end/>
        <hr/>
        <label>Length</label>
        <input type="text" data-mentions-selection-length/>
        <hr/>
    </fieldset>
    <fieldset>
        <b>Trigger</b>
        <hr/>
        <label>Key</label>
        <input type="text" data-mentions-trigger-key/>
        <hr/>
        <label>Type</label>
        <input type="text" data-mentions-trigger-type/>
        <hr/>
        <label>Buffer</label>
        <input type="text" data-mentions-trigger-buffer/>
        <hr/>
    </fieldset>
    <hr/>
    <fieldset>
        <b>Marker</b>
        <hr/>
        <label>Index</label>
        <input type="text" data-mentions-marker-index/>
        <hr/>
        <label>Start</label>
        <input type="text" data-mentions-marker-start/>
        <hr/>
        <label>End</label>
        <input type="text" data-mentions-marker-end/>
        <hr/>
        <label>Length</label>
        <input type="text" data-mentions-marker-length/>
        <hr/>
        <label>Text</label>
        <input type="text" data-mentions-marker-text/>
        <hr/>
    </fieldset>
    <fieldset>
        <b>Block</b>
        <hr/>
        <label>Html</label>
        <input type="text" data-mentions-block-html/>
        <hr/>
        <label>Text</label>
        <input type="text" data-mentions-block-text/>
        <hr/>
        <label>Type</label>
        <input type="text" data-mentions-block-type/>
        <hr/>
        <label>Value</label>
        <input type="text" data-mentions-block-value/>
        <hr/>
    </fieldset>
</div>
*/

$.Controller("Mentions.Inspector",
{
    defaultOptions: {

        view: {
            item: "mentions/item",
            inspector: "mentions/inspector"
        },

        "{inspector}": "[data-mentions-inspector]",

        "{selectionStart}" : "[data-mentions-selection-start]",
        "{selectionEnd}"   : "[data-mentions-selection-end]",
        "{selectionLength}": "[data-mentions-selection-length]",

        "{markerIndex}" : "[data-mentions-marker-index]",
        "{markerStart}" : "[data-mentions-marker-start]",
        "{markerEnd}"   : "[data-mentions-marker-end]",
        "{markerLength}": "[data-mentions-marker-length]",
        "{markerText}"  : "[data-mentions-marker-text]",

        "{blockText}" : "[data-mentions-block-text]",
        "{blockHtml}" : "[data-mentions-block-html]",
        "{blockType}" : "[data-mentions-block-type]",
        "{blockValue}": "[data-mentions-block-value]",

        "{triggerKey}" : "[data-mentions-trigger-key]",
        "{triggerType}" : "[data-mentions-trigger-type]",
        "{triggerBuffer}" : "[data-mentions-trigger-buffer]"
    }
},
function(self){ return {

    init: function() {
    },

    showInspector: function() {

        // If inspector hasn't been created yet
        if (self.inspector().length < 1) {

            // Create inspector and append to textfield
            self.view.inspector()
                .appendTo(self.element);
        }

        self.inspector().show();

        self.mentions.overlay().css("color", "green");
    },

    hideInspector: function() {

        self.inspector().hide();

        self.mentions.overlay().css("color", "transparent");
    },

    "{mentions.textarea} keyup": function() {

        self.inspect();
    },

    "{inspector} dblclick": function() {

        self.textarea().toggle();
    },

    inspect: $.debounce(function() {

        // Selection
        var caret = self.mentions.textarea().caret();

        self.selectionStart().val(caret.start);
        self.selectionEnd().val(caret.end);
        self.selectionLength().val(caret.end - caret.start);

        // Trigger
        var triggerKey = self.triggered;

        if (triggerKey) {
            var trigger = self.getTrigger(triggerKey);
            self.triggerKey().val(triggerKey);
            self.triggerType().val(trigger.type);
            self.triggerBuffer().val(self.buffer);
        } else {
            self.triggerKey().val('');
            self.triggerType().val('');
            self.triggerBuffer().val('');
        }

        // Marker
        var marker = self.mentions.getMarkerAt(caret.start);

        if (marker) {
            self.markerIndex().val(marker.index).data('marker', marker);
            self.markerStart().val(marker.start);
            self.markerEnd().val(marker.end);
            self.markerLength().val(marker.length);
            self.markerText().val(marker.text.nodeValue);
        } else {
            self.markerIndex().val('').data('marker', null);
            self.markerStart().val('');
            self.markerEnd().val('');
            self.markerLength().val('');
            self.markerText().val('');
        }

        // Block
        var block = (marker || {}).block;

        if (block) {
            self.blockText().val(marker.text.nodeValue);
            self.blockHtml().val($(block).clone().toHTML());
            // TODO: Retrieve block type & value
        } else {
            self.blockText().val('');
            self.blockHtml().val('');
        }

    }, 25),

    "{markerIndex} click": function(el) {
        console.dir(el.data("marker"));
    }

}});

};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("mentions", moduleFactory);

}());

(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
$.require() 
 .script("ui/position","easing") 
 .done(function() { 
var exports = function() { 

/**
 * jquery.dialog.
 * jQuery dialog with extensible transitions,
 * iframe & ajax content support.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

 $.template('dialog/default', '<div class="foundryDialog global"><div class="dialog-wrap"><div class="in"><div class="dialog-loader"><div class="loader-img"></div></div><div class="dialog-head"><span class="dialog-title"></span><a class="dialog-closeButton">Close</a></div><div class="dialog-body dialog-content"></div><div class="dialog-footer"><div class="dialog-loading"></div><div class="dialog-buttons"></div></div></div></div></div>');

$.Controller(
    'Dialog',
    {
        pluginName: "dialog",

        defaultOptions: {

            title: '',
            content: undefined,
            buttons: {},

            customClass: "",

            width: 'auto',
            height: 'auto',

            css: {
                position: 'absolute',
                width: 'auto',
                height: 'auto',
                zIndex: 10001
            },

            position: {
                my: 'center center',
                at: 'center center',
                of: window
            },

            offset: 100,

            // TODO: Overlay to be part of EJS
            showOverlay: true,
            overlay: {
                css: {
                    background: '#000',
                    opacity: '0.4',
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    zIndex: 10000,
                    width : '100%',
                    height: '100%',
                    display: 'none'
                }
            },

            body: {
                css: {
                    minWidth: 0,
                    minHeight: 0,

                    // If the dialog content immediate element contains margin,
                    // the margin will bleed outside of the parent container
                    // if overflow: 'auto' is not assigned.
                    overflow: 'auto'
                }
            },

            loader: {
                width: 300,
                height: 100,
            },

            loading: "",

            iframe: {
                css: {
                    width: '100%',
                    height: '100%',
                    border: 'none'
                }
            },

            transition: {
                show: 'zoom',
                hide: 'zoom'
            },

            escapeKey: true,

            beforeShow: function(){},
            afterShow : function(){},
            beforeHide: function(){},
            afterHide : function(){},

            dialogHead   : '.dialog-head',
            dialogBody   : '.dialog-body',
            dialogFooter : '.dialog-footer',
            dialogTitle  : '.dialog-title',
            dialogContent: '.dialog-content',
            dialogButtons: '.dialog-buttons',
            dialogLoader : '.dialog-loader',
            dialogLoading: '.dialog-loading',
            "{closeButton}"  : '.dialog-closeButton'
        }
    },
    function(self){ return {
        ready: false,

        contentReady: false,

        init: function()
        {
            self.setInitOptions(self.options);

            self.initElement = self.element.clone();

            self.element.finalizeContent = function(){ return self.finalizeContent.apply(self, arguments) };

            // Experimental optimization
            // Make a reference to all the static elements on init.
            $.each([
                'dialogHead',
                'dialogBody',
                'dialogFooter',
                'dialogTitle',
                'dialogContent',
                'dialogButtons',
                'dialogLoader',
                'dialogLoading'
            ], function(i, name)
            {
                self[name] = self.find(self.options[name]);
            });

            if (self.options.content===undefined) {
                return;
            }

            self.display();
        },

        "{self} destroyed": function() {
            $(document).off("keydown.foundry.dialog");
        },

        setInitOptions: function(options)
        {
            self.initOptions = $.extend(true, {}, options);

            // Remove callbacks
            $.each(['beforeShow', 'afterShow', 'beforeHide', 'afterHide'], function(i, name){
                self.initOptions[name] = function(){};
            });

            $.each(['title', 'content', 'buttons', 'loading', 'selectors', 'bindings'], function(i, name){
                self.initOptions[name] = null;
            });
        },

        // Update is called during subsequent $.dialog() calls.
        // A default behaviour of any controller class.
        update: function(options)
        {
            if (options)
            {
                // Prevent binder from updating dialog
                if (options.hasOwnProperty("{binder}")) return;

                var options = $.extend(true, {}, self.initOptions, options);

                // Remember certain options like width, height throughout
                // the lifetime of the dialog, but discard those that aren't
                // like title, content, buttons, selectors, bindings & transitions.
                self.setInitOptions(options);

                self.display(options);
            }

            return self;
        },

        determineContentType: function(content) {

            if (/<dialog>(.*?)/.test(content)) {
                return 'dialog';
            }

            if ($.isUrl(content)) {
                return 'iframe';
            }

            if ($.isDeferred(content)) {
                return 'deferred';
            }

            return 'html';
        },

        displayQueue: [],

        display: function(options)
        {

            if (self.resizing) {
                return self.displayQueue.push(options);
            }

            if ($.isPlainObject(options)) {
                self.options = $.extend(true, {}, self.Class.defaults, options);
            }

            if (!self.ready)
            {
                // TODO: Overlay should be part of dialog template
                if (self.options.showOverlay)
                    self.createOverlay();
            }

            var options = self.options,
                content = options.content;

            // Determine if content is ready
            self.contentReady = content===null;

            // Determine content type
            self.contentType = self.determineContentType(content);

            // Normalize transition
            var transition = options.transition;
            if ($.isString(transition)) {
                options.transition = { show: transition, hide: transition };
            }

            switch (self.contentType)
            {
                case 'html':
                    self.hideLoader();
                    self.show();
                    break;

                case 'iframe':
                    var iframe = $(document.createElement('iframe')),
                        iframeUrl = content,
                        iframeCss = options.iframe.css,
                        iframeButtons = options.buttons,
                        dialogContent = self.dialogContent,
                        iframeOptions = $.extend(true, {}, options, {
                            content: iframe,
                            buttons: iframeButtons
                        });

                    self.showLoader(function()
                    {
                        onIframeLoaded = (function()
                        {
                            return function(event)
                            {
                                // Expose dialog object to iframe
                                // Inside a try catch because does not work on cross-site domain,
                                // and url checking takes a lot more code to write.
                                try { iframe[0].contentWindow.parentDialog = self; } catch(err) {};

                                self.update(iframeOptions);
                            };
                        })();

                        // Prevent scrollbar from showing in loading dialog
                        self.dialogBody
                            .addClass('type-iframe');

                        iframe
                            .appendTo(dialogContent)
                            .css(iframeCss)
                            .css({position: 'absolute', visibility: 'hidden'})
                            .one('load', onIframeLoaded)
                            .attr('src', iframeUrl);
                    });

                    break;

                case 'deferred':
                    var ajax = content;

                    self.showLoader(function() {

                        ajax.done(function(html) {

                            if (!html) return;

                            var newOptions = ($.isString(html)) ? {content: html} : html;

                            // Do not proceed if there are no new content to update.
                            if (!newOptions.content) return;

                            self.update($.extend(true, {}, options, newOptions));
                        })
                        .fail(function(message, type){

                            var title =
                                    $.isString(type) ?
                                        $.String.capitalize(type) :
                                        "Error",

                                content =
                                    $.isString(message) ?
                                        message :
                                        "There was an error loading content.";

                            self.update({
                                title: title,
                                content: content
                            });
                        });
                    });
                    break;


                // Test with:
                // '<dialog><after_show type="javascript">function(){console.log("after_show_executed");}</after_show><selectors type="json">{"{OKButton}": ".okButton"}</selectors><width>400</width><height>200</height><show_overlay>0</show_overlay><title>foobar_title</title><content>foobar_content</content><buttons>foobar_buttons</buttons></dialog>'

                case 'dialog':
                    var xmlOptions = $.buildHTML(content),
                        newOptions = {};

                    $.each(xmlOptions.children(), function(i, node){

                        var node = $(node),
                            key  = $.String.camelize(this.nodeName.toLowerCase()),
                            val  = node.html(),
                            type = node.attr("type");

                        switch (type) {
                            case "json":
                                try {
                                    val = $.parseJSON(val);
                                } catch(e) {};
                                break;

                            case "javascript":
                                try {
                                    val = eval('(function($){ return ' + $.trim(val) + ' })(' + $.globalNamespace + ')');
                                } catch(e) {};
                                break;

                            case "text":
                                val = node.text();
                                break;
                        }

                        // Automatically convert numerical values
                        if ($.isNumeric(val)) val = parseFloat(val);

                        // console.log(type, key, val);

                        newOptions[key] = val;
                    });

                    self.update($.extend(true, {}, options, newOptions));
                    break;
            }
        },

        loading: function(flag) {

            var el = self.element;

            if (flag===undefined) {
                return el.hasClass("loading");
            }

            if (flag===false) {
                el.removeClass("loading");
                return;
            }

            if (flag===true) {
                flag = self.options.loading || "";
            }

            if ($.isString(flag)) {
                el.addClass("loading");
                self.dialogLoading.html(flag);
            }
        },

        showLoader: function(callback)
        {
            var originalWidth = self.options.width,
                originalHeight = self.options.height;

            var showLoaderOverlay = function()
            {
                self.dialogLoader
                    .show()
                    .css(
                    {
                        width: self.dialogBody.outerWidth(true),
                        height: self.dialogBody.outerHeight(true)
                    })
                    .position({
                        my: 'top left',
                        at: 'top left',
                        of: self.options.dialogContent
                    });

                // Reset width & height
                self.options.width = originalWidth;
                self.options.height = originalHeight;

                return callback && callback();
            };

            return (self.ready) ? showLoaderOverlay() : self.update(
            $.extend({
                title: self.options.title,
                content: '',
                width: self.initOptions.body.css.minWidth,
                height: self.initOptions.body.css.minHeight,
                afterShow: showLoaderOverlay
            }, self.options.loader));
        },

        hideLoader: function()
        {
            self.element.removeClass("loading");
            self.dialogLoader.hide();
        },

        autoSize: function()
        {
            return self.initOptions.css.width=='auto' || self.initOptions.css.height=='auto';
        },

        finalizeContent: function(finale)
        {
            var options = self.options,
                content = options.content;

            self.element
                .css(options.css);

            self.dialogContent
                .css(options.body.css);

            if (self.refreshing) return;

            if (options.title!==null)
                self.dialogTitle
                    .html(options.title);

            if (content!==null)
            {
                var isIframe = !$.isString(content) && $(content).is('iframe');

                self.dialogBody
                    .toggleClass('type-iframe', isIframe);

                if (isIframe)
                {
                    // This is a replacement for jQuery's .siblings().
                    // The difference is that this code will go through
                    // not only html elements but also other types of dom nodes,
                    // e.g. text nodes.
                    var parent = content.parent()[0];

                    var i = 0;
                    while(parent.childNodes.length > 1)
                    {
                        var node = parent.childNodes[i];
                        if (node!==content[0])
                            parent.removeChild(node);
                        i++;
                    }

                    content
                        .css({position: 'relative', visibility: 'visible'});
                } else {

                    // Finalize content might be called multiple times during different
                    // transition states. But only the last one should be inserted
                    // with the embedded scripts.

                    var finalContent;

                    if (finale) {
                        finalContent = content;

                        // Store the stripped version into the options
                        options.content = self.stripScript(finalContent);
                    } else {
                        finalContent = self.stripScript(content);
                    }

                    // This is inserted with scripts
                    self.dialogContent
                        .html(finalContent);
                }
            }

            if (!self.contentReady)
                self.finalizeButtons();

            return self.element;
        },

        stripScript: function(html) {

            if (!$.isString(html)) return html;

            var content = $($.parseHTML(html));

            content.find("script").remove();

            return content;
        },

        finalizeSize: function(fast)
        {
            var refElement = self.refElement,
                options = self.options,
                body = options.body,
                content = options.content,
                css = options.css,
                bodyCss = body.css;

            // Create a new ref element
            if (refElement===undefined) {
                refElement = self.refElement = self.initElement.clone().removeClass('global').insertAfter(self.element);

            // Because it could be detached at this moment
            } else {
                refElement.insertAfter(self.element);
            }

            if (!fast)
            {
                refTitle   = refElement.find(options.dialogTitle);
                refBody    = refElement.find(options.dialogBody);
                refFooter  = refElement.find(options.dialogFooter);
                refButtons = refElement.find(options.dialogButtons);

                refElement
                    .css(self.initOptions.css)
                    .css({display: 'block'});

                refTitle
                    .html(options.title);

                if (!$.isEmptyObject(options.buttons))
                {
                    refFooter.show();
                    refButtons.append('<button>test</button>');
                } else {
                    refFooter.hide();
                }

                // Pass 1: Readjust dialog body's dimension based on dialog's content
                var isIframe = !$.isString(content) && $(content).is('iframe');

                var refContent = (isIframe) ? document.createElement('div') : self.stripScript(content);

                bodyCss.width  = (isIframe && options.width=='auto')  ? content.contents().width() : options.width;
                bodyCss.height = (isIframe && options.height=='auto') ? content.contents().height() : options.height;

                refBody
                    .css(bodyCss)
                    .toggleClass('type-iframe', isIframe)
                    .html(refContent);

                var refBodyWidth = refBody.width(),
                    refBodyHeight = refBody.height();

                if (refBody.css("boxSizing")!=="border-box") {
                    bodyCss.width  = refBodyWidth;
                    bodyCss.height = refBodyHeight;
                }

                if (bodyCss.width < bodyCss.minWidth) {
                    bodyCss.width = bodyCss.minWidth;
                }

                if (bodyCss.height < bodyCss.minHeight) {
                    bodyCss.height = bodyCss.minHeight;
                }

                // Pass 2: Re-adjust dialog's dimension based on window's dimension
                var offset         = options.offset,
                    width          = refElement.width(),
                    height         = refElement.height(),
                    maxWidth       = $(window).width() - offset,
                    maxHeight      = $(window).height() - offset,
                    widthExceeded  = width > maxWidth,
                    heightExceeded = height > maxHeight;

                css.width  = (widthExceeded) ? maxWidth : width;
                css.height = (heightExceeded) ? maxHeight : height;

                // Pass 3: Readjust dialog body's dimension based on readjusted dialog's dimension

                if (bodyCss.width!=="auto") bodyCss.width  -= (width  - css.width);
                if (bodyCss.width <= 0) bodyCss.width = "auto";

                if (bodyCss.height!=="auto") bodyCss.height -= (height - css.height);
                if (bodyCss.height <= 0) bodyCss.height = "auto";

                bodyCss.minWidth = bodyCss.minHeight = 'auto';

                // Pass 4: Decide scrollbar visiblity based on readjusted dialog body's dimension.
                refBody.css(bodyCss);

                bodyCss.overflowX = (!widthExceeded  || isIframe || refBody[0].scrollWidth  <= bodyCss.width)  ? 'auto' : 'scroll';
                bodyCss.overflowY = (!heightExceeded || isIframe || refBody[0].scrollHeight <= bodyCss.height) ? 'auto' : 'scroll';

                // Clean up
                refBody.html('');

            }

            // Pass 5: Readjust position based on final dialog dimension
            refElement
                .css(css)
                //  FF3 can't retrieve css positions when element is on display: none;
                // .initialPosition(options.position, true);
                .css('visibility', 'hidden')
                .position(options.position);

            css.top  = refElement.css('top');
            css.left = refElement.css('left')
        },

        finalizeButtons: function()
        {
            var dialogFooter  = self.dialogFooter,
                dialogButtons = self.dialogButtons;

            dialogButtons.empty();

            var buttons = self.options.buttons;

            // No buttons
            if ($.isEmptyObject(buttons)) {
                dialogFooter.hide();
                return;
            }

            // Buttons as html
            if ($.isString(buttons)) {
                dialogButtons.html(buttons);
            }

            // Programmable buttons
            if ($.isArray(buttons)) {
                $.each(buttons, function(i, button) {
                    var events = $.extend({}, button),
                        classNames  = button.classNames ? button.classNames : '';
                    delete events.name;
                    delete events.classNames;

                    $(document.createElement('button'))
                        .attr('type', 'button')
                        .addClass( classNames )
                        .html(button.name)
                        .bind(events)
                        .appendTo(dialogButtons);
                });
            }

            dialogFooter.show();
        },

        show: function(callback)
        {
            if (self.ready && self.resizing) return;

            var options = self.options;

            if (self.refElement) {
                self.refElement.remove();
            }

            if (!self.contentReady) {
                options.beforeShow.apply(self);
            }

            $(document).off("keydown.foundry.dialog");

            if (options.escapeKey) {
                $(document).on("keydown.foundry.dialog", function(event){
                    if (event.keyCode==27) {
                        self.close();
                    }
                });
            }

            self.resizing = true;

            self.finalizeSize();

            self.element.addClass('resizing');

            $(window).trigger("dialogTransitionStart");

            self.transition[options.transition.show].show
                .apply(self, [function()
                {
                    if (!self.ready)
                    {
                        self.on("resize.dialog scroll.dialog", window, $._.debounce(function(){ self.refresh() }, 150));
                        self.ready = true;
                    }

                    if (!self.contentReady)
                    {
                        if (callback) callback.apply(self);
                        options.afterShow.apply(self);
                    }

                    // Detach shadow dialog
                    self.refElement.detach();

                    self.element.removeClass('resizing');

                    self.contentReady = true;

                    // Let the dialog container wrap to dialog content's final natural size,
                    // so we can avoid all the tedious box model issues.
                    self.element.css({width: 'auto', height: 'auto'});

                    // Remove old binder
                    self.removePlugin("binder");

                    // Create new bindings
                    var selectors = options.selectors,
                        bindings  = options.bindings;

                    if (selectors && bindings) {

                        var binder = $.Controller(
                            $.uid("dialogBinder"),
                            {defaultOptions: selectors},
                            function(self){ return bindings }
                        );

                        self.addPlugin("binder", binder);
                    }

                    if (self.displayQueue.length > 0)
                    {
                        setTimeout(function(){
                            self.resizing = false;
                            self.display(self.displayQueue.shift());
                        }, 500);
                    } else {
                        self.resizing = false;

                        $(window).trigger("dialogTransitionEnd");
                    }

                }]);
        },

        "{self} removePlugin": function(el, event, name, plugin) {

            if (plugin===undefined) return;

            delete $.Controller[plugin.Class.fullName];
        },

        hide: function(callback)
        {
            if (!self.contentReady)
                self.options.beforeHide.apply(self);

            $(window).trigger("dialogTransitionStart");

            self.transition[self.options.transition.hide].hide
                .apply(self, [function()
                {
                    if (callback) callback.apply(self);
                    self.options.afterHide.apply(self);

                    $(window).trigger("dialogTransitionEnd");
                }]);
        },

        refresh: function()
        {
            if (self.closing) return;

            if (self.resizing) return;

            self.finalizeSize(true);

            self.resizing = true;

            self.refreshing = true;

            $(window).trigger("dialogTransitionStart");

            self.transition[self.options.transition.show].show.apply(self, [function()
            {
                $(window).trigger("dialogTransitionEnd");

                self.resizing = false;

                self.refreshing = false;

                // Let the dialog container wrap to dialog content's final natural size,
                // so we can avoid all the tedious box model issues.
                self.element.css({width: 'auto', height: 'auto'});
            }]);
        },

        // TODO: Transition parameters
        transition:
        {
            none: {
                show: function(callback)
                {
                    // TODO: Fix IE7 z-index issue.

                    if (!self.ready)
                        self.overlay.show();

                    self.element
                        .finalizeContent()
                        .show(0, callback);
                },

                hide: function(callback)
                {
                    self.overlay.hide();
                    self.element.hide(0, callback);
                }
            },

            fade: {
                show: function(callback)
                {
                    if (!self.ready)
                        self.overlay.fadeOut(0).fadeIn('normal');

                    if (!self.contentReady)
                    {
                        self.element
                            .fadeOut((!self.contentReady) ? 0 : 'fast', function()
                            {
                                self.element
                                    .finalizeContent()
                                    .fadeIn('normal', 'easeInCubic', callback);
                            });

                    } else {
                        self.element.finalizeContent();
                        return callback && callback();
                    }
                },

                hide: function(callback)
                {
                    self.overlay.fadeOut('normal', 'easeOutCubic');
                    self.element.fadeOut('normal', 'easeOutCubic', callback);
                }
            },

            zoom: {
                show: function(callback)
                {
                    var dialogBody = self.dialogBody,
                        dialogFooter = self.dialogFooter,
                        css = self.options.css;

                    if (!self.ready)
                    {
                        self.overlay.fadeIn('fast');

                        self.element
                            .finalizeContent()
                            .css(
                            {
                                top: parseInt(css.top) + (parseInt(css.height) / 2),
                                left: parseInt(css.left) + (parseInt(css.width) / 2),
                                width: 0,
                                height: 0
                            });
                    }

                    if (!self.contentReady)
                    {
                        dialogBody.css({opacity: 0});
                        dialogFooter.css({opacity: 0});
                    }

                    self.element
                        .animate(
                        {
                            top   : css.top,
                            left  : css.left,
                            width : css.width,
                            height: css.height
                        }, 'normal', 'easeInCubic',
                        function()
                        {
                            self.element.finalizeContent(true);

                            dialogBody.css({opacity: 1});
                            dialogFooter.css({opacity: 1});

                            // TODO: Circular reference. IE8 show() callback gets executed when closing. Double check if its fixed.
                            return callback && callback();
                        });
                },
                hide: function(callback)
                {
                    var css = self.options.css;

                    self.element
                        .animate(
                            {
                                top: parseInt(css.top) + (parseInt(css.height) / 2),
                                left: parseInt(css.left) + (parseInt(css.width) / 2),
                                width: 0,
                                height: 0
                            }, 'normal', 'easeOutCubic',
                            function()
                            {
                                self.overlay.fadeOut('fast');
                                return callback && callback();
                            });
                }
            }
        },

        overlay: $('<div></div>'),

        createOverlay: function()
        {
            self.overlay
                .css(self.options.overlay.css)
                .click(function()
                {
                    self.close();
                })
                .appendTo('body');
        },

        closing: false,

        close: function()
        {
            if (self.closing) return;

            self.closing = true;

            $(document).off("keydown.foundry.dialog");

            self.hide(function()
            {
                self.removePlugin("binder");
                self.element.remove();
                self.refElement && self.refElement.remove();
            });

            return self;
        },

        "{closeButton} click": function()
        {
            self.close();
        },

        content: function()
        {
            var dialogContent = self.dialogContent;
            var iframe = dialogContent.find("> iframe");
            return (iframe.length > 0) ? iframe.contents() : dialogContent;
        },

        messageGroup: function() {

            var dialogBody = self.dialogBody,
                messageGroup = dialogBody.find("> [data-message-group]");

            if (messageGroup.length < 1) {
                messageGroup = $("<div data-message-group></div>").prependTo(dialogBody);
            }

            return messageGroup;
        }
    }}
);
$.dialog = function(options) {

    // When dialog is loaded via iframe
    if (window.parentDialog) {
        return window.parentDialog.update(options);
    }

    var dialog = $('.foundryDialog.global'),
        controller = dialog.controllers("dialog")[0];

    // Return dialog controller if no options given
    if (arguments.length < 1 && controller) {
        return controller;
    }

    // Create dialog if element not exist.
    if (dialog.length < 1) {
        dialog = $($.View('dialog/default')).addClass('global').addClass(options.customClass).appendTo('body');
    }

    // Translate options shorthand
    if (typeof options === "string" || $.isDeferred(options)) {

    	var afterShow = arguments[1];

    	options = {
    		content: options,
    		afterShow: ($.isFunction(afterShow)) ? afterShow : $.noop
    	}
    }

    // If it is an existing dialog
    if (controller) {

        controller.update(options);

    } else {

        controller = dialog.addController('Dialog', options);
    }

    return controller;
};

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("dialog", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/* ============================================================
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Open source under the BSD License.
 *
 * Copyright © 2008 George McGinley Smith
 * All rights reserved.
 * https://raw.github.com/danro/jquery-easing/master/LICENSE
 * ======================================================== */

jQuery.easing['jswing'] = jQuery.easing['swing'];

jQuery.extend( jQuery.easing,
{
	// t: current time, b: begInnIng value, c: change In value, d: duration
	
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158; 
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 * 
 * Open source under the BSD License. 
 * 
 * Copyright © 2001 Robert Penner
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list 
 * of conditions and the following disclaimer in the documentation and/or other materials 
 * provided with the distribution.
 * 
 * Neither the name of the author nor the names of contributors may be used to endorse 
 * or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
 */
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("easing", moduleFactory);

}());
(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*
 * Gritter for jQuery
 * http://www.boedesign.com/
 *
 * Copyright (c) 2012 Jordan Boesch
 * Dual licensed under the MIT and GPL licenses.
 *
 * Date: February 24, 2012
 * Version: 1.7.4
 */

(function($){
 	
	/**
	* Set it up as an object under the jQuery namespace
	*/
	$.gritter = {};
	
	/**
	* Set up global options that the user can over-ride
	*/
	$.gritter.options = {
		position: '',
		class_name: '', // could be set to 'gritter-light' to use white notifications
		fade_in_speed: 'medium', // how fast notifications fade in
		fade_out_speed: 1000, // how fast the notices fade out
		time: 6000 // hang on the screen for...
	}
	
	/**
	* Add a gritter notification to the screen
	* @see Gritter#add();
	*/
	$.gritter.add = function(params){

		try {
			return Gritter.add(params || {});
		} catch(e) {
		
			var err = 'Gritter Error: ' + e;
			(typeof(console) != 'undefined' && console.error) ? 
				console.error(err, params) : 
				alert(err);
				
		}
		
	}
	
	/**
	* Remove a gritter notification from the screen
	* @see Gritter#removeSpecific();
	*/
	$.gritter.remove = function(id, params){
		Gritter.removeSpecific(id, params || {});
	}
	
	/**
	* Remove all notifications
	* @see Gritter#stop();
	*/
	$.gritter.removeAll = function(params){
		Gritter.stop(params || {});
	}
	
	/**
	* Big fat Gritter object
	* @constructor (not really since its object literal)
	*/
	var Gritter = {
		
		// Public - options to over-ride with $.gritter.options in "add"
		position: '',
		fade_in_speed: '',
		fade_out_speed: '',
		time: '',
		
		// Private - no touchy the private parts
		_custom_timer: 0,
		_item_count: 0,
		_is_setup: 0,
		_tpl_close: '<a class="gritter-close" href="#" tabindex="1">Close Notification</a>',
		_tpl_title: '<span class="gritter-title">[[title]]</span>',
		_tpl_item: '<div id="gritter-item-[[number]]" class="gritter-item-wrapper [[item_class]]" style="display:none" role="alert"><div class="gritter-top"></div><div class="gritter-item">[[close]][[image]]<div class="[[class_name]]">[[title]]<p>[[text]]</p></div><div style="clear:both"></div></div><div class="gritter-bottom"></div></div>',
		_tpl_wrap: '<div id="gritter-notice-wrapper"></div>',
		
		/**
		* Add a gritter notification to the screen
		* @param {Object} params The object that contains all the options for drawing the notification
		* @return {Integer} The specific numeric id to that gritter notification
		*/
		add: function(params){
			// Handle straight text
			if(typeof(params) == 'string'){
				params = {text:params};
			}

			// We might have some issues if we don't have a title or text!
			if(params.text === null){
				throw 'You must supply "text" parameter.'; 
			}
			
			// Check the options and set them once
			if(!this._is_setup){
				this._runSetup();
			}
			
			// Basics
			var title = params.title, 
				text = params.text,
				image = params.image || '',
				sticky = params.sticky || false,
				item_class = params.class_name || $.gritter.options.class_name,
				position = $.gritter.options.position,
				time_alive = params.time || '';

			this._verifyWrapper();
			
			this._item_count++;
			var number = this._item_count, 
				tmp = this._tpl_item;
			
			// Assign callbacks
			$(['before_open', 'after_open', 'before_close', 'after_close']).each(function(i, val){
				Gritter['_' + val + '_' + number] = ($.isFunction(params[val])) ? params[val] : function(){}
			});

			// Reset
			this._custom_timer = 0;
			
			// A custom fade time set
			if(time_alive){
				this._custom_timer = time_alive;
			}
			
			var image_str = (image != '') ? '<img src="' + image + '" class="gritter-image" />' : '',
				class_name = (image != '') ? 'gritter-with-image' : 'gritter-without-image';
			
			// String replacements on the template
			if(title){
				title = this._str_replace('[[title]]',title,this._tpl_title);
			}else{
				title = '';
			}
			
			tmp = this._str_replace(
				['[[title]]', '[[text]]', '[[close]]', '[[image]]', '[[number]]', '[[class_name]]', '[[item_class]]'],
				[title, text, this._tpl_close, image_str, this._item_count, class_name, item_class], tmp
			);

			// If it's false, don't show another gritter message
			if(this['_before_open_' + number]() === false){
				return false;
			}

			$('#gritter-notice-wrapper').addClass(position).append(tmp);
			
			var item = $('#gritter-item-' + this._item_count);
			
			item.fadeIn(this.fade_in_speed, function(){
				Gritter['_after_open_' + number]($(this));
			});
			
			if(!sticky){
				this._setFadeTimer(item, number);
			}
			
			// Bind the hover/unhover states
			$(item).bind('mouseenter mouseleave', function(event){
				if(event.type == 'mouseenter'){
					if(!sticky){ 
						Gritter._restoreItemIfFading($(this), number);
					}
				}
				else {
					if(!sticky){
						Gritter._setFadeTimer($(this), number);
					}
				}
				Gritter._hoverState($(this), event.type);
			});
			
			// Clicking (X) makes the perdy thing close
			$(item).find('.gritter-close').click(function(){
				Gritter.removeSpecific(number, {}, null, true);
				return false;
			});
			
			return number;
		
		},
		
		/**
		* If we don't have any more gritter notifications, get rid of the wrapper using this check
		* @private
		* @param {Integer} unique_id The ID of the element that was just deleted, use it for a callback
		* @param {Object} e The jQuery element that we're going to perform the remove() action on
		* @param {Boolean} manual_close Did we close the gritter dialog with the (X) button
		*/
		_countRemoveWrapper: function(unique_id, e, manual_close){
			
			// Remove it then run the callback function
			e.remove();
			this['_after_close_' + unique_id](e, manual_close);
			
			// Check if the wrapper is empty, if it is.. remove the wrapper
			if($('.gritter-item-wrapper').length == 0){
				$('#gritter-notice-wrapper').remove();
			}
		
		},
		
		/**
		* Fade out an element after it's been on the screen for x amount of time
		* @private
		* @param {Object} e The jQuery element to get rid of
		* @param {Integer} unique_id The id of the element to remove
		* @param {Object} params An optional list of params to set fade speeds etc.
		* @param {Boolean} unbind_events Unbind the mouseenter/mouseleave events if they click (X)
		*/
		_fade: function(e, unique_id, params, unbind_events){

			var params = params || {},
				fade = (typeof(params.fade) != 'undefined') ? params.fade : true,
				fade_out_speed = params.speed || this.fade_out_speed,
				manual_close = unbind_events;

			this['_before_close_' + unique_id](e, manual_close);
			
			// If this is true, then we are coming from clicking the (X)
			if(unbind_events){
				e.unbind('mouseenter mouseleave');
			}
			
			// Fade it out or remove it
			if(fade){
			
				e.animate({
					opacity: 0
				}, fade_out_speed, function(){
					e.animate({ height: 0 }, 300, function(){
						Gritter._countRemoveWrapper(unique_id, e, manual_close);
					})
				})
				
			}
			else {
				
				this._countRemoveWrapper(unique_id, e);
				
			}
						
		},
		
		/**
		* Perform actions based on the type of bind (mouseenter, mouseleave) 
		* @private
		* @param {Object} e The jQuery element
		* @param {String} type The type of action we're performing: mouseenter or mouseleave
		*/
		_hoverState: function(e, type){
			
			// Change the border styles and add the (X) close button when you hover
			if(type == 'mouseenter'){
				
				e.addClass('hover');
				
				// Show close button
				e.find('.gritter-close').show();
						
			}
			// Remove the border styles and hide (X) close button when you mouse out
			else {
				
				e.removeClass('hover');
				
				// Hide close button
				e.find('.gritter-close').hide();
				
			}
			
		},
		
		/**
		* Remove a specific notification based on an ID
		* @param {Integer} unique_id The ID used to delete a specific notification
		* @param {Object} params A set of options passed in to determine how to get rid of it
		* @param {Object} e The jQuery element that we're "fading" then removing
		* @param {Boolean} unbind_events If we clicked on the (X) we set this to true to unbind mouseenter/mouseleave
		*/
		removeSpecific: function(unique_id, params, e, unbind_events){
			
			if(!e){
				var e = $('#gritter-item-' + unique_id);
			}

			// We set the fourth param to let the _fade function know to 
			// unbind the "mouseleave" event.  Once you click (X) there's no going back!
			this._fade(e, unique_id, params || {}, unbind_events);
			
		},
		
		/**
		* If the item is fading out and we hover over it, restore it!
		* @private
		* @param {Object} e The HTML element to remove
		* @param {Integer} unique_id The ID of the element
		*/
		_restoreItemIfFading: function(e, unique_id){
			
			clearTimeout(this['_int_id_' + unique_id]);
			e.stop().css({ opacity: '', height: '' });
			
		},
		
		/**
		* Setup the global options - only once
		* @private
		*/
		_runSetup: function(){
		
			for(opt in $.gritter.options){
				this[opt] = $.gritter.options[opt];
			}
			this._is_setup = 1;
			
		},
		
		/**
		* Set the notification to fade out after a certain amount of time
		* @private
		* @param {Object} item The HTML element we're dealing with
		* @param {Integer} unique_id The ID of the element
		*/
		_setFadeTimer: function(e, unique_id){
			
			var timer_str = (this._custom_timer) ? this._custom_timer : this.time;
			this['_int_id_' + unique_id] = setTimeout(function(){ 
				Gritter._fade(e, unique_id);
			}, timer_str);
		
		},
		
		/**
		* Bring everything to a halt
		* @param {Object} params A list of callback functions to pass when all notifications are removed
		*/  
		stop: function(params){
			
			// callbacks (if passed)
			var before_close = ($.isFunction(params.before_close)) ? params.before_close : function(){};
			var after_close = ($.isFunction(params.after_close)) ? params.after_close : function(){};
			
			var wrap = $('#gritter-notice-wrapper');
			before_close(wrap);
			wrap.fadeOut(function(){
				$(this).remove();
				after_close();
			});
		
		},
		
		/**
		* An extremely handy PHP function ported to JS, works well for templating
		* @private
		* @param {String/Array} search A list of things to search for
		* @param {String/Array} replace A list of things to replace the searches with
		* @return {String} sa The output
		*/  
		_str_replace: function(search, replace, subject, count){
		
			var i = 0, j = 0, temp = '', repl = '', sl = 0, fl = 0,
				f = [].concat(search),
				r = [].concat(replace),
				s = subject,
				ra = r instanceof Array, sa = s instanceof Array;
			s = [].concat(s);
			
			if(count){
				this.window[count] = 0;
			}
		
			for(i = 0, sl = s.length; i < sl; i++){
				
				if(s[i] === ''){
					continue;
				}
				
				for (j = 0, fl = f.length; j < fl; j++){
					
					temp = s[i] + '';
					repl = ra ? (r[j] !== undefined ? r[j] : '') : r[0];
					s[i] = (temp).split(f[j]).join(repl);
					
					if(count && s[i] !== temp){
						this.window[count] += (temp.length-s[i].length) / f[j].length;
					}
					
				}
			}
			
			return sa ? s : s[0];
			
		},
		
		/**
		* A check to make sure we have something to wrap our notices with
		* @private
		*/  
		_verifyWrapper: function(){


			if ($("body > [id=fd].gritter").length < 1) {

				// Create container for #fd.gritter
				$(document.createElement("div"))
					.attr("id", "fd")
					.addClass("gritter")
					.css({
						position: "absolute",
						top: 0,
						left: 0,
						overflow: "visible",
						width: 0,
						height: 0,
						zIndex: 10003
					})
					.appendTo("body");
			}
		  
			if($('#gritter-notice-wrapper').length == 0){
				$("[id=fd].gritter").append(this._tpl_wrap);
			}
		}
		
	}
	
})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("gritter", moduleFactory);

}());});
FD40.installer("EasySocial", "definitions", function($){
$.module(["easysocial/admin","easysocial/admin/access/discover","easysocial/progress/progress","easysocial/admin/alerts/discover","easysocial/admin/badges/discover","easysocial/admin/events/approveRecurring","easysocial/admin/events/store","easysocial/admin/events/users","easysocial/admin/grid/grid","easysocial/admin/grid/sort","easysocial/admin/grid/publishing","easysocial/admin/grid/ordering","easysocial/admin/groups/groups","easysocial/admin/groups/users","easysocial/admin/indexer/indexer","easysocial/admin/mailer/mailer","easysocial/admin/maintenance/database","easysocial/admin/maintenance/maintenance","easysocial/admin/migrators/migrator","easysocial/admin/points/discover","easysocial/admin/polls/polls","easysocial/admin/privacy/discover","easysocial/admin/profiles/avatar","easysocial/uploader/uploader","easysocial/uploader/queue","easysocial/admin/profiles/fields","easysocial/field","easysocial/admin/profiles/form","easysocial/utilities/alias","easysocial/admin/profiles/members","easysocial/admin/profiles/profile","easysocial/admin/profiles/profiles","easysocial/admin/regions/form","easysocial/admin/regions/init","easysocial/admin/reports/reporters","easysocial/admin/reports/reports","easysocial/admin/sidebar/sidebar","easysocial/admin/themes/compiler","easysocial/admin/users/form","easysocial/admin/users/privacy","easysocial/admin/users/users","easysocial/albums/album","easysocial/albums/browser","easysocial/albums/editor","easysocial/albums/editor/sortable","easysocial/albums/editor/uploader","easysocial/albums/uploader","easysocial/albums/uploader.item","easysocial/albums/item","easysocial/apps/event/discussions","easysocial/apps/event/guests","easysocial/apps/event/tasks","easysocial/apps/fields/event/description/content","easysocial/apps/fields/event/permalink/content","easysocial/apps/fields/event/permalink/sample_content","easysocial/apps/fields/event/recurring/content","easysocial/apps/fields/event/startend/content","easysocial/apps/fields/event/startend/display","easysocial/apps/fields/group/permalink/content","easysocial/apps/fields/group/permalink/sample_content","easysocial/apps/fields/user/address/content","easysocial/apps/fields/user/address/display_content","easysocial/apps/fields/user/address/maps","easysocial/apps/fields/user/autocomplete/content","easysocial/apps/fields/user/avatar/content","easysocial/apps/fields/user/avatar/sample_content","easysocial/apps/fields/user/checkbox/content","easysocial/apps/fields/user/checkbox/sample_content","easysocial/apps/fields/user/country/content","easysocial/apps/fields/user/country/sample_content","easysocial/apps/fields/user/cover/content","easysocial/apps/fields/user/currency/sample_content","easysocial/apps/fields/user/datetime/content","easysocial/apps/fields/user/datetime/display_content","easysocial/apps/fields/user/datetime/dropdown","easysocial/apps/fields/user/datetime/sample_content","easysocial/apps/fields/user/dropdown/content","easysocial/apps/fields/user/email/content","easysocial/apps/fields/user/file/content","easysocial/apps/fields/user/file/sample_content","easysocial/apps/fields/user/gender/content","easysocial/apps/fields/user/joomla_email/content","easysocial/apps/fields/user/joomla_email/registermini_content","easysocial/apps/fields/user/joomla_email/sample_content","easysocial/apps/fields/user/joomla_fullname/content","easysocial/apps/fields/user/joomla_fullname/sample_content","easysocial/apps/fields/user/joomla_password/content","easysocial/apps/fields/user/joomla_password/registermini_content","easysocial/apps/fields/user/joomla_password/sample_content","easysocial/apps/fields/user/joomla_timezone/content","easysocial/apps/fields/user/joomla_username/content","easysocial/apps/fields/user/joomla_username/registermini_content","easysocial/apps/fields/user/joomla_username/sample_content","easysocial/apps/fields/user/multidropdown/content","easysocial/apps/fields/user/multilist/content","easysocial/apps/fields/user/multitextbox/content","easysocial/apps/fields/user/permalink/content","easysocial/apps/fields/user/permalink/sample_content","easysocial/apps/fields/user/relationship/content","easysocial/site/friends/suggest","easysocial/apps/fields/user/separator/sample","easysocial/apps/fields/user/terms/content","easysocial/apps/fields/user/textarea/content","easysocial/apps/fields/user/textbox/content","easysocial/apps/fields/user/textbox/sample_content","easysocial/apps/fields/user/url/content","easysocial/apps/fields/user/url/sample_content","easysocial/apps/group/feeds","easysocial/apps/group/tasks","easysocial/avatar","easysocial/utilities/webcam","easysocial/cover","easysocial/easysocial","easysocial/site/likes/likes","easysocial/site/reports/reports","easysocial/site/blocks/blocks","easysocial/site/repost/repost","easysocial/site/share/share","easysocial/site/layout/dialog","easysocial/site/layout/responsive","easysocial/site/layout/elements","easysocial/site/photos/photos","easysocial/site/photos/popup","easysocial/site/photos/dialog","easysocial/site/photos/avatar","easysocial/site/users/login","easysocial/site/dashboard/dashboard.guest.login","easysocial/validate","easysocial/site/profile/popbox","easysocial/site/conversations/composer","easysocial/site/privacy/privacy","easysocial/site/locations/popbox","easysocial/site/sidebar/sidebar","easysocial/site/friends/api","easysocial/site/popbox/popbox","easysocial/site/conversations/api","easysocial/site/groups/api","easysocial/site/followers/api","easysocial/site/stream/video","easysocial/oauth/facebook","easysocial/groups/suggest","easysocial/libraries/lightbox","easysocial/locations","easysocial/pagination","easysocial/photos/avatar","easysocial/photos/browser","easysocial/photos/editor","easysocial/photos/item","easysocial/photos/tags","easysocial/photos/tagger","easysocial/photos/navigation","easysocial/prism","easysocial/privacy","easysocial/sharing","easysocial/site/activities/activities","easysocial/site/activities/sidebar","easysocial/site/activities/sidebar.item","easysocial/site/activities/apps","easysocial/site/activities/item","easysocial/site/activities/list","easysocial/site/albums/all","easysocial/site/apps/apps","easysocial/site/badges/badge","easysocial/site/comments/control","easysocial/site/comments/frame","easysocial/site/comments/item","easysocial/site/conversations/conversations","easysocial/site/conversations/mailbox","easysocial/site/conversations/item","easysocial/site/conversations/filter","easysocial/site/conversations/read","easysocial/site/dashboard/apps","easysocial/site/dashboard/dashboard","easysocial/site/dashboard/feeds","easysocial/site/dashboard/sidebar","easysocial/site/stream/filter","easysocial/site/stream/sidebar","easysocial/site/dashboard/groups","easysocial/site/dashboard/events","easysocial/site/events/browser","easysocial/site/events/guestState","easysocial/site/events/buttonState","easysocial/site/events/create","easysocial/site/events/createRecurring","easysocial/site/events/edit","easysocial/site/events/item","easysocial/site/events/update","easysocial/site/explorer","easysocial/site/explorer/uploader","easysocial/site/explorer/popup","easysocial/site/followers/followers","easysocial/site/friends/friends","easysocial/site/friends/list","easysocial/site/friends/item","easysocial/site/groups/groups","easysocial/site/groups/item","easysocial/site/notifications/list","easysocial/site/points/history","easysocial/site/polls/polls","easysocial/site/profile/about","easysocial/site/profile/admintool","easysocial/site/profile/edit","easysocial/site/profile/feeds","easysocial/site/profile/friends","easysocial/site/profile/header","easysocial/site/profile/subscriptions","easysocial/site/profile/miniheader","easysocial/site/profile/notifications","easysocial/site/profile/privacy","easysocial/site/profile/profile","easysocial/site/registrations/registrations","easysocial/site/search/advanced.criteria","easysocial/site/search/map","easysocial/site/search/advanced","easysocial/site/search/advanced.list.group","easysocial/site/search/advanced.list","easysocial/site/search/item","easysocial/site/search/dating","easysocial/site/search/list","easysocial/site/search/search","easysocial/site/search/sidebar","easysocial/site/search/toolbar","easysocial/site/stream/item","easysocial/site/stream/stream","easysocial/site/subscriptions/follow","easysocial/site/system/broadcast","easysocial/site/toolbar/conversations","easysocial/site/toolbar/friends","easysocial/site/toolbar/login","easysocial/site/toolbar/notifications","easysocial/site/toolbar/story","easysocial/site/toolbar/system","easysocial/site/toolbar/profile","easysocial/site/users/popbox","easysocial/site/users/users","easysocial/story","easysocial/story/blog","easysocial/story/broadcast","easysocial/story/event","easysocial/story/files","easysocial/story/friends","easysocial/story/links","easysocial/story/locations","easysocial/story/mood","easysocial/story/photos","easysocial/story/polls","easysocial/story/quickpost","easysocial/story/tasks","easysocial/story/videos","easysocial/stream","easysocial/comment","easysocial/tab","easysocial/toggle","easysocial/uploader/item","easysocial/videos/form","easysocial/videos/item","easysocial/videos/list","easysocial/videos/process"]);
$.require.template.loader(["easysocial/site/loading/small","easysocial/site/uploader/queue.item","easysocial/admin/profiles/fields/editor.item","easysocial/admin/profiles/fields/step.item","easysocial/admin/profiles/fields/editor.page","easysocial/admin/profiles/fields/config","easysocial/admin/profiles/fields/dialog.move","easysocial/admin/profiles/dialog.delete.profileavatar","easysocial/site/albums/browser.list.item","easysocial/site/albums/upload.item","easysocial/fields/user/checkbox/item","easysocial/site/friends/suggest.item","easysocial/site/friends/suggest.hint.search","easysocial/site/friends/suggest.hint.empty","easysocial/site/hashtags/suggest.item","easysocial/site/hashtags/suggest.hint.search","easysocial/site/hashtags/suggest.hint.empty","easysocial/site/dialog/default","easysocial/site/photos/popup","easysocial/site/groups/suggest.item","easysocial/site/location/story.suggestion","easysocial/site/photos/tags.item","easysocial/site/photos/tags.menu.item","easysocial/admin/profiles/form.privacy.custom.item","easysocial/site/activities/loadbutton","easysocial/site/explorer/popup","easysocial/site/friends/default.empty","easysocial/site/friends/list.assign","easysocial/site/registration/dialog.error","easysocial/site/search/loadbutton","easysocial/site/stream/loadbutton","easysocial/site/notifications/system.empty","easysocial/site/users/button.following","easysocial/apps/user/links/story/attachment.item","easysocial/apps/user/files/story/attachment.item","easysocial/apps/user/files/story/progress","easysocial/site/links/story/attachment.item","easysocial/apps/group/tasks/story/attachment.item","easysocial/site/likes/item","easysocial/site/uploader/preview"]);
$.require.language.loader(["COM_EASYSOCIAL_SCAN_COMPLETED","JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST","COM_EASYSOCIAL_INDEXER_REINDEX_PROCESSING","COM_EASYSOCIAL_INDEXER_REINDEX_FINISHED","COM_EASYSOCIAL_INDEXER_REINDEX_RESTART","COM_EASYSOCIAL_CANCEL_BUTTON","COM_EASYSOCIAL_CLOSE_BUTTON","COM_EASYSOCIAL_POLLS_VIEW_POLLS_DIALOG_TITLE","COM_EASYSOCIAL_POLLS_ACTIONS_DIALOG_TITLE","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_ITEM_CONFIG_LOADING","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_TITLE","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CONFIRMATION","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CONFIRM","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CANCEL","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_DELETING","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_TITLE","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_CONFIRMATION","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_CONFIRM","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_CANCEL","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_DELETING","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_PARAMS_CORE_UNIQUE_KEY_SAVE_FIRST","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_CONFIGURE_PAGE","COM_EASYSOCIAL_PROFILES_FORM_FIELDS_CONFIGURE_FIELD","COM_EASYSOCIAL_FIELDS_REQUIRE_MANDATORY_FIELDS","COM_EASYSOCIAL_FIELDS_UNSAVED_CHANGES","COM_EASYSOCIAL_FIELDS_INVALID_VALUES","COM_EASYSOCIAL_ASSIGN_BUTTON","COM_EASYSOCIAL_PROFILES_ASSIGN_USER_DIALOG_TITLE","COM_EASYSOCIAL_PROFILES_FORM_CLEAR_AVATAR","COM_EASYSOCIAL_REGIONS_FORM_INCOMPLETE","COM_EASYSOCIAL_REPORTS_VIEW_REPORTS_DIALOG_TITLE","COM_EASYSOCIAL_REPORTS_ACTIONS_DIALOG_TITLE","PLG_FIELDS_EVENT_DESCRIPTION_VALIDATION_INPUT_REQUIRED","FIELDS_EVENT_PERMALINK_EXCEEDED_MAX_LENGTH","FIELDS_EVENT_PERMALINK_REQUIRED","FIELDS_EVENT_STARTEND_VALIDATION_DATETIME_START_REQUIRED","FIELDS_EVENT_STARTEND_VALIDATION_DATETIME_END_REQUIRED","FIELDS_USER_DATETIME_LOCAL_TIMEZONE","FIELDS_USER_DATETIME_TIMEZONE_CHECKING","PLG_FIELDS_GROUP_PERMALINK_EXCEEDED_MAX_LENGTH","PLG_FIELDS_GROUP_PERMALINK_REQUIRED","PLG_FIELDS_ADDRESS_PLEASE_ENTER_ADDRESS1","PLG_FIELDS_ADDRESS_PLEASE_ENTER_ADDRESS2","PLG_FIELDS_ADDRESS_PLEASE_ENTER_CITY","PLG_FIELDS_ADDRESS_PLEASE_ENTER_STATE","PLG_FIELDS_ADDRESS_PLEASE_ENTER_ZIP","PLG_FIELDS_ADDRESS_PLEASE_ENTER_COUNTRY","COM_EASYSOCIAL_LOCATION_PERMISSION_ERROR","COM_EASYSOCIAL_LOCATION_TIMEOUT_ERROR","COM_EASYSOCIAL_LOCATION_UNAVAILABLE_ERROR","COM_EASYSOCIAL_STREAM_AT","PLG_FIELDS_AVATAR_VALIDATION_EMPTY_PROFILE_PICTURE","PLG_FIELDS_CHECKBOX_CHECK_AT_LEAST_ONE_ITEM","PLG_FIELDS_COUNTRY_VALIDATION_REQUIRED","PLG_FIELDS_COUNTRY_VALIDATION_MINIMUM_ERROR","PLG_FIELDS_COUNTRY_VALIDATION_MAXIMUM_ERROR","PLG_FIELDS_COVER_VALIDATION_REQUIRED","PLG_FIELDS_DATETIME_VALIDATION_INVALID_DATETIME_FORMAT","PLG_FIELDS_DATETIME_VALIDATION_PLEASE_SELECT_DATETIME","PLG_FIELDS_DATETIME_DAY","PLG_FIELDS_DROPDOWN_VALIDATION_PLEASE_SELECT_A_VALUE","PLG_FIELDS_EMAIL_VALIDATION_REQUIRED","PLG_FIELDS_EMAIL_VALIDATION_INVALID_FORMAT","PLG_FIELDS_FILE_ERROR_UNKNOWN_ERROR_OCCURED","COM_EASYSOCIAL_WORKING","PLG_FIELDS_GENDER_VALIDATION_GENDER_REQUIRED","PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_REQUIRED","PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_RECONFIRM_REQUIRED","PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_NOT_MATCHING","PLG_FIELDS_JOOMLA_EMAIL_CHECKING","PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_INVALID_FORMAT","PLG_FIELDS_JOOMLA_FULLNAME_VALIDATION_EMPTY_NAME","PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_PASSWORD","PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_RECONFIRM_PASSWORD","PLG_FIELDS_JOOMLA_PASSWORD_NOT_MATCHING","PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_CHAR","PLG_FIELDS_JOOMLA_PASSWORD_MAXIMUM_CHAR","PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_INTEGER","PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_SYMBOLS","PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_UPPERCASE","PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_VERY_WEAK","PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_WEAK","PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_NORMAL","PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_STRONG","PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_VERY_STRONG","PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_ORIGINAL_PASSWORD","PLG_FIELDS_JOOMLA_PASSWORD_TOO_SHORT","PLG_FIELDS_JOOMLA_PASSWORD_TOO_LONG","PLG_FIELDS_JOOMLA_TIMEZONE_VALIDATION_SELECT_TIMEZONE","PLG_FIELDS_JOOMLA_USERNAME_CHECKING","PLG_FIELDS_JOOMLA_USERNAME_EMPTY_USERNAME","PLG_FIELDS_MULTIDROPDOWN_VALIDATION_REQUIRED_FIELD","PLG_FIELDS_MULTILIST_VALIDATION_PLEASE_SELECT_A_VALUE","PLG_FIELDS_MULTITEXTBOX_VALIDATION_REQUIRED_FIELD","PLG_FIELDS_PERMALINK_EXCEEDED_MAX_LENGTH","PLG_FIELDS_PERMALINK_REQUIRED","COM_EASYSOCIAL_FRIENDS_REQUEST_SENT","PLG_FIELDS_RELATIONSHIP_APPROVE_CONFIRM","PLG_FIELDS_RELATIONSHIP_ACTION_APPROVE","PLG_FIELDS_TERMS_VALIDATION_REQUIRED","PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_REQUIRED","PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_TOO_SHORT","PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_TOO_LONG","PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_REQUIRED","PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_TOO_SHORT","PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_TOO_LONG","PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_INVALID_FORMAT","PLG_FIELDS_URL_VALIDATION_EMPTY_URL","COM_EASYSOCIAL_CONVERSATIONS_ERROR_EMPTY_RECIPIENTS","COM_EASYSOCIAL_CONVERSATIONS_ERROR_EMPTY_MESSAGE","COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_PUBLIC","COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_MEMBER","COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_FRIENDS_OF_FRIEND","COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_FRIEND","COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_ONLY_ME","COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_CUSTOM","COM_EASYSOCIAL_AT_LOCATION","COM_EASYSOCIAL_ACTIVITY_APPS_UNHIDE_SUCCESSFULLY","COM_EASYSOCIAL_ACTIVITY_USERS_UNHIDE_SUCCESSFULLY","COM_EASYSOCIAL_ACTIVITY_LOG_LOAD_PREVIOUS_STREAM_ITEMS","COM_EASYSOCIAL_COMMENTS_STATUS_SAVE_ERROR","COM_EASYSOCIAL_COMMENTS_STATUS_LOADING","COM_EASYSOCIAL_COMMENTS_STATUS_LOAD_ERROR","COM_EASYSOCIAL_COMMENTS_STATUS_DELETING","COM_EASYSOCIAL_COMMENTS_STATUS_DELETE_ERROR","COM_EASYSOCIAL_LIKES_LIKE","COM_EASYSOCIAL_LIKES_UNLIKE","COM_EASYSOCIAL_COMMENTS_LOADED_OF_TOTAL","COM_EASYSOCIAL_COMMENTS_STATUS_SAVING","COM_EASYSOCIAL_COMMENTS_STATUS_SAVED","COM_EASYSOCIAL_NO_BUTTON","COM_EASYSOCIAL_CONVERSATION_REPLY_POSTED_SUCCESSFULLY","COM_EASYSOCIAL_CONVERSATION_REPLY_FORM_EMPTY","COM_EASYSOCIAL_STREAM_FILTER_WARNING_TITLE_EMPTY","COM_EASYSOCIAL_STREAM_FILTER_WARNING_HASHTAG_EMPTY","COM_EASYSOCIAL_EVENTS_GUEST_PENDING","COM_EASYSOCIAL_EVENTS_DETECTING_LOCATION","COM_EASYSOCIAL_EXPLORER_ENTER_FOLDER_NAME","COM_EASYSOCIAL_EXPLORER_INVALID_FOLDER_NAME","COM_EASYSOCIAL_FRIENDS_REQUEST_SENT_PENDING_APPROVAL","COM_EASYSOCIAL_FRIENDS_REQUEST_DIALOG_TITLE","COM_EASYSOCIAL_FRIENDS_CANCEL_REQUEST_DIALOG_CANCELLED","COM_EASYSOCIAL_FRIENDS_DIALOG_CANCEL_REQUEST","COM_EASYSOCIAL_YES_CANCEL_MY_REQUEST_BUTTON","COM_EASYSOCIAL_REGISTRATION_ERROR_DIALOG_TITLE","COM_EASYSOCIAL_ADVANCED_SEARCH_ADDRESS_DISTANCE_NOTICE","COM_EASYSOCIAL_STREAM_LOAD_PREVIOUS_STREAM_ITEMS","COM_EASYSOCIAL_SEARCH_LOAD_MORE_ITEMS","COM_EASYSOCIAL_FRIENDS_REQUEST_SENT_NOTICE","COM_EASYSOCIAL_SUBSCRIPTION_INFO","COM_EASYSOCIAL_FRIENDS_REQUEST_REJECTED","COM_EASYSOCIAL_STREAM_META_JOINER","COM_EASYSOCIAL_STORY_SUBMIT_ERROR","COM_EASYSOCIAL_STORY_CONTENT_EMPTY","COM_EASYSOCIAL_STORY_NOT_ON_STREAM_FILTER","COM_EASYSOCIAL_STORY_EVENT_INSUFFICIENT_DATA","COM_EASYSOCIAL_STORY_EVENT_INVALID_START_END_DATETIME","COM_EASYSOCIAL_STREAM_STORY_WITH","COM_EASYSOCIAL_STREAM_STORY_WITH_JOINER","COM_EASYSOCIAL_STREAM_STORY_WITH_LAST_JOINER","COM_EASYSOCIAL_AND","COM_EASYSOCIAL_MOOD_FEELING_CUSTOM","COM_EASYSOCIAL_VIDEOS_STORY_SELECT_CATEGORY","COM_EASYSOCIAL_VIDEOS_STORY_ENTER_VIDEO","COM_EASYSOCIAL_VIDEOS_STORY_PROCESSING_VIDEO","COM_EASYSOCIAL_VIDEOS_STORY_CLICK_INSERT_VIDEO","COM_EASYSOCIAL_VIDEOS_STORY_NO_VIDEO_DETECTED","COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_UNSUBSCRIBE","COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_SUBSCRIBE","COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_OK","COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_SUBMIT","COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_CANCEL","COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_UNSUBSCRIBE","COM_EASYSOCIAL_SUBSCRIPTION_ARE_YOU_SURE_UNSUBSCRIBE","COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_SUBSCRIBE","COM_EASYSOCIAL_STREAM_DIALOG_FEED","COM_EASYSOCIAL_STREAM_BUTTON_CLOSE"]);
(function(){
var stylesheetNames = ["easysocial/imgareaselect/default"];
var state = ($.stylesheet({"content":""})) ? "resolve" : "reject";
$.each(stylesheetNames, function(i, stylesheet){ $.require.stylesheet.loader(stylesheet)[state](); });
})();
});
FD40.installer("EasySocial", "scripts", function($){
EasySocial.module("admin", function($){

	var module = this;

	EasySocial.require()
		.library(
			"uniform",
			"chosen",
			"flot"
		)
		.done(function($){

			// Once uniform.js is implemented, we want to apply uniform to the elements.
			$(".uniform, .check :checkbox, .radio :radio, input:file[data-uniform], .usergroups :checkbox").uniform();

			// Apply chosen
			$('[data-chosen]').chosen({
				disable_search: true
			});

			$('[data-chosen-search]').chosen({
				disable_search 	: false
			});

			$('[data-sidebar-menu-toggle]').on('click' , function() {
				var parent 		= $( this ).parent( 'li' ),
					child 		= parent.find( 'ul' ),
					isActive 	= $( this ).parent( 'li' ).hasClass( 'active' );

				if( isActive )
				{
					parent.removeClass( 'active' );
					child.removeClass( 'in' );
				}
				else
				{
					parent.addClass( 'active' );
					child.addClass( 'in' );
				}
			});

			module.resolve();
		});
});

EasySocial.module('admin/access/discover', function($) {
	var module = this;

	EasySocial
		.require()
		.script('progress/progress')
		.language('COM_EASYSOCIAL_SCAN_COMPLETED')
		.done(function($) {
			EasySocial.Controller('Access.Discover', {
				defaultOptions: {
					files: [],

					progressController: null,

					'{progressBar}': '.discoverProgress',

					'{results}': '[data-access-discovery-result]'
				}
			}, function(self) {
				return {
					init: function() {
						self.options.progressController = self.progressBar().addController(EasySocial.Controller.Progress);

						$.Joomla('submitbutton', function(task) {

							if (task == 'discover') {
								self.startDiscovering();
							}
						});
					},

					reset: function() {
						self.results().html('');

						self.options.progressController.reset();
					},

					addLog: function(msg) {
						$('<tr></tr>').append($('<td></td>').html(msg)).appendTo(self.results());
					},

					startDiscovering: function() {
						self.reset();

						// Discover the list of files.
						EasySocial.ajax('admin/controllers/access/scanFiles').done(function(files, message) {
							self.reset();

							// Set the files to the properties.
							self.options.files 	= files;

							if (self.options.files.length > 0) {
								// Begin progress.
								self.options.progressController.begin(self.options.files.length);

								// Add logging
								self.addLog(message);

								// Begin to loop through each files.
								self.startIterating();
							} else {
								// Update once.
								self.options.progressController.begin(1);
								self.options.progressController.completed('Discover Completed');

								// Append message to the result list.
								self.addLog($.language('COM_EASYSOCIAL_SCAN_COMPLETED'));
							}
						});
					},

					startIterating: function() {
						// Get the file from the shelf
						var file = self.options.files.shift();

						EasySocial.ajax('admin/controllers/access/installFile',
						{
							"file": file
						})
						.always(function(message){

							// As long as the files list are not empty yet, we still need to process it.
							if (self.options.files.length > 0) {
								// Update once.
								self.options.progressController.touch('...');

								// Append message to the result list.
								self.addLog(message);

								// Run this again.
								self.startIterating();
							} else {
								// Update once.
								self.options.progressController.touch('...');

								// Append message to the result list.
								self.addLog(message);

								// Append message to the result list.
								self.addLog($.language('COM_EASYSOCIAL_SCAN_COMPLETED'));
							}
						});
					}
				}
			});

			module.resolve();
		});
});

EasySocial.module( 'progress/progress' , function($) {

	var module = this;

	EasySocial.Controller(
		'Progress',
		{
			// A list of selectors we define
			// and expect template makers to follow.
			defaultOptions:
			{
				// Controller Properties.
				current 		: 0,
				eachWidth 		: null,
				total	 		: null,

				progressClass	: "progress progress-info progress-striped",

				// Controller Elements
				"{progressBar}"		: ".bar",
				"{progressResult}"	: ".progress-result",

				// View items.
				view			:
				{
				}
			}
		},
		function(self){

			return {

				init: function()
				{
				},

				reset: function()
				{
					self.options.current 	= 0;
					self.eachWidth 			= null;
					self.total 				= null;

					self.progressBar().css( 'width' , '0%' ).html( '' );
				},

				begin: function( total )
				{
					// Set the total number of items
					self.options.total 	= total;

					// Set the width of each item.
					self.options.eachWidth	= 100 / total;


					// Only show progress bar when the there's more than 1 item.
					if( total > 0 )
					{
						self.element
							.addClass( self.options.progressClass )
							.show();
					}
				},

				touch : function( message )
				{
					self.options.current 	+= self.options.eachWidth;

					//ensure the progress bar do not exceed 100%
					if( self.options.current > 100 )
					{
						self.options.current = 100;
					}

					self.progressBar().css( 'width' , self.options.current + '%' );
					self.progressResult().html( Math.round( self.options.current ) + '%' );
				},

				completed: function( message )
				{
					self.options.current 	= 100;

					self.progressBar().css( 'width' , self.options.current + '%' );
					self.progressResult().html( Math.round( self.options.current ) + '%' );
				}
			}

		}
	);

	module.resolve();

});

EasySocial.module( 'admin/alerts/discover' , function($) {

	var module = this;

	EasySocial.require()
	.script( 'progress/progress' )
	.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' )
	.done(function($){

		EasySocial.Controller('Alerts.Discover', {

				// A list of selectors we define
				// and expect template makers to follow.
				defaultOptions: {
					// Controller Properties.
					files 			: [],

					// Progress bar controller
					progressController : null,

					// Progress Bar
					"{progressBar}" : "[data-alerts-discovery-progress]",

					// Logging results
					"{results}"		: "[data-alerts-discovery-result]"
				}
			}, function(self) {

				return {

					init: function() {
						// Initialize progress bar.
						self.initProgressBar();

						$.Joomla('submitbutton', function(task) {
							if (task == 'discover') {
								self.startDiscovering();
							}
						})
					},

					startDiscovering: function() {

						self.reset();

						// Discover the list of files.
						EasySocial.ajax('admin/controllers/alerts/discoverFiles' , {
						}).done(function(files, message) {
							self.reset();

							// Set the files to the properties.
							self.options.files 	= files;

							if (self.options.files.length > 0) {
								// Begin progress.
								self.options.progressController.begin( self.options.files.length );

								// Add logging
								self.addLog(message);

								// Begin to loop through each files.
								self.startIterating();
							}
						});
					},

					// Resets the scan.
					reset: function() {
						// Reset the logs
						self.results().html('');

						// Reset progress bar.
						self.options.progressController.reset();
					},

					initProgressBar: function() {
						// Implement progressbar
						self.progressBar().implement( EasySocial.Controller.Progress );

						// Set this to the options so that we can easily access the controller.
						self.options.progressController	= self.progressBar().controller();
					},

					addLog: function(message) {
						$( '<tr>' ).append( $( '<td>' ).html( message ) ).appendTo( self.results() );
					},

					startIterating: function() {
						// Get the file from the shelf
						var file 	= self.options.files.shift();

						EasySocial.ajax( 'admin/controllers/alerts/scan' ,
						{
							"file"	: file
						})
						.always(function( data , message , completeMessage ){

							// As long as the files list are not empty yet, we still need to process it.
							if( self.options.files.length > 0 )
							{
								// Update once.
								self.options.progressController.touch( '...' );

								// Append message to the result list.
								self.addLog( message );

								// Run this again.
								self.startIterating();
							}
							else
							{
								// Update once.
								self.options.progressController.touch( '...' );

								// Append message to the result list.
								self.addLog( $.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' ) );

							}
						});
					}
				}

			}
		);

		module.resolve();
	});

});

EasySocial.module( 'admin/badges/discover' , function($) {

	var module = this;

	EasySocial.require()
	.script( 'progress/progress' )
	.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' )
	.done(function($){

		EasySocial.Controller(
			'Badges.Discover',
			{
				// A list of selectors we define
				// and expect template makers to follow.
				defaultOptions:
				{
					// Controller Properties.
					files 			: [],

					// Progress bar controller
					progressController : null,

					// Progress Bar
					"{progressBar}" : "[data-badgesDiscover-progress]",

					// Logging results
					"{results}"		: "[data-badgesDiscover-result]",

					// View logs button.
					"{viewLog}"		: "[data-badgesDiscover-viewLog]"
				}
			},
			function(self){

				return {

					init: function() {
						// Initialize progress bar.
						self.initProgressBar();

						// Initialize the logging area.
						self.initLogging();

						$.Joomla('submitbutton', function(task) {
							if (task == 'discover') {
								self.startDiscovering();
							}
						});
					},

					// Resets the scan.
					reset: function()
					{
						// Reset the logs
						self.results().html('');

						// Hide the viewlog button
						self.initLogging();

						// Reset progress bar.
						self.options.progressController.reset();
					},

					initLogging: function()
					{
						// Ensure view log button is always hidden.
						self.viewLog().hide();
					},

					initProgressBar: function()
					{
						// Implement progressbar
						self.progressBar().implement( EasySocial.Controller.Progress );

						// Set this to the options so that we can easily access the controller.
						self.options.progressController	= self.progressBar().controller();
					},

					addLog: function( message )
					{
						$( '<tr>' ).append( $( '<td>' ).html( message ) ).appendTo( self.results() );
					},

					startIterating: function()
					{
						// Get the file from the shelf
						var file 	= self.options.files.shift();

						EasySocial.ajax( 'admin/controllers/badges/scan' ,
						{
							"file"	: file
						})
						.always(function( data , message )
						{

							// As long as the files list are not empty yet, we still need to process it.
							if( self.options.files.length > 0 )
							{
								// Update once.
								self.options.progressController.touch( '...' );

								// Append message to the result list.
								self.addLog( message );

								// Run this again.
								self.startIterating();
							}
							else
							{
								// Update once.
								self.options.progressController.touch( '...' );

								// Append message to the result list.
								self.addLog( message );

								// Append completed message to the result list since we know this is the last item.
								self.addLog( $.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' ) );

								// Show view log button.
								self.viewLog().show();
							}
						});
					},

					startDiscovering: function() {
						self.reset();

						// Discover the list of files.
						EasySocial.ajax( 'admin/controllers/badges/discoverFiles' , {

						}).done(function(files, message) {
							// Set the files to the properties.
							self.options.files 	= files;

							if( self.options.files.length > 0 )
							{
								// Begin progress.
								self.options.progressController.begin( self.options.files.length );

								// Add logging
								self.addLog( message );

								// Begin to loop through each files.
								self.startIterating();
							}
							else
							{
								// Update once.
								self.options.progressController.begin( 1 );
								self.options.progressController.completed( 'Discover Completed' );

								// Append message to the result list.
								self.addLog( $.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' ) );
							}

						});
					},

					"{viewLog} click" : function()
					{
						self.results().toggle();
					}
				}

			}
		);

		module.resolve();
	});

});

EasySocial.module('admin/events/approveRecurring', function($) {
    var module = this;

    EasySocial.Controller('Events.ApproveRecurring', {
        defaultOptions: {
            postdatas: {},
            schedules: {},
            eventids: [],

            '{progress}': '[data-progress-bar]',

            '{form}': '[data-form]'
        }
    }, function(self) {
        return {
            init: function() {
                // Calculate the total things to do
                var length = 0;

                $.each(self.options.schedules, function(i, s) {
                    length += s.length;
                });

                self.total = length;

                self.startCreate();
            },

            total: 0,
            doneCounter: 0,
            eventCounter: 0,
            createCounter: 0,

            updateProgressBar: function() {
                var percentage = Math.ceil((self.doneCounter / self.total) * 100);

                self.progress().css({
                    width: percentage + '%'
                });
            },

            startCreate: function() {
                if (self.options.eventids[self.eventCounter] === undefined) {
                    return self.completed();
                }

                self.create()
                    .done(function() {
                        self.doneCounter++;

                        self.createCounter++;

                        if (self.options.schedules[self.options.eventids[self.eventCounter]][self.createCounter] === undefined) {
                            self.eventCounter++;
                            self.createCounter = 0;
                        }

                        self.updateProgressBar();

                        self.startCreate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            create: function() {
                var eventId = self.options.eventids[self.eventCounter],
                    datetime = self.options.schedules[eventId][self.createCounter],
                    postdata = self.options.postdatas[eventId];

                return EasySocial.ajax('admin/controllers/events/createRecurring', {
                    eventId: eventId,
                    datetime: datetime,
                    postdata: postdata
                });
            },

            completed: function() {
                self.progress().parent().removeClass('progress-info').addClass('progress-success');
                self.form().submit();
            }
        }
    });

    module.resolve();
});

EasySocial.module('admin/events/store', function($) {
    var module = this;

    EasySocial.Controller('Events.Update', {
        defaultOptions: {
            postdata: {},
            updateids: [],
            schedule: [],
            eventId: null,

            '{progress}': '[data-progress-bar]',

            '{form}': '[data-form]'
        }
    }, function(self) {
        return {
            init: function() {
                self.startUpdate();
            },

            updateCounter: 0,
            createCounter: 0,

            updateProgressBar: function() {
                var percentage = Math.ceil(((self.updateCounter + self.createCounter) / (self.options.updateids.length + self.options.schedule.length)) * 100);

                self.progress().css({
                    width: percentage + '%'
                });
            },

            startUpdate: function() {
                if (self.options.updateids[self.updateCounter] === undefined) {
                    return self.startCreate();
                }

                self.update(self.options.updateids[self.updateCounter])
                    .done(function() {
                        self.updateCounter++;

                        self.updateProgressBar();

                        self.startUpdate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            update: function(id) {
                var post = $.extend({}, self.options.postdata, {
                    id: id,
                    applyRecurring: 1
                });

                return EasySocial.ajax('admin/controllers/events/store', post);
            },

            startCreate: function() {
                if (self.options.schedule[self.createCounter] === undefined) {
                    return self.completed();
                }

                self.create(self.options.schedule[self.createCounter])
                    .done(function() {
                        self.createCounter++;

                        self.updateProgressBar();

                        self.startCreate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            create: function(datetime) {
                return EasySocial.ajax('admin/controllers/events/createRecurring', {
                    eventId: self.options.eventId,
                    datetime: datetime,
                    postdata: self.options.postdata
                });
            },

            completed: function() {
                self.progress().parent().removeClass('progress-info').addClass('progress-success');
                self.form().submit();
            }
        }
    });

    module.resolve();
});

EasySocial.module('admin/events/users', function($) {
    var module = this;

    EasySocial
        .require()
        .language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST')
        .done(function($) {
            EasySocial.Controller('Events.Users', {
                defaultOptions: {
                    eventid: null,

                    '{inviteGuest}': '[data-event-invite-guest]',
                    '{removeGuest}': '[data-event-remove-guest]',
                    '{approveGuest}': '[data-event-approve-guest]',
                    '{promoteGuest}': '[data-event-promote-guest]',
                    '{demoteGuest}': '[data-event-demote-guest]'
                }
            }, function(self) {
                return {
                    init: function() {
                    },

                    '{inviteGuest} click': function(el, ev) {
                        var guests = {};

                        window.inviteGuests = function(guest) {
                            if (guest.state) {
                                guests[guest.id] = guest
                            } else {
                                delete guests[guest.id];
                            }
                        };

                        var confirmInviteGuests = function() {
                            EasySocial.dialog({
                                content: EasySocial.ajax('admin/views/events/confirmInviteGuests', {
                                    guests: guests,
                                    eventid: self.options.eventid
                                }),
                                bindings: {
                                    '{submitButton} click': function() {
                                        this.inviteGuestsForm().submit();
                                    }
                                }
                            });
                        };

                        EasySocial.dialog({
                            content: EasySocial.ajax('admin/views/events/inviteGuests'),
                            bindings: {
                                '{submitButton} click': function() {
                                    confirmInviteGuests();
                                }
                            }
                        });
                    },

                    '{removeGuest} click': function(el, ev) {
                        if(document.adminForm.boxchecked.value == 0) {
                            alert($.language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST'));
                        } else {
                            $.Joomla('submitform', ['removeGuests']);
                        }
                    },

                    '{approveGuest} click': function(el, ev) {
                        if(document.adminForm.boxchecked.value == 0) {
                            alert($.language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST'));
                        } else {
                            $.Joomla('submitform', ['approveGuests']);
                        }
                    },

                    '{promoteGuest} click': function(el, ev) {
                        if(document.adminForm.boxchecked.value == 0) {
                            alert($.language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST'));
                        } else {
                            $.Joomla('submitform', ['promoteGuests']);
                        }
                    },

                    '{demoteGuest} click': function(el, ev) {
                        if(document.adminForm.boxchecked.value == 0) {
                            alert($.language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST'));
                        } else {
                            $.Joomla('submitform', ['demoteGuests']);
                        }
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module( 'admin/grid/grid' , function($) {

	var module = this;

	EasySocial.require()
	.script( 'admin/grid/sort' , 'admin/grid/publishing')
	.done(function($)
	{
		EasySocial.Controller(
			'Grid',
			{
				defaultOptions :
				{
					"{sortColumns}"		: "[data-table-grid-sort]",
					"{ordering}"		: "[data-table-grid-ordering]",
					"{saveorder}"		: "[data-table-grid-saveorder]",
					"{direction}"		: "[data-table-grid-direction]",

					"{task}"			: "[data-table-grid-task]",

					"{searchInput}"		: "[data-table-grid-search-input]",
					"{search}"			: "[data-table-grid-search]",
					"{resetSearch}"		: "[data-table-grid-search-reset]",

					"{checkAll}"		: "[data-table-grid-checkall]",
					"{checkboxes}"		: "[data-table-grid-id]",

					"{publishItems}"	: "[data-table-grid-publishing]",

					"{itemRow}"			: "tr",

					"{boxChecked}"		: "[data-table-grid-box-checked]",
					"{filters}"			: "[data-table-grid-filter]"
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						// Implement sortable items.
						self.implementSortable();

						// Implement publish / unpublish
						self.implementPublishing();
					},

					"{filters} change" : function()
					{
						// Always reset the task before submitting.
						self.setTask( '' );

						self.submitForm();
					},

					"{search} click" : function()
					{
						self.submitForm();
					},

					"{saveorder} click" : function()
					{
						self.setTask('saveorder');

						// check all checkbox.
						self.checkAll().click();
						self.submitForm();
					},

					"{resetSearch} click" : function()
					{
						self.searchInput().val( '' );
						self.submitForm();
					},

					submitForm: function()
					{
						self.element.submit();
					},

					setTask: function( task )
					{
						self.task().val( task );
					},

					setOrdering: function( ordering )
					{
						self.ordering().val( ordering );
					},

					setDirection: function( direction )
					{
						self.direction().val( direction );
					},

					setTotalChecked: function( total )
					{
						self.boxChecked().val( total );
					},

					toggleSelectRow: function( row )
					{
						var checkbox 	= row.find( 'input[name=cid\\[\\]]' );

						if( $( checkbox ).prop( 'checked' ) == true )
						{
							$( checkbox ).prop( 'checked' , false );
						}
						else
						{
							$( checkbox ).prop( 'checked' , true );
						}

					},
					selectRow: function( row )
					{
						var checkbox 	= row.find( 'input[name=cid\\[\\]]' );

						$( checkbox ).prop( 'checked' , true );
					},

					implementSortable: function()
					{
						self.sortColumns().implement( EasySocial.Controller.Grid.Sort ,
						{
							"{parent}" 	: self
						});
					},

					implementPublishing: function()
					{
						self.publishItems().implement( EasySocial.Controller.Grid.Publishing,
						{
							"{parent}"	: self
						});
					},

					"{checkAll} change": function( element , event )
					{
						// Find all checkboxes in the grid.
						self.checkboxes().prop( 'checked' , $( element ).is( ':checked' ) );

						// Update the total number of checkboxes checked.
						var total 	= $( element ).is( ':checked' ) ? self.checkboxes().length : 0;


						self.setTotalChecked( total );
					}
				}
			}
		);

		module.resolve();
	});


});

EasySocial.module( 'admin/grid/sort' , function($) {

	var module = this;

	EasySocial.Controller(
		'Grid.Sort',
		{
			defaultOptions : 
			{
				items 	: "[data-grid-sort-item]"
			}
		},
		function( self )
		{
			return {

				init : function()
				{
				},

				"{self} click": function()
				{
					var direction 	= self.element.data( 'direction' ),
						column 		= self.element.data( 'sort' );

					// Set the ordering
					self.parent.setOrdering( column );

					// Set the direction
					self.parent.setDirection( direction );

					// Remove any task associated to the form.
					self.parent.setTask( '' );
					
					// Submit the form.
					self.parent.submitForm();
				}
			}
		}
	);
		
	module.resolve();

});
EasySocial.module( 'admin/grid/publishing' , function($) {

	var module = this;

	EasySocial.Controller(
		'Grid.Publishing',
		{
			defaultOptions : 
			{
			}
		},
		function( self )
		{
			return {

				init : function()
				{
				},

				"{self} click": function( el )
				{
					var row 	= self.element.parents( 'tr' ),
						task 	= self.element.data( 'task' );

					self.parent.selectRow( row );

					self.parent.setTask( task );

					self.parent.submitForm();
				}
			}
		}
	);
		
	module.resolve();

});
EasySocial.module( 'admin/grid/ordering' , function($) {

	var module = this;

	EasySocial.Controller('Grid.Ordering', {
		
		defaultOptions: {
			"{moveUp}": "[data-grid-order-up]",
			"{moveDown}": "[data-grid-order-down]",
			row: null
		}
	}, function(self) {
		return {

			init : function() {
				// Get the parent row
				self.options.row = self.element.parents( 'tr' );
			},

			selectRow : function() {
				var checkbox = self.options.row.find('input[name=cid\\[\\]]' );

				// Ensure that the checkbox is checked
				$(checkbox).prop('checked', true);
			},

			"{moveUp} click" : function() {
				self.selectRow();

				$.Joomla('submitform', ['moveUp']);
			},

			"{moveDown} click" : function() {
				self.selectRow();

				$.Joomla('submitform', ['moveDown']);
			}
		}
	});
		
	module.resolve();

});
EasySocial.module('admin/groups/groups' , function($) {

	var module = this;

	EasySocial
	.require()
	.library('expanding')
	.done(function($) {
		
		EasySocial.Controller('Groups.Pending.Item', {
				defaultOptions: {
					"{approve}": "[data-pending-approve]",
					"{reject}": "[data-pending-reject]"
				}
			}, function(self) { return {
				
				init: function() {
					self.options.id = self.element.data('id');
				},

				"{approve} click": function() {
					EasySocial.dialog({
						content: EasySocial.ajax( 'admin/views/groups/approveGroup' , { "ids" : self.options.id } )
					});
				},

				"{reject} click" : function() {
					EasySocial.dialog({
						content: EasySocial.ajax( 'admin/views/groups/rejectGroup' , { "ids" : self.options.id } )
					});
				}
		}});

		module.resolve();
	});

});
EasySocial.module('admin/groups/users', function($) {
    var module = this;

    EasySocial
        .require()
        .language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST')
        .done(function($) {
            EasySocial.Controller('Groups.Users', {
                defaultOptions: {
                    groupid: null,

                    '{addMember}': '[data-group-add-member]',
                    '{removeMember}': '[data-group-remove-member]',
                    '{approveMember}': '[data-group-approve-member]',
                    '{promoteMember}': '[data-group-promote-member]',
                    '{demoteMember}': '[data-group-demote-member]'
                }
            }, function(self) {
                return {
                    init: function() {

                    },

                    '{addMember} click': function(el, ev) {
                        var members = {};

                        window.addMembers = function(obj) {
                            if (obj.state) {
                                members[obj.id] = obj;
                            } else {
                                delete members[obj.id];
                            }
                        };

                        var confirmAddMembers = function() {
                            EasySocial.dialog({
                                content: EasySocial.ajax('admin/views/groups/confirmAddMembers', {
                                    members: members,
                                    groupid: self.options.groupid
                                }),
                                bindings: {
                                    '{submitButton} click': function() {
                                        this.addMembersForm().submit();
                                    }
                                }
                            });
                        };

                        EasySocial.dialog({
                            content: EasySocial.ajax('admin/views/groups/addMembers'),
                            bindings: {
                                '{submitButton} click': function() {
                                    confirmAddMembers();
                                }
                            }
                        });
                    },

                    '{removeMember} click': function(el, ev) {
                        if(document.adminForm.boxchecked.value == 0) {
                            alert($.language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST'));
                        } else {
                            $.Joomla('submitform', ['removeMembers']);
                        }
                    },

                    '{approveMember} click': function(el, ev) {
                        if(document.adminForm.boxchecked.value == 0) {
                            alert($.language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST'));
                        } else {
                            $.Joomla('submitform', ['publishUser']);
                        }
                    },

                    '{promoteMember} click': function(el, ev) {
                        if(document.adminForm.boxchecked.value == 0) {
                            alert($.language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST'));
                        } else {
                            $.Joomla('submitform', ['promoteMembers']);
                        }
                    },

                    '{demoteMember} click': function(el, ev) {
                        if(document.adminForm.boxchecked.value == 0) {
                            alert($.language('JLIB_HTML_PLEASE_MAKE_A_SELECTION_FROM_THE_LIST'));
                        } else {
                            $.Joomla('submitform', ['demoteMembers']);
                        }
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module( 'admin/indexer/indexer' , function($){

	var module	= this;

	EasySocial.require()
	.language(
		'COM_EASYSOCIAL_INDEXER_REINDEX_PROCESSING',
		'COM_EASYSOCIAL_INDEXER_REINDEX_FINISHED',
		'COM_EASYSOCIAL_INDEXER_REINDEX_RESTART'
		)
	.view( 'site/loading/small' )
	.done(function($){

		EasySocial.Controller(
		'Indexer',
		{
			defaultOptions:
			{
				// Elements
				"{startButton}"	: "[data-start-button]",
				"{indexerBar}" : "[data-indexer-bar]",
				"{indexerResult}" : "[data-indexer-result]",
				"{indexerMessage}" : "[data-indexer-message]",
				"{resultsButton}"	: "[data-results-button]",

				view :
				{
					loadingContent 	: "site/loading/small"
				}
			}
		},
		function( self ){
			return {

				init : function(){},

				"{startButton} click" : function()
				{
					self.runIndex( 0 );
					self.indexerMessage().html( $.language('COM_EASYSOCIAL_INDEXER_REINDEX_PROCESSING') );
					self.indexerMessage().show();
					self.startButton().hide();
				},

				runIndex : function( max ){

					//ajax call here.
					EasySocial.ajax( 'admin/controllers/indexer/indexing',
					{
						"max" 		: max,

					},
					{
						beforeSend: function()
						{
							// self.startButton().html( self.view.loadingContent() );
						}
					})
					.done(function( max, progress )
					{
						if( max < 0 )
						{
							progress = '100';
						}

						self.updateProgress( progress );

						if( max >= 0)
						{
							self.runIndex( max );
						}

					})
					.fail(function( message ){
						self.setMessage( message );
					})
					.always(function(){

					});


				},

				updateProgress: function( progress )
				{
					self.indexerBar().css( 'width', progress + '%')
					self.indexerResult().html( progress + '%' );

					if( progress == 100 )
					{
						self.indexerMessage().html( $.language( 'COM_EASYSOCIAL_INDEXER_REINDEX_FINISHED' ) );
						self.startButton().html( $.language( 'COM_EASYSOCIAL_INDEXER_REINDEX_RESTART' ) );
						self.startButton().show();

						self.resultsButton().removeClass('hide');
					}
				},



			}
		});

		module.resolve();
	});

});

EasySocial.module( 'admin/mailer/mailer' , function($) {

	var module = this;

	EasySocial.Controller(
		'Mailer',
		{
			defaultOptions :
			{
				"{item}"	: "[data-mailer-item]"
			}
		},
		function( self )
		{
			return {
				init : function()
				{
					self.item().implement( EasySocial.Controller.Mailer.Item );
				}
			}
		});

	EasySocial.Controller(
		'Mailer.Item',
		{
			defaultOptions :
			{
				"{preview}"	: "[data-mailer-item-preview]"
			}
		},
		function( self )
		{
			return {
				init : function()
				{
					self.options.id 	= self.element.data( 'id' );
				},

				"{preview} click" : function( el , event )
				{
					EasySocial.dialog(
					{
						content 	: EasySocial.ajax( 'admin/views/mailer/preview' , { 'id' : self.options.id } )
					})

				}
			}
		});

	module.resolve();

});

EasySocial.module('admin/maintenance/database', function($) {
    var module = this;

    EasySocial.Controller('Maintenance.Database', {
        defaultOptions: {
            '{start}': '[data-start]',

            '{progress}': '[data-progress]',

            '{progressBox}': '[data-progress-box]',

            '{progressBar}': '[data-progress-bar]',

            '{progressPercentage}': '[data-progress-percentage]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{start} click': function(el) {
                el.hide();

                self.progress().show();

                self.process();
            },

            counter: 0,

            versions: [],

            process: function() {
                self.getStats().done(function(versions) {
                    self.versions = versions;

                    self.execute();
                });
            },

            getStats: function() {
                return EasySocial.ajax('admin/controllers/maintenance/getDatabaseStats');
            },

            execute: function() {
                if (self.versions[self.counter] === undefined) {
                    return self.completed();
                }

                EasySocial.ajax('admin/controllers/maintenance/synchronizeDatabase', {
                    version: self.versions[self.counter]
                }).done(function() {
                    self.counter++;

                    var percentage = Math.floor((self.counter/self.versions.length) * 100) + '%';

                    self.progressBar().css('width', percentage);

                    self.progressPercentage().text(percentage);

                    self.execute();
                });
            },

            completed: function() {
                self.progressBar().css('width', '100%');

                self.progressPercentage().text('100%');

                self.progressBox()
                    .removeClass('progress-info')
                    .addClass('progress-success');
            }
        }
    });

    $('[data-base]').addController('EasySocial.Controller.Maintenance.Database');

    module.resolve();
});

EasySocial.module('admin/maintenance/maintenance', function($) {
    var module = this;

    EasySocial.Controller('Maintenance.Execute', {
        defaultOptions: {
            '{row}': '[data-row]'
        }
    }, function(self) {
        return {
            init: function() {
                self.runscript();
            },

            counter: 0,

            success: 0,

            fail: 0,

            runscript: function() {
                var row = self.row().eq(self.counter);

                if (row.length === 0) {
                    return self.completed();
                }

                var key = row.data('key');

                EasySocial.ajax('admin/controllers/maintenance/runscript', {
                    key: key
                }).done(function() {
                    self.setStatus(row, 1);
                    self.success++;
                }).fail(function() {
                    self.setStatus(row, 0);
                    self.fail++;
                }).always(function() {
                    self.counter++;
                    self.runscript();
                });
            },

            completed: function() {
                if (self.fail < 1) {
                    window.location = 'index.php?option=com_easysocial&view=maintenance&success=' + self.success;
                }
            },

            setStatus: function(row, state) {
                var status = row.find('[data-status]'),
                    icon = row.find('[data-icon]'),
                    statuses = ['label-danger', 'label-success', 'label-warning'],
                    icons = ['fa-exclamation-triangle', 'fa-check', 'fa-wrench'];

                for (i = 0; i < 3; i++) {
                    status.toggleClass(statuses[i], state == i);
                    icon.toggleClass(icons[i], state == i);
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module( 'admin/migrators/migrator' , function($) {

	var module = this;

	EasySocial.require()
	.script( 'progress/progress' )
	.done(function($){

		EasySocial.Controller(
			'Migrators.Migrator',
			{
				// A list of selectors we define
				// and expect template makers to follow.
				defaultOptions:
				{
					// Controller Properties.
					component 			: null,

					processState 		: 0,

					// Progress bar controller
					progressController : null,

					mapping 			: null,

					updateconfig 		: 0,


					"{initiateButton}"	: "[data-initiate-migration]",
					"{progressBar}" 	: ".discoverProgress",
					"{results}"			: ".scannedResult",
					"{viewLog}"			: ".viewLog",
					"{customFieldsMap}" : "[data-custom-fields-map]",

					"{resultForm}"		: "[data-migration-result]",

					"{startWidget}"		: "[data-start-widget]",
					"{fieldItem}"		: "[data-field-item]",

					"{startMigrationButton}" : "[data-start-migration]",

					"{rows}"			: "[data-row-item]",
					"{selection}"		: "[data-field-item]",

					"{jomsocialBackButton}" : "[data-jomsocial-back-button]"
				}
			},
			function(self){

				return {

					init: function()
					{
						// Initialize progress bar.
						self.initProgressBar();

						// Initialize the logging area.
						self.initLogging();
					},

					showCustomFields: function()
					{
						// Hide the initial section
						self.startWidget().slideUp();

						//Show the custom fields map.
						self.customFieldsMap().slideDown();
					},

					showResultForm: function()
					{
						self.customFieldsMap().slideUp();

						if( self.options.component != 'com_community' )
						{
							self.startWidget().slideUp();
						}

						self.resultForm().slideDown();
					},

					startMigration: function()
					{
						// Disable start button.
						// self.startButton().attr( 'disabled' , 'disabled' );

						self.showResultForm();

						// to prevent user click multiple times.
						if( self.options.processState == 1 )
						{
							return;
						}
						else
						{
							self.options.processState = 1;
						}

						self.reset();


						// Discover the list of files.
						EasySocial.ajax( 'admin/controllers/migrators/check' ,
						{
							'component' : self.options.component
						})
						.done(function( data )
						{

							if( data.isvalid )
							{
								// Begin progress.
								self.options.progressController.begin( data.count );

								// Begin to loop through each files.
								self.startIterating('');
							}
							else
							{
								// Ensure results is always hidden.
								self.results().show();

								// Add logging
								self.addLog( 'Error: ' + data.message );

								// reopen the process state.
								self.options.processState = 0;
							}

						});
					},

					// Resets the scan.
					reset: function()
					{
						// Reset the logs
						self.results().html('');

						// Hide the viewlog button
						self.initLogging();

						// Reset progress bar.
						self.options.progressController.reset();
					},

					initLogging: function()
					{
						// Ensure view log button is always hidden.
						self.viewLog().hide();
					},

					initProgressBar: function()
					{
						// Implement progressbar
						self.progressBar().implement( EasySocial.Controller.Progress );

						// Set this to the options so that we can easily access the controller.
						self.options.progressController	= self.progressBar().controller();
					},

					addLog: function( message )
					{
						$( '<li>' ).html( message )
							.appendTo( self.results() );
					},

					startIterating: function( item )
					{

						if( self.options.mapping == null )
						{
							if( self.selection().length > 0 )
							{
								self.options.mapping = $('#adminForm').serializeArray();
							}
						}

						EasySocial.ajax( 'admin/controllers/migrators/process' ,
						{
							"component"	: self.options.component,
							"item" 		: item,
							"mapping"	: self.options.mapping,
							"updateconfig"	: self.options.updateconfig,
						})
						.always(function( data, updateConfig )
						{

							self.options.updateconfig = updateConfig;

							// As long as the files list are not empty yet, we still need to process it.
							if( data["continue"] )
							{
								// Update once.
								self.options.progressController.touch( 'Discovering...' );

								// Append message to the result list.
								self.addLog( data.message );

								// Run this again.
								self.startIterating( data.item );
							}
							else
							{
								// Update once.
								self.options.progressController.touch( 'Discover Completed' );

								// Append message to the result list.
								self.addLog( data.message );

								// Append completed message to the result list since we know this is the last item.
								self.addLog( 'migration process completed.' );

								// Show view log button.
								self.viewLog().show();

								// Make the scan button work again.
								self.jomsocialBackButton().show();

								// reopen the process state.
								self.options.processState = 0;
							}
						});
					},

					"{fieldItem} change" : function( el )
					{
						var value 	= $( el ).val();

						// Add error class on row
						if( value == '' )
						{
							$( el ).parents( '[data-row-item]' ).removeClass( 'success' ).addClass( 'error' );
						}
						else
						{
							$( el ).parents( '[data-row-item]' ).removeClass( 'error' ).addClass( 'success' );
						}
					},

					"{startMigrationButton} click" : function()
					{
						// If there's error, show dialog and confirm that the user doesn't want to migrate
						// selected fields.
						if( self.selection().length > 0 )
						{
							self.selection().each( function( i, el ) {

								if( $( el ).val() == "" )
								{
									$( el ).parents( '[data-row-item]' ).removeClass( 'success' ).addClass( 'error' );
								}
								else
								{
									$( el ).parents( '[data-row-item]' ).removeClass( 'error' ).addClass( 'success' );
								}
							});
						}

						var hasError = self.rows().hasClass( 'error' );

						if( hasError )
						{
							EasySocial.dialog(
							{
								content 	: EasySocial.ajax( 'admin/views/migrators/confirmMigration' ),
								bindings 	:
								{
									"{submitButton} click" : function()
									{
										self.startMigration();

										EasySocial.dialog().close();
									}
								}
							});
						}
						else
						{
							// do lets this.
							self.startMigration();

						}

					},

					"{initiateButton} click" : function( element )
					{
						self.showCustomFields();
					},

					"{viewLog} click" : function()
					{
						self.results().toggle();
					}
				}

			}
		);

		module.resolve();
	});

});

EasySocial.module( 'admin/points/discover' , function($) {

	var module = this;

	EasySocial.require()
	.script( 'progress/progress' )
	.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' )
	.done(function($){

		EasySocial.Controller(
			'Points.Discover',
			{
				// A list of selectors we define
				// and expect template makers to follow.
				defaultOptions:
				{
					// Controller Properties.
					files 			: [],

					// Progress bar controller
					progressController : null,

					// Progress Bar
					"{progressBar}" : ".discoverProgress",

					// Logging results
					"{results}"		: "[data-points-discovery-result]"
				}
			},
			function(self){

				return {

					init: function() {
						// Initialize progress bar.
						self.initProgressBar();

						$.Joomla('submitbutton', function(task) {

							if (task == 'discover') {
								self.startDiscovering();
							}

							return;
						});
					},

					// Resets the scan.
					reset: function()
					{
						// Reset the logs
						self.results().html('');

						// Reset progress bar.
						self.options.progressController.reset();
					},

					initProgressBar: function()
					{
						// Implement progressbar
						self.progressBar().implement( EasySocial.Controller.Progress );

						// Set this to the options so that we can easily access the controller.
						self.options.progressController	= self.progressBar().controller();
					},

					addLog: function( message )
					{
						$( '<tr>' ).append( $( '<td>' ).html( message ) ).appendTo( self.results() );
					},

					startIterating: function()
					{
						// Get the file from the shelf
						var file 	= self.options.files.shift();

						EasySocial.ajax( 'admin/controllers/points/scan' ,
						{
							"file"	: file
						})
						.always(function( data , message , completeMessage ){

							// As long as the files list are not empty yet, we still need to process it.
							if( self.options.files.length > 0 )
							{
								// Update once.
								self.options.progressController.touch( '...' );

								// Append message to the result list.
								self.addLog( message );

								// Run this again.
								self.startIterating();
							}
							else
							{
								// Update once.
								self.options.progressController.touch( '...' );

								// Append message to the result list.
								self.addLog( message );

								// Append message to the result list.
								self.addLog( $.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' ) );
							}
						});
					},

					startDiscovering: function() {
						self.reset();

						// Discover the list of files.
						EasySocial.ajax( 'admin/controllers/points/discoverFiles' , {})
						.done(function( files , message )
						{
							self.reset();

							// Set the files to the properties.
							self.options.files 	= files;

							if( self.options.files.length > 0 )
							{
								// Begin progress.
								self.options.progressController.begin( self.options.files.length );

								// Add logging
								self.addLog( message );

								// Begin to loop through each files.
								self.startIterating();
							}
							else
							{
								// Update once.
								self.options.progressController.begin( 1 );
								self.options.progressController.completed( 'Discover Completed' );

								// Append message to the result list.
								self.addLog( $.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' ) );
							}


						});
					}
				}

			}
		);

		module.resolve();
	});

});

EasySocial.module( 'admin/polls/polls' , function($) {

	var module = this;

	EasySocial
	.require()
	.language( 
		'COM_EASYSOCIAL_CANCEL_BUTTON',
		'COM_EASYSOCIAL_CLOSE_BUTTON',
		'COM_EASYSOCIAL_POLLS_VIEW_POLLS_DIALOG_TITLE',
		'COM_EASYSOCIAL_POLLS_ACTIONS_DIALOG_TITLE'
	)
	.done( function($)
	{

		EasySocial.Controller(
			'Polls',
			{
				defaultOptions : 
				{
					"{item}"		: "[data-poll-item]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.item().implement( EasySocial.Controller.Polls.Item )
					}
				}
			});

		EasySocial.Controller(
			'Polls.Item',
			{
				defaultOptions :
				{
					"{action}"		: "[data-polls-item-view-actions]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.options.id 		= self.element.data( 'id' );
						self.options.extension	= self.element.data( 'extension' );
						self.options.uid 		= self.element.data( 'uid' );
						self.options.type 		= self.element.data( 'type' );
					},

					"{action} click" : function()
					{
						EasySocial.dialog( 
						{
							title 		: $.language( 'COM_EASYSOCIAL_REPORTS_ACTIONS_DIALOG_TITLE' ),
							content		: '<div>Perform some actions on the item</div>',
							width 		: 500,
							height 		: 250,
							buttons 	: 
							[
								{
									name 		: $.language( 'COM_EASYSOCIAL_CLOSE_BUTTON' ),
									classNames	: "btn btn-es",
									click 		: function()
									{
										EasySocial.dialog().close();
									}
								}
							]
						})
					}
				}
			})

		module.resolve();
	});

});
EasySocial.module( 'admin/privacy/discover' , function($) {

	var module = this;

	EasySocial.require()
	.script( 'progress/progress' )
	.done(function($){

		EasySocial.Controller(
			'Privacy.Discover',
			{
				// A list of selectors we define
				// and expect template makers to follow.
				defaultOptions:
				{
					// Controller Properties.
					files 			: [],

					// Progress bar controller
					progressController : null,

					// Start button
					"{startButton}"	: ".scanRules",

					// Progress Bar
					"{progressBar}" : ".discoverProgress",

					// Logging results
					"{results}"		: ".scannedResult",

					// View logs button.
					"{viewLog}"		: ".viewLog",

					// View items.
					view			:
					{
					}
				}
			},
			function(self){

				return {

					init: function()
					{
						// Initialize progress bar.
						self.initProgressBar();

						// Initialize the logging area.
						self.initLogging();
					},

					// Resets the scan.
					reset: function()
					{
						// Reset the logs
						self.results().html('');

						// Hide the viewlog button
						self.initLogging();

						// Reset progress bar.
						self.options.progressController.reset();
					},

					initLogging: function()
					{
						// Ensure view log button is always hidden.
						self.viewLog().hide();
					},

					initProgressBar: function()
					{
						// Implement progressbar
						self.progressBar().implement( EasySocial.Controller.Progress );

						// Set this to the options so that we can easily access the controller.
						self.options.progressController	= self.progressBar().controller();
					},

					addLog: function( message )
					{
						$( '<li>' ).html( message )
							.appendTo( self.results() );
					},

					startIterating: function()
					{
						// Get the file from the shelf
						var file 	= self.options.files.shift();

						EasySocial.ajax( 'admin/controllers/privacy/scan' ,
						{
							"file"	: file
						})
						.always(function( data ){

							// As long as the files list are not empty yet, we still need to process it.
							if( self.options.files.length > 0 )
							{
								// Update once.
								self.options.progressController.touch( 'Discovering...' );

								// Append message to the result list.
								self.addLog( 'Scanned ' + data.file + ' : ' + data.rules.length + ' rules installed.' );

								// Run this again.
								self.startIterating();
							}
							else
							{
								// Update once.
								self.options.progressController.touch( 'Discover Completed' );

								// Append message to the result list.
								self.addLog( 'Scanned ' + data.file + ' : ' + data.rules.length + ' rules installed.' );

								// Append completed message to the result list since we know this is the last item.
								self.addLog( 'Scanning completed.' );

								// Show view log button.
								self.viewLog().show();

								// Make the scan button work again.
								self.startButton().removeAttr( 'disabled' );
							}
						});
					},

					"{startButton} click" : function( element )
					{
						self.reset();

						// Disable start button.
						self.startButton().attr( 'disabled' , 'disabled' );

						// Discover the list of files.
						EasySocial.ajax( 'admin/controllers/privacy/discoverFiles' , {})
						.done(function( files ){

							// Set the files to the properties.
							self.options.files 	= files;

							if( self.options.files.length > 0 )
							{
								// Begin progress.
								self.options.progressController.begin( self.options.files.length );

								// Ensure results is always hidden.
								self.results().hide();

								// Add logging
								self.addLog( 'Found a total of ' + files.length + ' rules file in the site.' );

								// Begin to loop through each files.
								self.startIterating();
							}
							else
							{
								// Update once.
								self.options.progressController.begin( 1 );
								self.options.progressController.completed( 'Discover Completed' );

								// Append message to the result list.
								self.addLog( $.language( 'COM_EASYSOCIAL_SCAN_COMPLETED' ) );

								// Make the scan button work again.
								self.startButton().removeAttr( 'disabled' );
							}

						});
					},

					"{viewLog} click" : function()
					{
						self.results().toggle();
					}
				}

			}
		);

		module.resolve();
	});

});

EasySocial.module( 'admin/profiles/avatar' , function($){

	var module	= this;

	EasySocial.require()
	.script( 'uploader/uploader' )
	.done( function(){

		EasySocial.Controller(
			'Profiles.Avatar',
			{
				defaultOptions:
				{
					// Properties
					token 				: null,

					// Elements
					"{fileUploader}"		: "[data-profile-avatars-uploader]",
					"{startUploadButton}"	: "[data-profile-avatars-startupload]",
					"{avatarList}"			: "[data-profile-avatars-list]",
					"{avatarEmpty}"			: "[data-profile-avatars-empty]",
					"{avatarItem}"			: "[data-profile-avatars-item]",
					"{messagePlaceholder}"	: "[data-profile-avatars-message]",
					"{removeFile}"			: ".removeFile",
					"{clearUploadedItems}"	: "[data-uploader-clear]"
				}
			},
			function(self)
			{
				return {

					init: function()
					{
						// Get the current profile id
						self.options.id 	= self.element.data( 'id' );

						// Initialize upload controller
						self.initUploader();

						// Initialize avatar controller
						self.initAvatar();
					},

					initUploader: function()
					{
						// Apply uploader controller on the file uploader.
						self.fileUploader().implement( EasySocial.Controller.Uploader,
							{
								url : $.indexUrl + '?option=com_easysocial&namespace=admin/controllers/profiles/uploadDefaultAvatars&' + self.options.token + '=1&tmpl=component&format=ajax&uid=' + self.options.id
							});
					},

					initAvatar: function()
					{
						// Apply controller to avatar items.
						self.avatarItem().implement( 'EasySocial.Controller.Profiles.Avatar.Item',
						{
							"{parent}"	: self,
							items		: self.avatarItem
						});
					},

					addMessage: function( message )
					{
						// Clear previous messages first
						self.clearMessage();

						self.setMessage( message );
					},
					/**
					 * Override the file removal click event.
					 */
					"{removeFile} click" : function( el , event )
					{
						var id 	= $(el).parents( 'li' ).attr( 'id' );

						self.fileUploader().controller().removeItem( id );
					},

					/**
					 * Bind the click event on the start upload button.
					 */
					"{startUploadButton} click" : function()
					{
						var controller	= self.fileUploader().controller();

						controller.startUpload();
					},

					/**
					 * Track the progress of the uploaded item.
					 */
					"{fileUploader} UploadProgress" : function( el , event , file )
					{
						// Get the upload progress.
						var progress	= file.percent,
							elementId	= '#' + file.id,
							progressBar	= $( elementId ).find( '.progressBar' );

						// Show the progress bar.
						progressBar.show();

						// Update the width of the progress bar.
						progressBar.find( '.bar' ).css( 'width' , progress + '%' );
					},

					// Bind the UploadComplete method provided by uploader
					"{fileUploader} FileUploaded" : function( el, event, file, response )
					{
						if( response[ 0 ] != undefined )
						{
							var contents 	= response[0].data[ 0 ];

							// Hide empty if any
							self.avatarEmpty().hide();

							// Prepend the item
							self.avatarList().prepend( contents );

							self.clearUploadedItems().show();

							// Apply the controller
							self.initAvatar();
						}
					},

					"{clearUploadedItems} click" : function()
					{
						var controller 	= self.fileUploader().controller();

						// Reset the queue
						controller.reset();

						// Hide itself since there's no history now.
						self.clearUploadedItems().hide();
					}
				}
			}
		);

		/**
		 * Avatar item controller.
		 */
		EasySocial.Controller(
			'Profiles.Avatar.Item',
			{
				defaultOptions:
				{
					// Properties.
					id 		: null,

					"{deleteLink}"			: "[data-avatar-delete]",
					"{setDefaultAvatar}"	: "[data-avatar-default]"
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						self.options.id 	= self.element.data( 'id' );
					},

					/**
					 * Sets an avatar as the default avatar.
					 */
					"{setDefaultAvatar} click" : function(el , event )
					{
						EasySocial.ajax(
						'admin/controllers/avatars/setDefault',
						{
							"id" : self.options.id
						})
						.done(function( message )
						{
							// Remove all default class
							self.parent.avatarItem().removeClass( 'default' );

							// Add a default class to itself
							self.element.addClass( 'default' );

							self.parent.addMessage( message );
						});
					},

					"{deleteLink} click": function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'admin/views/profiles/confirmDeleteAvatar' ),
							bindings	: 
							{
								"{deleteButton} click" : function( el , event )
								{
									$( el ).addClass( 'btn-loading' );
									
									EasySocial.ajax( 'admin/controllers/avatars/delete' , 
									{
										"id" : self.options.id
									})
									.done(function( message )
									{										
										// Remove the element
										self.element.remove();

										if( self.parent.avatarList().children().length == 0 )
										{
											self.parent.avatarEmpty().show();
										}

										self.parent.addMessage( message );

										// Hide the dialog
										EasySocial.dialog().close();										
									});
								}
							}
						})
					}
				}
			});

		module.resolve();

	});

});



EasySocial.module( 'uploader/uploader' , function($){

	var module 	= this;

	EasySocial.require()
	.library( 'plupload' )
	.view('site/uploader/queue.item')
	.script( 'uploader/queue' )
	.done( function(){

		EasySocial.Controller('Uploader', {
				defaults: {
					url: $.indexUrl + '?option=com_easysocial&controller=uploader&task=uploadTemporary&format=json&tmpl=component&' + EasySocial.token() + '=1',
					uploaded: [],

					// Allows caller to define their custom query.
					query: "",

					plupload: '',
					dropArea: 'uploaderDragDrop',
					extensionsAllowed: 'jpg,jpeg,png,gif',

					// Determines if we should upload the file first or not
					temporaryUpload: false,

					// Contains a list of files in the queue so others can manipulate this.
					files: [],

					'{uploaderForm}': '[data-uploader-form]',
					'{uploadButton}': '[data-uploader-browse]',
					'{uploadArea}': '.uploadArea',

					// This contains the file list queue.
					'{queue}': '[data-uploaderQueue]',

					// The queue item.
					'{queueItem}': '[data-uploaderQueue-item]',

					// When the queue doesn't have any item, this is the container.
					'{emptyFiles}': '[data-uploader-empty]',

					// This is the file removal link.
					'{removeFile}': '[data-uploaderQueue-remove]',
					'{uploadCounter}': '.uploadCounter',

					view : {
						queueItem : "site/uploader/queue.item"
					}
				}
			}, function(self, opts, base){ return {

				init: function(){

					// Implement the uploader queue.
					self.queue().implement(EasySocial.Controller.Uploader.Queue);

					if (opts.temporaryUpload) {
						opts.url = $.indexUrl + '?option=com_easysocial&controller=uploader&task=uploadTemporary&format=json&tmpl=component&' + EasySocial.token() + '=1';
					}

					if (opts.query != '') {
						opts.url = opts.url + '&' + opts.query;
					}

					// Implement the plupload controller on the upload form
					self.uploaderForm().implement('plupload', {
						settings: {
							url: opts.url,
							drop_element: opts.dropArea,
							filters: [{
								title: 'Allowed File Type',
								extensions: opts.extensionsAllowed
							}]
						},
						'{uploader}': '[data-uploader-form]',
						'{uploadButton}': '[data-uploader-browse]'
					}, function() {
						// Get the plupload options
						opts.plupload = this.plupload;
					});
				},


				createFileItem: function(files) {
					
					$.each(files, function(index, file) {

						// Get the file size.
						file.size = self.formatSize(file.size);

						// Get the upload queue content.
						var content = self.view.queueItem({
												"file": file,
												"temporaryUpload" : self.options.temporaryUpload
									});

						// Implement the queue item controller.
						$(content).implement(EasySocial.Controller.Uploader.Queue.Item, {
							"{uploader}": self
						});

						// Add this item into our own queue.
						opts.files.push(file);

						// Hide the "No files" value
						self.emptyFiles().hide();

						// Append the queue item into the queue
						self.queue().append( content );
					});
				},

				/**
				 * Formats the size in bytes into kilobytes.
				 */
				formatSize: function(bytes) {

					// @TODO: Currently this only converts bytes to kilobytes.
					var val = parseInt( bytes / 1024 );

					return val;
				},

				/**
				 * Clears the list of upload items in the queue.
				 */
				reset: function() {
					// Remove the item from the list.
					self.queueItem().remove();
				},

				removeItem: function(id) {
					var element = $('#' + id);

					// When an item is removed, we need to send an ajax call to the server to delete this record
					var uploaderId = $(element).find('input[name=upload-id\\[\\]]').val();

					EasySocial.ajax( 'site/controllers/uploader/delete' , { "id" : uploaderId } )
					.done(function() {
						// Remove the item from the attachment list.
						$( '#' + id ).remove();

						// Now remove the item from the plupload queue.
						self.options.plupload.removeFile( self.options.plupload.getFile( id ) );
					});
				},

				startUpload: function() {
					self.upload();
				},

				upload: function() {
					
					if(self.options.plupload.files.length > 0) {
						self.options.uploading 	= true;
						self.options.plupload.start();
					}
				},

				 hasFiles: function(){
				 	return self.options.files.length > 0;
				 },

				"{uploaderForm} FilesAdded": function(el, event, uploader, files ) {
					
					// Add a file to the queue when files are selected.
					self.createFileItem(files);

					// Begin the upload immediately if needed
					if (opts.temporaryUpload) {
						self.startUpload();
					}
				},

				"{uploaderForm} UploadProgress" : function(el, event, uploader, file) {

					// Trigger upload progress on the queue item.
					if (file) {				
						self.queueItem('#' + file.id)
							.trigger('UploadProgress', file);
					}

				},

				'{uploaderForm} FileUploaded' : function( el , event, uploader, file , response ){
					// Trigger upload progress on the queue item.
					self.queueItem( '#' + file.id ).trigger( 'FileUploaded' , [file , response] );
				},

				"{uploaderForm} UploadComplete" : function(el, event , uploader , files) {
					self.options.uploading 	= false;
				},

				'{uploaderForm} Error': function(el, event, uploader, error) {
					// Clear previous message
					self.clearMessage();

					var obj = { 'message' : error.message , 'type' : 'error' };

					self.setMessage( obj );
				},

				'{uploaderForm} FileError': function(el, event, uploader, file, response) {
					var obj = { 'message' : response.message , 'type' : 'error' };

					self.setMessage(obj);

					self.queueItem( '#' + file.id ).trigger('FileError', [file, response]);
				}
			} }
		);

		module.resolve();
	});


});

EasySocial.module( 'uploader/queue' , function($){

	var module 	= this;

	EasySocial.require()
	.view( 'site/uploader/queue.item' )
	.done( function($){

		EasySocial.Controller(
			'Uploader.Queue',
			{
				defaults:
				{
					"{item}"	: "[data-uploaderQueue-item]"
				}
			},
			function( self ){

				return {

					init: function()
					{
						self.item().implement( EasySocial.Controller.Uploader.Queue.Item );
					}
				}
			}
		);

		EasySocial.Controller( 
			'Uploader.Queue.Item',
			{
				defaultOptions:
				{
					"{delete}"	: "[data-uploaderQueue-remove]",
					"{progress}": "[data-uploaderQueue-progress]",
					"{progressBar}" : "[data-uploaderQueue-progressBar]",
					"{status}"		: "[data-uploaderQueue-status]",
					"{id}"			: "[data-uploaderQueue-id]"
				}
			},
			function( self ){
				return {
					init : function()
					{

						if( self.uploader.options.temporaryUpload )
						{						
							// Store it as template and remove it
							self.idTemplate = self.id().toHTML();
							self.id().remove();
						}
					},

					"{delete} click" : function()
					{
						self.uploader.removeItem( self.element.attr( 'id' ) );
					},

					"{self} FileUploaded" : function( el , event , file , response )
					{
						// var response	= response[0];

						if( self.uploader.options.temporaryUpload )
						{
							// Create a hidden input containing the id
							$.buildHTML(self.idTemplate)
								.val(response.id)
								.appendTo(self.element);
						}

						if( file.status == 5 )
						{
							self.element.addClass( 'is-done' );
							self.status().html( 'Done' );
						}
					},

					"{self} UploadProgress" : function( el , event , progress )
					{
						// Set the progress.
						self.status().html( progress.percent + '%' );

						self.progressBar().css( 'width' , progress.percent + '%');
					},

					"{self} FileError": function()
					{
						self.element.removeClass("is-done is-queue").addClass("is-error");

						self.progress()
							.removeClass("progress-danger progress-success progress-info progress-warning")
							.addClass("progress-danger");

						self.status().html( 'Error' );
					}
				}
			}
		);

		module.resolve();
	});
});

EasySocial.module('admin/profiles/fields', function($) {
	var module = this;

	EasySocial.require()
	.library(
		'ui/draggable',
		'ui/sortable',
		'ui/droppable'
	)
	.script(
		'field'
	)
	.view(
		'admin/profiles/fields/editor.item',
		'admin/profiles/fields/step.item',
		'admin/profiles/fields/editor.page',
		'admin/profiles/fields/config',
		'admin/profiles/fields/dialog.move'
	)
	.language(
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_ITEM_CONFIG_LOADING',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_TITLE',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CONFIRMATION',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CONFIRM',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CANCEL',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_DELETING',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_TITLE',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_CONFIRMATION',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_CONFIRM',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_CANCEL',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_DELETING',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_PARAMS_CORE_UNIQUE_KEY_SAVE_FIRST',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_CONFIGURE_PAGE',
		'COM_EASYSOCIAL_PROFILES_FORM_FIELDS_CONFIGURE_FIELD',
		'COM_EASYSOCIAL_FIELDS_REQUIRE_MANDATORY_FIELDS',
		'COM_EASYSOCIAL_FIELDS_UNSAVED_CHANGES',
		'COM_EASYSOCIAL_FIELDS_INVALID_VALUES'
	)
	.done(function() {

		// Controller instance
		var $Parent, $Browser, $Editor, $Steps, $Config;

		// Data registry
		var $Apps = {}, $Core = {}, $Check = {}, $Fields = {}, $Pages = {};

		// Delete registry
		var $Deleted = {
			pages: [],
			fields: []
		}

		EasySocial.Controller('Fields', {
			defaultOptions: {
				id: 0,

				group: null,

				'{wrap}'		: '[data-fields-wrap]',

				'{browser}'		: '[data-fields-browser]',
				'{editor}'		: '[data-fields-editor]',
				'{steps}'		: '[data-fields-steps]',
				'{config}'		: '[data-fields-config]',
				'{saveForm}'	: '[data-fields-save]',

				view: {
					config: 'admin/profiles/fields/config'
				}
			}
		}, function(self) {
			return {

				init: function()
				{
					$Parent = self;

					// The id's are bound in data-id
					self.options.id = self.element.data('id');

					// Get the controller for field browser.
					$Browser	= self.addPlugin('browser');

					// Get the controller for field editor.
					$Editor		= self.addPlugin('editor');

					// Get the controller for steps.
					$Steps		= self.addPlugin('steps');

					var controllers = [$Browser.state, $Editor.state, $Steps.state];

					// Only trigger when all of the states is resolved
					$.when.apply(null, controllers).done(function() {
						$Parent.trigger('controllersReady');
					});

					// Listen to save event on profileForm to perform the save
					$('.profileForm').on('save', function(ev, task, result) {
						var data = self.save(task);
						result.push(data);
					});
				},

				changed: false,

				customFieldChanged: function() {
					self.changed = true;
				},

				'{window} beforeunload': function(el, ev) {
					if(self.changed) {
						return $.language('COM_EASYSOCIAL_FIELDS_UNSAVED_CHANGES');
					}
				},

				/**
				 * When save form is called, call each page's export function to get the data
				 */
				'{saveForm} click': function()
				{
					self.save();
				},

				/**
				 * Send the data to the controller to process the fields.
				 */
				save: function(task)
				{
					var dfd = $.Deferred();

					// Disable all input and select within this form to prevent them from getting through POST
					self.element.find('input,select').not(self.saveForm()).prop('disabled', true);

					// Reset saveform value first
					self.saveForm().val('');

					if( task === 'savecopy' )
					{
						self.changed = true;
					}

					// If no changes, then skip this saving
					if( !self.changed )
					{
						dfd.resolve();

						return dfd;
					}

					// Trigger saving event
					$Parent.trigger('saving');

					// If config is open, we run a internal populate first on the config
					if($Config && $Config.state) {
						if(!$Config.checkConfig()) {

							EasySocial.dialog({
								content: $.language('COM_EASYSOCIAL_FIELDS_INVALID_VALUES')
							});

							dfd.reject();

							return dfd;
						}
					}

					// Clone a non-referenced $Core object into $Check
					$Check = $.extend(true, {}, $Core);

					var data = [];

					// Loop through each step
					$.each($Steps.step(), function(i, step) {
						step = $(step);

						// Get the step's page controller
						var page = $Editor.getPage(step.data('id'));

						// Call the page's export function to get the data of the page
						data.push(page._export());
					});

					// Check if all core apps has been used
					if($._.keys($Check).length > 0) {
						// Trigger saved event and pass in false to indicate error
						$Parent.trigger('saved', [false]);

						EasySocial.dialog({
							content: $.language('COM_EASYSOCIAL_FIELDS_REQUIRE_MANDATORY_FIELDS')
						});

						dfd.reject();

						return dfd;
					}

					$Parent.changed = false;

					var saveData = {
						data: data,
						deleted: $Deleted
					};

					self.injectSaveData(saveData);

					dfd.resolve();

					return dfd;
				},

				/**
				 * Responsible to inject the data object into the hidden input for POST processing
				 */
				injectSaveData: function(data) {
					data = JSON.stringify(data);

					self.saveForm().val(data);
				},

				/**
				 * Update the form based on the returned data
				 */
				updateResult: function(data)
				{
					// It has the same format as the data
					$.each(data, function(i, dataStep) {
						// Get the step based on index (sequence)
						var step = $Steps.step().eq(i);

						// Assign step id first
						var stepid = step.data('id');

						// Get the page
						var page = $Editor.getPage(stepid);

						// Update the step id
						$Steps.updateResult(i, dataStep.id);

						// Update the page id
						page.updateResult(stepid, dataStep);
					});
				},

				'{self} doneConfiguring': function() {
					self.element.removeClass('editting');
				},

				loadConfiguration: function(item, type) {
					self.element.addClass('editting');

					// var config = self.config().clone();
					var config = $(self.view.config());

					$Config = config.addController('EasySocial.Controller.Fields.Config', {
						controller: {
							item: item
						}
					});

					if(type === 'page')
					{
						item.pageHeader().append(config);
					}
					else
					{
						item.element.append(config);
					}

					// $('body').append(config);

					self.element.trigger('loadingConfig', [type]);
				}
			}
		});

		/* Browser Controller */
		EasySocial.Controller('Fields.Browser', {
			defaultOptions: {
				'{browser}'		: '[data-fields-browser]',

				'{mandatory}'	: '[data-fields-browser-group-mandatory]',
				'{unique}'		: '[data-fields-browser-group-unique]',
				'{standard}'	: '[data-fields-browser-group-standard]',

				'{list}'		: '[data-fields-browser-list]',
				'{item}'		: '[data-fields-browser-item]',

				'affixClass'	: 'es-browser-affix'
			}
		}, function(self) {
			return {
				state: $.Deferred(),

				init: function() {
					// Things to do before resolving self
					self.registerApps();

					self.ready();

					self.affixHandler();

					self.initAffix();
				},

				ready: function() {
					self.state.resolve();
				},

				'{parent} controllersReady': function() {
					var id = $Steps.getCurrentStep().data('id');

					self.initDraggable(id);
				},

				'{parent} pageChanged': function(el, ev, page, uid) {
					self.item().draggable('destroy');

					self.initDraggable(uid);
				},

				'{parent} pageAdded': function(el, ev, page, uid) {
					self.item().draggable('destroy');

					self.initDraggable(uid);
				},

				initDraggable: function(id) {
					self.item().draggable({
						revert: 'invalid',
						helper: 'clone',
						connectToSortable: '[data-fields-editor-page-items-' + id + ']'
					});
				},

				affixHandler: function() {
					var parent = $(window),
						wrap = self.parent.wrap(),
						height = wrap.offset().top,
						scroll = parent.scrollTop();

					if(scroll > height && !self.browser().hasClass(self.options.affixClass)) {
						self.browser().addClass(self.options.affixClass);
					}

					if(scroll <= height && self.browser().hasClass(self.options.affixClass)) {
						self.browser().removeClass(self.options.affixClass);
					}
				},

				initAffix: function() {
					$(window).scroll(self.affixHandler);
				},

				registerApps: function() {
					// Register all available apps into an object
					$.each(self.item(), function(index, item) {
						item = $(item);

						var id = item.data('id');

						$Apps[id] = {
							id: id,
							element: item.data('element'),
							title: item.data('title'),
							params: item.data('params'),
							core: item.data('core'),
							unique: item.data('unique'),
							item: item
						};

						// Keep a list of core apps id in $Core
						if(item.data('core')) {
							$Core[id] = $Apps[id];
						}
					});
				},

				/**
				 * Used to check if core apps has been used in saving. Core apps have to be completely used to saved.
				 */
				checkout: function(id) {
					if($Check[id] !== undefined) {
						delete $Check[id];
					}
				},

				/**
				 * This is the event handler for the field items selection.
				 */
				'{item} click': function(el) {
					// Get the current page.
					var currentPage = $Editor.currentPage();

					// Get the app id of the item clicked
					var appid = el.data('id');

					// Add new item to the page
					currentPage.addNewField(appid);
				},

				/**
				 * Carry out any necessary actions when app is added as a field
				 */
				'{parent} fieldAdded': function(el, event, appid) {
					var app = $Apps[appid];

					if(app && app.core) {
						app.item.hide();

						// If core app is added, check if there are any remaining core app left to hide the core group
						var items = self.mandatory().find(self.item.selector).filter(':visible');

						self.mandatory().toggle((items.length > 0));
					}

					if(app && app.unique) {
						app.item.hide();

						// If unique app is added, check if there are any remaining unique app left to hide the unique group
						var items = self.unique().find(self.item.selector).filter(':visible');

						self.unique().toggle((items.length > 0));
					}
				},

				/**
				 * Carry out any necessary actions when field is removed
				 */
				'{parent} fieldDeleted': function(el, event, appid, fieldid) {
					var app = $Apps[appid];

					if(app && app.core) {
						app.item.show();

						// If core app is deleted, then the browser group for core fields have to definitely show
						self.mandatory().show();

						return;
					}

					if(app && app.unique) {
						app.item.show();

						// If unique app is deleted, then the browser group for unique fields have to definitely show
						self.unique().show();

						return;
					}
				}
			}
		});

		/* Config Controller */
		EasySocial.Controller('Fields.Config', {
			defaultOptions: {
				'{config}'		: '[data-fields-config]',

				'{header}'		: '[data-fields-config-header]',

				'{close}'		: '[data-fields-config-close]',

				'{form}'		: '[data-fields-config-form]',

				'{param}'		: '[data-fields-config-param]',

				'{tabnav}'		: '[data-fields-config-tab-nav]',
				'{tabcontent}'	: '[data-fields-config-tab-content]',

				'{done}'		: '[data-fields-config-done]'
			}
		}, function(self) {
			return {
				init: function() {
				},

				state: false,

				load: function(config) {
					// Set state to true to indicate editting mode
					self.state = true;

					// Apply multi choices
					config.find('[data-fields-config-param-choices]').addController('EasySocial.Controller.Config.Choices', {
						controller: {
							item: self.item
						}
					});

					// Hide the field title
					config.find( 'h4' ).hide();

					// Update the header
					self.header().html( config.find( 'h4' ).html() );

					// Inject the html into the form
					self.form().html(config);

					// Carry out necessary actions after config has been loaded if this is a new field
					if(self.item.options.newfield) {

						// Disable the unique key field if it is a new field
						self.param('[data-fields-config-param-field-unique_key]')
							.attr('disabled', true)
							.val($.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_PARAMS_CORE_UNIQUE_KEY_SAVE_FIRST'));
					}

					// Load the first tab as active
					if(self.tabnav().length > 0) {
						var coreTab = self.tabnav().find('a[data-tabname="core"]');

						if(coreTab.length > 0) {
							coreTab.tab('show');
						} else {
							self.tabnav().find('a:first').tab('show');
						}
					}

					self.populateConfig();

					// Get the config height for css fix
					var configHeight = self.element.height();

					$Parent.wrap().css('padding-bottom', configHeight + 'px');

					$Parent.trigger('configLoaded');
				},

				'{close} click': function(el, ev) {
					self.closeConfig();
				},

				'{done} click': function(el, ev) {
					self.closeConfig();
				},

				closeConfig: function() {
					var values = self.populateConfig();

					// Check through the values
					var state = self.checkConfig(values);

					if(state) {
						self.item.updateHtml(self.form().html());

						self.item.content().trigger('onConfigSave', [values]);

						self.element.remove();

						$Config = null;

						$Parent.trigger('doneConfiguring');
					} else {
						EasySocial.dialog({
							content: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_INVALID_VALUES'),
							width: 400,
							height: 100
						});
					}
				},

				'{parent} loadingConfig': function(el, ev, header) {

					// Set the config header
					if(header !== undefined && header != 'field' )
					{
						var headerText = $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_CONFIGURE_' + header.toUpperCase());
						self.header().html(headerText);
					}

					// Show the config panel
					self.config().show();

					// Hide the close button first
					self.close().hide();

					// Set the loading state
					self.form().html($.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_ITEM_CONFIG_LOADING'));
				},

				'{parent} configLoaded': function(el, ev) {
					self.close().show();
				},

				'{param} change': function(el) {
					self.paramChanged(el);
				},

				'{param} keyup': function(el) {
					self.paramChanged(el);
				},

				paramChanged: function(el) {
					var name = el.data('name'),
						value = self.getConfigValue(name);

					var field = self.item.appParams[name];

					// Manually convert boolean field into boolean value for toggle to work properly
					if(field.type === 'boolean') {
						value = !!value;
					}

					self.item.fieldItem().trigger('onConfigChange', [name, value]);

					$Parent.customFieldChanged();
				},

				getConfigValue: function(name) {
					var field = self.item.appParams[name],
						// element = self.param('[data-fields-config-param-field-' + name +']');
						element = self.param().filterBy('name', name);

					if(element.length === 0) {
						return undefined;
					}

					var values = '';

					switch(field.type) {
						case 'choices':
							values = [];

							$.each(element.find('li'), function(i, choice) {
								choice = $(choice);

								var titleField = choice.find('[data-fields-config-param-choice-title]'),
									valueField = choice.find('[data-fields-config-param-choice-value]'),
									defaultField = choice.find('[data-fields-config-param-choice-default]');

								values.push({
									'id': choice.data('id'),
									'title': titleField.val(),
									'value': valueField.val(),
									'default': defaultField.val()
								});

								titleField.attr('value', titleField.val());
								valueField.attr('value', valueField.val());
								defaultField.attr('value', defaultField.val());
							});
						break;

						case 'boolean':
							var tmp = element.val();

							values = (tmp === 'true' || tmp === '1' || tmp === 1) ? 1 : 0;

							element.attr('value', values);
						break;

						case 'checkbox':
							values = [];
							$.each(field.option, function(k, option) {
								var checkbox = element.filter('[data-fields-config-param-option-' + option.value + ']');

								if(checkbox.length > 0 && checkbox.is(':checked')) {
									values.push(option.value);

									checkbox.attr('checked', 'checked');
								} else {
									checkbox.removeAttr('checked');
								}
							});
						break;

						case 'list':
						case 'select':
						case 'dropdown':
							values = element.length > 0 ? element.val() : field["default"] || '';

							element.find('option').prop('selected', false);

							element.find('option[value="' + values + '"]').prop('selected', true);
						break;

						case 'input':
					case 'text':
						default:
							values = element.length > 0 ? element.val() : field["default"] || '';

							element.attr('value', values);
						break;
					}

					return values;
				},

				populateConfig: function() {
					var data = {};

					$.each(self.item.appParams, function(name, field) {
						var value = self.getConfigValue(name);

						if(value === undefined) {
							// If getConfigValue returns undefined, means this field is not found, then skip to the next field
							return false;
						}

						data[name] = value;
					});

					self.item.trigger('onPopulateConfig', [data]);

					return data;
				},

				checkConfig: function(values) {
					if(values === undefined) {
						values = self.populateConfig();
					}

					// Perform custom checks here
					var state = true;

					$.each(values, function(name, value) {
						var field = self.item.appParams[name];

						switch(field.type) {
							// custom check for choices
							case 'choices':
								// Get all the values first
								var choiceValues = [];

								$.each(value, function(i, choice) {
									if($.isEmpty(choice.value) && !$.isEmpty(choice.title)) {
										choice.value = choice.title.toLowerCase().replace(' ', '');
									}

									if(!$.isEmpty(choice.value) && $.inArray(choice.value, choiceValues) > -1) {
										state = false;
										return false;
									}

									choiceValues.push(choice.value);

									// if((!$.isEmpty(choice.title) && $.isEmpty(choice.value)) || ($.isEmpty(choice.title) && !$.isEmpty(choice.value))) {
									// 	state = false;
									// 	return false;
									// }
								});
							break;
						}

						if(state === false) {
							return false;
						}
					});

					return state;
				},

				'{parent} fieldDeleted': function() {
					if(self.state) {
						$Parent.trigger('doneConfiguring');
					}
				},

				'{parent} pageDeleted': function() {
					if(self.state) {
						$Parent.trigger('doneConfiguring');
					}
				},

				'{parent} pageAdded': function() {
					if(self.state) {
						$Parent.trigger('doneConfiguring');
					}
				},

				'{parent} pageChanged': function() {
					if(self.state) {
						$Parent.trigger('doneConfiguring');
					}
				}
			}
		});

		/* Steps Controller */
		EasySocial.Controller('Fields.Steps', {
			defaultOptions: {
				'{steps}'	: '[data-fields-step]',

				// The step item.
				'{step}'	: '[data-fields-step-item]',

				// The link of each step.
				'{stepLink}': '[data-fields-step-item-link]',

				// The add step button
				'{add}'		: '[data-fields-step-add]',

				view: {
					stepItem: 'admin/profiles/fields/step.item'
				}
			}
		}, function(self) {

			return {
				state: $.Deferred(),

				init: function() {
					self.ready();
				},

				ready: function() {
					self.state.resolve();
				},

				// Delayed init
				'{parent} controllersReady': function() {
					self.initSort();
				},

				initSort: function() {
					self.steps().sortable({
						items: self.step.selector,
						placeholder: 'ui-state-highlight',
						cursor: 'move',
						helper: 'clone',
						forceHelperSize: true,
						stop: function() {
							// Manually remove all the freezing tooltip due to conflict between bootstrap tooltip and jquery sortable
							$('.tooltip-es').remove();

							// Mark as changed
							$Parent.customFieldChanged();
						}
					});
				},

				'{parent} pageDeleted': function(el, event, uid) {
					self.deleteStep(uid);

					// Load the first step as the active page
					if($Steps.step().length > 0) {
						$Steps.stepLink(':first').tab('show');
					}
				},

				'{step} click': function(el, ev) {
					if(!el.hasClass('active')) {
						var id = el.data('id');
						$Parent.trigger('pageChanged', [$Editor.getPage(id), id]);
					}
				},

				/**
				 * Creates a new step.
				 */
				'{add} click': function() {
					// Generate an unique id to link between step and page
					var stepuid = $.uid('step');

					// Add a new step progress at the progress list.
					self.addStep(stepuid);

					// Add a new page form.
					$Editor.addPage(stepuid);

					// Go to the last page automatically since the last page would be the item that is created.
					self.stepLink(':last').tab('show');
				},

				addStep: function(uid) {
					// Always add new step before before the add button
					self.add().before(self.view.stepItem({
						uid: uid
					}));

				},

				getStep: function(uid) {
					return self.step().filterBy('id', uid);
				},

				getStepLink: function(uid) {
					return self.stepLink().filterBy('id', uid);
				},

				deleteStep: function(uid) {
					self.getStep(uid).remove();
				},

				getCurrentStep: function() {
					return self.step('.active');
				},

				currentStepIndex: function() {
					return self.step().index(self.step('.active')) + 1;
				},

				updateResult: function(sequence, newid) {
					var step = self.step(':eq(' + sequence + ')');

					if(step.data('id') != newid) {
						var oldid = step.data('id');

						step.removeAttr('data-fields-step-item-' + oldid);

						step.attr('data-fields-step-item-' + newid, true);

						step.data('id', newid);

						step.attr('data-id', newid);

						var stepLink = self.stepLink().eq(sequence);

						stepLink.removeAttr('data-fields-step-item-link-' + oldid);

						stepLink.attr('data-fields-step-item-link-' + newid, true);

						stepLink.attr('href', '#formStep_' + newid);
					}
				},

				toObject: function() {
					var data = [];

					$.each(self.stepLink(), function(i, step) {
						step = $(step);

						data.push({
							uid: step.data('id'),
							title: step.text(),
							description: step.attr('data-original-title')
						});
					});

					return data;
				}
			}
		});

		/* Editor Controller */
		EasySocial.Controller('Fields.Editor', {
			defaultOptions: {
				'{editor}'	: '[data-fields-editor]',

				'{page}'	: '[data-fields-editor-page]',

				'{items}'	: '[data-fields-editor-page-items]',
				'{item}'	: '[data-fields-editor-page-item]',

				view: {
					editorPage: 'admin/profiles/fields/editor.page'
				}
			}
		}, function(self) {
			return {
				state: $.Deferred(),

				init: function() {
					self.ready();
				},

				ready: function() {
					self.state.resolve();
				},

				'{parent} controllersReady': function() {
					// Implements page controller to all pages
					self.page().addController('EasySocial.Controller.Fields.Editor.Page');
				},

				/**
				 * Returns the current page's controller
				 */
				currentPage: function() {
					return self.page('.active').controller();
				},

				/**
				 * Creates a new page container.
				 */
				addPage: function(uid) {
					// Create a new page item
					var newPage = self.view.editorPage({
						uid: uid
					});

					// Initialize the page controller
					newPage.addController('EasySocial.Controller.Fields.Editor.Page', {
						uid: uid,
						newpage: true,
					});

					// Append the new page
					// self.pages().append(newPage.element);
					self.editor().append(newPage);

					// Trigger pageAdded event on all the pages
					self.page().trigger('pageAdded', [newPage, uid]);

					$Parent.customFieldChanged();
				},

				/**
				 * Returns a page controller container based on uid
				 */
				getPage: function(uid) {
					return self.page().filterBy('id', uid).controller();
				},

				/**
				 * Carry out the necessary action when form is saving
				 */
				'{parent} saving': function(el, event) {
					self.element.addClass('saving');
				},

				/**
				 * Carry out the necessary action when form is saved
				 */
				'{parent} saved': function(el, event, state) {
					// If state is false, this means error during saving
					if(state === false) {
						// TODO: Dialog box needed
					}

					self.element.removeClass('saving');
				}
			}
		});

		/* Editor Page Controller */
		EasySocial.Controller('Fields.Editor.Page', {
			defaultOptions: {
				// This is the stepid stored in the db
				pageid						: 0,

				// This is the unique id generated if the page is a new page
				uid							: 0,

				newpage						: false,

				'{items}'					: '[data-fields-editor-page-items]',
				'{item}'					: '[data-fields-editor-page-item]',

				'{pageHeader}'				: '[data-fields-editor-page-header]',

				// $Config compatibility
				'{content}'					: '[data-fields-editor-page-header]',
				'{fieldItem}'					: '[data-fields-editor-page-header]',

				'{pageTitle}'				: '[data-fields-editor-page-title]',
				'{pageDescription}'			: '[data-fields-editor-page-description]',

				'{inputTitle}'				: '[data-fields-editor-page-title-input]',
				'{inputDescription}'		: '[data-fields-editor-page-description-input]',

				'{pageVisibleRegistration}'	: '[data-fields-editor-page-visible-registration]',
				'{pageVisibleEdit}'			: '[data-fields-editor-page-visible-edit]',
				'{pageVisibleView}'			: '[data-fields-editor-page-visible-view]',
				'{pageDelete}'				: '[data-fields-editor-page-delete]',
				'{pageEdit}'				: '[data-fields-editor-page-edit]',
				'{pageInfo}'				: '[data-fields-editor-page-info]',
				'{pageInfoDone}'			: '[data-fields-editor-page-done]',

				view: {
					editorItem: 'admin/profiles/fields/editor.item'
				}
			}
		}, function(self) {

			return {
				init: function() {

					// Assign uid as pageid if this is not a new page
					if(!self.options.newpage)
					{
						self.options.uid = self.options.pageid = self.element.data('id');
					}

					// Register self into Pages registry
					self.registerPage();

					self.item().addController('EasySocial.Controller.Fields.Editor.Item', {
						pageid: self.options.uid
					});

					// Check for delete button state
					self.checkPageDeleteButton();

					// Init the sorting
					self.initSort();
				},

				// Keep a registry of current page's fields
				fields: {},

				getStep: function() {
					return $Steps.getStep(self.options.uid);
				},

				registerPage: function() {
					$Pages[self.options.uid] = self;
				},

				initSort: function() {
					self.items().sortable({
						items: self.item.selector,
						handle: '[data-fields-editor-page-item-handle]',
						placeholder: 'ui-state-highlight',
						cursor: 'move',
						helper: 'clone',
						forceHelperSize: true,
						stop: function(event, ui) {
							if(ui.item.is($Browser.item.selector)) {
								var appid = ui.item.data('id');

								// Create a placeholder first
								var placeholder = self.createPlaceholder();
								ui.item.replaceWith(placeholder);

								// Create new field and let it replace the placeholder
								self.createNewField(appid, placeholder);
							}

							// Mark change
							$Parent.customFieldChanged();
						}
					});
				},

				addNewField: function(appid) {
					// Append a placeholder first
					var placeholder = self.createPlaceholder();
					self.items().append(placeholder);

					$.scrollTo(placeholder, 200);

					// Create new field and let new field replace the placeholder
					self.createNewField(appid, placeholder);

					$Parent.customFieldChanged();
				},

				createPlaceholder: function() {
					// Generate a uid first
					var uid = $.uid('newfield');

					// Generate a placeholder
					var placeholder = self.view.editorItem({
						uid: uid
					});

					return placeholder;
				},

				createNewField: function(appid, placeholder) {
					// Trigger fieldAdded event
					$Parent.trigger('fieldAdded', [appid]);

					// get the html asyncly
					self.getFieldHtml(appid)
						.done(function(html) {
							// Third parameter set to true to preserve script tags
							html = $.parseHTML(html, document, true);

							// Wrap the whole parsed html as jquery object
							html = $(html);

							// Replace the original loading placeholder with the html object
							placeholder.replaceWith(html);

							// Retrieve the main div to implement item controller
							var div = html.filter('[data-appid="' + appid + '"]');

							// Implement the item controller
							div.addController('EasySocial.Controller.Fields.Editor.Item', {
								controller: {
									page: self
								},

								appid: appid,
								pageid: self.options.uid,
								newfield: true,
							});
						}).fail(function(msg) {
							placeholder.html(msg);
						});
				},

				getFieldHtml: function(appid) {
					var state = $.Deferred();

					if($Apps[appid].html === undefined) {
						EasySocial.ajax('admin/controllers/fields/renderSample', {
							appid: appid,
							profileid: $Parent.options.id,
							group: $Parent.options.group
						}).done(function(html) {
							$Apps[appid].html = html;

							state.resolve(html);
						}).fail(function(msg) {
							state.reject(msg);
						});
					} else {
						state.resolve($Apps[appid].html);
					}

					return state;
				},

				'{pageHeader} click': function(el, event) {
					var clickedTarget = $(event.target);

					if(clickedTarget.not('[data-fields-editor-page-delete]') && !el.hasClass('editting')) {

						if($Config && $Config.state) {

							var state = $Config.checkConfig();

							// Remove itself from other field
							if(state) {
								$Config.closeConfig();
							} else {
								EasySocial.dialog({
									content: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_INVALID_VALUES'),
									width: 400,
									height: 100
								});

								return;
							}
						}

						self.loadConfiguration();
					}
				},

				loadConfiguration: function() {
					$Parent.loadConfiguration(self, 'page');

					self.pageHeader().addClass('editting');

					self.getPageConfig()
						.done(function() {
							var pageConfig = $(self.html);

							$Config.load(pageConfig);
						})
						.fail(function(msg) {
							$Config.load(msg);
						});
				},

				updateHtml: function(html) {
					self.html = html;
				},

				getPageConfig: function() {
					var state = $.Deferred();

					if(!$.isEmptyObject(self.params)) {
						state.resolve();
					} else {
						EasySocial.ajax('admin/controllers/fields/renderPageConfig', {
							pageid: self.options.pageid
						})
						.done(function(params, values, html) {
							self.params = params;
							self.values = values;
							self.html = html;

							// Compatibility with $Config
							self.appParams = params;

							state.resolve();
						})
						.fail(function(msg) {
							state.reject(msg);
						});
					}

					return state;
				},

				getConfigValues: function() {
					return self.values;
				},

				'{fieldItem} onConfigChange': function(el, ev, name, value) {

					self.values[name] = value;

					var step = $Steps.getStepLink(self.options.uid);


					if(name === 'title') {

						step.text(value);

						self.pageTitle().html(value);
					}

					if(name === 'description') {
						// Used attr('data-original-title') instead of data('original-title') because the tooltip reads the attribute directly while data() adds the value back as a jQuery data on to the element
						step.attr('data-original-title', value);

						self.pageDescription().html(value);
					}

					$Parent.customFieldChanged();
				},

				'{pageDelete} click': function(el) {
					if(el.enabled()) {
						el.disabled(true);

						// If it is the last page, then it shouldn't delete.
						if($Editor.page().length == 1) {
							el.enabled(true);

							// @TODO: error box needed

							return false;
						}

						EasySocial.dialog({
							width: 400,
							height: 150,
							title: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_TITLE'),
							content: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CONFIRMATION'),
							showOverlay: false,
							buttons: [
								{
									// CANCEL button
									name: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CANCEL'),
									classNames: 'btn btn-es',
									click: function() {
										el.enabled(true);
										EasySocial.dialog().close();
									}
								},
								{
									// DELETE button
									name: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CONFIRM'),
									classNames: 'btn btn-es-danger',
									click: function() {
										// Update the dialog content first
										EasySocial.dialog().update({
											content: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_DELETING')
										});

										// Start deleting the page
										self.deletePage();

										// Close the dialog
										EasySocial.dialog().close();
									}
								}
							]
						});
					}
				},

				deletePage: function() {
					// Trigger pageDeleted event
					self.item().trigger('pageDeleted');
					$Parent.trigger('pageDeleted', [self.options.uid]);

					// Remove self from $Pages registry
					delete $Pages[self.options.uid];

					// Add self into $DeletedPages registry
					if(!self.options.newpage) {
						$Deleted.pages.push(self.options.uid);
					}

					// Removed current page
					self.element.remove();

					// Check for delete button
					$.each($Editor.page(), function(i, page) {
						$(page).controller().checkPageDeleteButton();
					});

					$Parent.customFieldChanged();
				},

				_export: function() {
					var fields = [];

					$.each(self.item(), function(j, item) {
						item = $(item).controller();

						if(item !== undefined)
						{
							fields.push(item._export());
						}
					});

					var data = {
						fields: fields,
						newpage: self.options.newpage,
						id: self.options.uid
					}

					if(self.values !== undefined) {
						var data = $.extend(data, self.values);
					}

					return data;
				},

				updateResult: function(oldid, data) {
					if(self.options.newpage) {

						// Update the page element id attribute (to correspond with the step tab structure)
						self.element.attr('id', 'formStep_' + data.id);

						// Remove the old selector and add in the new selector
						self.element.removeAttr('data-fields-editor-page-' + oldid);
						self.element.attr('data-fields-editor-page-' + data.id, true);

						// Assign pageid to self.options
						self.options.pageid = self.options.uid = data.id;

						// Update the $Pages registry
						$Pages[data.id] = $.extend(true, {}, $Pages[oldid]);
						delete $Pages[oldid];

						// Since the page has been saved, then it should not be a new page anymore
						self.options.newpage = false;
					}

					if(data.fields !== undefined) {
						$.each(data.fields, function(i, field) {
							// Go by sequence
							var item = self.item().eq(i).controller();

							item.updateResult(field);
						});
					}
				},

				/**
				 * Carry out necessary action when a new page is added
				 */
				'{self} pageAdded': function(el, event, page) {
					self.checkPageDeleteButton();

					$Parent.customFieldChanged();
				},

				checkPageDeleteButton: function() {
					if($Editor.page().length > 1) {
						self.pageDelete().show();
					} else {
						self.pageDelete().hide();
					}
				},

				'{parent} loadingConfig': function() {
					self.pageHeader().removeClass('editting');
					self.item().removeClass('editting');
				},

				'{parent} doneConfiguring': function() {
					self.pageHeader().removeClass('editting');
					self.item().removeClass('editting');
				}
			}
		});

		/* Editor Item Controller */
		EasySocial.Controller('Fields.Editor.Item', {
			defaultOptions: {
				appid			: 0,
				fieldid			: 0,
				pageid			: 0,

				newfield		: false,

				'{edit}'		: '[data-fields-editor-page-item-edit]',
				'{deleteButton}': '[data-fields-editor-page-item-delete]',
				'{moveButton}'	: '[data-fields-editor-page-item-move]',
				'{content}'		: '[data-fields-editor-page-item-content]',
				'{fieldItem}'	: '[data-field]',

				'{config}'		: '[data-fields-config]',

				'{closeConfig}'	: '[data-fields-config-close]',

				view: {
					moveDialog: 'admin/profiles/fields/dialog.move'
				}
			}
		}, function(self) {

			return {
				app: {},

				field: {
					id: 0,
					appid: 0,
					params: {}
				},

				state: $.Deferred(),

				appParams: {},

				init: function() {

					// Check if it has a valid appid or not
					if(self.options.appid == 0 && self.element.data('appid') !== undefined) {
						self.options.appid = self.element.data('appid');
					}

					// Check if this field's app is a valid app or not
					if($Apps[self.options.appid] !== undefined) {

						// Link the reference copy to self.app from $Apps registry
						self.app = $Apps[self.options.appid];
					}

					// Check if it has fieldid or not
					if(self.options.fieldid == 0 && self.element.data('id') !== undefined) {
						self.options.fieldid = self.element.data('id');
					}

					// Register $Fields
					self.registerFields();

					// Generate a unique id to identify configuration tabs
					self.uniqueid = $.uid(self.app.id + '_');

					self.loadedInit();
				},

				registerFields: function() {
					if(self.options.fieldid != 0) {
						$Fields[self.options.fieldid] = {
							id: self.options.fieldid,
							appid: self.options.appid,
							params: self.field.params || {}
						}

						// Link the reference copy to self.field if this is an existing field
						self.field = $Fields[self.options.fieldid];
					}
				},

				loadedInit: function() {

					// Implement field base controller
					self.element.addController('EasySocial.Controller.Field.Base', {
						mode: 'sample',
						element: self.app.element
					});

					// Implement a common config controller on the item
					self.content().addController('EasySocial.Controller.Fields.Editor.Item.Config');
				},

				// export data during save
				_export: function() {
					// Call checkout function from browser to check if all core apps has been used
					$Browser.checkout(self.options.appid);

					// Initialise export data with appid and fieldid
					// If fieldid == 0, means it is a new field
					// If appid == 0, means it is a non valid application
					var exportData 	= {
						"fieldid"	: self.options.fieldid,
						"appid"		: self.options.appid,
						"newfield"	: self.options.newfield
					};

					// Add in parameter values into export data
					exportData = $.extend(exportData, self.expandConfig(self.field.params));

					return exportData;
				},

				'{self} click': function(el, event) {
					var clickedElement = $(event.target);

					// Click on anywhere of the element except the delete button to load the configuration panel
					if(!clickedElement.is(self.deleteButton.selector) && !clickedElement.is(self.moveButton.selector) && !clickedElement.is(self.config.selector) && !clickedElement.is(self.closeConfig.selector) && !el.hasClass('editting')) {

						// If config state is true, means it is editting other field
						if($Config && $Config.state) {

							var state = $Config.checkConfig();

							// Remove itself from other field
							if(state) {
								$Config.closeConfig();
							} else {
								EasySocial.dialog({
									content: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_INVALID_VALUES'),
									width: 400,
									height: 100
								});

								return;
							}
						}

						self.loadConfiguration();
					}
				},

				loadConfiguration: function() {
					// $Parent.trigger('loadingConfig', ['field']);
					$Parent.loadConfiguration(self, 'field');

					self.element.addClass('editting');

					self.getAppParams()
						.done(function() {

							var html = $(self.field.html);

							// Pass objects to config panel
							$Config.load(html);
						})
						.fail(function() {

						});
				},

				updateHtml: function(html) {
					self.field.html = html;
				},

				/**
				 * Get field parameters from the server.
				 */
				getAppParams: function() {
					var state = $.Deferred();

					if(self.field.html) {
						state.resolve();
					} else {
						EasySocial.ajax('admin/controllers/fields/renderConfiguration', {
							// Send the application id
							appid		: self.options.appid,

							// Send the field id.
							fieldid		: self.options.fieldid
						})
						.done(function(params, values, html) {

							self.app.params = params;

							self.field.params = values;

							self.field.html = html;

							// This will keep a flat list of the available parameters
							self.populateAppParams();

							state.resolve();
						})
						.fail(function(msg) {
							state.reject(msg);
						});
					}

					return state;
				},

				/**
				 * Populate parameters data
				 */
				populateAppParams: function() {
					$.each(self.app.params, function(i, paramProperties) {
						$.each(paramProperties.fields, function(name, field) {

							if(field.subfields) {
								$.each(field.subfields, function(subname, subfield) {
									self.appParams[name + '_' + subname] = subfield;
								});
							} else {
								self.appParams[name] = field;
							}
						});
					});
				},

				/**
				 * To return the field parameters value
				 */
				getConfigValues: function() {
					return self.field.params;
				},

				/**
				 * Converts flatten config data to expanded data for saving purposes
				 */
				expandConfig: function() {
					var newData = {
						params: {},
						choices: {}
					};

					$.each(self.field.params, function(name, value) {

						var field = self.appParams[name];

						if(!field) {
							return false;
						}

						var type = field.type == 'choices' ? 'choices' : 'params';

						newData[type][name] = value;
					});

					if(self.options.newfield) {
						newData.params.unique_key = '';
					}

					return newData;
				},

				'{moveButton} click': function(el) {
					var pages = $Steps.toObject(),
						currentPageId = el.parents($Editor.page.selector).data('id'),
						newPages = [];

					$.each(pages, function(i, page) {
						if(page.uid != currentPageId) {
							newPages.push(page);
						}
					});

					EasySocial.dialog({
						content: self.view.moveDialog(true, {
							pages: newPages
						}),
						selectors: {
							"{selection}"		: "[data-move-selection]",
							"{confirmButton}"	: "[data-move-confirm]",
							"{cancelButton}"	: "[data-move-cancel]"
						},
						bindings: {
							"{cancelButton} click" : function()
							{
								// Close the dialog
								EasySocial.dialog().close();
							},

							"{confirmButton} click": function() {
								var id = this.selection().val(),
									page = $Editor.getPage(id);

								page.items().append(self.element);

								$Parent.customFieldChanged();

								EasySocial.dialog().close();
							}
						}
					});
				},

				'{deleteButton} click': function(el) {

					if(el.enabled()) {
						el.disabled(true);

						EasySocial.dialog(
						{
							width: 400,
							height: 150,
							title: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_TITLE'),
							content: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_CONFIRMATION'),
							showOverlay: false,
							buttons: [
								{
									// CANCEL button
									name: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_CANCEL'),
									classNames: 'btn btn-es btn-sm',
									click: function() {
										el.enabled(true);
										EasySocial.dialog().close();
									}
								},
								{
									// DELETE button
									name: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_PAGE_DIALOG_CONFIRM'),
									classNames: 'btn btn-es-danger btn-sm',
									click: function() {

										// Update the dialog content first
										EasySocial.dialog().update({
											content: $.language('COM_EASYSOCIAL_PROFILES_FORM_FIELDS_DELETE_ITEM_DIALOG_DELETING')
										});

										// Start deleting the field
										self.deleteField();

										// Close the dialog
										EasySocial.dialog().close();
									}
								}
							]
						});
					}
				},

				deleteField: function() {
					// Trigger fieldDeleted event
					$Parent.trigger('fieldDeleted', [self.options.appid, self.options.fieldid]);

					if(!self.options.newfield) {

						// Delete fields in registry
						delete $Fields[self.options.fieldid];

						// Add this field into the deleted registry
						$Deleted.fields.push(self.options.fieldid);
					}

					// Remove field element
					self.element.remove();

					$Parent.customFieldChanged();
				},

				'{self} pageDeleted': function() {
					self.deleteField();
				},

				'{content} onConfigChange': function(el, event, name, value) {
					self.field.params[name] = value;
				},

				'{self} onPopulateConfig': function(el, event, values) {
					self.field.params = values;
				},

				// Unused
				updateResult: function(data) {
					// Update the unique key
					self.field.params.unique_key = data.unique_key;
					self.itemParam('[data-fields-config-param-field-unique_key]').val(data.unique_key);

					// If this is a new field, the some things need to be updated
					if(self.options.newfield) {
						// Set newfield to false because post-save, this will no longer be a new field
						self.options.newfield = false;

						// Set the fieldid
						self.options.fieldid = data.fieldid;
						self.element.data('id', data.fieldid);

						// Enable the unique key field
						self.itemParam('[data-fields-editor-page-item-param-field-unique_key]').removeAttr('disabled');

						// Register into $Fields registry
						self.registerFields();
					}

					if(data.choices !== undefined) {
						$.each(data.choices, function(name, choices) {
							var element = self.itemParam('[data-fields-config-param-field-' + name + ']');

							$.each(choices, function(i, choice) {
								// Go by sequence
								var item = element.find('li').eq(i);

								if(!item.data('id')) {
									item.attr('data-id', choice.id);
									item.data('id', choice.id);
								}
							});
						});
					}
				}
			}
		});

		/* Config Choices Controller */
		EasySocial.Controller( 'Config.Choices', {
			defaultOptions: {
				'{choiceItems}'	: '[data-fields-config-param-choice]',

				unique			: 1
			}
		}, function(self) {

			return {
				init: function() {
					self.options.unique = self.element.data('unique') !== undefined ? self.element.data('unique') : 1;

					self.choiceItems().implement( EasySocial.Controller.Config.Choices.Choice, {
						controller: {
							'item': self.item,
							'choices': self
						}
					});

					self.initSortable();
				},

				initSortable: function() {
					self.element.sortable({
						items: self.choiceItems.selector,
						placeholder: 'ui-state-highlight',
						cursor: 'move',
						forceHelperSize: true,
						handle: '[data-fields-config-param-choice-drag]',
						stop: function() {
							// Manually remove all the freezing tooltip due to conflict between bootstrap tooltip and jquery sortable
							$('.tooltip-es').remove();

							// Mark change
							$Parent.customFieldChanged();
						}
					});
				}
			}
		});

		/* Config Choices Choice Controller */
		EasySocial.Controller( 'Config.Choices.Choice', {
			defaultOptions: {
				'{choiceValue}'		: '[data-fields-config-param-choice-value]',
				'{choiceTitle}'		: '[data-fields-config-param-choice-title]',
				'{choiceDefault}'	: '[data-fields-config-param-choice-default]',
				'{addChoice}'		: '[data-fields-config-param-choice-add]',
				'{removeChoice}'	: '[data-fields-config-param-choice-remove]',
				'{setDefault}'		: '[data-fields-config-param-choice-setdefault]',

				'{defaultIcon}'		: '[data-fields-config-param-choice-defaulticon]'
			}
		}, function(self) {

			return {

				init: function() {
				},

				'{choiceTitle} keyup': $._.debounce(function(el, event) {
					var index = self.element.index();

					self.item.fieldItem().trigger('onChoiceTitleChanged', [index, el.val()]);

					$Parent.customFieldChanged();
				}, 500),

				'{choiceValue} keyup': $._.debounce(function(el, event) {
					var index = self.element.index();

					self.item.fieldItem().trigger('onChoiceValueChanged', [index, el.val()]);

					$Parent.customFieldChanged();
				}, 500),

				'{addChoice} click' : function() {
					// Clone a new item from current clicked element
					var newItem = self.element.clone();

					// Let's leave the value blank by default.
					var inputElement = newItem.find('input[type="text"]');

					inputElement.attr('value', '');

					inputElement.val('');

					// Set the default as 0 and the icon to unfeatured
					var inputDefault = newItem.find('input[type="hidden"]');

					inputDefault.attr('value', 0);

					inputDefault.val(0);

					var defaultLabel = newItem.find('[data-fields-config-param-choice-defaulticon]');

					defaultLabel.removeClass('es-state-featured').addClass('es-state-default');

					// set id = 0
					newItem.attr('data-id', 0);
					newItem.data('id', 0);

					// Implement the controller for this choice
					newItem.implement(EasySocial.Controller.Config.Choices.Choice, {
						controller: {
							'item': self.item,
							'choices': self.choices
						}
					});

					// Append this item
					self.element.after(newItem);

					// Get the index of the new item
					var index = newItem.index();

					self.item.fieldItem().trigger('onChoiceAdded', [index]);

					$Parent.customFieldChanged();
				},

				'{removeChoice} click' : function() {
					// We need to minus one because we're trying to remove ourself also.
					var remaining = self.choices.choiceItems().length - 1;

					// If this is the last item, we wouldn't want to allow the last item to be removed.
					if( remaining >= 1 ) {
						// Get the index of the new item
						var index = self.element.index();

						self.item.fieldItem().trigger('onChoiceRemoved', [index]);

						self.element.remove();

						// Manually remove the tooltip generated on the remove button
						$('.tooltip-es').remove();
					}

					$Parent.customFieldChanged();
				},

				'{setDefault} click': function() {
					var index = self.element.index(),
						title = self.choiceTitle().val(),
						value = self.choiceValue().val();

					self.choices.choiceItems().trigger( 'toggleDefault', [index] );

					self.item.fieldItem().trigger('onChoiceToggleDefault', [index, parseInt(self.choiceDefault().val())]);

					$Parent.customFieldChanged();
				},

				'{self} toggleDefault': function(el, ev, i) {
					var index = self.element.index(),
						value = parseInt(self.choiceDefault().val());

					if(index === i) {
						if(value) {
							self.defaultIcon()
								.removeClass('es-state-featured')
								.addClass('es-state-default');

							self.choiceDefault().val(0);
						} else {
							self.defaultIcon()
								.removeClass('es-state-default')
								.addClass('es-state-featured');

							self.choiceDefault().val(1);
						}
					} else {
						if(self.choices.options.unique) {
							self.defaultIcon()
								.removeClass('es-state-featured')
								.addClass('es-state-default');

							self.choiceDefault().val(0);
						}
					}
				}
			}
		});

		/* Editor Item Common Controller */
		// This is the common item config controller to implement on item
		EasySocial.Controller('Fields.Editor.Item.Config', {
			defaultOptions: {
				'{required}'			: '[data-required]',

				'{title}'				: '[data-title]',
				'{description}'			: '[data-description]',

				'{displayTitle}'		: '[data-display-title]',
				'{displayDescription}'	: '[data-display-description]'
			}
		}, function(self) {
			return {
				init: function() {

				},

				'{self} onConfigChange': function(el, event, name, value) {
					switch(name) {
						case 'display_title':
							self.displayTitle().toggle(!!value);
						break;

						case 'title':
							self.title().text(value);
						break;

						case 'display_description':
							self.displayDescription().toggle(!!value);
						break;

						case 'description':
							self.description().text(value);
						break;

						case 'required':
							self.required().toggle(!!value);
						break;
					}
				}
			}
		});

		module.resolve();
	}); // require end

}); // module end

EasySocial.module('field', function($) {
    var module = this;

    EasySocial.Controller('Field.Base', {
        defaultOptions: {
            regPrefix   : 'easysocial/',

            modPrefix   : 'field.',

            ctrlPrefix  : 'EasySocial.Controller.Field.',

            fieldname   : '',

            element     : null,

            id          : null,

            required    : false,

            mode        : 'edit',

            '{field}'   : '[data-field]',

            '{content}' : '[data-content]',

            '{notice}'  : '[data-check-notice]'
        }
    }, function(self) {
        return {
            init: function() {

                self.options.fieldname = self.element.data('fieldname');

                self.options.element = self.options.element || self.element.data('element');

                self.options.id = self.element.data('id');

                self.options.required = !!self.element.data('required');

                self.initMode();

                // Check if there are errors

                if (self.notice().text().trim().length > 0) {
                    self.content().popover({
                        animation: false,
                        content: self.notice().text().trim(),
                        html: true,
                        placement: 'left-top',
                        trigger: 'manual',
                        container: 'body',
                        template: '<div id="fd" class="fd-popover es es-field-error"><div class="arrow"></div><h3 class="fd-popover-title"></h3><div class="fd-popover-content"></div></div>'
                    });

                    self.content().popover('show');
                }
            },

            initMode: function() {
                // Trigger the necessary mode here for field to do necessary init
                switch(self.options.mode)
                {
                    case 'registermini':
                        self.field().trigger('onRegisterMini');
                        break;
                    case 'register':
                        self.field().trigger('onRegister');
                        break;
                    case 'edit':
                        self.field().trigger('onEdit');
                        break;
                    case 'adminedit':
                        self.field().trigger('onAdminEdit');
                        break;
                    case 'sample':
                        self.field().trigger('onSample');
                        break;
                    case 'display':
                        self.field().trigger('onDisplay');
                        break;
                }
            },

            // Some base triggers/functions
            '{field} error': function(el, ev, state, msg) {
                state = state !== undefined ? state : true;

                if($.isString(state)) {
                    msg = state;
                    state = true;
                }

                if($.isBoolean(state)) {
                    self.field().toggleClass('has-error', state);
                }

                if(msg !== undefined) {
                    self.content().popover({
                        animation: false,
                        content: msg,
                        html: true,
                        placement: 'left-top',
                        trigger: 'manual',
                        container: 'body',
                        template: '<div id="fd" class="fd-popover es es-field-error"><div class="arrow"></div><h3 class="fd-popover-title"></h3><div class="fd-popover-content"></div></div>'
                    });

                    self.content().popover('show');
                }
            },

            '{field} clear': function(el, ev) {
                self.field().removeClass('has-error');
                self.field().removeClass('is-loading');

                self.content().popover('destroy');
            },

            '{self} show': function() {
                self.field().trigger('onShow');
            },

            '{field} loading': function(el, ev, msg) {
                self.field().addClass('is-loading');

                self.notice().html(msg);
            },

            '{field} loaded': function(el, ev) {
                self.field().removeClass('is-loading');
            }
        }
    });

    module.resolve();
});

EasySocial.module('admin/profiles/form', function($) {
	var module = this;

	EasySocial.require()
	.script('utilities/alias')
	.done(function($) {

		EasySocial.Controller('Profiles.Profile', {
			defaultOptions: {
				id: null,

				// Profile avatar
				hasAvatar: false,
				defaultAvatar: null,

				'{profileAvatar}': '[data-profile-avatar]',
				'{profileAvatarImage}': '[data-profile-avatar-image]',
				'{profileAvatarRemoveWrap}': '[data-profile-avatar-remove-wrap]',
				'{profileAvatarRemoveButton}': '[data-profile-avatar-remove-button]',
				'{profileAvatarUpload}': '[data-profile-avatar-upload]'
			}
		}, function(self) {
			
			return {
				init: function() {

					self.element.addController('EasySocial.Controller.Utilities.Alias', {
						"{source}"	: "#title",
						"{target}"	: "#alias"
					});

					self.options.hasAvatar = self.profileAvatar().data('hasavatar');
					self.options.defaultAvatar = self.profileAvatar().data('defaultavatar');
				},

				'{profileAvatarUpload} change': function(el) {
					var value = el.val();

					if(!$.isEmpty(value)) {
						self.profileAvatarRemoveWrap().show();
					} else {
						if(!self.options.hasAvatar) {
							self.profileAvatarRemoveWrap().hide();
						}
					}
				},

				'{profileAvatarRemoveButton} click': function(el) {

					if (!self.options.hasAvatar) {
						self.profileAvatarUpload()
							.val('')
							.trigger('change');

						return;
					}

					EasySocial.dialog({
						content: EasySocial.ajax('admin/views/profiles/confirmRemoveProfileAvatar'),
						bindings: {
							'{deleteButton} click': function() {

								EasySocial.ajax('admin/controllers/profiles/deleteProfileAvatar', {
									id: self.options.id
								}).done(function() {

									self.profileAvatarImage().attr('src', self.options.defaultAvatar);

									self.profileAvatarRemoveWrap().hide();

									self.options.hasAvatar = false;

									EasySocial.dialog().close();
								});
							}
						}
					});
				}
			}
		});

		module.resolve();
	});
});


EasySocial.module('utilities/alias', function($) {

	var module = this;

	EasySocial.Controller('Utilities.Alias', {
			defaultOptions: {
				// Should be overriden by the caller.
				"{target}"	: "",
				"{source}"	: ""
			}
		},function(self) { 
			return {
				init: function() {
				},

				convertToPermalink: function(title) {
					return title.replace(/\s/g, '-').replace(/[^\w/-]/g, '').toLowerCase();
				},

				"{source} keyup" : function(input, event) {
						
					var permalink = self.convertToPermalink(self.source().val());

					// Update the target when the source is change.
					self.target()
						.val(permalink);
				},

				"{target} keyup" : function(input, event) {

					var permalink = self.convertToPermalink(self.target().val());

					self.target()
						.val(permalink);
				}
			}
		});

	module.resolve();
});

EasySocial.module( 'admin/profiles/members' , function($) {

	var module = this;

	EasySocial
	.require()
	.language( 
		'COM_EASYSOCIAL_CANCEL_BUTTON',
		'COM_EASYSOCIAL_ASSIGN_BUTTON',
		'COM_EASYSOCIAL_PROFILES_ASSIGN_USER_DIALOG_TITLE'
	)
	.done( function($)
	{
		EasySocial.Controller(
			'Profiles.Members',
			{
				defaultOptions :
				{
					"{addUser}"	: "[data-profiles-addUser]",
					"{row}"		: "[data-profiles-members-row]"
				}
			},
			function(self)
			{
				return {

					init : function()
					{
						self.options.id 	= self.element.data( 'id' );
					},

					"{memberList} userSelected": function( el , event , id , name )
					{
						EasySocial.ajax( 'admin/controllers/profiles/insertMember', 
						{
							"id"			: id,
							"profile_id"	: self.options.id
						})
						.done( function( row )
						{
							self.row().append( row );

							// Close the dialog.
							EasySocial.dialog().close();
						});
					},

					"{addUser} click" : function()
					{
						var callbackId 	= $.callback( function(memberList){
							self.addPlugin( 'memberList' , memberList );
						});

						var url 		= $.indexUrl + "?option=com_easysocial&view=users&tmpl=component&callback=" + callbackId;

						EasySocial.dialog({
							title 		: $.language( 'COM_EASYSOCIAL_PROFILES_ASSIGN_USER_DIALOG_TITLE' ),
							content		: url,
							showOverlay	: false,
							width 		: 700,
							height 		: 600,
							buttons		:
							[
								{
									"name"			: $.language( "COM_EASYSOCIAL_CANCEL_BUTTON" ),
									"classNames"	: "btn btn-es",
									"click"			: function()
									{
										EasySocial.dialog().close();
									}
								}
							]
						});
					}

				}
			});

		module.resolve();

	});

});
EasySocial.module('admin/profiles/profile', function($) {
	var module = this;

	EasySocial.require()
	.script('utilities/alias')
	.view('admin/profiles/dialog.delete.profileavatar')
	.language('COM_EASYSOCIAL_PROFILES_FORM_CLEAR_AVATAR')
	.done(function($) {
		EasySocial.Controller('Profiles.Profile', {
			defaultOptions: {
				id: null,

				// Profile avatar
				hasAvatar: false,
				defaultAvatar: null,
				'{profileAvatar}': '[data-profile-avatar]',
				'{profileAvatarImage}': '[data-profile-avatar-image]',
				'{profileAvatarRemoveWrap}': '[data-profile-avatar-remove-wrap]',
				'{profileAvatarRemoveButton}': '[data-profile-avatar-remove-button]',
				'{profileAvatarUpload}': '[data-profile-avatar-upload]',

				view: {
					deleteProfileAvatar: 'admin/profiles/dialog.delete.profileavatar'
				}
			}
		}, function(self) {
			return {
				init: function() {
					self.element.addController('EasySocial.Controller.Utilities.Alias', {
						"{source}"	: "#title",
						"{target}"	: "#alias"
					});

					self.options.hasAvatar = self.profileAvatar().data('hasavatar');
					self.options.defaultAvatar = self.profileAvatar().data('defaultavatar');
				},

				'{profileAvatarUpload} change': function(el) {
					var value = el.val();

					if(!$.isEmpty(value)) {
						self.profileAvatarRemoveWrap().show();
					} else {
						if(!self.options.hasAvatar) {
							self.profileAvatarRemoveWrap().hide();
						}
					}
				},

				'{profileAvatarRemoveButton} click': function(el) {
					if(self.options.hasAvatar) {
						EasySocial.dialog({
							content: self.view.deleteProfileAvatar(true),
							bindings: {
								'{deleteButton} click': function() {
									var dialog = this.parent;

									dialog.loading(true);

									EasySocial.ajax('admin/controllers/profiles/deleteProfileAvatar', {
										id: self.options.id
									}).done(function() {
										dialog.loading(false);

										dialog.close();

										self.profileAvatarImage().attr('src', self.options.defaultAvatar);

										self.profileAvatarRemoveWrap().hide();

										self.profileAvatarRemoveButton().text($.language('COM_EASYSOCIAL_PROFILES_FORM_CLEAR_AVATAR'));

										self.options.hasAvatar = false;
									});
								}
							}
						});
					} else {
						self.profileAvatarUpload().val('').trigger('change');
					}
				}
			}
		});

		module.resolve();
	});
});

EasySocial.module( 'admin/profiles/profiles' , function($) {

	var module = this;

	EasySocial
	.require()
	.done( function($)
	{

		EasySocial.Controller(
			'Profiles',
			{
				defaultOptions :
				{
					"{updateOrdering}"	: "[data-profiles-update-ordering]",
					"{item}"	: "[data-profiles-item]",

					view :
					{
						deleteConfirmation : 'admin/profiles/dialog.delete.confirm'
					}
				}
			},
			function(self)
			{
				return {

					init : function()
					{
						// Implement controller on each row.
						self.item().implement( EasySocial.Controller.Profiles.Item );
					},

					"{updateOrdering} click" : function()
					{
						// Check in all items
						$( '[data-table-checkall]' ).prop( 'checked' , true ).trigger( 'change' );

						$.Joomla( 'submitform' , [ 'updateOrdering' ] );
					}
				}
			});

		EasySocial.Controller(
		'Profiles.Item',
		{
			defaultOptions : 
			{
				"{insertLink}"		: "[data-profile-insert]"
			}
		},
		function( self )
		{
			return {
				init : function()
				{
					self.options.title 	= self.element.data( 'title' );
					self.options.id 	= self.element.data( 'id' );
				},

				"{insertLink} click" : function()
				{
					self.trigger( 'profileSelected' , [ self.options.id , self.options.title ] );
				}
			}
		});

		module.resolve();

	});

});
EasySocial.module('admin/regions/form', function($) {
    var module = this;

    EasySocial.require().language('COM_EASYSOCIAL_REGIONS_FORM_INCOMPLETE').done(function() {

        $.template('easysocial/parents.select', '<select name="parent_uid" data-parent-uid></select>');
        $.template('easysocial/parents.option', '<option value="[%= uid %]">[%= name %]</option>');

        EasySocial.Controller('Regions.Form', {
            defaultOptions: {
                '{type}': '[data-type]',
                '{parentBase}': '[data-parent-base]',
                '{parentContent}': '[data-parent-content]',
                '{parentUid}': '[data-parent-uid]',
                '{parentType}': '[data-parent-type]',

                view: {
                    parentsSelect: 'parents.select',
                    parentsOption: 'parents.option'
                }
            }
        }, function(self) {
            return {
                init: function() {
                    self.element.find('input[type="text"]').prop('disabled', !self.type().val());

                    self.element.find('[data-bs-toggle="radio-buttons"]').toggleClass('disabled', !self.type().val());

                    $.Joomla('submitbutton', function(task) {

                        if (task == 'cancel') {
                            window.location = 'index.php?option=com_easysocial&view=regions';
                            return false;
                        }

                        if (self.validate()) {
                            $.Joomla('submitform', [task]);
                        } else {
                            alert($.language('COM_EASYSOCIAL_REGIONS_FORM_INCOMPLETE'));
                        }
                    });
                },

                '{type} change': function(el) {
                    var parentType = el.find(':selected').data('parent');

                    self.parentType().val(parentType);

                    self.element.find('input[type="text"]').prop('disabled', !el.val());

                    self.element.find('[data-bs-toggle="radio-buttons"]').toggleClass('disabled', !el.val());

                    if (parentType) {
                        self.parentBase().show();

                        !self.parentContent().data('loaded') &&
                        self.getParents(parentType)
                            .done(function(parents) {
                                var base = $(self.view.parentsSelect());

                                $.each(parents, function(i, parent) {
                                    self.view.parentsOption({
                                        uid: parent.uid,
                                        name: parent.name
                                    }).appendTo(base);
                                });

                                self.parentContent().html(base);
                            });
                    } else {
                        self.parentBase().hide();
                    }
                },

                getParents: $.memoize(function(key) {
                    return EasySocial.ajax('admin/controllers/regions/getParents', {
                        type: key
                    });
                }),

                validate: function() {
                    return self.type().val() && self.element.find('input[name="name"]').val() && self.element.find('input[name="code"]').val();
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('admin/regions/init', function($) {
    var module = this;

    EasySocial.Controller('Region.Init', {
        defaultOptions: {
            callback: function() {},

            '{startButton}': '[data-start]',
            '{table}': '[data-table]',
            '{tableBody}': '[data-table-body]',
            '{row}': '[data-table-row]'
        }
    }, function(self) {
        return {
            init: function() {
                self.row().addController('EasySocial.Controller.Region.Init.Row');
            },

            '{startButton} click': function(el, ev) {
                el.hide();

                self.table().show();

                self.counter = 0;
                self.progress = $.Deferred()
                    .done(function() {
                        self.options.callback();
                    });

                self.process();
            },

            process: function() {
                var row = self.row().eq(self.counter);

                if (row.length === 0) {
                    return self.progress.resolve();
                }

                row.show();

                EasySocial.ajax('admin/controllers/regions/initialise', {
                    key: row.data('key')
                }).done(function() {
                    row.trigger('updateStatus', [1]);

                    self.counter++;

                    self.process();
                });
            }
        }
    });

    EasySocial.Controller('Region.Init.Row', {
        defaultOptions: {
            '{title}': '[data-row-title]',
            '{status}': '[data-row-status]',
            '{icon}': '[data-row-icon]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            statuses: ['label-danger', 'label-success', 'label-warning'],
            icons: ['fa-exclamation-triangle', 'fa-check', 'fa-wrench'],

            '{self} updateStatus': function(el, ev, state) {
                var status = self.status(),
                    icon = self.icon();

                for (i = 0; i < 3; i++) {
                    status.toggleClass(self.statuses[i], state == i);
                    icon.toggleClass(self.icons[i], state == i);
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module( 'admin/reports/reporters' , function($) {

	var module = this;

	EasySocial.Controller(
		'Reports.Reporters',
		{
			defaultOptions : 
			{
				"{item}"		: "[data-reporters-item]"
			}
		},
		function( self )
		{
			return {
				init : function()
				{
					self.item().implement( EasySocial.Controller.Reports.Reporters.Item ,
						{
							"{parent}"	: self
						});
				}
			}
		}
	);

	EasySocial.Controller(
		'Reports.Reporters.Item',
		{
			defaultOptions :
			{
				"{removeItem}"	: "[data-remove-item]"			
			}
		},
		function( self )
		{
			return {
				init : function()
				{
					self.options.id 	= self.element.data( 'id' );
				},

				"{removeItem} click" : function()
				{
					// Remove any messages.
					self.parent.clearMessage();

					EasySocial.ajax( 'admin/controllers/reports/removeItem' ,
					{
						"id"	: self.options.id
					})
					.done(function( result )
					{
						self.parent.setMessage( result.message , result.type );

						self.element.remove();
					});
					
				}
			}
		}
	);

	module.resolve();

});
EasySocial.module( 'admin/reports/reports' , function($) {

	var module = this;

	EasySocial
	.require()
	.language( 
		'COM_EASYSOCIAL_CANCEL_BUTTON',
		'COM_EASYSOCIAL_CLOSE_BUTTON',
		'COM_EASYSOCIAL_REPORTS_VIEW_REPORTS_DIALOG_TITLE',
		'COM_EASYSOCIAL_REPORTS_ACTIONS_DIALOG_TITLE'
	)
	.done( function($)
	{

		EasySocial.Controller(
			'Reports',
			{
				defaultOptions : 
				{
					"{item}"		: "[data-reports-item]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.item().implement( EasySocial.Controller.Reports.Item )
					}
				}
			});

		EasySocial.Controller(
			'Reports.Item',
			{
				defaultOptions :
				{
					"{action}"		: "[data-reports-item-view-actions]",
					"{viewReports}"	: "[data-reports-item-view-reports]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.options.id 		= self.element.data( 'id' );
						self.options.extension	= self.element.data( 'extension' );
						self.options.uid 		= self.element.data( 'uid' );
						self.options.type 		= self.element.data( 'type' );
					},

					"{viewReports} click" : function()
					{

						EasySocial.dialog(
						{
							title 		: $.language( 'COM_EASYSOCIAL_REPORTS_VIEW_REPORTS_DIALOG_TITLE' ),
							content 	: EasySocial.ajax( 'admin/controllers/reports/getReporters' , 
											{ 
												id 			: self.options.id
											}),
							width 		: 600,
							height 		: 450
						});

					},

					"{action} click" : function()
					{
						EasySocial.dialog( 
						{
							title 		: $.language( 'COM_EASYSOCIAL_REPORTS_ACTIONS_DIALOG_TITLE' ),
							content		: '<div>Perform some actions on the item</div>',
							width 		: 500,
							height 		: 250,
							buttons 	: 
							[
								{
									name 		: $.language( 'COM_EASYSOCIAL_CLOSE_BUTTON' ),
									classNames	: "btn btn-es",
									click 		: function()
									{
										EasySocial.dialog().close();
									}
								}
							]
						})
					}
				}
			})

		module.resolve();
	});

});
EasySocial.module( 'admin/sidebar/sidebar' , function($) {

	var module = this;

	EasySocial.require()
	.done(function($){

		EasySocial.Controller(
				'Sidebar.Sidebar', {
					defaultOptions: {
						intervalPendingUsers: 5000,
						"{usersBadge}": ".menu-user > a .badge",
						"{pendingUsersBadge}"	: ".menu-user .menu-ies-vcard > .badge"
					}
				}, function(self) {

					return {

						init: function() {
							// Check for pending users.
							self.checkPendingUsers();
						},

						monitorPendingUsers: function() {
							self.options.state	= setTimeout(self.checkPendingUsers, self.options.intervalPendingUsers);
						},

						checkPendingUsers: function() {

							// Stop monitoring so that there wont be double calls at once.
							self.stopMonitorPendingUsers();

							// Needs to run in a loop since we need to keep checking for new notification items.
							setTimeout( function(){

								EasySocial.ajax('admin/controllers/users/getTotalPending')
								.done(function(total) {

									if (total > 0) {
										self.usersBadge().html(total);
										self.pendingUsersBadge().html(total);
									} else {
										self.usersBadge().html('');
									}

									// Continue monitoring.
									self.monitorPendingUsers();
								});

							}, self.options.intervalPendingUsers );

						},

						stopMonitorPendingUsers: function() {
							clearTimeout(self.options.state);
						},
					}
				}
		);

		module.resolve();
	});

});

EasySocial.module("admin/themes/compiler", function($){

var module = this;

// TODO: Move this away
$.fn.at = function(key) {
	return this.find("[data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + "]");
}

$.template("easysocial/compiler/detail", '<tr class="[%= type %]"><td>[%= timestamp %]</td><td width="100%">[%= message %]</td></tr>');

EasySocial.Controller("Themes.Compiler", {

	defaultOptions: {

		view: {
			detail: "compiler/detail"
		},

		"{section}": "[data-section]",

		"{compileButton}"     : "[data-compile-button]",
		"{minifyButton}"      : "[data-minify-button]",
		"{buildButton}"       : "[data-build-button]",
		"{filesButton}"       : "[data-files-button]",
		"{purgeButton}"       : "[data-purge-button]",
		"{resetButton}"       : "[data-reset-button]",
		"{forceCompileButton}": "[data-force-compile-button]",
		"{clearLogButton}"    : "[data-clear-log-button]",
		"{toggleLogButton}"   : "[data-toggle-log-button]",

		"{refreshButton}": "[data-refresh-button]",
		"{refreshSectionButton}": "[data-refresh-section-button]",
		"{buildWithoutMinifyButton}": "[data-build-without-minify-button]",

		"{log}"        : "[data-log]",
		"{details}"    : "[data-details]",
		"{status}"     : "[data-status]",
		"{imports}"    : "[data-imports]",

		"{progress}"      : "[data-progress]",
		"{progressBar}"   : "[data-progress-bar]",
		"{progressStatus}": "[data-progress-status]",

		"{tabItem}": ".tab-item"
	}
},
function(self, opts, base) { return {

	init: function() {

		self.location = base.data("location");
		self.name     = base.data("name");
		self.override = base.data("override");
	},

	sections: function() {

		var sections =
			$.map(self.section(), function(section) {

				var name = $(section).data("sectionName"),
					id   = self.sectionId(name);

				return {id: id, name: name};
			});

		return sections;
	},

	sectionId: function(sectionName) {

		return self.location + '-' + self.name + '-' + sectionName;
	},

	sectionTab: function(sectionName) {

		return self.tabItem({"sectionId": self.sectionId(sectionName)}).find("> a");
	},

	sectionNameOf: function(el) {

		var section = self.section.of(el),
			sectionName = section.data("sectionName");

		return sectionName;
	},

	getLog: function(sectionName) {

		if (sectionName) return self.section({"sectionName": sectionName}).at("log");
		return self.log(":first");
	},

	addLog: function(detail, sectionName) {

		var log = self.getLog(sectionName),
			body = log.find("tbody");

		// Normalize arguments
		if ($.isString(detail)) {
			detail = {
				timestamp: new Date(),
				message: detail,
				type: "info"
			}
		}

		// Type
		var type = detail.type;
		if (/warning|warn/.test(type)) type = 'warning';
		if (/danger|error|failed|fail/.test(type)) type = 'danger';
		if (/pending|default|primary/.test(type)) type = '';

		// Timestamp
		var timestamp = detail.timestamp,
			date = (timestamp instanceof Date) ? timestamp : new Date(parseFloat(timestamp));

		// Convert timestamp to h:i:s
		timestamp = date.getHours() + ':' + date.getMinutes() + ":" + date.getSeconds();

		// Message
		var message = detail.message;

		self.view.detail({
				type: type,
				timestamp: timestamp,
				message: message
			})
			.appendTo(body);

		body[0].scrollTop = body[0].scrollHeight;
	},

	appendLog: function(details, sectionName) {

		$.each(details, function(key, detail){
			self.addLog(detail, sectionName);
		});
	},

	clearLog: function(sectionName) {

		var log = self.getLog(sectionName),
			body = log.find("tbody");

		body.empty();

		log.at("timeTotal").data("value", 0).html("0s");
		log.at("memoryUsage").data("value", 0).html("0mb");
	},

	generateLog: function(task, sectionName) {

		self.clearLog(sectionName);

		self.appendLog(task.details, sectionName);

		var log = self.getLog(sectionName),
			timeTotalValue = parseFloat(task.time_total),
			timeTotalText  = timeTotalValue.toFixed(2) + 's',
			memoryUsageValue = parseInt(task.mem_peak),
			memoryUsageText  = (memoryUsageValue / 1024 / 1024).toFixed(2) + 'mb';

		log.at("timeTotal")
			.data("value", timeTotalValue)
			.html(timeTotalText);

		log.at("memoryUsage")
			.data("value", memoryUsageValue)
			.html(memoryUsageText);

		self.addLog({
			type: (task.failed) ? "danger" : "success",
			timestamp: task.time_end,
			message: (task.failed) ? "Task failed." : "Task completed.",
		}, sectionName);
	},

	updateLog: function(task, sectionName) {

		var log = self.getLog(sectionName),
			timeTotal = log.at("timeTotal"),
			memoryUsage = log.at("memoryUsage");

		// Append log
		self.appendLog(task.details, sectionName);

		// Refactor this. Copied code from above.
		var timeTotalValue = timeTotal.data("value") + parseFloat(task.time_total),
			timeTotalText  = timeTotalValue.toFixed(2) + 's',
			memoryUsageValue = Math.max(memoryUsage.data("value"), parseInt(task.mem_peak)),
			memoryUsageText  = (memoryUsageValue / 1024 / 1024).toFixed(2) + 'mb';

		timeTotal
			.data("value", timeTotalValue)
			.html(timeTotalText);

		memoryUsage
			.data("value", memoryUsageValue)
			.html(memoryUsageText);
	},

	perform: function(task, options) {

		return EasySocial.ajax(
				"admin/controllers/themes/" + task,
				$.extend({
					location: self.location,
					name: self.name,
					override: self.override
				}, options));
	},

	build: function(preset) {

		var sections = self.sections(),

			preset = preset || 'cache',

			minify = (preset=='cache'),

			// To determine when to stop running tasks
			i = 0,
			length = sections.length - 1,

			// To determine progress bar width
			current = i + 1,
			total = ((length + 1) * (minify ? 2 : 1)) + 1, // one more for building
			max = 100,

			// To determine if there was a failure
			failed = false,

			log = self.log(":first"),

			progress       = self.progress(":first"),
			progressBar    = self.progressBar(":first"),
			progressStatus = self.progressStatus(":first"),

			updateProgress = function() {

				current++;

				// Update progress bar
				progressValue = current / total * max;
				progressBar.show().width(progressValue + "%");
			},

			run = function() {

				var section     = sections[i],
					sectionId   = section.id,
					sectionName = section.name,
					sectionTab  = self.sectionTab(sectionName);

				// Message
				var message = "Compiling section '" + sectionName + "'.";

				// Update progress bar
				updateProgress();

				// Update compile status
				progressStatus.html(message);

				// Show section tab content
				sectionTab.tab("show");

				self.compile(sectionName, {force: true})
					.done(function(data){
						self.updateLog(data.task);
					})
					.fail(function(data){
						self.updateLog(data.task);
						failed = true;
					})
					.always(function(){

						if (!minify) {
							nextSection();
						} else {

							// Message
							var message = "Minifying section '" + sectionName + "'.";

							// Update progress bar
							updateProgress();

							// Update compile status
							progressStatus.html(message);

							self.minify(sectionName)
								.done(function(data){
									self.updateLog(data.task);
								})
								.fail(function(data){
									self.updateLog(data.task);
									failed = true;
								})
								.always(function(){
									nextSection();
								});
						}
					});
			},

			nextSection = function() {

				// Compile next section
				if (length > i++) return run();

				// If all sections have been compiled, build.
				build();
			},

			build = function() {

				progressStatus.html("Building stylesheets.");
				updateProgress();

				var task;

				self.perform("build", {preset: preset})
					.done(function(data){
						self.status(":first").replaceWith(data.status);
						task = data.task;
					})
					.fail(function(data){
						task = data.task;
					})
					.always(function(){

						// Fallback pseudo task object.
						if (!task) {
							task = {
								failed: true,
								details: [],
								time_end: new Date()
							};
						}

						// Update log
						self.updateLog(task);

						self.addLog({
							type: (task.failed) ? "danger" : "success",
							timestamp: task.time_end,
							message: (task.failed) ? "Build failed." : "Build completed.",
						});

						progressStatus.html("Build completed!");
						progressBar.width("100%");

						// Hide compiler progress
						base.removeClass("is-busy");
					});
			};

		// Reset progress bar
		progressBar.hide().width("0%");

		// Show compiler progress
		base.addClass("is-busy");

		// Log
		self.clearLog();

		if (sections.length > 0) {
			self.addLog("Compiling all sections.");
			// Compile section
			run();
		} else {
			build();
		}
	},

	minify: function(sectionName, options) {

		var task = self.perform("minify", $.extend({section: sectionName}, options));

		self.trigger("minify", [sectionName, task]);

		return task;
	},

	"{self} minify": function(base, event, sectionName, task) {

		var section = self.section({"sectionName": sectionName}),
			progressStatus = section.at("progressStatus"),
			progressBar = section.at("progressBar"),
			message = "Minifying section '" + sectionName + "'.";

		// Progress bar
		section.addClass("is-busy");
		progressStatus.html(message);
		progressBar.hide().width("0%").show().width("100%");

		// Log
		// self.clearLog(sectionName);
		// self.addLog(message, sectionName);

		task
			.done(function(data){

				// Update imports & status html
				section.at("imports").replaceWith(data.imports);
				section.at("status").replaceWith(data.status);

				// Generate log
				self.appendLog(data.task.details, sectionName);

				self.addLog({
					type: (task.failed) ? "danger" : "success",
					timestamp: data.task.time_end,
					message: (task.failed) ? "Task failed." : "Task completed.",
				}, sectionName);
			})
			.always(function(){
				section.removeClass("is-busy");
			});
	},

	compile: function(sectionName, options) {

		var task = self.perform("compile", $.extend({section: sectionName}, options));

		self.trigger("compile", [sectionName, task]);

		return task;
	},

	"{self} compile": function(base, event, sectionName, task) {

		var section = self.section({"sectionName": sectionName}),
			progressStatus = section.at("progressStatus"),
			progressBar = section.at("progressBar"),
			message = "Compiling section '" + sectionName + "'.";

		// Progress bar
		section.addClass("is-busy");
		progressStatus.html(message);
		progressBar.hide().width("0%").show().width("100%");

		// Log
		self.clearLog(sectionName);
		self.addLog(message, sectionName);

		task
			.done(function(data){

				// Update imports & status html
				section.at("imports").replaceWith(data.imports);
				section.at("status").replaceWith(data.status);

				// Generate log
				self.generateLog(data.task, sectionName);
			})
			.fail(function(data){

				// Generate log
				self.generateLog(data.task, sectionName);
			})
			.always(function(){

				section.removeClass("is-busy");
			});
	},

	purge: function() {

		var progress       = self.progress(":first"),
			progressBar    = self.progressBar(":first"),
			progressStatus = self.progressStatus(":first");

		base.addClass("is-busy");

		self.clearLog();

		progressBar.hide().width("0%").show().width("100%");
		progressStatus.html("Purging cache and log files.");

		self.perform("purge")
			.done(function(task){

				self.generateLog(task);
			})
			.fail(function(task){

			})
			.always(function(){
				base.removeClass("is-busy");
			});
	},

	"{buildButton} click": function(buildButton) {

		self.build('cache');
	},

	"{buildWithoutMinifyButton} click": function() {

		self.build('development');
	},

	"{compileAllButton} click": function(compilceAllButton) {

		// self.compileAllSections();
	},

	"{compileButton} click": function(compileButton) {

		var sectionName = self.sectionNameOf(compileButton);
		return self.compile(sectionName);
	},

	"{forceCompileButton} click": function(forceCompileButton) {

		var sectionName = self.sectionNameOf(forceCompileButton);
		return self.compile(sectionName, {force: true});
	},

	"{minifyButton} click": function(minifyButton) {

		var sectionName = self.sectionNameOf(minifyButton);
		return self.minify(sectionName);
	},

	"{refreshButton} click": function() {

		// Show loading indicator
		base.addClass("is-busy");

		// Show indefinite progress bar
		self.progressBar(":first").show().width("100%");

		// Update status text
		self.progressStatus(":first").html("Refreshing");

		EasySocial.ajax("admin/views/themes/compiler",
		{
			location: self.location,
			name: self.name,
			override: self.override
		})
		.done(function(html){

			base.replaceWith(html);
		})
		.fail(function(){
			alert("Unable to refresh section.");
		})
		.always(function(){
			base.removeClass("is-busy");
		});
	},

	"{refreshSectionButton} click": function(refreshSectionButton) {

		var sectionName = self.sectionNameOf(refreshSectionButton),
			section = self.section({"sectionName": sectionName});

		// Show loading indicator
		section.addClass("is-busy");

		// Update status text
		section.at("progressStatus").html("Refreshing");

		EasySocial.ajax("admin/views/themes/section",
		{
			location: self.location,
			name: self.name,
			override: self.override,
			section: sectionName
		})
		.done(function(html){
			section.html(html);
		})
		.fail(function(){
			// TODO: Nicer alert.
			alert("Unable to refresh section.");
		})
		.always(function(){
			section.removeClass("is-busy");
		});
	},

	"{resetButton} click": function() {

		alert("TODO: Restore to factory default.");
	},

	"{purgeButton} click": function() {

		self.purge();
	}
}});

module.resolve();

});
EasySocial.module( 'admin/users/form' , function($) {

	var module = this;

	EasySocial.require()
	.script('field')
	.done(function($) {
		
		EasySocial.Controller('Users.Form', {
			defaultOptions: {
				userid: null,
				mode: 'adminedit',

				"{selectProfile}": "[data-user-select-profile]",
				"{content}": "[data-user-new-content]",
				"{profileTitle}": "[data-profile-title]",

				"{fieldItem}": "[data-profile-adminedit-fields-item]",

				"{tabnav}": "[data-tabnav]",
				"{tabcontent}": "[data-tabcontent]",

				"{stepnav}": "[data-stepnav]",
				"{stepcontent}": "[data-stepcontent]",

				view: {
					loading : "site/loading/large"
				}
			}
		}, function(self) {
			return {

				init : function() {
					window.selectedProfile 	= self.selectedProfile;

					self.fieldItem().addController('EasySocial.Controller.Field.Base', {
						userid: self.options.userid,
						mode: self.options.mode
					});
				},

				selectedProfile : function(profileId) {
					EasySocial.dialog().close();

					window.location.href	= 'index.php?option=com_easysocial&view=users&layout=form&profileId=' + profileId;
				},

				"{selectProfile} click" : function() {
					EasySocial.dialog(
					{
						content 	: EasySocial.ajax( 'admin/views/profiles/browse' )
					});
				},

				errorFields: [],

				'{fieldItem} error': function(el, ev) {
					var id = el.data('id');

					if($.inArray(id, self.errorFields) < 0) {
						self.errorFields.push(id);
					}

					var stepid = el.parents(self.stepcontent.selector).data('for');

					self.stepnav().filterBy('for', stepid).trigger('error');

					var tabid = el.parents(self.tabcontent.selector).data('for');

					self.tabnav().filterBy('for', tabid).trigger('error');
				},

				'{fieldItem} clear': function(el, ev) {
					var fieldid = el.data('id');

					self.errorFields = $.without(self.errorFields, fieldid);

					var stepid = el.parents(self.stepcontent.selector).data('for');

					self.stepnav().filterBy('for', stepid).trigger('clear');

					var tabid = el.parents(self.tabcontent.selector).data('for');

					self.tabnav().filterBy('for', tabid).trigger('clear');
				},

				'{stepnav} error': function(el) {
					el.addClass('error');
				},

				'{tabnav} error': function(el) {
					el.addClass('error');
				},

				'{stepnav} clear': function(el) {
					if(self.errorFields.length < 1) {
						el.removeClass('error');
					}
				},

				'{tabnav} clear': function(el) {
					if(self.errorFields.length < 1) {
						el.removeClass('error');
					}
				},

				'{stepnav} click': function(el) {
					var id = el.data('for');

					self.stepcontent().filterBy('for', id).find(self.fieldItem.selector).trigger('show');
				}
			}
		});

		module.resolve();
	});

});

EasySocial.module( 'admin/users/privacy' , function($){

	var module 	= this;

	EasySocial.require()
	.library( 'textboxlist' )
	.view( 'site/loading/small' )
	.done(function($){

		EasySocial.Controller(
			'Profile.Privacy',
			{
				defaultOptions:
				{
					userId	: '',

					"{privacyItem}" : "[data-privacy-item]",

					//input form
					"{privacyForm}" : "[data-profile-privacy-form]",

					view :
					{
						loading : "site/loading/small"
					}
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						self.privacyItem().implement( EasySocial.Controller.Profile.Privacy.Item ,
						{
							"{parent}"	: self
						});
					}
				}
			}
		);


		EasySocial.Controller(
			'Profile.Privacy.Item',
			{
				defaultOptions :
				{
					"{selection}"		: "[data-privacy-select]",
					"{hiddenCustom}" 	: "[data-hidden-custom]",
					"{customForm}" 		: "[data-privacy-custom-form]",

					"{customTextInput}" : "[data-textfield]",
					"{customItems}"		: "input[]",
					"{customHideBtn}"	: "[data-privacy-custom-hide-button]",
					"{customInputItem}"	: "[data-textboxlist-item]",
					"{customEditBtn}"   : "[data-privacy-custom-edit-button]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.customTextInput().textboxlist(
							{
								component: 'es',
								unique: true,

								plugin: {
									autocomplete: {
										exclusive: true,
										minLength: 2,
										cache: false,
										query: function( keyword ) {

											var users = self.getTaggedUsers();

											var ajax = EasySocial.ajax("site/views/privacy/getfriends",
												{
													q: keyword,
													userid: self.parent.options.userId,
													exclude: users
												});
											return ajax;
										}
									}
								}
							}
						);

						self.textboxlistLib = self.customTextInput().textboxlist("controller");
					},

					getTaggedUsers: function()
					{
						var users = [];
						var items = self.customInputItem();

						if( items.length > 0 )
						{
							$.each( items, function( idx, element ) {
								users.push( $( element ).data('id') );
							});
						}

						return users;
					},

					// event listener for adding new name
					"{customTextInput} addItem": function(el, event, data) {

						// lets get the exiting ids string
						var ids    = self.hiddenCustom().val();
						var values = '';

						if( ids == '')
						{
							values = data.id;
						}
						else
						{
							var idsArr = ids.split(',');
							idsArr.push( data.id );

							values = idsArr.join(',');
						}

						//now update the customhidden value.
						self.hiddenCustom().val( values );
					},

					// event listener for removing name
					"{customTextInput} removeItem": function(el, event, data ) {
						// lets get the exiting ids string
						var ids    = self.hiddenCustom().val();
						var values = '';
						var newIds = [];

						var idsArr = ids.split(',');

						for( var i = 0; i < idsArr.length; i++ )
						{
							if( idsArr[i] != data.id )
							{
								newIds.push( idsArr[i] );
							}
						}

						if( newIds.length <= 0 )
						{
							values = '';
						}
						else
						{
							values = newIds.join(',');
						}

						//now update the customhidden value.
						self.hiddenCustom().val( values );
					},

					"{customEditBtn} click" : function( el )
					{
						self.customForm().toggle();
					},

					"{selection} change" : function( el )
					{
						var selected = el.val();

						if( selected == 'custom' )
						{
							self.customForm().show();
							self.customEditBtn().show();
						}
						else
						{
							self.customForm().hide();
							self.customEditBtn().hide();
						}

						return;
					},

					"{customHideBtn} click" : function()
					{
						self.customForm().hide();
						self.customEditBtn().show();

						self.textboxlistLib.autocomplete.hide();

						return;
					}
				}
			});


		module.resolve();
	});

});

EasySocial.module( 'admin/users/users' , function($) {

	var module = this;

	EasySocial
	.require()
	.library( 'expanding' )
	.done( function($)
	{

		EasySocial.Controller(
			'Users',
			{
				defaultOptions : 
				{
					"{item}"	: "[data-user-item]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.item().implement( EasySocial.Controller.Users.Item );
					}
				}
			});

		EasySocial.Controller(
			'Users.Item',
			{
				defaultOptions : 
				{
					"{insertLink}"	: "[data-user-item-insertLink]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.options.name 	= self.element.data( 'name' );
						self.options.avatar	= self.element.data( 'avatar' );
						self.options.email	= self.element.data( 'email' );
						self.options.id 	= self.element.data( 'id' );
					},

					"{insertLink} click" : function()
					{
						self.trigger( 'userSelected' , [ self.options.id , self.options.name , self.options.avatar , self.options.email ] );
					}
				}
			});


		EasySocial.Controller(
			'Users.Pending',
			{
				defaultOptions : 
				{
					"{item}"	: "[data-pending-item]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.item().implement( EasySocial.Controller.Users.Pending.Item );
					}
				}
			});


		EasySocial.Controller(
			'Users.Pending.Item',
			{
				defaultOptions : 
				{
					"{approve}" : "[data-pending-approve]",
					"{reject}"	: "[data-pending-reject]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.options.id 	= self.element.data( 'id' );
					},

					"{approve} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'admin/views/users/confirmApprove' , { "id" : self.options.id } ),
							bindings 	:
							{
								"{approveButton} click" : function()
								{
									$( '[data-users-approve-form]' ).submit();
								}
							}
						});
					},

					"{reject} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'admin/views/users/confirmReject' , { "id" : self.options.id } )
						});

					}
				}
			})		
		module.resolve();

	});

});
EasySocial.module("albums/album", function($){

	var module = this;

	EasySocial.require()
		.library(
			"tinyscrollbar"
		)
		.done(function(){

			EasySocial.Controller("Albums.Album",
			{
				defaultOptions: {
					"{title}"        : "[data-album-title]",
					"{count}"        : "[data-album-count]",
					"{privacy}"      : "[data-album-privacy]",
					"{cover}"        : "[data-album-cover]",
					"{coverImage}"   : "[data-album-cover-image]",
					"{link}"         : "[data-album-link]",
					"{menu}"         : "[data-album-menu]",
					"{menuActions}"  : "[data-album-menu-actions]",
					"{shareButton}"  : "[data-album-share-button]",
					"{shareContent}" : "[data-sharing]",
					"{followButton}" : "[data-album-follow-button]",
					"{reportButton}" : "[data-album-report-button]",
					"{deleteButton}" : "[data-album-delete-button]",

					"{likeButton}"        : "[data-album-like-button]",
					"{commentButton}"     : "[data-album-comment-button]",

					"{countsButton}"      : "[data-album-counts-button]",
					"{commentCount}"      : "[data-album-comment-count]",
					"{likeCount}"         : "[data-album-like-count]",

					"{actions}"           : "[data-item-actions]",
					"{actionContent}"     : "[data-item-action-content]",
					"{actionCloseButton}" : "[data-item-action-close-button]",
					"{actionsMenu}"       : "[data-item-actions-menu]",

					"{likesHolder}"       : "[data-album-likes-holder]",
					"{commentsHolder}"    : "[data-album-comments-holder]",
					"{responseHolder}"    : "[data-album-response-holder]",

					"{comments}": "[data-comments]"
				}
			},
			function(self) { return {

				init: function()
				{
					self.id = self.element.data("album-id");

					self.actionContent()
						.tinyscrollbar();

					if (self.actions().hasClass("open")) {
						self.loadResponse();
						self.element.addClass("show-all");
					}
				},

				remove: function()
				{
					self.element.remove();
				},

				"{coverImage} click": function() {

					window.location = self.link().attr("href");
				},

				"{shareButton} click": function()
				{
					self.shareContent().show();
				},

				"{deleteButton} click": function()
				{
					EasySocial.dialog(
					{
						content: EasySocial.ajax( "site/views/albums/confirmDelete", { id: self.id })
					});
				},

				like: function() {

					EasySocial.ajax(
						"site/controllers/albums/like",
						{
							id: self.id
						}
					)
					.done(function(like) {

						// TODO: Update like count
						self.likeCount().html( like.count );

						// TODO: Change like text
						if( like.state )
						{
							self.likeButton().addClass( "liked" );
						}
						else
						{
							self.likeButton().removeClass("liked");
						}

						// TODO: Update like summary
						self.likesHolder().html( like.html );

						// To determine whether or not to like or unlike
						// self.likeButton().hasClass("liked")
					});
				},

				loadResponse: function() {

					var loader = self.loadResponse.loader;

					if (!loader || loader.state()=="rejected") {

						self.loadResponse.loader =
							EasySocial.ajax(
								"site/views/albums/response",
								{
									id: self.id
								}
							)
							.done(function(html) {

								self.responseHolder().html(html);

								self.actionContent()
									.removeClass("loading")
									.tinyscrollbar_update();
							});
					}
				},

				getButton: function(toggle) {

					var toggle = $(toggle),
						countsButton = self.countsButton(),
						commentButton = self.commentButton();

						if (toggle.is(countsButton) ||
							toggle.parents().filter(countsButton).length > 0) {
							return countsButton;
						}

						if (toggle.is(commentButton) ||
							toggle.parents().filter(commentButton).length > 0)
							return commentButton;

						return $();
				},

				lastButton: $(),

				"{actions} shown.bs.dropdown": function(actions, event, toggle) {

					// Show likes & comments
					self.loadResponse();

					// Make dropdown persistent even when hovered away
					self.element
						.addClass("show-all");

					var actionContent = self.actionContent(),
						button = self.lastButton = self.getButton(toggle),
						offset = (button.position().left + (button.width() / 2)) - (actionContent.width() / 2);

						actionContent
							.css("margin-left", offset)
							.tinyscrollbar_update();
				},

				"{actions} hide.bs.dropdown": function(actions, event, toggle) {

					self.element.removeClass("show-all");

					var button = self.getButton(toggle),
						lastButton = self.lastButton;

					if (!button.is(lastButton)) {
						setTimeout(function(){button.trigger("click")}, 0);
					}
				},

				"{actionCloseButton} click": function(el) {

					self.hideActionContent();
				},

				"{likeButton} click": function() {
					self.like();
				},

				"{comments} newCommentSaved": function() {

					var stat = self.comments().controller("EasySocial.Controller.Comments.Stat");
					self.commentCount().html(stat.total());

					self.actionContent()
						.tinyscrollbar_update("bottom");
				},

				"{comments} commentDeleted": function() {

					var stat = self.comments().controller("EasySocial.Controller.Comments.Stat");
					self.commentCount().html(stat.total());

					self.actionContent()
						.tinyscrollbar_update();
				},

				"{actionsMenu} shown.bs.dropdown": function() {
					self.element.addClass("show-all");
				},

				"{actionsMenu} hidden.bs.dropdown": function() {
					self.element.removeClass("show-all");
				}

			}});

			module.resolve();

		});
});


EasySocial.module("albums/browser", function($){

	var module = this;

	EasySocial.require()
		.library(
			"history"
		)
		.view(
			"site/albums/browser.list.item"
		)
		.done(function(){

			EasySocial.Controller("Albums.Browser",
			{
				hostname: "browser",

				defaultOptions: {

					view: {
						listItem: "site/albums/browser.list.item"
					},

					itemRenderOptions: {},

					"{sidebar}": "[data-album-browser-sidebar]",
					"{content}": "[data-album-browser-content]",

					"{createAlbumButton}"    : "[data-album-create-button]",
					"{createAlbumButtonLink}": "[data-album-create-button] > a",

					"{listItemGroup}": "[data-album-list-item-group]",
					"{listItemRegularGroup}": "[data-album-list-item-group=regular]",
					"{listItemCoreGroup}": "[data-album-list-item-group=core]",

					"{listItem}"     : "[data-album-list-item]",
					"{listItemLink}" : "[data-album-list-item] > a",
					"{listItemTitle}": "[data-album-list-item-title]",
					"{listItemCover}": "[data-album-list-item-cover]",
					"{listItemCount}": "[data-album-list-item-count]",

					"{albumItem}": "[data-album-item]",

					"{photoBrowser}": "[data-photo-browser]"
				}
			},
			function(self) { return {

				init: function() {

					// Attach existing album items as subscriber
					self.albumItem().each(function(){
						self.addSubscriber($(this).controller("EasySocial.Controller.Albums.Item"));
					})
				},

				setLayout: function(layout) {

					// Don't switch layout on dialog.
					if (self.element.hasClass("layout-dialog")) return;

					self.element
						.data("layout", layout)
						.switchClass("layout-" + layout);
				},

				open: function(view) {

					var args = $.makeArray(arguments);

					self.trigger("contentload", args);

					var method = "view" + $.String.capitalize(view),
						loader = self[method].apply(self, args.slice(1));

					loader
						.done(self.displayContent(function(){
							self.trigger("contentdisplay", args);
							return arguments;
						}))
						.fail(function(){
							self.trigger("contentfail", args);
						})
						.always(function(){
							self.trigger("contentcomplete", args);
						});

					return loader;
				},

				"{self} contentdisplay": function(el, event, view) {

					if (/album|albumform/gi.test(view)) {
						self.setLayout("album");
					}

					if (/photo/gi.test(view)) {
						self.setLayout("photo");
					}
				},

				displayContent: $.Enqueue(function(html){

					var scripts = [],
						content = $($.buildFragment([html], document, scripts));

					// Insert content
					self.content().html(content);

					// Remove scripts
					$(scripts).remove();
				}),

				viewAlbum: function(albumId) {

					// Remove loading indicator from any existing ones
					self.listItem().removeClass("active loading");

					var listItem =
						self.getListItem(albumId)
							.addClass("active loading");

					// Don't route if we're on dialog layout
					if (self.element.data("layout")!=="dialog") {
						listItem.find("> a").route();
					}

					var loader =
						EasySocial.ajax(
							"site/views/albums/item",
							{
								id: albumId,
								renderOptions: self.options.itemRenderOptions
							})
							.fail(function(){

							})
							.always(function(){

								listItem.removeClass("loading");
							});

					return loader;
				},

				viewAlbumForm: function()
				{

					// Remove loading indicator from any existing ones
					var listItems = self.listItem().removeClass("active loading"),
						listItem =
							self.view.listItem({})
								.addClass("active loading new")
								.prependTo(self.listItemRegularGroup());


					var loader = EasySocial.ajax( "site/views/albums/form" ,
									{
										"uid"	: self.options.uid,
										"type"	: self.options.type
									})
									.fail(function(){

									})
									.always(function(){

										listItem.removeClass("loading");
									});

					return loader;
				},

				viewPhoto: function(photoId) {

					var loader =
						EasySocial.ajax(
							"site/views/photos/item",
							{
								id: photoId,
								browser: 1
							})
							.fail(function(){
							})
							.always(function(){
							});

					return loader;
				},

				"{listItem} click": function(listItem) {

					// Don't do anything on new album item
					if (listItem.hasClass("new")) return;

					var albumId = listItem.data("albumId");

					// Load album
					self.open("Album", albumId);
				},

				"{listItemLink} click": function(listItemLink, event) {

					// Progressive enhancement, no longer refresh the page.
					event.preventDefault();

					// Prevent item from getting into :focus state
					listItemLink.blur();
				},

				"{createAlbumButton} click": function() {

					self.open("AlbumForm");

					// Don't route if we're on dialog layout
					if (self.element.data("layout")!=="dialog") {

						self.createAlbumButtonLink().route();
					}
				},

				"{createAlbumButtonLink} click": function(el, event) {

					event.preventDefault();
				},

				"{albumItem} init.albums.item": function(el, event, albumItem) {

					self.addSubscriber(albumItem);
				},

				getListItem: function(albumId, context) {

					var listItem =
						(!albumId) ?
							self.listItem(".new") :
							self.listItem().filterBy("albumId", albumId);

					if (!context) return listItem;

					return listItem.find(self["listItem" + $.String.capitalize(context)].selector);
				},

				updateListItemCount: function(albumId, val, append) {

					var stat = self.getListItem(albumId, "count");

					// If no stat element found, stop.
					if (stat.length < 0) return;

					// Get current stat count
					var statCount;

					if (append) {
						statCount = (parseInt(stat.text()) || 0) + (parseInt(val) || 0);
					} else {
						statCount = val;
					}

					// Always stays at 0 if less than that
					if (statCount < 0) statCount = 0;

					// Update stat count
					stat.text(statCount);
				},

				"{albumItem} albumSave": function(el, event, task)
				{
					task.done(function(album)
					{
						// For new albums
						// Remove item link's new state
						self.getListItem()
							.attr("data-album-id", album.id)
							.removeClass("new")

						// Update item link & route url
						self.getListItem(album.id)
							.find("> a")
							.attr({
								href : album.permalink,
								title: album.title
							})
							.route();

						// For existing albums
						self.getListItem(album.id, "title")
							.html(album.title);
					});
				},

				"{albumItem} titleChange": function(el, event, title, album) {

					self.getListItem(album.id, "title")
						.html($.trim(title) || "&nbsp;");
				},

				"{albumItem} coverChange": function(el, event, photo, album) {

					self.getListItem(album.id, "cover")
						.css("backgroundImage", $.cssUrl(photo.sizes.thumbnail.url));
				},

				"{albumItem} coverRemove": function(el, event, album) {

					self.getListItem(album.id, "cover")
						.css("backgroundImage", "");
				},

				"{albumItem} photoAdd": function(el, event, photoItem, photoData, album) {

					self.updateListItemCount(album.id, 1, true);
				},

				"{albumItem} photoMove": function(el, event, task, photo) {

					task
						.done(function(){
							self.updateListItemCount(photo.album.id, -1, true);
						});
				},

				"{albumItem} photoDelete": function(el, event, task, photo) {

					task
						.done(function(){
							self.updateListItemCount(photo.album.id, -1, true);
						});
				},

				"{photoBrowser} init.photos.browser": function(el, event, photoBrowser) {

					// Attach browser to photo browser
					self.addSubscriber(photoBrowser);
				},

				"{self} contentload": function() {

					// Remove any new item because there can only be one
					self.listItem(".new").remove();
				}

			}});

			module.resolve();

		});
});
EasySocial.module("albums/editor", function($){

	var module = this;

	// Constants
	var photoEditorController = "EasySocial.Controller.Photos.Editor"

	// Non-essential dependencies
	EasySocial.require()
		.script(
			"albums/editor/sortable",
			"albums/editor/uploader"
		)
		.done();

	// Essential dependencies
	var Controller =

	EasySocial.Controller("Albums.Editor",
	{
		hostname: "editor",

		defaultOptions: {

			view: {
		        uploadItem: "site/albums/upload.item"
			},

			canReorder: false,
			canUpload: true,

			"{titleField}"        : "[data-album-title-field]",
			"{captionField}"      : "[data-album-caption-field]",
			"{coverField}"        : "[data-album-cover-field]",

			"{type}"			  : "[data-album-type]",
			"{uid}"				  : "[data-album-uid]",

			"{location}"          : "[data-album-location]",
			"{locationCaption}"   : "[data-album-location-caption]",
			"{addLocationButton}" : "[data-album-addLocation-button]",
			"{date}"              : "[data-album-date]",
			"{dateCaption}"       : "[data-album-date-caption]",
			"{addDateCaption}"    : "[data-album-addDate-button]",
			"{privacy}"           : "[data-album-privacy]",

			"{uploadButton}"      : "[data-album-upload-button]",
			"{deleteButton}"      : "[data-album-delete-button]",
			"{moreButton}"        : "[data-album-more-button]",

			"{privacy}"			  : "[data-privacy-hidden]",
			"{privacycustom}"	  : "[data-privacy-custom-hidden]",

			"{uploadItem}"        : "[data-photo-upload-item]",

			"{dateDay}"		    : "[data-date-day]",
			"{dateMonth}"		: "[data-date-month]",
			"{dateYear}"		: "[data-date-year]",

			"{editButton}"     : "[data-album-edit-button]",
			"{editButtonLink}" : "[data-album-edit-button] > a",
			"{doneButton}"     : "[data-album-done-button]",
			"{doneButtonLink}" : "[data-album-done-button] > a",
			"{cancelButton}"   : "[data-album-cancel-button]",
			"{cancelButtonLink}"   : "[data-album-cancel-button] > a",

			"{locationWidget}"  : ".es-album-location-form .es-locations",
			"{latitude}"        : "[data-location-lat]",
			"{longitude}"       : "[data-location-lng]"
		}
	},
	function(self) { return {

		init: function() {

			self.id = self.element.data("album-id");

			var options = self.options;

			// If we can sort photos, load & implement sortable.
			if (options.canReorder) {
				EasySocial.module("albums/sortable")
					.done(function(SortableController){
						self.addPlugin("sortable", SortableController);
					});
			}

			// If we can upload photos, load & implement uploader.
			if (options.canUpload) {

				EasySocial.module("albums/editor/uploader")
					.done(function(UploaderController){
						self.uploader = self.addPlugin("uploader", UploaderController);
					});
			}

			// If this is an existing album, there's no need to create album
			if (self.id) {
				self.createAlbum.task = $.Deferred().resolve();
				self.createStream = 0;
			} else {
				self.createStream = 1;
			}
		},

		data: function() {

			var title         	= self.titleField().val(),
				caption       	= self.captionField().val(),
				date          	= self.formatDate(),
				address       	= self.locationCaption().html(),
				latitude      	= self.latitude().val(),
				longitude     	= self.longitude().val(),
				privacy       	= self.privacy().val(),
				privacycustom 	= self.privacycustom().val();
				uid 			= self.element.data( 'album-uid' );
				type 			= self.element.data( 'album-type' );

			return {
				id           : self.id,
				uid 		 : uid,
				type 		 : type,
				title        : title,
				caption      : caption,
				date         : date,
				address      : address,
				latitude     : latitude,
				longitude    : longitude,
				privacy      : privacy,
				privacycustom: privacycustom,
				createStream : self.createStream
			}
		},

		createAlbum: function() {

			var task = self.createAlbum.task;

			if (!task) {

				task = self.createAlbum.task =

					self.save({
							createStream: 0
						})
						.done(function(album){
							self.deleteButton().disabled(false);
							self.element.attr("data-album-id", self.id = album.id);
						})
						.fail(function(message, type){
							self.setMessage(message, type);
						});
			}

			return task;
		},

		save: function(options) {

			self.trigger("beforeAlbumSave", [self]);

			// Build save data
			var data = $.extend(self.data(), options);

				data.photos =
					$.map(
						self.album.photoItem(),
						function(photoItem, i){
							var editor = $(photoItem).controller("EasySocial.Controller.Photos.Editor");
							return (editor) ? editor.data() : null;
						});

				// TODO: Get photo ordering
				// data.ordering = self.getPhotoOrdering();

			// Clear any messages
			self.clearMessage();

			// Save album
			var task = EasySocial.ajax( "site/controllers/albums/store" , data );

			// Trigger albumSave event
			self.trigger("albumSave", [task, self]);

			// Return task
			return task;
		},

		"{self} photoAdd": function(el, event, photoItem, photoData) {

			// Set cover if this is the first photo
			if (self.album.photoItem().length <= 1) {
				self.changeCover(photoData);
			}
		},

		setCover: function(photoId) {

			var task =
				EasySocial.ajax(
					"site/controllers/albums/setCover",
					{
						albumId: self.id,
						coverId: photoId
					}
				)
				.done(function(photo){
					self.changeCover(photo);
				})
				.fail(function(){

				});

			return task;
		},

		removeCover: function() {

			self.trigger("coverRemove", [self.album]);
		},

		changeCover: function(photo) {

			self.trigger("coverChange", [photo, self]);
		},

		"{self} coverChange": function(el, event, photo) {

			self.coverField()
				.removeClass("no-cover")
				.css("backgroundImage", $.cssUrl(photo.sizes.thumbnail.url));
		},

		"{self} coverRemove": function() {

			self.coverField()
				.addClass("no-cover")
				.css("backgroundImage", "");
		},

		"{editButton} click": function() {

			// Change viewer layout
			self.album.setLayout("form");

			// Change address bar url
			self.editButtonLink().route();
		},

		"{editButtonLink} click": function(editButtonLink, event) {

			event.preventDefault();
		},

		"{cancelButton} click": function() {

			// Change viewer layout
			self.album.setLayout("item");

			// Change address bar url
			self.cancelButtonLink().route();
		},

		"{cancelButtonLink} click": function(editButtonLink, event) {

			event.preventDefault();
		},

		"{doneButton} click": function(el, event) {

			// Add a loading indicator here
			self.doneButtonLink().addClass('btn-loading');

			self.save()
				.done(function(album, html){

					// Replace the done link again
					self.doneButtonLink().removeClass('btn-loading');

					$.buildHTML(html).replaceAll(self.element);
				})
				.progress(function(message, type){
					self.setMessage(message, type);
				});
		},

		"{doneButtonLink} click": function(doneButtonLink, event) {
			event.preventDefault();
		},

		"{deleteButton} click": function(deleteButton) {
			
			if (deleteButton.disabled()) return;

			EasySocial.dialog({
				content: EasySocial.ajax("site/views/albums/confirmDelete", {id: self.id})
			});
		},

		formatDate: function() {
			var day = self.dateDay().val() || self.dateDay().data('date-default'),
				month = self.dateMonth().val() || self.dateMonth().data('date-default'),
				year = self.dateYear().val() || self.dateYear().data('date-default');

			return year + '-' + month + '-' + day;
			},

		updateDate: function() {

			self.date().addClass("has-data");
			var dateCaption = self.dateDay().val() + ' ' + $.trim(self.dateMonth().find(":selected").html()) + ' ' + self.dateYear().val();
			self.dateCaption().html(dateCaption);
		},

		"{dateDay} keyup": function() {
			self.updateDate();
		},

		"{dateMonth} change": function() {
			self.updateDate();
		},

		"{dateYear} keyup": function() {
			self.updateDate();
		},

		"{titleField} keyup": function(titleField) {

			self.trigger("titleChange", [titleField.val(), self]);
		},

		"{locationWidget} locationChange": function(el, event, location) {
			var address = location.address || location.fulladdress || location.formatted_address;

			// Set the address in the caption
			self.locationCaption().html(address);
			self.location().addClass("has-data");
		}

	}});

	module.resolve(Controller);
});

EasySocial.module("albums/editor/sortable", function($){

	var module = this;

	EasySocial.require()
		.library(
			"ui/sortable"
		)
		.done(function(){

			var Controller = 

			EasySocial.Controller("Albums.Editor.Sortable",
			{
				defaultOptions: {

				}
			},
			function(self) { return {

				init: function() {

					return;

					self.photoItemGroup()
						.sortable({
							forcePlaceholderSize: true,
							items: self.photoItem.selector,
							placeholder: 'es-photo-item placeholder',
							tolerance: 'pointer',
							delay: 150
						});
				},

				getPhotoOrdering: function() {

					var ordering = {};

					self.photoItem().each(function(i){
						var id = $(this).data("photoId");
						ordering[id] = i;
					});

					return ordering;
				},				

				"{parent.photoItemGroup} sortstart": function(el, event, ui) {

					ui.item.addClass("dragging");
					el.addClass("ordering");
					self.setLayout();
				},

				"{parent.photoItemGroup} sortchange": function(el, event, ui) {
					self.setLayout();
				},

				"{parent.photoItemGroup} sortstop": function(el, event, ui) {
					ui.item.removeClass("dragging");
					el.removeClass("ordering");
					self.setLayout();

					EasySocial.ajax(
						"site/controllers/photos/reorder",
						{
							id: ui.item.controller().id,
							order: ui.item.index()
						});					
				}
				
			}});

			module.resolve(Controller);

		});
});

EasySocial.module("albums/editor/uploader", function($){

	var module = this;

	EasySocial.require()
		.script(
			"albums/uploader"
		)
		.view(
			"site/albums/upload.item"
		)		
		.done(function(){

			var Controller = 

			EasySocial.Controller("Albums.Editor.Uploader",
			{
				defaultOptions: {

				}
			},
			function(self) { return {

				init: function() {

					// Shortcuts
					self.album = self.editor.album;

					// Get upload settings
					var settings = self.album.options.uploader;

					// Implement uploader
					self.uploader =
						self.addPlugin(
							"uploader",
							EasySocial.Controller.Albums.Uploader,
							{
								settings: settings,
								"{uploadButton}"   : self.editor.uploadButton.selector,
								"{uploadItemGroup}": self.album.photoItemGroup.selector,
								"{uploadDropsite}" : self.album.content.selector
							}
						);
				},

				setLayout: function() {

					self.album.setLayout_();
				},

				"{self} beforeAlbumSave": function() {

					// Stop existing upload process.
					self.uploader.stop();
				},

				"{self} albumSave": function(el, event, task) {

					task.done(function(album){

						var url = 
							$.uri(self.uploader.settings("url"))
								.replaceQueryParam("albumId", album.id)
								.toString();

						self.uploader.settings("url", url);							
					});
				},

				"{self} layoutChange": function(el, event, layoutName) {

					// Stop any running upload process
					// and clear upload items.
					self.uploader.stop();
					self.uploader.clear();

					var url = 
						$.uri(self.uploader.settings("url"))
							.replaceQueryParam("createStream", layoutName=="form" ? 0 : 1)
							.replaceQueryParam("layout", layoutName)
							.toString();

					self.uploader.settings("url", url);
				},

				"{self} QueueCreated": function(el, event, uploadItem) {
					
					// Give upload item a layout when we're under editor
					if (self.album.currentLayout()=="form") {
						uploadItem.element.addClass("layout-form");
					}

					self.setLayout();
				},
				
				startUpload: $.Enqueue(),

				"{uploader} FilesAdded": function(el, event, uploader, files) {

					// If this is a new album
					if (!self.id) {

						// Create the album first
						self.editor.createAlbum()
							.done(
								// Before we start uploading
								self.startUpload(function(){
									self.uploader.start();
								})
							);

					// Else start uploading straightaway
					} else {
						self.uploader.start();
					}

					self.setLayout();
				},

				"{uploader} FilesRemoved": function() {

					self.setLayout();
				},

				"{uploader} FileUploaded": function(el, event, uploader, file, response) {

					var uploadItem = self.uploader.getItem(file),

						photoItem = $.buildHTML(response.html),

						photoData = response.data;

						// Initialize photo item
						photoItem
							.addClass("new-item")
							.insertAfter(uploadItem.element);

						setTimeout(function(){
							photoItem.removeClass("new-item");
						}, 1);

						self.uploader.removeItem(file.id);

						self.trigger("photoAdd", [photoItem, photoData, self.album]);

						self.setLayout();
				}

			}});

			module.resolve(Controller);

		});
});

// module: start
EasySocial.module("albums/uploader", function($) {

    var module = this;

    // require: start
    EasySocial.require()
    .library("plupload")
    .script("albums/uploader.item")
    .view("site/albums/upload.item")
    .done(function(){

        // controller: start
        EasySocial.Controller("Albums.Uploader", {
    		defaultOptions: {

                view: {
                    uploadItem: "site/albums/upload.item"
                },

                direction: 'prepend',

                "{uploadButton}"   : "[data-upload-button]",
                "{uploadItemGroup}": "[data-upload-item-group]",
                "{uploadItem}"     : "[data-upload-item]",
                "{uploadDropsite}" : "[data-upload-dropsite]"
    		}
    	}, function(self, opts, base) { return {

                init: function() {

                    var uploader = self.element;

                    // Plupload controller
                    self.pluploadController =
                        self.element
                            .addController(
                                "plupload",
                                $.extend({
                                    "{uploadButton}" : self.uploadButton.selector,
                                    "{uploadDropsite}": self.uploadDropsite.selector
                                },self.options.settings)
                            );

                    // Plupload
                    self.plupload = self.pluploadController.plupload;

                    // Indicate uploader supports drag & drop
                    if (!$.IE && self.plupload.runtime=="html5") {

                        uploader.addClass("can-drop-file");
                    }

                    // Indicate uploader is ready
                    uploader.addClass("can-upload");
        		},

        		setLayout: function() {

                    self.uploadItemGroup().toggleClass("no-upload-items", self.uploadItem().length < 1);
        		},

                items: {},

                getItem: function(file) {

                    var id;

                    // By id
                    if ($.isString(file)) id = file;

                    // By file object
                    if (file && file.id) id = file.id;

                    return self.items[id];
                },

                createItem: function(file) {

                    // Create item controller
                    var item =
                        self.view.uploadItem({file: file})
                            .switchClass("layout-" + (base.data("albumLayout") || "form"))
                            .addController(
                                "EasySocial.Controller.Albums.Uploader.Item",
                                {
                                    "{uploader}": self,
                                    file: file
                                }
                            );

                    // Add to item group
                    item.element[opts.direction=='append' ? 'appendTo' : 'prependTo'](self.uploadItemGroup());

                    // Keep a copy of the item in our registry
                    self.items[file.id] = item;

                    self.setLayout();

                    self.trigger("QueueCreated", [item]);

                    return item;
                },

                settings: function(key, val) {

                    var settings = self.plupload.settings;

                    // Setter
                    if (val!==undefined) {
                        settings[key] = val;
                    }

                    // Getter
                    return (key) ? settings[key] : settings;
                },

                start: function() {

                    return self.plupload.start();
                },

                stop: function() {

                    return self.plupload.stop();
                },

                "{self} FilesAdded": function(el, event, uploader, files) {

                    // Wrap the entire body in a try...catch scope to prevent
                    // browser from trying to redirect and load the file if anything goes wrong here.
                    try {

                        // Reverse upload ordering as we are prepending.
                        files.reverse();

                        $.each(files, function(i, file) {

                            // The item may have been created before, e.g.
                            // when plupload error event gets triggered first.
                            if (self.getItem(file)) return;

                            self.createItem(file);
                        });

                    } catch (e) {

                        console.error(e);
                    };
                },

                "{self} BeforeUpload": function(el, event, uploader, file) {

                    var item = self.getItem(file);
                    if (!item) return;

                    item.setState("preparing");
                },

                "{self} UploadFile": function(el, event, uploader, file) {

                    var item = self.getItem(file);
                    if (!item) return;

                    item.setState("uploading");
                },

                "{self} UploadProgress": function(el, event, uploader, file) {

                    var item = self.getItem(file);
                    if (!item) return;

                    item.setState("uploading");
                    item.setProgress();
                },

                "{self} FileUploaded": function(el, event, uploader, file, response) {

                    var item = self.getItem(file);
                    if (!item) return;

                    // If the response is not a valid object
                    if (!$.isPlainObject(response)) {

                        // Set upload item state to failed.
                        item.setState("failed");
                        return;
                    }

                    item.setState("done");
                },

                "{self} FileError": function(el, event, uploader, file, response) {

                    var item = self.getItem(file);

                    // If the item hasn't been created, create first.
                    if (!item) item = self.createItem(file);

                    item.setState("failed");
                    item.setMessage(response.message);
                },

                "{self} Error": function(el, event, uploader, error) {

                    // If the returned error object also returns a file object
                    if (error.file) {

                        // Check if the upload item has been created
                        var file = error.file,
                            item = self.getItem(file);

                        // If the upload item doesn't exist
                        if (!item) item = self.createItem(file);

                        item.setState("failed");
                        item.setMessage(error.message);
                    }
                },

                removeItem: function(id) {

                    var item = self.getItem(id);
                    if (!item) return;

                    // Remove item
                    self.plupload.removeFile(item.file());
                    item.element.remove();
                    delete self.items[id];

                    self.setLayout();
                },

                clear: function(id) {

                    $.each(self.items, function(id, item){

                        // Remove item
                        self.plupload.removeFile(item.file());
                        item.element.remove();
                        delete self.items[id];
                    });

                    self.items = {};
                }

        	}}

        );
        // controller: end

    module.resolve();

    });
    // require: end

});
// module: end

EasySocial.module("albums/uploader.item", function($) {

	var module = this;

	EasySocial.Controller("Albums.Uploader.Item",

	    {
	        defaultOptions: {
	        	"{status}"       : ".upload-status",
	            "{filename}"     : ".upload-filename",
	            "{progressBar}"  : ".upload-progress-bar",
	            "{percentage}"   : ".upload-percentage",
	            "{filesizeTotal}": ".upload-filesize-total",
	            "{filesizeLeft}" : ".upload-filesize-left",
	            "{details}"      : ".upload-details",
	            "{detailsButton}": ".upload-details-button",
	            "{removeButton}" : ".upload-remove-button",
	            "{message}"      : ".upload-message"
	        }
	    },

		// Instance properties
		function(self) { return {

			init: function() {

				self.id = self.element.attr("id");

				var file = self.file();

				// Set filename
				self.filename().html(file.name);

				// Set state
				self.setState("pending");

				// Set progress & filesize
				self.setProgress();

				var html4 = self.uploader.plupload.runtime=="html4";

				if ($.IE < 10 || html4) {
					// So upload item will display with indefinite progressbar
					self.element.addClass("indefinite-progress");
				}

				if (html4) {
					self.element.addClass("no-filesize");
				}
			},

	        file: function() {

	            var file = self.uploader.plupload.getFile(self.id) || self.options.file;

	            if (file) {
	            	var noFilesize = (file.size===undefined || file.size=="N/A");
	            	file.percentage = file.percent + "%";
	                file.filesize   = (noFilesize) ? "" : $.plupload.formatSize(file.size);
	                file.remaining  = (noFilesize) ? "" : $.plupload.formatSize(file.size - (file.loaded || 0));
	            }

	            return file;
	        },

	        setProgress: function() {

				var file = self.file(),
					percentage = file.percentage;

				// Never use 100% because users might think
				// the photo is completely uploaded when it might
				// still be working.
				// - Thanks Alex Heil.
				if (percentage=="100%") percentage = "99%";
				if (percentage=="0%") percentage = "1%";

				// Progress bar width
				self.progressBar()
					.width(percentage);

				// Progress bar percentage
				self.percentage()
					.html(percentage);

				// Total filesize
				self.filesizeTotal()
					.html(file.filesize);

				// Remaining filesize
				self.filesizeLeft()
					.html(file.remaining);
	        },

	        setState: function(state) {

				self.element
					.removeClass("pending preparing uploading failed done")
					.addClass(state);

				self.state = state;
	        },

			setMessage: function(message) {

			   	self.detailsButton()
			   		.attr("data-popbox", message);
			},

			"{removeButton} click": function(el, event) {

			    self.uploader.removeItem(self.id);
			}

	    }}
	);

	module.resolve();

});

EasySocial.module("albums/item", function($){

	var module = this;

	// Non-essential dependencies
	EasySocial.require()
		.script("albums/editor")
		.done();

	// Essential dependencies
	EasySocial.require()
		.library(
			"masonry"
		)
		.done(function(){

			EasySocial.Controller("Albums.Item",
			{
				hostname: "album",

				defaultOptions: {

					tilesPerRow: 4,
					editable: false,
					multipleSelection: false,

					"{header}": "[data-album-header]",
					"{content}": "[data-album-content]",
					"{footer}": "[data-album-footer]",

					"{info}": "[data-album-info]",

					"{title}": "[data-album-title]",
					"{caption}"       : "[data-album-caption]",
					"{location}"      : "[data-album-location]",
					"{date}"          : "[data-album-date]",
					"{cover}"         : "[data-album-cover]",
					"{favouriteButton}"	  : "[data-album-favourite-button]",

					"{photoItemGroup}": "[data-photo-item-group]",
					"{photoItem}"     : "[data-photo-item]",
					"{photoImage}"    : "[data-photo-image]",
					"{photoImageCss}" : "[data-photo-image-css]",
					"{featuredItem}"  : "[data-photo-item].featured",
					"{featuredImage}" : "[data-photo-item].featured [data-photo-image]",
					"{featuredImageCss}" : "[data-photo-item].featured [data-photo-image-css]",
					"{uploadItem}"    : "[data-photo-upload-item]",

					"{moreButton}"    : "[data-album-more-button]",
					"{viewButton}"    : "[data-album-view-button]",

					"{share}"			  : "[data-repost-action]",
					"{likes}"			  : "[data-likes-action]",
					"{likeContent}" 	  : "[data-likes-content]",
					"{repostContent}" 	  : "[data-repost-content]",
					"{counterBar}"	  	  : "[data-stream-counter]"
				}
			},
			function(self, opts, base) { return {

				init: function()
				{
					self.id = base.data("album-id");

					self.nextStart = base.data("album-nextstart") || -1;

					// If this viewer is editable, load & implement editor.
					if (self.options.editable) {
						EasySocial.module("albums/editor")
							.done(function(EditorController)
							{
								self.editor = self.addPlugin("editor", EditorController);
							});
					}

					// Set layout when window is resized
					self.setLayout();

					// Show load more button
					// Quick monkey fix for load more button showing
					// on the right corner before layout is set.
					self.moreButton().show();

					// Attach existing photo items as subscribers
					self.addSubscriber(
						self.photoItem()
							.controllers("EasySocial.Controller.Photos.Item")
					);
				},

				"{window} resize": $.debounce(function(){
					self.setLayout();
				}, 250),

				currentLayout: function() {

					return base.data("albumLayout");
				},

				setLayout_: $.debounce(function(){

					self.setLayout();
				}, 100),

				setLayout: function(layoutName) {

					var photoItemGroup = self.photoItemGroup(),

						// Build layout state
						currentLayout = self.currentLayout(),
						layoutName    = layoutName || currentLayout,
						seed          = self.setLayout.seed,
						intact        = (seed == photoItemGroup.width() && currentLayout==layoutName)
						hasPhotoItem  = self.photoItem().length > 0,
						hasUploadItem = self.uploadItem().length > 0,
						hasItem       = hasPhotoItem || hasUploadItem,
						masonry       = $.data(photoItemGroup[0], "masonry"),

						// Put them in an object
						layout = {
							currentLayout: currentLayout,
							seed         : seed,
							intact       : intact,
							hasPhotoItem : hasPhotoItem,
							hasUploadItem: hasUploadItem,
							hasItem      : hasItem,
							masonry      : masonry
						};

					// Determine if we need to switch layout
					if (!intact) {

						// Switch layout
						base
							.data("albumLayout", layoutName)
							.switchClass("layout-" + layoutName);

						// Switch all photo item's layout
						self.photoItem()
							.switchClass("layout-" + layoutName);

						// Reset viewport width to force layout redraw
						self.setLayout.seed = layout.seed = null;

						// Only trigger layout change when layout has really changed.
						if (currentLayout !== layoutName) {
							// Trigger layout change event
							self.trigger("layoutChange", [layoutName, layout]);
						}
					}

					// Show upload hint when content is empty
					base.toggleClass("has-photos", hasItem);

					// If there's no item from the list
					if (!hasItem) {

						// If this is coming from deleting the last item
						// from the list, we need to keep the container
						// on zero height.
						photoItemGroup.css("opacity", 1);
					}

					// Execute layout handler
					var layoutHandler = "set" + $.String.capitalize(layoutName) + "Layout";
					self[layoutHandler](layout);

					// Save current layout
					self.setLayout.seed = photoItemGroup.width();
				},

				setItemLayout: function(layout) {

					self.photoItem().attr("data-es-photo-disabled", 0);

					// Get photoItemGroup
					var tilesPerRow = 4,
						photoItemGroup = self.photoItemGroup(),
						viewportWidth  = base.width(),
						containerWidth = Math.floor(viewportWidth / tilesPerRow) * tilesPerRow;

					self.photoItemGroup()
						.width(containerWidth);

					if (layout.masonry) {

						photoItemGroup.masonry("reloadItems").masonry("layout");
					} else {

						photoItemGroup
							.masonry({
								columnWidth: ".es-photo-item.grid-sizer",
								itemSelector: self.photoItem.selector + ", " + self.uploadItem.selector,
								isOriginLeft: !self.options.rtl
							});
					}
				},

				setFormLayout: function(layout) {

					self.photoItem().attr("data-es-photo-disabled", 1);

					// Destroy masonry if we are on form layout
					layout.masonry && layout.masonry.destroy();

					// Reset layout
					self.clearLayout();
				},

				setDialogLayout: function() {

					self.photoItem().attr("data-es-photo-disabled", 1);

					// Destroy masonry if we are on form layout
					layout.masonry && layout.masonry.destroy();

					// Reset layout
					self.clearLayout();
				},

				setThumbnailLayout: function() {

				},

				setRowLayout: function() {

					self.photoItem().attr("data-es-photo-disabled", 0);

					self.clearLayout();
				},

				clearLayout: function() {

					self.photoItemGroup()
						.addClass("no-transition");

					self.photoItem
						.css().remove();

					self.photoImage
						.css().remove();

					self.photoImageCss
						.css().remove();

					self.featuredItem
						.css().remove();

					self.featuredImage
						.css().remove();

					self.featuredImageCss
						.css().remove();

					self.uploadItem
						.css().remove();

					self.setLayout.seed = null;
				},

				getSelectedItems: function() {

					var selectedPhotos = self.photoItem(".selected");

					var data = [];

					selectedPhotos.each(function(i, photo){
						data.push($(photo).controller("EasySocial.Controller.Photos.Item").data());
					});

					return data;
				},

				"{photoItem} init.photos.item": function(el, event, photoItem) {

					self.addSubscriber(photoItem);
				},

				"{photoItem} destroyed": function() {

					self.setLayout();
				},

				"{photoItem} activate": function(photoItem, event, photo) {

					// Activate is a non-standard IE event,
					// if photo is undefined then it is coming
					// from the browser not photo item controller.
					if (!photo) return;

					var currentLayout = self.currentLayout();

					switch (currentLayout) {

						case "item":
						case "row":

							// Show loading indicator
							photoItem.addClass("loading");

							// If browser is available, ask browser
							// to load photo view via ajax.
							if (self.browser) {

								// View photo
								self.browser
									.open("photo", photo.id)
									.always(function(){

										// Remove loading indicator
										photoItem.removeClass("loading");
									});

								// Change address bar url
								photo.imageLink().route();

							// If browser is not available,
							// just load the photo view normally.
							} else {
								window.location = photo.imageLink().attr("href");
							}
							break;

						case "form":
							// photo.editor && photo.editor.enable();
							break;

						case "dialog":

							var selectedPhotos = self.photoItem(".selected");

							if (!self.options.multipleSelection) {

								var selected = photoItem.hasClass("selected");

								// In case it came from multiple selection
								selectedPhotos.removeClass("selected");

								photoItem.toggleClass("selected", !selected);

							} else {

								photoItem.toggleClass("selected");
							}
							break;
					}
				},

				"{photoItem} photoFeature": function(el, event, task, photo, featured) {

					// Set layout to accomodate double size photo item
					self.setLayout();

					// When a photo fail to be featured, it shrinks
					task
						.fail(function(){

							// So we're resetting layout again
							self.setLayout();
						});
				},

				"{photoItem} photoMove": function(el, event, task, photo, targetAlbumId) {

					self.clearMessage();

					task
						.done(function(){

							// Remove photo
							photo.element.remove();

							// Set layout
							self.setLayout();

							// If there are no more photos, remove cover
							if (self.photoItem().length < 1) {
								self.trigger("coverRemove", [self]);
							}
						})
						.fail(function(message, type){
							self.setMessage(message, type);
						});
				},

				"{photoItem} photoDelete": function(el, event, task, photo) {

					self.clearMessage();

					task
						.done(function(){

							// Remove photo
							photo.element.remove();

							// Set layout
							self.setLayout();

							// If there are no more photos, remove cover
							if (self.photoItem().length < 1) {
								self.trigger("coverRemove", [self]);
							}
						})
						.fail(function(message, type){
							self.setMessage(message, type);
						});
				},

				// These are coming from album editor
				"{self} albumSave": function(el, event, task) {

					task.done(function(album){
						self.id = album.id;
					});
				},

				"{self} coverChange": function(el, event, photo, album) {

					self.cover()
						.css("backgroundImage", $.cssUrl(photo.sizes.thumbnail.url));
				},

				"{self} coverRemove": function() {

					self.cover()
						.css("backgroundImage", "");
				},

				"{viewButton} click": function(viewButton, event) {
					if (self.browser)
					{
						event.preventDefault();
						base.addClass("loading");
						self.browser.open("Album", self.id);
					}
				},

				"{moreButton} click": function(moreButton) {

					// If nextStart is -1, means no more photos
					if (self.nextStart == -1) {
						return;
					}

					if (moreButton.disabled()) {
						return;
					}

					// Disable this button
					moreButton.toggleClass('loading');
					moreButton.disabled(true);

					// Set the button into loading state
					// moreButton.addClass('loading');

					// Get the new photos content
					EasySocial.ajax(
						"site/controllers/albums/loadMore",
						{
							albumId: self.id,
							start: self.nextStart,
							layout: self.currentLayout()
						})
						.done(function(htmls, nextStart) {

							self.nextStart = nextStart;

							var photoItemGroup = self.photoItemGroup();

							$.each(htmls, function(i, html){
								$.buildHTML(html).appendTo(photoItemGroup);
							});

							moreButton.toggleClass('loading');

							// If there is no more photos to load, hide the button
							if (nextStart < 0) {
								moreButton.hide();
							}

							self.setLayout();
						})
						.always(function(){

							moreButton.disabled(false);
						});
				},

                "{share} create": function(el, event, itemHTML) {
                	self.counterBar().removeClass('hide');
                },

 				"{likes} onLiked": function(el, event, data) {

					//need to make the data-stream-counter visible
					self.counterBar().removeClass( 'hide' );
				},

				"{likes} onUnliked": function(el, event, data) {

					var isLikeHide 		= self.likeContent().hasClass('hide');
					var isRepostHide 	= self.repostContent().hasClass('hide');

					if( isLikeHide && isRepostHide )
					{
						self.counterBar().addClass( 'hide' );
					}
				},

				"{favouriteButton} click": function()
				{
					EasySocial.ajax(
						"site/controllers/albums/favourite",
						{
							id: self.id
						}
					)
					.done(function(favourite) {
					
						self.favouriteButton().toggleClass( "is-fav btn-es-primary" );	
					});
				}

			}});

			module.resolve();
		});
});

EasySocial.module('apps/event/discussions', function($) {

    var module  = this;

    EasySocial.Controller(
        'Events.Item.Discussions',
        {
            defaultOptions:
            {
                "{filter}"  : "[data-event-discussions-filter]",
                "{contents}": "[data-event-discussion-contents]"
            }
        },
        function(self)
        {
            return {
                init: function()
                {
                    self.options.id     = self.element.data( 'id' );
                },

                setContent: function( html )
                {
                    // Remove loading class since we already have the content.
                    self.contents().removeClass( 'is-loading' );

                    self.contents().html( html );
                },

                setActiveFilter: function( el )
                {
                    // Remove active class.
                    self.filter().removeClass( 'active' );

                    // Add active class to the current element
                    el.addClass( 'active' );
                },

                "{filter} click" : function( el , event )
                {
                    var filter = el.data( 'filter' );

                    // Add loader for the contents area
                    self.contents().html( '&nbsp;' ).addClass( 'is-loading' );

                    // Set active filter
                    self.setActiveFilter( el );

                    // Run the ajax call now
                    EasySocial.ajax( 'apps/event/discussions/controllers/discussion/getDiscussions' ,
                    {
                        "id"        : self.options.id,
                        "filter"    : filter
                    })
                    .done(function( contents , empty )
                    {
                        if( empty )
                        {
                            self.contents().addClass( 'is-empty' );
                        }
                        else
                        {
                            self.contents().removeClass( 'is-empty' );
                        }
                        // Set the contents
                        self.setContent( contents );
                    });
                }
            }
        }
    );
    EasySocial.Controller(
        'Events.Item.Discussion',
        {
            defaultOptions:
            {
                "{form}"        : "[data-reply-form]",
                "{list}"        : "[data-reply-list]",
                "{replies}"     : "[data-reply-item]",
                "{repliesWrap}" : "[data-replies-wrapper]",

                "{replyCounter}": "[data-reply-count]",

                "{lock}"        : "[data-discussion-lock]",
                "{unlock}"      : "[data-discussion-unlock]",
                "{delete}"      : "[data-discussion-delete]"
            }
        },
        function( self )
        {
            return {
                init: function()
                {
                    self.options.id = self.element.data('id');
                    self.options.eventId = self.element.data('eventid');

                    self.implementReply(self.replies());

                    self.form().implement(EasySocial.Controller.Events.Item.Discussion.Form,{
                        "{parent}": self
                    });
                },

                implementReply: function()
                {
                    self.replies().implement(EasySocial.Controller.Events.Item.Discussion.Reply, {
                        "{parent}": self
                    });
                },

                insertReply: function(html)
                {
                    // Since we know that we need to append the reply item, we need to remove is-unanswered
                    self.element.removeClass( 'is-unanswered' );

                    // Since an item is added, we want to remove the empty class.
                    self.repliesWrap().removeClass( 'is-empty' );

                    // Append the new item
                    self.list().append( html );

                    // Implement the controller again
                    self.implementReply();
                },

                updateReplyCounter: function( total )
                {
                    if( total == 0 )
                    {
                        self.repliesWrap().addClass( 'is-empty' );
                    }
                    self.replyCounter().html( total );
                },

                setResolved: function()
                {
                    self.element.addClass( 'is-resolved' );
                },

                "{unlock} click" : function( el , event )
                {
                    EasySocial.ajax('apps/event/discussions/controllers/discussion/unlock', {
                        "id" : self.options.id
                    }).done(function() {
                        // Add lock element
                        self.element.removeClass('is-locked');
                    });
                },

                "{delete} click" : function(el, event)
                {
                    EasySocial.dialog({
                        content : EasySocial.ajax( 'apps/event/discussions/controllers/discussion/confirmDelete' , { "id" : self.options.id , "eventId" : self.options.eventId })
                    });
                },

                "{lock} click" : function( el , event )
                {
                    EasySocial.dialog(
                    {
                        content : EasySocial.ajax( 'apps/event/discussions/controllers/discussion/confirmLock' ),
                        bindings:
                        {
                            "{lockButton} click" : function()
                            {
                                EasySocial.ajax( 'apps/event/discussions/controllers/discussion/lock' ,
                                {
                                    "id" : self.options.id
                                })
                                .done(function()
                                {
                                    // Hide the dialog
                                    EasySocial.dialog().close();

                                    // Add lock element
                                    self.element.addClass( 'is-locked' );
                                });
                            }
                        }
                    });
                }
            }
        }
    );

    EasySocial.Controller(
        'Events.Item.Discussion.Reply',
        {
            defaultOptions:
            {
                "{acceptAnswer}"    : "[data-reply-accept-answer]",
                "{delete}"          : "[data-reply-delete]",
                "{edit}"            : "[data-reply-edit]",
                "{cancelEdit}"      : "[data-reply-edit-cancel]",
                "{update}"          : "[data-reply-edit-update]",
                "{textarea}"        : "[data-reply-content]",
                "{content}"         : "[data-reply-display-content]",
                "{alertDiv}"        : "div.alert-error"
            }
        },
        function( self )
        {
            return {
                init: function()
                {
                    console.log(self.element)
                    self.options.id     = self.element.data( 'id' );
                },
                "{acceptAnswer} click" : function()
                {
                    EasySocial.ajax( 'apps/event/discussions/controllers/reply/accept' ,
                    {
                        "id" : self.options.id
                    })
                    .done(function() {
                        self.parent.setResolved();
                    });
                },

                cancelEditing : function()
                {
                    self.element.removeClass( 'is-editing' );
                },

                "{cancelEdit} click" : function()
                {
                    self.cancelEditing();
                },

                "{edit} click" : function()
                {
                    self.element.addClass( 'is-editing' );
                },

                "{update} click" : function()
                {
                    var content     = self.textarea().val();

                    // console.log( self.element);

                    // If content is empty, throw some errors
                    if (content == '') {
                        self.element.addClass('is-empty');
                        self.alertDiv().show();
                        return false;
                    }

                    EasySocial.ajax( 'apps/event/discussions/controllers/reply/update' , {
                        "id": self.options.id,
                        "eventId": self.parent.options.eventId,
                        "content": content
                    })
                    .done(function(content) {
                        // Update the content
                        self.content().html( content );

                        self.element.removeClass('is-empty');
                        self.alertDiv().hide();


                        // Hide the textarea
                        self.cancelEditing();
                    });
                },

                "{delete} click" : function()
                {
                    EasySocial.dialog(
                    {
                        content     : EasySocial.ajax( 'apps/event/discussions/controllers/reply/confirmDelete' , { "id"    : self.options.id } ),
                        bindings    :
                        {
                            "{deleteButton} click" : function()
                            {
                                EasySocial.ajax( 'apps/event/discussions/controllers/reply/delete',
                                {
                                    "id"    : self.options.id
                                })
                                .done(function(discussion) {

                                    // Update the counter
                                    self.parent.updateReplyCounter( discussion.total_replies );

                                    // Hide the dialog
                                    EasySocial.dialog().close();

                                    // Remove the element
                                    self.element.remove();
                                });
                            }
                        }
                    });
                }
            }
        }
    );

    EasySocial.Controller(
        'Events.Item.Discussion.Form',
        {
            defaultOptions:
            {
                "{textarea}"    : "[data-reply-content]",
                "{submitReply}" : "[data-reply-submit]"
            }
        },
        function( self )
        {
            return {
                init: function()
                {
                },

                "{submitReply} click" : function( el , event )
                {
                    var content     = self.textarea().val();

                    // If content is empty, throw some errors
                    if ( content == '' ) {
                        self.element.addClass( 'is-empty' );
                        return false;
                    }

                    EasySocial.ajax('apps/event/discussions/controllers/reply/submit', {
                        "id"        : self.parent.options.id,
                        "eventId"   : self.parent.options.eventId,
                        "content"   : content
                    })
                    .done(function(html) {
                        // Inser the new node back.
                        self.parent.insertReply(html);

                        // Update the textarea
                        self.textarea().val('');
                    });

                }
            }
        }
    );

    module.resolve();
});


EasySocial.module('apps/event/guests', function($) {

    var module  = this;


    EasySocial.Controller('Events.Item.Guests', {
        defaultOptions: {
            '{filters}': '[data-event-guests-filter]',
            '{content}': '[data-event-guests-content]'
        }
    }, function(self) {
        return {
            init : function()
            {
                self.options.id = self.element.data('id');

                self.items = self.addPlugin('Item');
            },

            '{filters} click': function(el, event)
            {
                event.preventDefault();

                el.route();

                // Remove active
                self.filters().removeClass('active');

                // Set current to active
                el.addClass('active');

                // Get the filter
                var filter  = el.data('filter');

                // Set the loading class
                self.content().html('&nbsp;');
                self.content().addClass('is-loading');

                EasySocial.ajax('apps/event/guests/controllers/events/filterGuests', {
                    'id': self.options.id,
                    'filter': filter
                }).done(function(contents, total) {
                    self.content().removeClass('is-loading');

                    if (total == 0) {
                        self.content().addClass('is-empty');
                    } else {
                        self.content().removeClass('is-empty');
                    }
                    self.content().html(contents);
                });
            },

            '{self} emptyGuest': function() {
                self.content().addClass('is-empty');
            }
        }
    });

    EasySocial.Controller(
        'Events.Item.Guests.Item',
        {
            defaultOptions:
            {
                '{item}': '[data-event-guest-item]',
                '{promote}': '[data-guest-promote]',
                '{demote}': '[data-guest-demote]',
                '{approve}': '[data-guest-approve]',
                '{reject}': '[data-guest-reject]',
                '{remove}': '[data-guest-remove]'
            }
        },
        function( self )
        {
            return {
                init : function()
                {
                },

                getItem: function(el)
                {
                    var item = self.item.of(el);

                    return item;
                },

                '{approve} click' : function(el)
                {
                    var item = self.getItem(el),
                        guestId = item.data('guestId');

                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/confirmApproveGuest', {
                            'id': guestId
                        }),
                        bindings: {
                            '{approveButton} click': function() {
                                EasySocial.ajax('site/controllers/events/approveGuest', {
                                    'id': guestId
                                })
                                .done(function() {
                                    EasySocial.dialog().close();

                                    // Remove guest from the pending list
                                    item.remove();

                                    self.item().length === 0 && self.element.trigger('emptyGuest');
                                });
                            }
                        }
                    });
                },

                '{reject} click' : function(el)
                {
                    var item = self.getItem(el),
                        guestId = item.data('guestId');

                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/confirmRejectGuest', {
                            'id': guestId
                        }),
                        bindings: {
                            '{rejectButton} click': function() {
                                EasySocial.ajax('site/controllers/events/rejectGuest', {
                                    'id': guestId
                                })
                                .done(function() {
                                    EasySocial.dialog().close();

                                    // Remove guest from the pending list
                                    item.remove();

                                    self.item().length === 0 && self.element.trigger('emptyGuest');
                                });
                            }
                        }
                    });
                },

                '{promote} click' : function(el)
                {
                    var item = self.getItem(el),
                        guestId = item.data('guestId');


                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/confirmPromoteGuest', {
                            'id': guestId
                        }),
                        bindings: {
                            '{promoteButton} click': function() {
                                EasySocial.ajax('site/controllers/events/promoteGuest', {
                                    'id': guestId
                                }).done(function() {
                                    EasySocial.dialog().close();

                                    // Add the admin label
                                    item.removeClass('is-member')
                                        .addClass('is-admin');
                                });
                            }
                        }
                    })
                },

                '{demote} click' : function(el)
                {
                    var item = self.getItem(el),
                        guestId = item.data('guestId');

                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/confirmDemoteGuest', {
                            'id': guestId
                        }),
                        bindings: {
                            '{demoteButton} click' : function() {
                                EasySocial.ajax('site/controllers/events/demoteGuest', {
                                    'id': guestId
                                })
                                .done(function() {
                                    EasySocial.dialog().close();

                                    // If the current tab is admin, then we remove instead
                                    if (self.parent.filters('.active').data('filter') == 'admin') {
                                        item.remove();

                                        self.item().length === 0 && self.element.trigger('emptyGuest');
                                    } else {
                                        // Remove the admin label
                                        item.removeClass('is-admin').addClass('is-member');
                                    }
                                });

                            }
                        }
                    });
                },

                '{remove} click' : function(el, event)
                {
                    var item = self.getItem(el),
                        guestId = item.data('guestId');

                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/confirmRemoveGuest', {
                            'id': guestId
                        }),
                        bindings: {
                            '{removeButton} click': function() {
                                EasySocial.ajax('site/controllers.events/removeGuest', {
                                    'id': guestId
                                })
                                .done(function() {
                                    EasySocial.dialog().close();

                                    // Remove guest from the list
                                    item.remove();

                                    self.item().length === 0 && self.element.trigger('emptyGuest');
                                });
                            }
                        }
                    });
                }
            }
        }
    );


    module.resolve();
});


EasySocial.module('apps/event/tasks', function($)
{
    var module = this;

    EasySocial.Controller('Events.Apps.Tasks.Milestones.Browse', {
        defaultOptions: {
            eventId: null,

            "{milestone}": "[data-tasks-milestone-item]"
        }
    }, function(self) {
        return {
            init: function()
            {
                self.options.eventId = self.element.data('eventid');

                self.milestone().addController(EasySocial.Controller.Events.Apps.Tasks.Milestones.Item, {
                    "{parent}"  : self
                });
            }
        }
    });

    EasySocial.Controller('Events.Apps.Tasks.Milestones.Item', {
        defaultOptions: {
            "{complete}": "[data-milestone-mark-complete]",
            "{incomplete}": "[data-milestone-mark-incomplete]",
            "{delete}": "[data-milestone-delete]",
            "{milestone}": "[data-event-tasks-milestone-item]"
        }
    }, function(self) {
        return {
            init: function()
            {
                self.options.id = self.element.data('id');
            },

            "{incomplete} click" : function(el)
            {
                EasySocial.ajax('apps/event/tasks/controllers/milestone/unresolve',
                {
                    id: self.options.id,
                    eventId: self.parent.options.eventId
                })
                .done(function() {
                    self.element.removeClass('is-due').removeClass('is-completed');

                    el.hide();

                    self.complete().show();
                });
            },

            "{complete} click" : function(el)
            {
                EasySocial.ajax('apps/event/tasks/controllers/milestone/resolve', {
                    id: self.options.id,
                    eventId: self.parent.options.eventId
                })
                .done(function() {
                    self.element.removeClass('is-due').addClass('is-completed');

                    el.hide();

                    self.incomplete().show();
                });
            },

            "{delete} click" : function()
            {
                EasySocial.dialog( {
                    content : EasySocial.ajax('apps/event/tasks/controllers/milestone/confirmDelete', {
                        id: self.options.id,
                        eventId: self.parent.options.eventId
                    }),
                    bindings: {
                        '{deleteButton} click' : function() {
                            EasySocial.ajax('apps/event/tasks/controllers/milestone/delete', {
                                id: self.options.id,
                                eventId: self.parent.options.eventId
                            })
                            .done(function() {
                                EasySocial.dialog().close();

                                self.element.remove();
                            });
                        }
                    }
                });
            }
        }
    });

    EasySocial.Controller('Events.Apps.Tasks', {
        defaultOptions: {
            '{form}': '[data-tasks-form]',
            '{formWrapper}': '[data-tasks-form-wrapper]',
            '{taskList}': '[data-tasks-list]',
            '{item}': '[data-tasks-list-item]',
            '{completedList}': '[data-tasks-completed]',
            '{openCounter}': '[data-tasks-open-counter]',
            '{closedCounter}': '[data-tasks-closed-counter]',
            "{completeMilestone}": "[data-milestone-mark-complete]",
            "{incompleteMilestone}": "[data-milestone-mark-incomplete]",
            "{deleteMilestone}": "[data-milestone-delete]",
            "{wrapper}": "[data-tasks-wrapper]"
        }
    }, function(self) {
        return {
            init: function()
            {
                self.options.id = self.element.data('id');
                self.options.eventId = self.element.data('eventid');
                self.options.milestoneId = self.element.data('milestoneid');

                // Implement form controller
                self.form().addController(EasySocial.Controller.Events.Apps.Tasks.Form, {
                    "{parent}": self
                });

                self.implementItemController();
            },
            implementItemController: function()
            {
                // Implement task item controller
                self.item().addController(EasySocial.Controller.Events.Apps.Tasks.Item, {
                    "{parent}": self
                });
            },
            updateOpenCounter: function(total)
            {
                self.openCounter().html(total);
            },
            updateClosedCounter: function(total)
            {
                self.closedCounter().html(total);
            },
            insertCompleted: function(taskItem)
            {
                $(taskItem).appendTo(self.completedList());
            },
            insertTask: function(taskItem)
            {
                self.formWrapper().after(taskItem);

                // Implement item controller on the tasks
                self.implementItemController();
            },
            "{uncompleteMilestone} click" : function()
            {
                EasySocial.ajax('apps/event/tasks/controllers/milestone/unresolve',
                {
                    id: self.options.milestoneId,
                    eventId: self.options.eventId
                })
                .done(function()
                {
                    self.wrapper().removeClass('is-due').removeClass('is-completed');
                });
            },
            "{completeMilestone} click" : function()
            {
                EasySocial.ajax('apps/event/tasks/controllers/milestone/resolve', {
                    id: self.options.milestoneId,
                    eventId: self.options.eventId
                })
                .done(function() {
                    self.wrapper().removeClass('is-due').addClass('is-completed');
                });
            },

            "{deleteMilestone} click" : function()
            {
                EasySocial.dialog( {
                    content : EasySocial.ajax('apps/event/tasks/controllers/milestone/confirmDelete', {
                        id: self.options.milestoneId,
                        eventId: self.options.eventId
                    }),
                    bindings: {
                        '{deleteButton} click' : function() {
                            EasySocial.ajax('apps/event/tasks/controllers/milestone/delete', {
                                id: self.options.id,
                                eventId: self.options.eventId
                            })
                            .done(function() {
                                EasySocial.dialog().close();

                                window.location = self.options.redirect;
                            });
                        }
                    }
                });
            }
        }
    });

    EasySocial.Controller('Events.Apps.Tasks.Item', {
        defaultOptions: {
            '{checkbox}': '[data-item-checkbox]',
            '{delete}': '[data-tasks-item-remove]'
        }
    }, function(self) {
        return {
            init: function()
            {
                self.options.id = self.element.data('id');
            },
            '{delete} click' : function()
            {
                EasySocial.dialog({
                    content: EasySocial.ajax('apps/event/tasks/controllers/tasks/confirmDelete', {
                        'eventId': self.parent.options.eventId
                    }),
                    bindings: {
                        '{deleteButton} click' : function() {
                            EasySocial.ajax('apps/event/tasks/controllers/tasks/delete', {
                                id: self.options.id,
                                eventId: self.parent.options.eventId
                            })
                            .done(function() {
                                EasySocial.dialog().close();

                                var total = parseInt(self.parent.openCounter().html());

                                self.parent.updateOpenCounter(total - 1);

                                self.element.remove();
                            });
                        }
                    }
                });
            },
            '{checkbox} change': function(el, event)
            {
                var checked = $(el).is(':checked');

                if (checked) {
                    EasySocial.ajax('apps/event/tasks/controllers/tasks/resolve', {
                        id: self.options.id,
                        eventId: self.parent.options.eventId
                    })
                    .done(function() {
                        // Decrease the open counter
                        var total = parseInt(self.parent.openCounter().html());

                        self.parent.updateOpenCounter(total - 1);

                        var total = parseInt(self.parent.closedCounter().html());

                        self.parent.updateClosedCounter(total + 1);

                        self.parent.insertCompleted(self.element);
                    });

                } else {
                    EasySocial.ajax('apps/event/tasks/controllers/tasks/unresolve', {
                        id: self.options.id,
                        eventId: self.parent.options.eventId
                    })
                    .done(function($) {
                        // Decrease the open counter
                        var total = parseInt(self.parent.openCounter().html());

                        self.parent.updateOpenCounter(total + 1);

                        var total = parseInt(self.parent.closedCounter().html());

                        self.parent.updateClosedCounter(total - 1);

                        self.parent.insertTask(self.element);
                    });
                }
            }
        }
    });

    EasySocial.Controller('Events.Apps.Tasks.Form', {
        defaultOptions: {
            '{title}': "[data-form-tasks-title]",
            '{create}': "[data-form-tasks-create]",
            '{assignee}': "[data-form-tasks-assignee]",
            '{due}': "[data-form-tasks-due]",
            '{error}': "[data-tasks-form-error]"
        }
    }, function(self) {
        return {
            init: function()
            {

            },

            resetForm: function()
            {
                self.element[0].reset();
            },

            "{title} keyup" : function(el, event)
            {
                // Enter key
                if(event.keyCode == 13) {
                    self.create().click();
                }
            },

            "{create} click" : function()
            {
                if(self.title().val() == '') {
                    self.error().removeClass('hide');

                    return false;
                }

                self.error().addClass('hide');

                EasySocial.ajax('apps/event/tasks/controllers/tasks/save', {
                    title: self.title().val(),
                    assignee: self.assignee().val(),
                    due: self.due().val(),
                    eventId: self.parent.options.eventId,
                    milestoneId: self.parent.options.milestoneId
                })
                .done(function(content) {

                    // Reset the form
                    self.resetForm();

                    // Increment the counter
                    var total = parseInt(self.parent.openCounter().html());

                    self.parent.updateOpenCounter(total + 1);

                    self.parent.insertTask(content);
                });
            }
        }
    });

    module.resolve();
});


EasySocial.module('apps/fields/event/description/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_EVENT_DESCRIPTION_VALIDATION_INPUT_REQUIRED')
        .done(function($) {

            EasySocial.Controller('Field.Event.Description', {
                defaultOptions: {
                    "required": false,
                    "editor": null,
                    "{input}": '[data-field-description]'
                }
            }, function(self) { return {

                init: function() {
                    self.editor = self.options.editor;
                },

                '{input} keyup': function() {
                    self.validateInput();
                },

                '{input} blur': function() {
                    self.validateInput();
                },

                validateInput: function() {
                    self.clearError();

                    var value = self.editor.getContent();

                    if (self.options.required && $.isEmpty(value)) {
                        self.raiseError($.language('PLG_FIELDS_EVENT_DESCRIPTION_VALIDATION_INPUT_REQUIRED'));
                        return false;
                    }

                    return true;
                },

                raiseError: function(msg) {
                    self.trigger('error', [msg]);
                },

                clearError: function() {
                    self.trigger('clear');
                },
                
                '{self} onError': function(el, ev, type) {
                    if(type === 'required') {
                        self.raiseError($.language('PLG_FIELDS_EVENT_DESCRIPTION_VALIDATION_INPUT_REQUIRED'));
                    }
                },

                '{self} onSubmit': function(el, ev, register) {
                    register.push(self.validateInput());
                }
            }});

            module.resolve();
        });
});

EasySocial.module('apps/fields/event/permalink/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language(
            'FIELDS_EVENT_PERMALINK_EXCEEDED_MAX_LENGTH',
            'FIELDS_EVENT_PERMALINK_REQUIRED')
        .done(function($) {

            EasySocial.Controller(
                'Field.Event.Permalink',
                {
                    defaultOptions:
                    {
                        required: false,

                        max     : 0,

                        id      : null,
                        clusterid   : null,
                        userid  : null,

                        '{field}'           : '[data-field-permalink]',

                        '{checkButton}'     : '[data-permalink-check]',
                        '{input}'           : '[data-permalink-input]',
                        '{available}'       : '[data-permalink-available]'
                    }
                },
                function(self)
                {
                    return {
                        state: false,

                        init: function()
                        {
                            self.options.max = self.field().data('max');
                        },

                        "{checkButton} click" : function()
                        {
                            self.delayedCheck();
                        },

                        "{input} keyup" : function()
                        {
                            self.delayedCheck();
                        },

                        delayedCheck: $.debounce(function()
                        {
                            self.checkPermalink();
                        }, 250),

                        checkPermalink: function()
                        {
                            self.clearError();

                            var permalink   = self.input().val();

                            self.available().hide();

                            if (self.options.max > 0 && permalink.length > self.options.max) {
                                self.raiseError($.language('FIELDS_EVENT_PERMALINK_EXCEEDED_MAX_LENGTH'));
                                return false;
                            }

                            if (!$.isEmpty(permalink)) {
                                self.checkButton().addClass('btn-loading');

                                var state = $.Deferred();

                                EasySocial.ajax('fields/event/permalink/isValid', {
                                    "id"        : self.options.id,
                                    "clusterid" : self.options.clusterid,
                                    "permalink" : permalink
                                })
                                .done(function(msg) {
                                    self.clearError();

                                    self.checkButton().removeClass('btn-loading');

                                    self.available().show();

                                    state.resolve();
                                })
                                .fail(function(msg) {
                                    self.raiseError(msg);

                                    self.checkButton().removeClass('btn-loading');

                                    self.available().hide();

                                    state.reject();
                                });

                                return state;
                            }

                            if (self.options.required && $.isEmpty(permalink)) {
                                self.available().hide();

                                self.raiseError($.language('FIELDS_EVENT_PERMALINK_REQUIRED'));
                                return false;
                            }

                            return true;
                        },

                        raiseError: function(msg)
                        {
                            self.trigger('error', [msg]);
                        },

                        clearError: function()
                        {
                            self.trigger('clear');
                        },

                        '{self} onSubmit': function(el, ev, register)
                        {
                            register.push(self.checkPermalink());
                        }
                    }
                }
            );

            module.resolve();
        });
});

EasySocial.module('apps/fields/event/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/event/recurring/content', function($) {
    var module = this;

    EasySocial.require().library('datetimepicker').done(function() {

        EasySocial.Controller('Field.Event.Recurring', {
            defaultOptions: {
                id: null,

                value: {},

                allday: 0,

                showWarningMessages: 0,

                eventId: null,

                '{type}': '[data-recurring-type]',

                '{endBlock}': '[data-recurring-end-block]',

                '{picker}': '[data-recurring-end-picker]',

                '{toggle}': '[data-recurring-end-toggle]',

                '{result}': '[data-recurring-end-result]',

                '{dailyBlock}': '[data-recurring-daily-block]',

                '{dailyInput}': '[data-recurring-daily-block] input',

                '{summaryBlock}': '[data-recurring-summary-block]',

                '{scheduleToggle}': '[data-recurring-schedule-toggle]',

                '{scheduleBlock}': '[data-recurring-schedule-block]',

                '{scheduleLoadingBlock}': '[data-recurring-schedule-loading-block]',

                '{deleteRecurringButton}': '[data-recurring-delete]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.picker()._datetimepicker({
                        pickTime: false,
                        component: "es",
                        useCurrent: false
                    });

                    var value = self.result().val();

                    if (!$.isEmpty(value)) {
                        var dateObj = $.moment(value);

                        self.datetimepicker('setDate', dateObj);
                    }

                    self.calculateTotalRecur();
                },

                changed: 0,

                '{window} easysocial.fields.allday.change': function(el, ev, value) {
                    self.options.allday = value;

                    self.calculateTotalRecur();
                },

                '{window} easysocial.fields.startend.start.change': function(el, ev, date) {
                    self.calculateTotalRecur();
                },

                '{toggle} click': function() {
                    self.picker().focus();
                },

                '{picker} dp.change': function(el, ev) {
                    self.setDateValue(ev.date.toDate());

                    self.detectChanges();

                    self.calculateTotalRecur();
                },

                '{type} change': function(el, ev) {
                    var value = el.val();

                    self.endBlock()[value === 'none' ? 'hide' : 'show']();

                    self.dailyBlock()[value === 'daily' ? 'show': 'hide']();

                    self.detectChanges();

                    self.calculateTotalRecur();
                },

                '{dailyInput} change': function(el, ev) {
                    self.detectChanges();

                    self.calculateTotalRecur();
                },

                calculateTotalRecur: function() {
                    self.summaryBlock().hide();

                    self.clearError();

                    var start = $('[data-event-start]').find('[data-datetime]').val(),
                        timezone = $('[data-event-timezone]').val(),
                        end = self.result().val(),
                        type = self.type().val(),
                        daily = [];

                    if (type == 'none' && !self.options.showWarningMessages) {
                        return;
                    }

                    if ($.isEmpty(start) || $.isEmpty(end) || $.isEmpty(type)) {
                        return;
                    }

                    $.each(self.dailyBlock().find('input'), function(i, input) {
                        el = $(input);
                        if (el.is(':checked')) {
                            daily.push(el.val());
                        }
                    });

                    self.scheduleLoadingBlock().show();

                    self.getTotalRecur({
                        start: start,
                        timezone: timezone,
                        end: end,
                        type: type,
                        daily: daily
                    });
                },

                getTotalRecur: $.debounce(function(options) {
                    self.clearError();

                    EasySocial.ajax('fields/event/recurring/calculateTotalRecur', {
                        id: self.options.id,
                        start: options.start,
                        timezone: options.timezone,
                        allday: self.options.allday,
                        end: options.end,
                        type: options.type,
                        daily: options.daily,
                        eventId: self.options.eventId,
                        changed: self.changed,
                        showWarningMessages: self.options.showWarningMessages
                    }).done(function(html) {
                        self.summaryBlock().html(html).show();
                    }).fail(function(msg) {
                        self.raiseError(msg);
                    }).always(function() {
                        self.scheduleLoadingBlock().hide();
                    });
                }, 500),

                detectChanges: function() {
                    var end = self.result().val(),
                        type = self.type().val(),
                        daily = [],
                        changed = false;

                    $.each(self.dailyBlock().find('input'), function(i, input) {
                        el = $(input);
                        if (el.is(':checked')) {
                            daily.push(el.val());
                        }
                    });

                    if (type != self.options.value.type || end != self.options.value.end || daily.length != self.options.value.daily.length) {
                        changed = true;
                    }

                    $.each(daily, function(i, d) {
                        if ($.inArray(d, self.options.value.daily) == -1) {
                            changed = true;
                            return false;
                        }
                    });

                    $.each(self.options.value.daily, function(i, d) {
                        if ($.inArray(d, daily) == -1) {
                            changed = true;
                            return false;
                        }
                    });

                    self.changed = changed ? 1 : 0;

                    $(window).trigger('easysocial.fields.recurring.changed', [changed]);
                },

                '{scheduleToggle} click': function(el, ev) {
                    self.scheduleBlock().toggle();
                },

                '{deleteRecurringButton} click': function(el, ev) {
                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/deleteRecurringDialog', {
                            id: self.options.eventId
                        }),
                        bindings: {
                            "{submitButton} click": function()
                            {
                                var dialog = this.parent;

                                dialog.loading(true);

                                self.deleteRecurring()
                                    .done(function() {
                                        dialog.loading(false);

                                        dialog.close();

                                        self.calculateTotalRecur();
                                    });
                            }
                        }
                    })
                },

                deleteRecurring: function() {
                    return EasySocial.ajax('site/controllers/events/deleteRecurring', {
                        eventId: self.options.eventId
                    })
                },

                datetimepicker: function(name, value) {
                    return self.picker().data('DateTimePicker')[name](value);
                },

                setDateValue: function(date) {
                    // Convert the date object into sql format and set it into the input
                    self.result().val(date.getFullYear() + '-' +
                                        ('00' + (date.getMonth()+1)).slice(-2) + '-' +
                                        ('00' + date.getDate()).slice(-2) + ' ' +
                                        ('00' + date.getHours()).slice(-2) + ':' +
                                        ('00' + date.getMinutes()).slice(-2) + ':' +
                                        ('00' + date.getSeconds()).slice(-2));
                },

                '{self} onSubmit': function(el, ev, register) {
                    register.push(true);
                },

                raiseError: function(msg) {
                    self.trigger('error', [msg]);
                },

                clearError: function() {
                    self.trigger('clear');
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/event/startend/content', function($) {
    
    var module = this;
    var lang = EasySocial.options.momentLang;

    EasySocial
    .require()
    .library('datetimepicker', 'moment/' + lang)
    .language('FIELDS_EVENT_STARTEND_VALIDATION_DATETIME_START_REQUIRED', 'FIELDS_EVENT_STARTEND_VALIDATION_DATETIME_END_REQUIRED')
    .done(function($) {

        EasySocial.Controller('Field.Event.Startend', {
            defaultOptions: {
                dateFormat: '',
                allowTime: true,
                allowTimezone: true,
                disallowPast: false,
                minuteStepping: 15,
                yearfrom: '',
                yearto: '',
                requiredEnd: false,
                allday: false,
                calendarLanguage: 'english',
                dow: 0,

                '{startForm}': '[data-event-start]',
                '{endForm}': '[data-event-end]',

                '{timezone}': '[data-event-timezone]'
            }
        }, function(self) {
            return {
                init: function() {

                    // There is an issue with yearto where if I set yearto = 2014, I won't be able to select 2014 dates. 
                    // This is a bug in datetimepicker. Currently, temporarily, we manually add 1 to the value if there are value set.
                    if (!$.isEmpty(self.options.yearto)) {
                        self.options.yearto = parseInt(self.options.yearto) + 1;
                    } else {
                        self.options.yearto = new Date().getFullYear() + 100
                    }

                    self.options.yearfrom = self.options.yearfrom || 1930;

                    // Add controller on the start date
                    self.startDatetime = self.startForm().addController('EasySocial.Controller.Field.Event.Startend.Form', {
                        '{parent}': self,
                        "type": 'start'
                    });

                    // Add controller on the end date
                    self.endDatetime = self.endForm().addController('EasySocial.Controller.Field.Event.Startend.Form', {
                        '{parent}': self,
                        "type": 'end'
                    });
                },

                '{self} onSubmit': function(el, ev, register) {
                    register.push(self.validateInput());
                },

                validateInput: function() {
                    self.clearError();

                    if ($.isEmpty(self.startDatetime.datetime().val())) {
                        self.raiseError($.language('FIELDS_EVENT_STARTEND_VALIDATION_DATETIME_START_REQUIRED'));

                        return false;
                    }

                    if (self.options.requireEnd && $.isEmpty(self.endDatetime.datetime().val())) {
                        self.raiseError($.language('FIELDS_EVENT_STARTEND_VALIDATION_DATETIME_END_REQUIRED'));

                        return false;
                    }

                    return true;
                },

                raiseError: function(msg) {
                    self.trigger('error', [msg]);
                },

                clearError: function() {
                    self.trigger('clear');
                }
            }
        });

        EasySocial.Controller('Field.Event.Startend.Form', {
            defaultOptions: {
                type: null,

                '{picker}': '[data-picker]',
                '{toggle}': '[data-picker-toggle]',
                '{datetime}': '[data-datetime]'
            }
        }, function(self, options) {

            return {
                init: function() {
                    self.load();
                },

                "{window} easysocial.fields.startend.start.change": function() {

                    // When the start date is changed, set the minimum date on the end date
                    if (options.type == 'start' && self.parent.endDatetime) {
                        self.parent.endDatetime.datetimepicker('destroy');

                        self.parent.endDatetime.load();
                    }
                },


                '{window} easysocial.fields.allday.change': function(el, ev, value) {
                    self.datetimepicker('destroy');

                    self.parent.options.allday = value == 1 ? true : false;

                    self.load();
                },

                // We move this here because there is a possibility that we want to "reinit"
                load: function() {

                    // Generate a minimum date from momentjs
                    var minDate = new $.moment();

                    // If configured to disallow past dates, we need to minus 1 on the date as we need to allow today.
                    if (self.parent.options.disallowPast) {
                        minDate.date(minDate.date() - 1);
                    } else {
                        minDate.year(self.parent.options.yearfrom);
                    }

                    // If this type is end date, we need to set the minimum date based on the start date
                    if (options.type == 'end') {
                        var startDatetimeValue = self.parent.startDatetime.datetime().val();

                        if (startDatetimeValue) {
                            var minDate = $.moment(startDatetimeValue);
                            
                            // minus 1 on the date as we need to allow today.
                            var minDate = minDate.date(minDate.date() - 1);
                        }
                    }

                    var allowTime = self.parent.options.allowTime && !self.parent.options.allday;
                    var dateFormat = self.parent.options.dateFormat;

                    // If time is not allowed, then we remove the time part
                    // Since the format is always (10 chars) (remaining chars)
                    // We just substr by 10 chars
                    if (!allowTime) {
                        dateFormat = dateFormat.substr(0, 10);
                    }

                    self.picker()._datetimepicker({
                        component: "es",
                        useCurrent: false,
                        format: dateFormat,
                        minDate: minDate,
                        maxDate: new $.moment({y: self.parent.options.yearto}),
                        icons: {
                            time: 'glyphicon glyphicon-time',
                            date: 'glyphicon glyphicon-calendar',
                            up: 'glyphicon glyphicon-chevron-up',
                            down: 'glyphicon glyphicon-chevron-down'
                        },
                        sideBySide: false,
                        pickTime: allowTime,
                        minuteStepping: parseInt(self.parent.options.minuteStepping),
                        language: self.parent.options.calendarLanguage == 'english' ? 'en-gb' : lang,
                        dow: self.parent.options.dow
                    });

                    var date = self.datetime().val();

                    // Datetimepicker is using moment.js, hence here we manually create a moment object to pass in instead of passing in date time string
                    // This is because datetimepicker.setDate function passes along the format from self.options.calendarDateFormat to generate the date object, which will render moment.js to generate an invalid dateobject
                    // self.options.calendarDateFormat is only for display purposes
                    // Raw date object is always in SQL format
                    if (!$.isEmpty(date)) {
                        var dateObj = $.moment(date);

                        self.datetimepicker('setDate', dateObj);
                    }
                },

                datetimepicker: function(name, value) {
                    return self.picker().data('DateTimePicker')[name](value);
                },

                '{toggle} click': function() {
                    self.picker().focus();
                },

                '{picker} dp.change': function(el, ev) {

                    self.setDateValue(ev.date.toDate());

                    // easysocial.fields.startend.start.change
                    // easysocial.fields.startend.end.change
                    $(window).trigger('easysocial.fields.startend.' + options.type + '.change', [ev.date]);
                },

                '{picker} change': function(el, ev) {
                    if ($.isEmpty(el.val())) {
                        self.datetime().val('');
                    }
                },

                setDateValue: function(date) {
                    // Convert the date object into sql format and set it into the input
                    self.datetime().val(date.getFullYear() + '-' +
                                        ('00' + (date.getMonth()+1)).slice(-2) + '-' +
                                        ('00' + date.getDate()).slice(-2) + ' ' +
                                        ('00' + date.getHours()).slice(-2) + ':' +
                                        ('00' + date.getMinutes()).slice(-2) + ':' +
                                        ('00' + date.getSeconds()).slice(-2));
                }

                /*'{clear} click': function(el, ev) {
                    // Brute force way to clear the datetimepicker
                    self.datetimepicker('setValue', new $.moment());

                    self.picker().val('');

                    self.datetime().val('');

                    el.hide();

                    self.parent.element.trigger('event' + $.String.capitalize(self.options.type), [null]);
                },*/
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/event/startend/display', function($) {
    var module = this;

    EasySocial
    .require()
    .library('chosen', 'popbox')
    .language('FIELDS_USER_DATETIME_LOCAL_TIMEZONE', 'FIELDS_USER_DATETIME_TIMEZONE_CHECKING')
    .done(function($) {
        EasySocial.Controller('Field.Event.Startend.Display', {
            defaultOptions: {
                id: null,

                userid: null,

                '{box}': '[data-startend-box]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.box().addController('EasySocial.Controller.Field.Event.Startend.Display.Box', {
                        '{parent}': self
                    });
                }
            }
        });

        EasySocial.Controller('Field.Event.Startend.Display.Box', {
            defaultOptions: {
                date: null,

                timezone: null,

                local: null,

                '{toggle}': '[data-popbox]',

                '{content}': '[data-popbox-content]',

                '{date}': '[data-date]',

                '{timezone}': '[data-timezone]',

                '{loading}': '[data-loading]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.options.timezone = self.timezone().data('timezone');

                    self.options.date = self.date().data('date-utc');

                    // Get the local timezone first through client browser
                    self.options.local = -new Date().getTimezoneOffset()/60;

                    var content = self.content().html(),
                        position = self.toggle().data('popbox-position');

                    self.toggle().popbox({
                        content: content,
                        id: 'fd',
                        component: 'es',
                        type: 'timezone',
                        toggle: 'click',
                        position: position
                    }).attr('data-popbox', '');
                },

                '{toggle} popboxActivate': function(el, event, popbox) {
                    popbox.tooltip.addController('EasySocial.Controller.Field.Event.Startend.Display.Timezone', {
                        '{parent}': self
                    });
                },

                datetime: $.memoize(function(tz) {
                    return EasySocial.ajax('fields/event/startend/getDatetime', {
                        id: self.parent.options.id,
                        userid: self.parent.options.userid,
                        tz: tz,
                        local: self.options.local,
                        datetime: self.options.date
                    });
                })
            }
        });

        EasySocial.Controller('Field.Event.Startend.Display.Timezone', {
            defaultOptions: {
                '{timezones}': '[data-timezone-select]',
                '{reset}': '[data-timezone-reset]',
                '{local}': '[data-timezone-local]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.timezones().chosen({
                        search_contains: true
                    });
                },

                '{timezones} change': function(el, event) {
                    var key = el.val();

                    self.parent.date().html($.language('FIELDS_USER_DATETIME_TIMEZONE_CHECKING'));
                    self.parent.timezone().html(key === 'local' ? $.language('FIELDS_USER_DATETIME_LOCAL_TIMEZONE') : key);

                    self.parent.datetime(key).done(function(value) {
                        self.parent.date().html(value);
                    });
                },

                '{reset} click': function() {
                    self.setTimezone(self.parent.options.timezone);
                },

                '{local} click': function() {
                    self.setTimezone('local')
                },

                setTimezone: function(tz) {
                    self.timezones()
                        .val(tz)
                        .trigger('liszt:updated')
                        .trigger('change');
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/group/permalink/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language(
            'PLG_FIELDS_GROUP_PERMALINK_EXCEEDED_MAX_LENGTH',
            'PLG_FIELDS_GROUP_PERMALINK_REQUIRED')
        .done(function($) {

            EasySocial.Controller(
                'Field.Group.Permalink',
                {
                    defaultOptions:
                    {
                        required: false,

                        max     : 0,

                        id      : null,
                        groupid : null,
                        userid  : null,

                        '{field}'           : '[data-field-permalink]',

                        '{checkButton}'     : '[data-permalink-check]',
                        '{input}'           : '[data-permalink-input]',
                        '{available}'       : '[data-permalink-available]'
                    }
                },
                function(self)
                {
                    return {
                        state: false,

                        init: function()
                        {
                            self.options.max = self.field().data('max');
                        },

                        "{checkButton} click" : function()
                        {
                            self.delayedCheck();
                        },

                        "{input} keyup" : function()
                        {
                            self.delayedCheck();
                        },

                        delayedCheck: $.debounce(function()
                        {
                            self.checkPermalink();
                        }, 250),

                        checkPermalink: function()
                        {
                            self.clearError();

                            var permalink   = self.input().val();

                            self.available().hide();

                            if (self.options.max > 0 && permalink.length > self.options.max) {
                                self.raiseError($.language('PLG_FIELDS_GROUP_PERMALINK_EXCEEDED_MAX_LENGTH'));
                                return false;
                            }

                            if (!$.isEmpty(permalink)) {
                                self.checkButton().addClass('btn-loading');

                                var state = $.Deferred();

                                EasySocial.ajax('fields/group/permalink/isValid', {
                                    "id"        : self.options.id,
                                    "groupid"   : self.options.groupid,
                                    "permalink" : permalink
                                })
                                .done(function(msg) {
                                    self.clearError();

                                    self.checkButton().removeClass('btn-loading');

                                    self.available().show();

                                    state.resolve();
                                })
                                .fail(function(msg) {
                                    self.raiseError(msg);

                                    self.checkButton().removeClass('btn-loading');

                                    self.available().hide();

                                    state.reject();
                                });

                                return state;
                            }

                            if (self.options.required && $.isEmpty(permalink)) {
                                self.available().hide();

                                self.raiseError($.language('PLG_FIELDS_GROUP_PERMALINK_REQUIRED'));
                                return false;
                            }

                            return true;
                        },

                        raiseError: function(msg)
                        {
                            self.trigger('error', [msg]);
                        },

                        clearError: function()
                        {
                            self.trigger('clear');
                        },

                        '{self} onSubmit': function(el, ev, register)
                        {
                            register.push(self.checkPermalink());
                        }
                    }
                }
            );

            module.resolve();
        });
});

EasySocial.module('apps/fields/group/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/address/content', function($) {
    var module = this;

    EasySocial.require()
        .library('gmaps')
        .language(
            'PLG_FIELDS_ADDRESS_PLEASE_ENTER_ADDRESS1',
            'PLG_FIELDS_ADDRESS_PLEASE_ENTER_ADDRESS2',
            'PLG_FIELDS_ADDRESS_PLEASE_ENTER_CITY',
            'PLG_FIELDS_ADDRESS_PLEASE_ENTER_STATE',
            'PLG_FIELDS_ADDRESS_PLEASE_ENTER_ZIP',
            'PLG_FIELDS_ADDRESS_PLEASE_ENTER_COUNTRY')
        .done(function() {
            EasySocial.Controller('Field.Address', {
                defaultOptions: {
                    required        : {},
                    show            : {},

                    "{field}"       : "[data-field-address]",

                    "{address1}"    : "[data-field-address-address1]",
                    "{address2}"    : "[data-field-address-address2]",
                    "{city}"        : "[data-field-address-city]",
                    "{state}"       : "[data-field-address-state]",
                    "{country}"     : "[data-field-address-country]",
                    "{zip}"         : "[data-field-address-zip]",

                    '{required}'    : '[data-required]',

                    '{notice}'      : '[data-check-notice]'
                }
            }, function(self) {
                return {
                    init : function() {
                    },

                    fields: [
                        'address1',
                        'address2',
                        'city',
                        'state',
                        'zip',
                        'country'
                    ],

                    validateInput : function() {
                        self.clearError();

                        var errorRaised = false;

                        self.clearError();

                        $.each(self.fields, function(i, field) {
                            var el = self[field]();

                            el.removeClass('has-error');

                            var val = el.val();

                            if($.isEmpty(val) && self.options.required[field] && self.options.show[field])
                            {
                                el.addClass('has-error');

                                if(!errorRaised) {
                                    self.raiseError($.language('PLG_FIELDS_ADDRESS_PLEASE_ENTER_' + field.toUpperCase()));

                                    errorRaised = true;
                                }

                            }
                        });

                        return true;
                    },

                    '{address1}, {address2}, {zip}, {city}, {state} blur': function() {
                        self.validateInput();
                    },

                    '{country} change': function(el) {
                        self.validateInput();

                        if (self.state().is('select')) {
                            EasySocial.ajax('fields/user/address/getStates', {
                                id: self.options.id,
                                country: el.val()
                            }).done(function(states) {
                                self.state().html('');

                                $.each(states, function(code, name) {
                                    var option = $('<option></option>').html(name).val(name).appendTo(self.state());
                                });
                            });
                        }
                    },

                    raiseError: function(msg) {
                        // self.trigger('error', [msg]);

                        self.notice()
                            .css('color', '#a94442')
                            .text(msg)
                            .parent('.controls-error')
                            .show();
                    },

                    clearError: function() {
                        self.notice()
                            .parent('.controls-error')
                            .hide();
                    },

                    "{self} onSubmit" : function(el, event, register) {
                        register.push(self.validateInput());
                    },

                    "{self} onConfigChange": function(el, event, name, value) {
                        var requires = ['address1', 'address2', 'city', 'zip', 'state', 'country'];

                        if($.inArray(name, requires) >= 0) {
                            self.options.required[name] = !!value;
                        }

                        self.required().hide();

                        $.each(requires, function(i, t) {
                            if(self.options[t]) {
                                self.required().show();
                                return false;
                            }
                        });
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/address/display_content', function($) {
    var module = this;

    EasySocial
    .require()
    .library('gmaps')
    .done(function() {
        EasySocial.Controller('Field.Address.Display', {
            defaultOptions: {
                latitude: null,
                longitude: null,
                ratio: 1,

                '{base}': '[data-location-base]',

                '{map}': '[data-location-map]',
                '{mapImage}': '[data-location-map-image]'
            }
        }, function(self) {
            return {
                init: function() {
                    // Init params
                    var map = self.map();

                    self.options.latitude = map.data('latitude');
                    self.options.longitude = map.data('longitude');

                    self.setLayout();
                },

                '{window} resize': $.debounce(function() {
                    self.setLayout();
                }, 250),

                navigate: function(lat, lng) {
                    var mapImage = self.mapImage(),
                        width = Math.floor(mapImage.width()),
                        height = Math.floor(mapImage.height()),
                        url = $.GMaps.staticMapURL({
                            size: [1280, 1280],
                            lat: lat,
                            lng: lng,
                            sensor: true,
                            scale: 2,
                            markers: [
                                {lat: lat, lng: lng}
                            ]
                        });

                    var url = url.replace(/http\:|https\:/, '');
                    
                    // When map is loaded, fade in.
                    $.Image.get(url)
                        .done(function(){
                            mapImage.css({
                                "backgroundImage": $.cssUrl(url),
                                "backgroundSize": "cover",
                                "backgroundPosition": "center center"
                            });
                            self.base().addClass("has-location");
                        })
                        .always(function(){
                            self.base().removeClass("is-loading");
                        });
                },

                setLayout: function() {
                    setTimeout(function() {
                        if (self.options.latitude && self.options.longitude) {
                            self.navigate(self.options.latitude, self.options.longitude);
                        }
                    }, 1);
                },

                '{self} onShow': function() {
                    self.setLayout();
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/address/maps', function($) {
    var module = this;

    // Create search template first
    $.template('easysocial/maps.suggestion', '<div class="es-location-suggestion" data-location-suggestion><span class="formatted_address">[%= location.formatted_address %]</span></div>');

    EasySocial
    .require()
    .library('gmaps', 'placeholder', 'image')
    .language(
        "COM_EASYSOCIAL_LOCATION_PERMISSION_ERROR",
        "COM_EASYSOCIAL_LOCATION_TIMEOUT_ERROR",
        "COM_EASYSOCIAL_LOCATION_UNAVAILABLE_ERROR",
        "COM_EASYSOCIAL_STREAM_AT"
    )
    .done(function() {

        // Constants
        var KEYCODE = {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            ENTER: 13,
            ESCAPE: 27,
            LEFT: 37,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        };

        EasySocial.Controller('Field.Address.Maps', {
            defaultOptions: {
                required            : null,

                zoom                : 2,

                latitude            : null,
                longitude           : null,
                address             : null,

                singleLocation      : true,

                required            : false,

                ratio               : 3,

                '{field}'           : '[data-field-address]',

                '{base}'            : '[data-location-base]',

                '{map}'             : '[data-location-map]',
                '{mapImage}'        : '[data-location-map-image]',

                '{detectButton}'    : '[data-location-detect]',
                '{removeButton}'    : '[data-location-remove]',

                '{form}'            : '[data-location-form]',
                '{textbox}'         : '[data-location-textbox]',
                '{textField}'       : '[data-location-textfield]',

                '{autocomplete}'    : '[data-location-autocomplete]',
                '{suggestions}'     : '[data-location-suggestions]',
                '{suggestion}'      : '[data-location-suggestion]',

                '{source}'          : '[data-location-source]',

                view: {
                    suggestion: 'maps.suggestion'
                }
            }
        }, function(self) {
            return {
                init: function() {
                    if (navigator.geolocation) {
                        self.base().addClass("is-detectable");
                        // self.detectButton().show();
                    }

                    // Add placeholder support for IE9
                    self.textField().placeholder();

                    // Allow textField input only when controller is implemented
                    self.textField().removeAttr("disabled");

                    if (!$.isEmpty(self.source().val())) {
                        var data = JSON.parse(self.source().val());

                        if (data.latitude && data.longitude) {
                            self.navigate(data.latitude, data.longitude);

                            self.base().addClass("has-location");
                        }
                    }
                },

                "{window} resize": $.debounce(function() {

                    var data = JSON.parse(self.source().val());

                    if (!data.latitude || !data.longitude) {
                        return;
                    }

                    var mapImage = self.mapImage();

                    if (mapImage.data("width") !== mapImage.width()) {
                        self.navigate(data.latitude, data.longitude);
                    }

                }, 250),

                '{self} onShow': function() {

                    var data = JSON.parse(self.source().val());

                    if (!data.latitude || !data.longitude) {
                        return;
                    }

                    var mapImage = self.mapImage();

                    if (mapImage.data("width") !== mapImage.width()) {
                        self.navigate(data.latitude, data.longitude);
                    }
                },

                navigate: function(lat, lng) {
                    self.field().css({
                        "max-width": "none"
                    });

                    var mapImage = self.mapImage(),
                        width = Math.floor(mapImage.width()),
                        height = Math.floor(mapImage.height()),
                        url = $.GMaps.staticMapURL({
                            size: [1280, 1280],
                            lat: lat,
                            lng: lng,
                            sensor: true,
                            scale: 2,
                            markers: [
                                {lat: lat, lng: lng}
                            ]
                        });

                    // When map is loaded, fade in.
                    $.Image.get(url)
                        .done(function(){
                            mapImage.css({
                                "backgroundImage": $.cssUrl(url),
                                "backgroundSize": "cover",
                                "backgroundPosition": "center center"
                            });
                            self.base().addClass("has-location");
                        })
                        .always(function(){
                            self.base().removeClass("is-loading");
                        });
                },

                locations: {},

                lastQueryAddress: null,

                results: [],

                result: null,

                "{textField} keypress": function(textField, event) {

                    switch (event.keyCode)
                    {
                        case KEYCODE.UP:

                            var prevSuggestion = $(
                                self.suggestion(".active").prev(self.suggestion.selector)[0] ||
                                self.suggestion(":last")[0]
                            );

                            // Remove all active class
                            self.suggestion().removeClass("active");

                            prevSuggestion
                                .addClass("active")
                                .trigger("activate");

                            self.suggestions()
                                .scrollTo(prevSuggestion, {
                                    offset: prevSuggestion.height() * -1
                                });

                            event.preventDefault();

                            break;

                        case KEYCODE.DOWN:

                            var nextSuggestion = $(
                                self.suggestion(".active").next(self.suggestion.selector)[0] ||
                                self.suggestion(":first")[0]
                            );

                            // Remove all active class
                            self.suggestion().removeClass("active");

                            nextSuggestion
                                .addClass("active")
                                .trigger("activate");

                            self.suggestions()
                                .scrollTo(nextSuggestion, {
                                    offset: nextSuggestion.height() * -1
                                });

                            event.preventDefault();

                            break;

                        case KEYCODE.ENTER:

                            var activeSuggestion = self.suggestion(".active"),
                                location = activeSuggestion.data("location");
                                self.set(location);

                            self.hideSuggestions();
                            break;

                        case KEYCODE.ESCAPE:
                            self.hideSuggestions();
                            break;
                    }

                },

                "{textField} keyup": function(textField, event) {

                    switch (event.keyCode) {

                        case KEYCODE.UP:
                        case KEYCODE.DOWN:
                        case KEYCODE.LEFT:
                        case KEYCODE.RIGHT:
                        case KEYCODE.ENTER:
                        case KEYCODE.ESCAPE:
                            // Don't repopulate if these keys were pressed.
                            break;

                        default:
                            var address = $.trim(textField.val());

                            if (address==="") {
                                self.base().removeClass("has-location");
                                self.hideSuggestions();
                            }

                            // if (address==self.lastQueryAddress) return;

                            var locations = self.locations[address];

                            // If this location has been searched before
                            if (locations) {

                                // And set our last queried address to this address
                                // so that it won't repopulate the suggestion again.
                                self.lastQueryAddress = address;

                                // Just use cached results
                                self.suggest(locations);

                            // Else ask google to find it out for us
                            } else {

                                self.lookup(address);
                            }
                            break;
                    }
                },

                lookup: $.debounce(function(address) {

                    self.base().addClass("is-busy");

                    $.GMaps.geocode({
                        address: address,
                        callback: function(locations, status) {

                            self.base().removeClass("is-busy");

                            if (status=="OK") {

                                // Store a copy of the results
                                self.locations[address] = locations;

                                // Suggestion locations
                                self.suggest(locations);

                                self.lastQueryAddress = address;
                            }
                        }
                    });

                }, 250),

                suggest: function(locations) {

                    var suggestions = self.suggestions();

                    // Clear location suggestions
                    suggestions
                        .empty();

                    if (locations.length < 0) return;

                    self.results = locations;

                    $.each(locations, function(i, location){
                        // Create suggestion and append to list
                        self.view.suggestion({
                                location: location
                            })
                            .data("location", location)
                            .appendTo(suggestions);
                    });

                    self.showSuggestions();
                },

                showSuggestions: function() {

                    self.focusSuggestion = true;

                    self.element.find(".es-story-footer")
                        .addClass("swap-zindex");

                    setTimeout(function(){

                        self.autocomplete().addClass("active");

                        var doc = $(document),
                            hideOnClick = "click.es.story.location";

                        doc
                            .off(hideOnClick)
                            .on(hideOnClick, function(event){

                                // Collect list of bubbled elements
                                var targets = $(event.target).parents().andSelf();

                                if (targets.filter(self.element).length > 0) return;

                                doc.off(hideOnClick);

                                self.hideSuggestions();
                            });

                    }, 500);
                },

                hideSuggestions: function() {

                    self.focusSuggestion = false;

                    self.autocomplete().removeClass("active");

                    $(document).off("click.es.story.location");

                    setTimeout(function(){

                        if (self.focusSuggestion) return;

                        self.element.find(".es-story-footer")
                            .removeClass("swap-zindex");

                    }, 500);
                },

                "{suggestion} activate": function(suggestion, event) {

                    var location = suggestion.data("location");

                    self.navigate(
                        location.geometry.location.lat(),
                        location.geometry.location.lng()
                    );
                },

                "{suggestion} mouseover": function(suggestion) {

                    // Remove all active class
                    self.suggestion().removeClass("active");

                    suggestion
                        .addClass("active")
                        .trigger("activate");
                },

                "{suggestion} click": function(suggestion, event) {

                    var location = suggestion.data("location");

                    self.set(location);

                    self.hideSuggestions();
                },

                set: function(location) {

                    self.currentLocation = location;

                    var lat = location.geometry.location.lat(),
                        lng = location.geometry.location.lng();

                    self.navigate(lat, lng);

                    var address = location.formatted_address;

                    self.textField().val(address);

                    self.lastQueryAddress = address;

                    self.base().addClass("has-location");

                    // Set the source here
                    self.result = location;
                    var data = self.getResult('source');
                    self.source().val(JSON.stringify(data));
                },

                unset: function() {

                    self.currentLocation = null;

                    self.textField().val('');

                    self.mapImage().attr("src", "");

                    self.base().removeClass("has-location");

                    self.source().val('');
                },

                detectTimer: null,

                "{detectButton} click": function() {

                    var textbox = self.textbox();

                    self.base().addClass("is-busy");

                    clearTimeout(self.detectTimer);

                    self.detectTimer = setTimeout(function() {
                        self.base().removeClass("is-busy");
                    }, 8000);

                    $.GMaps.geolocate({
                        success: function(position) {
                            $.GMaps.geocode({
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                                callback: function(locations, status) {
                                    if (status=="OK") {
                                        self.suggest(locations);
                                        self.textField().focus();
                                    }
                                }
                            });
                        },
                        error: function(error) {
                            var message = "";

                            switch (error.code) {

                                case 1:
                                    message = $.language("COM_EASYSOCIAL_LOCATION_PERMISSION_ERROR");
                                    break;

                                case 2:
                                    message = $.language("COM_EASYSOCIAL_LOCATION_TIMEOUT_ERROR");
                                    break;

                                case 3:
                                default:
                                    message = $.language("COM_EASYSOCIAL_LOCATION_UNAVAILABLE_ERROR");
                                    break;
                            }

                            // story.setMessage(message);
                        },
                        always: function() {
                            clearTimeout(self.detectTimer);
                            self.base().removeClass("is-busy");
                        }
                    });
                },

                "{removeButton} click": function() {
                    self.unset();
                    self.hideSuggestions();
                },

                getResult: function(type) {
                    if(!self.result) {
                        if(self.results.length === 0) {
                            return false;
                        }

                        self.result = self.results[0];
                    }

                    var r = self.result;

                    if(type === undefined) {
                        return r;
                    }

                    switch(type) {
                        case 'coords':
                            return {
                                lat: r.geometry.location.lat(),
                                lng: r.geometry.location.lng()
                            }
                        break;

                        case 'lat':
                        case 'latitude':
                            return r.geometry.location.lat();
                        break;

                        case 'lng':
                        case 'longitude':
                            return r.geometry.location.lng();
                        break;

                        case 'address':
                            return r.formatted_address;
                        break;

                        case 'viewport':
                            return r.geometry.viewport;
                        break;

                        case 'bounds':
                            return r.geometry.bounds || r.geometry.viewport;
                        break;

                        case 'source':
                            var components = {};

                            $.each(r.address_components, function(index, component) {
                                if(component.types[0]) {
                                    components[component.types[0]] = component.long_name;
                                }
                            });

                            var mapping = {
                                'address1': ['street_address', 'route'],
                                'address2': ['intersection', 'colloquial_area', 'neighborhood', 'premise', 'subpremise'],
                                'city': ['locality', 'sublocality', 'sublocality_level_1', 'sublocality_level_2', 'sublocality_level_3', 'sublocality_level_4', 'sublocality_level_5'],
                                'state': ['administrative_area_level_1', 'administrative_area_level_2', 'administrative_area_level_3'],
                                'zip': 'postal_code',
                                'country': 'country'
                            };

                            // Based on the mapping we build the legacy data
                            var legacy = {};

                            $.each(mapping, function(key, value) {

                                // Init with empty data
                                legacy[key] = '';

                                if ($.isArray(value)) {
                                    $.each(value, function(i, v) {

                                        // Search if components[v] exists
                                        if (components[v] !== undefined) {

                                            // Use it if it exists
                                            legacy[key] = components[v];

                                            // Break out and ignore other possible keys
                                            return false;
                                        } else {

                                            // Continue finding
                                            return true;
                                        }
                                    });

                                    // Continue on to the next key
                                    return true;
                                }

                                if (components[value] !== undefined) {
                                    legacy[key] = components[value];
                                }
                            });

                            var data = $.extend(legacy, {
                                components: components,
                                address: r.formatted_address,
                                latitude: r.geometry.location.lat(),
                                longitude: r.geometry.location.lng()
                            });

                            return data;
                        break;
                    }
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/autocomplete/content', function($) {
    var module = this;

    EasySocial
    .require()
    .library('textboxlist')
    .done(function($) {

        EasySocial.Controller('Field.Autocomplete', {
            defaultOptions: {

                required: false,
                id: null,
                types: null,
                fieldname: null,
                actor: null,
                target: null,

                // Determines pre-selected items
                selectedItems: [],

                // Suggest properties
                max: null,
                exclusive: true,
                exclusion: [],
                minLength: 1,
                highlight: true,
                name: "uid[]",
                type: "",

                "{suggest}": "[data-field-suggest]"
            }
        }, function(self, opts, base) {

            return {
                init: function() {

                    // Set the input's name.
                    opts.name = opts.fieldname + '[]';

                    self.initSuggest();
                },

                // Implement the textbox list on the implemented element.
                initSuggest: function() {
                    
                    self.suggest()
                        .textboxlist({
                            component: 'es',
                            name: opts.name,
                            max: opts.max,
                            plugin: {
                                autocomplete: {
                                    exclusive: opts.exclusive,
                                    minLength: opts.minLength,
                                    highlight: opts.highlight,
                                    showLoadingHint: true,
                                    showEmptyHint: true,

                                    query: function(keyword) {

                                        var result = EasySocial.ajax('fields/user/autocomplete/suggest', {
                                                                        "search": keyword,
                                                                        "id": opts.id
                                                                    });
                                        return result;
                                    }
                                }
                            }
                        })
                        .textboxlist("enable");
                },

                "{suggest} removeItem": function(el, event, menu) {
                    
                    // When an item is removed, remove it from the exclusion list
                    var isExcluded = $.inArray(menu.id.toString(), opts.exclusion) > -1;

                    if (isExcluded) {
                        opts.exclusion.splice(opts.exclusion.indexOf(menu.id.toString()), 1);
                    }
                },

                "{suggest} filterMenu": function(el, event, menu, menuItems, autocomplete, textboxlist) {

                    // Get list of items that are already added into the bucket
                    var selected = textboxlist.getAddedItems();
                    var selected = $.pluck(selected, "id");

                    // Add the items into the 
                    var exclude = selected.concat(opts.exclusion);

                    menuItems.each(function(){

                        var menuItem = $(this);
                        var item = menuItem.data("item");

                        var isSelected = $.inArray(item.id.toString(), exclude) > -1;
                        menuItem.toggleClass('hidden', isSelected);
                        
                    });
                }
            }
        });

        module.resolve();

    });
});

EasySocial.module('apps/fields/user/avatar/content', function($) {
    var module = this;

    EasySocial
        .require()
        .library('image', 'imgareaselect')
        .stylesheet('imgareaselect/default')
        .language('PLG_FIELDS_AVATAR_VALIDATION_EMPTY_PROFILE_PICTURE')
        .done(function(){

            EasySocial.Controller('Field.Avatar', {
                defaultOptions: {
                    required        : false,

                    id              : 0,

                    group           : null,

                    origSource      : null,

                    defaultAvatar   : null,

                    hasAvatar       : null,

                    '{field}'       : '[data-field-avatar]',

                    '{gallery}'     : '[data-field-avatar-gallery]',
                    '{galleryList}' : '[data-field-avatar-gallery-items]',
                    '{galleryItem}' : '[data-field-avatar-gallery-item]',

                    '{frame}'       : '[data-field-avatar-frame]',
                    '{viewport}'    : '[data-field-avatar-viewport]',

                    '{avatarSource}': '[data-field-avatar-source]',
                    '{avatarData}'  : '[data-field-avatar-data]',
                    '{avatarPath}'  : '[data-field-avatar-path]',
                    '{avatarType}'  : '[data-field-avatar-type]',
                    '{avatarName}'  : '[data-field-avatar-name]',

                    '{file}'        : '[data-field-avatar-file]',
                    '{image}'       : '[data-field-avatar-selected]',

                    '{note}'        : '[data-field-avatar-note]',

                    '{actions}'     : '[data-field-avatar-actions]',

                    '{cancel}'      : '[data-field-avatar-actions-cancel]',
                    '{crop}'        : '[data-field-avatar-actions-crop]',

                    '{removeFrame}' : '[data-field-avatar-remove]',
                    '{remove}'      : '[data-field-avatar-remove-button]',
                    '{revertFrame}' : '[data-field-avatar-revert]',
                    '{revert}'      : '[data-field-avatar-revert-button]',

                    '{loader}'      : '[data-field-avatar-loader]'
                }
            }, function(self) {
                return {
                    init: function() {
                        // Store the original photo first
                        // self.options.origSource = $.uri(self.frame().css('backgroundImage')).extract(0);

                        self.state = !!self.options.hasAvatar;
                    },

                    state: true,

                    "{file} change": function(el, event) {

                        if($.isEmpty(el.val())) {
                            return;
                        }

                        // Compatibility with input-group
                        var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');
                        el.parents('.input-group').find(':text').val(label);

                        // Set state to false
                        self.state = false;

                        // Show the loader
                        self.loader().show();

                        // Hide the previous picture
                        self.frame().hide();

                        // Hide the file upload field
                        self.file().hide();

                        // Hide the error frame
                        self.clearError();

                        EasySocial.ajax('fields/' + self.options.group + '/avatar/upload', {
                            id: self.options.id,
                            files: el
                        }, {
                            type: "iframe"
                        })
                        .done(function(raw, uri, path) {

                            // Set the name of the image
                            self.avatarName().val(raw.name);

                            // Set the source of the image
                            self.avatarSource().val(uri);

                            // Set the path of the image
                            self.avatarPath().val(path);

                            // Set the type as upload
                            self.avatarType().val('upload');

                            // Load the imgareaselect for cropping
                            self.setLayout(uri);

                            // Unset all gallery item
                            self.galleryItem().removeClass('active');

                            // Hide the remove button
                            self.removeFrame().hide();

                            // Hide the revert button
                            self.revertFrame().hide();

                            // Set state to true
                            self.state = true;
                        })
                        .fail(function(msg) {
                            self.loader().hide();

                            self.raiseError(msg);

                            self.file().show().val('');

                            self.frame().show();
                        });
                    },

                    setLayout: function(img) {
                        var loader = $.Image.get(img),
                            frame = self.frame();

                        loader.done(function(el, image) {
                            frame.css('background-image', $.cssUrl(img));

                            frame.addClass('avatar-frame-crop');

                            frame.show();

                            self.loader().hide();

                            self.actions().show();

                            self.note().show();

                            self.viewport().imgAreaSelect({remove: true});

                            self.viewport().show();

                            var size = $.Image.resizeWithin(
                                    image.width,
                                    image.height,
                                    frame.width(),
                                    frame.height()
                                ),
                                min = Math.min(size.width, size.height),
                                x1  = Math.floor((size.width  - min) / 2),
                                y1  = Math.floor((size.height - min) / 2),
                                x2  = x1 + min,
                                y2  = y1 + min;

                            self.viewport()
                                .css(size)
                                // .css('position', 'absolute')
                                .imgAreaSelect({
                                    handles: true,
                                    aspectRatio: '1:1',
                                    parent: frame,
                                    x1: x1,
                                    y1: y1,
                                    x2: x2,
                                    y2: y2,
                                    onSelectEnd: function(viewport, selection) {
                                        var hasSelection = !(selection.width=="0" && selection.height=="0");
                                        if(hasSelection) {
                                            var string = JSON.stringify(self.data());

                                            self.avatarData().val(string);
                                        }
                                    }
                                })
                        });
                    },

                    '{cancel} click': function() {
                        self.actions().hide();

                        self.note().hide();

                        self.frame().hide();

                        self.file().show();

                        self.file().val('');

                        self.file().parents('.input-group').find(':text').val('');

                        self.avatarSource().val('');

                        self.avatarPath().val('');

                        self.avatarData().val('');

                        self.avatarType().val('');

                        self.viewport()
                            .hide()
                            .imgAreaSelect({remove: true});

                        if(!$.isEmpty(self.options.origSource)) {
                            self.frame()
                                .css('background-image', $.cssUrl(self.options.origSource))
                                .removeClass('avatar-frame-crop')
                                .show();
                        }

                        if(self.options.hasAvatar) {
                            self.removeFrame().show();
                        }
                    },

                    data: function() {
                        var viewport = self.viewport(),

                            width  = viewport.width(),

                            height = viewport.height(),

                            selection =
                                viewport
                                    .imgAreaSelect({instance: true})
                                    .getSelection(),

                            data = {
                                // id    : self.photoId().val(),
                                // uid   : self.userId().val(),
                                top   : selection.y1 / height,
                                left  : selection.x1 / width,
                                width : selection.width / width,
                                height: selection.height / height
                            };

                        return data;
                    },

                    '{gallery} click': function() {
                        self.galleryList().toggle();
                    },

                    '{galleryItem} click': function(el, event) {
                        // If this item is not previously selected then only we proceed
                        if(!el.hasClass('active')) {


                            // Get the id
                            var id = el.data('id');

                            // Remove all other item selected state
                            self.galleryItem().removeClass('active');

                            // Set this item as selected
                            el.addClass('active');

                            // Set state to false
                            self.state = false;

                            // Show the loader
                            self.loader().show();

                            // Hide the previous picture
                            self.frame().hide();

                            // Hide the file upload field
                            self.file().hide();

                            // Clear the file input
                            self.file().val('');
                            self.file().parents('.input-group').find(':text').val('');

                            // Hide the error frame
                            self.clearError();

                            // Set the type as gallery
                            self.avatarType().val('gallery');

                            // Set the source id
                            self.avatarSource().val(id);

                            // Get the avatar source
                            EasySocial.ajax('fields/user/avatar/loadDefault', {
                                "avatarId": id
                            }).done(function(uri) {

                                // Set the image preview
                                self.frame().css('background-image', 'url(' + uri + ')');

                                // Show the image
                                self.frame().show();

                                // Remove crop class
                                self.frame().removeClass('avatar-frame-crop');

                                // Hide the loader
                                self.loader().hide();

                                // Hide the viewport
                                self.viewport().hide();

                                // Remove the imgareaselect from viewport
                                self.viewport().imgAreaSelect({remove: true});

                                // Hide the actions
                                self.actions().hide();

                                // Hide the note
                                self.note().hide();

                                // Show the file upload field
                                self.file().show();

                                // Show the revert button
                                self.revertFrame().show();

                                // Hide the remove button
                                self.removeFrame().hide();

                                // Set state to true
                                self.state = true;
                            });
                        }
                    },

                    '{remove} click': function() {
                        self.avatarType().val('remove');

                        self.frame().css('background-image', $.cssUrl(self.options.defaultAvatar));

                        self.removeFrame().hide();

                        if(self.options.hasAvatar) {
                            self.revertFrame().show();
                        }

                        self.state = false;
                    },

                    '{revert} click': function() {
                        self.avatarType().val('');

                        self.frame().css('background-image', $.cssUrl(self.options.origSource));

                        if(self.options.hasAvatar) {
                            self.removeFrame().show();
                        }

                        self.revertFrame().hide();

                        self.galleryItem().removeClass('active');

                        self.state = true;
                    },

                    '{self} onSubmit': function(el, event, register) {
                        if(self.options.required) {
                            if(!self.state) {
                                self.raiseError($.language('PLG_FIELDS_AVATAR_VALIDATION_EMPTY_PROFILE_PICTURE'));
                            }

                            register.push(self.state);
                        }
                    },

                    raiseError: function(msg) {
                        self.trigger('error', [msg]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    }
                }
            });

            module.resolve();
    });
});

EasySocial.module('apps/fields/user/avatar/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Avatar.Sample', {
        defaultOptions: {
            '{upload}': '[data-avatar-upload]',

            '{gallery}': '[data-avatar-gallery]',

            '{galleryTitle}': '[data-avatar-gallery-title]',

            '{galleryButton}': '[data-avatar-gallery-button]',

            '{gallerySelection}': '[data-avatar-gallery-selection]'
        }
    }, function(self) {
        return {
            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'upload':
                        self.upload().toggle(value);
                    break;

                    case 'gallery':
                        self.gallery().toggle(value);
                    break;

                    case 'use_gallery_button':
                        self.galleryButton().toggle(value);

                        self.gallerySelection().toggle(!value);

                        self.galleryTitle().toggle(!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/checkbox/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_CHECKBOX_CHECK_AT_LEAST_ONE_ITEM')
        .done(function() {
            EasySocial.Controller(
                'Field.Checkbox',
                {
                    defaultOptions:
                    {
                        required        : false,
                        "{item}"        : "[data-field-checkbox-item]"
                    }
                },
                function( self )
                {
                    return {
                        init : function() {
                        },

                        validateInput : function() {
                            self.clearError();

                            if(self.options.required && self.item(':checked').length == 0) {
                                self.raiseError();
                                return false;
                            }

                            return true;
                        },

                        raiseError: function() {
                            self.trigger('error', [$.language('PLG_FIELDS_CHECKBOX_CHECK_AT_LEAST_ONE_ITEM')]);
                        },

                        clearError: function() {
                            self.trigger('clear');
                        },

                        "{self} onSubmit": function(el, event, register) {
                            register.push(self.validateInput());
                            return;
                        }
                    }
                });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/checkbox/sample_content', function($) {
    var module  = this;

    EasySocial.require()
    .view('fields/user/checkbox/item')
    .done(function($){

        EasySocial.Controller('Field.Checkbox.Sample', {
            defaultOptions: {
                '{checkboxes}'      : '[data-checkboxes]',
                '{checkbox}'        : '[data-checkbox]',
                '{checkboxInput}'   : '[data-checkbox-input]',
                '{checkboxTitle}'   : '[data-checkbox-title]',

                view: {
                    sample  : 'fields/user/checkbox/item'
                }
            }
        }, function(self) {
            return {
                init: function() {
                },

                '{self} onChoiceTitleChanged': function(el, event, index, data) {
                    self.checkboxTitle().eq(index).text(data);
                },

                '{self} onChoiceValueChanged': function(el, event, index, data) {
                    self.checkboxInput().eq(index).val(data);
                },

                '{self} onChoiceAdded': function(el, event, index, data) {
                    if(self.checkbox().eq(index).length > 0) {
                        self.checkbox().eq(index).before(self.view.sample());
                    } else {
                        self.checkboxes().append(self.view.sample());
                    }
                },

                '{self} onChoiceRemoved': function(el, event, index) {
                    self.checkbox().eq(index).remove();
                },

                '{self} onChoiceToggleDefault': function(el, event, index, value) {
                    var element = self.checkboxInput().eq(index);

                    if(value) {
                        element.prop('checked', true);
                    } else {
                        element.prop('checked', false);
                    }
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/country/content', function($) {
    var module = this;

    EasySocial
        .require()
        .library('textboxlist')
        .language(
            'PLG_FIELDS_COUNTRY_VALIDATION_REQUIRED',
            'PLG_FIELDS_COUNTRY_VALIDATION_MINIMUM_ERROR',
            'PLG_FIELDS_COUNTRY_VALIDATION_MAXIMUM_ERROR'
        )
        .done(function() {
            EasySocial.Controller('Field.Country', {
                defaultOptions: {
                    fieldname       : '',

                    required        : false,

                    id              : null,

                    min             : null,

                    max             : null,

                    selecttype      : 'textboxlist',

                    '{field}'       : '[data-field-country]',

                    '{inputTextboxlist}'    : '[data-country-select-textboxlist]',

                    '{inputMultilist}'      : '[data-country-select-multilist]',

                    '{inputCheckbox}'       : '[data-country-select-checkbox]',

                    '{inputCheckboxes}'     : '[data-country-select-checkbox] input',

                    '{inputDropdown}'       : '[data-country-select-dropdown]'
                }
            }, function(self) {
                return {
                    init: function() {

                        self.options.max = self.field().data('max');
                        self.options.min = self.field().data('min');

                        self.options.selecttype = self.field().data('select-type');

                        if(self.options.selecttype === 'textboxlist') {
                            EasySocial.module('field.country/' + self.options.id).done(function(data) {
                                self.inputTextboxlist().textboxlist({
                                    component: 'es',
                                    name: self.options.fieldname + '[]',
                                    max: self.options.max < 1 ? null : self.options.max,
                                    plugin: {
                                        autocomplete: {
                                            exclusive: true,
                                            query: data
                                        }
                                    }
                                });
                            });
                        }
                    },

                    '{inputMultilist} change': function(el, ev) {
                        if(self.options.max > 0 && el.val().length > self.options.max) {
                            el.val(self.lastValidSelection ? self.lastValidSelection : '');

                            return false;
                        }

                        self.lastValidSelection = el.val();
                    },

                    '{inputCheckboxes} change': function(el, ev) {
                        var count = self.inputCheckboxes(':checked').length;

                        if(self.options.max > 0 && count > self.options.max) {
                            el.removeAttr('checked');
                            return false;
                        }
                    },

                    validateInput: function() {
                        var items = null;

                        if(self.options.selecttype === 'textboxlist') {
                            items = self.inputTextboxlist().controller('textboxlist').getAddedItems();
                        }

                        if(self.options.selecttype === 'multilist') {
                            items = self.inputMultilist().val();
                        }

                        if(self.options.selecttype === 'checkbox') {
                            items = self.inputCheckboxes(':checked');
                        }

                        if(self.options.selecttype === 'dropdown') {
                            var value = self.inputDropdown().val();

                            if(!$.isEmpty(value)) {
                                items = [value];
                            }
                        }

                        var count = items ? items.length : 0;

                        // If it is not required and no selection is made, then we pass this check.
                        // If there is selection made, then we have to check against the minimum and maximum count
                        if (!self.options.required && count === 0) {
                            return true;
                        }

                        if(self.options.required && count < 1) {
                            self.raiseError($.language('PLG_FIELDS_COUNTRY_VALIDATION_REQUIRED'));
                            return false;
                        }

                        if(self.options.min > 0 && count < self.options.min) {
                            self.raiseError($.language('PLG_FIELDS_COUNTRY_VALIDATION_MINIMUM_ERROR'));
                            return false;
                        }

                        if(self.options.max > 0 && count > self.options.max) {
                            self.raiseError($.language('PLG_FIELDS_COUNTRY_VALIDATION_MAXIMUM_ERROR'));
                            return false;
                        }

                        return true;
                    },

                    raiseError: function(msg) {
                        self.trigger('error', [msg]);
                    },

                    '{self} onSubmit': function(el, ev, register) {
                        register.push(self.validateInput());
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/country/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Country.Sample', {
        defaultOptions: {
            '{inputGeneral}'        : '[data-country-select]',

            '{inputTextboxlist}'    : '[data-country-select-textboxlist]',

            '{inputMultilist}'      : '[data-country-select-multilist]',

            '{inputCheckbox}'       : '[data-country-select-checkbox]',

            '{inputDropdown}'       : '[data-country-select-dropdown]',

            '{maxMessage}'          : '[data-country-max-message]',

            '{maxCount}'            : '[data-country-max-count]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, ev, name, value) {
                switch(name) {
                    case 'select_type':
                        self.inputGeneral().hide();

                        if(value === 'textboxlist') {
                            self.inputTextboxlist().show();
                        }

                        if(value === 'multilist') {
                            self.inputMultilist().show();
                        }

                        if(value === 'checkbox') {
                            self.inputCheckbox().show();
                        }

                        if(value === 'dropdown') {
                            self.inputDropdown().show();
                        }
                        break;

                    case 'multilist_size':
                        self.inputMultilist().attr('size', value);
                        break;

                    case 'show_max_message':
                        self.maxMessage().toggle(!!value);
                        break;

                    case 'max':
                        self.maxCount().text(value);
                        break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/cover/content', function($) {
    var module = this;

    EasySocial
        .require()
        .library('image')
        .language('PLG_FIELDS_COVER_VALIDATION_REQUIRED')
        .done(function() {
            EasySocial.Controller('Field.Cover', {
                defaultOptions: {
                    id              : 0,
                    group           : null,
                    required        : false,
                    hasCover        : true,
                    defaultCover    : null,

                    ratio           : 3,

                    '{image}'       : '[data-field-cover-image]',

                    '{data}'        : '[data-field-cover-data]',
                    '{position}'    : '[data-field-cover-position]',
                    '{file}'        : '[data-field-cover-file]',

                    '{note}'        : '[data-field-cover-note]',

                    '{loader}'      : '[data-field-cover-loader]',
                    '{error}'       : '[data-field-cover-error]',

                    '{removeButton}': '[data-field-cover-remove-button]',

                    '{revertFrame}' : '[data-field-cover-revert]',
                    '{revertButton}': '[data-field-cover-revert-button]'
                }
            },
            function(self) {
                return {
                    init : function() {
                        self.setFrame();

                        self.setLayout();

                        self.origCover = self.options.hasCover ? $.uri(self.image().css('backgroundImage')).extract(0) : null;

                        self.origPosition = self.options.hasCover ? self.image().css('backgroundPosition') : null;
                    },

                    '{self} onShow': function() {
                        setTimeout(function() {
                            self.setLayout();
                        }, 1);
                    },

                    setFrame: function() {
                        var frameWidth = self.image().width(),
                            frameHeight = frameWidth / self.options.ratio;

                        self.image().css('height', frameHeight);
                    },

                    '{window} resize': $.debounce(function() {
                        self.setFrame();
                    }, 250),

                    imageLoaders: {},

                    '{file} change' : function( el , event ) {
                        if($.isEmpty(el.val())) {
                            return;
                        }

                        var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');

                        el.parents('.input-group').find(':text').val(label);

                        self.loader().show();

                        self.error().hide();

                        self.image().hide();

                        self.note().hide();

                        self.file().hide();

                        EasySocial.ajax( 'fields/' + self.options.group + '/cover/upload' , {
                            id: self.options.id,
                            files   : el
                        }, {
                            type    : 'iframe'
                        }).done(function(result){

                            var resultString    = JSON.stringify(result);

                            // Set the result in a string format
                            self.data().val(resultString);

                            var positionString = JSON.stringify({
                                x: 0.5,
                                y: 0.5
                            });

                            // Set the position in string format defaulting to 50 50
                            self.position().val(positionString);

                            // Set the position to 50 50 by default
                            self.position().val()

                            var url = result.large.uri,
                                imageLoaders = self.imageLoaders,
                                imageLoader = (imageLoaders[url] || (imageLoaders[url] = $.Image.get(url))).done(function(image) {
                                    self.setLayout.image = image;

                                    self.file().show();

                                    self.image().show();

                                    self.note().show();

                                    self.loader().hide();

                                    self.revertFrame().hide();

                                    self.removeButton().show();

                                    self.setCover(result.large.uri);
                                });

                        }).fail(function(msg) {

                            self.loader().hide();

                            self.file().show();

                            self.error().show().html(msg);
                        });
                    },

                    setLayout: function() {
                        var cover = self.image(),
                            image = self.setLayout.image;

                        if(!image) {
                            var url = $.uri(cover.css('backgroundImage')).extract(0);

                            if(!url) return;

                            var imageLoaders = self.imageLoaders,
                                imageLoader =
                                    (imageLoaders[url] || (imageLoaders[url] = $.Image.get(url)))
                                        .done(function(image) {

                                            // Set it as current image
                                            self.setLayout.image = image;

                                            // Then set layout again
                                            self.setLayout();
                                        });

                                return;
                        }

                        var imageWidth  = image.data("width"),
                            imageHeight = image.data("height"),
                            coverWidth  = cover.width(),
                            coverHeight = cover.height(),
                            size = $.Image.resizeProportionate(
                                imageWidth, imageHeight,
                                coverWidth, coverHeight,
                                "outer"
                            );

                        self.availableWidth  = coverWidth  - size.width;
                        self.availableHeight = coverHeight - size.height;

                        self.setFrame();
                    },

                    setCover: function(url, position) {
                        position = position || '50% 50%';

                        self.image()
                            .css({
                                backgroundImage: $.cssUrl(url),
                                backgroundPosition: position
                            });

                        self.setLayout();

                        self.image().addClass('cover-move');

                        self.note().show();
                    },

                    x: 0.5,
                    y: 0.5,

                    moveCover: function(dx, dy, image) {

                        if (!image) {
                            image = self.image();
                        }

                        var w = self.availableWidth,
                            h = self.availableHeight,
                            x = (w==0) ? 0 : self.x + ((dx / w) || 0),
                            y = (h==0) ? 0 : self.y + ((dy / h) || 0);

                        // Always stay within 0 to 1.
                        if (x < 0) x = 0; if (x > 1) x = 1;
                        if (y < 0) y = 0; if (y > 1) y = 1;

                        // Set position on cover
                        image.css("backgroundPosition",
                            ((self.x = x) * 100) + "% " +
                            ((self.y = y) * 100) + "% "
                        );

                        var position = {
                            x: self.x,
                            y: self.y
                        }

                        self.position().val(JSON.stringify(position));
                    },

                    '{image} mousedown': function(selection, event) {
                        if (event.target === self.image()[0]) {
                            event.preventDefault();
                        }

                        // Initial cover position
                        var image = self.image(),
                            position = image.css("backgroundPosition").split(" ");
                            self.x = parseInt(position[0]) / 100;
                            self.y = parseInt(position[1]) / 100;

                        // Initial cursor position
                        var x = event.pageX,
                            y = event.pageY;

                        $(document)
                            .on("mousemove.movingCover mouseup.movingCover", function(event) {

                                self.moveCover(
                                    (x - (x = event.pageX)) * -1,
                                    (y - (y = event.pageY)) * -1,
                                    image
                                );
                            })
                            .on("mouseup.movingCover", function() {

                                $(document).off("mousemove.movingCover mouseup.movingCover");
                            });
                    },

                    '{removeButton} click': function(el) {
                        var data = self.data().val();

                        if($.isEmpty(data)) {
                            if(self.options.hasCover) {
                                self.setCover(self.options.defaultCover);

                                // Mark the data as delete

                                self.data().val('delete');

                                el.hide();

                                self.revertFrame().show();
                            }
                        } else {
                            // Backup the data first
                            self.origData = data;
                            self.origPosition = self.position().val();

                            self.data().val('');
                            self.position().val('');
                            self.file().val('');
                            self.file().parents('.input-group').find(':text').val('');

                            if(self.options.hasCover) {
                                self.setCover(self.origCover);
                            } else {
                                self.setCover(self.options.defaultCover);

                                // Mark the data as delete
                                self.data().val('delete');

                                el.hide();
                            }
                        }
                    },

                    '{revertButton} click': function() {
                        self.setCover(self.origCover, self.origPosition);

                        self.revertFrame().hide();

                        self.removeButton().show();

                        self.data().val('');

                        self.position().val('');

                        self.file().val('');
                        self.file().parents('.input-group').find(':text').val('');
                    },

                    '{self} onSubmit': function(el, ev, register) {
                        if(self.options.required && !self.options.hasCover && $.isEmpty(self.data().val()))
                        {
                            self.raiseError($.language('PLG_FIELDS_COVER_VALIDATION_REQUIRED'));
                            register.push(false);
                        }
                    },

                    raiseError: function(msg) {
                        self.trigger('error', [msg]);
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/currency/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Currency.Sample', {
        defaultOptions: {

        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'format':
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/datetime/content', function($) {
    var module = this;

    EasySocial.require()
    .library('datetimepicker', 'chosen', 'moment/' + EasySocial.options.momentLang)
    .language(
        'PLG_FIELDS_DATETIME_VALIDATION_INVALID_DATETIME_FORMAT',
        'PLG_FIELDS_DATETIME_VALIDATION_PLEASE_SELECT_DATETIME'
        )
    .done(function($){

        EasySocial.Controller(
            'Field.Datetime',
            {
                defaultOptions:
                {
                    required: false,

                    calendarDateFormat: null,

                    yearfrom: null,

                    yearto: null,

                    date: null,

                    lang: null,

                    allowTime: false,
                    allowTimezone: false,

                    calendarLanguage: 'english',

                    '{field}': '[data-field-datetime]',

                    '{date}': '[data-field-datetime-select]',

                    '{dateValue}': '[data-field-datetime-value]',

                    '{timezone}': '[date-field-datetime-timezone]',

                    '{form}': '[data-field-datetime-form]',

                    '{icon}': '[data-field-datetime-icon]',

                    '{clearButton}': '[data-clear]',
                }
            },
            function( self )
            {
                return {
                    init : function() {
                        // self.legacyInit();

                        self.options.yearfrom = self.options.yearfrom || 1930;

                        // There is an issue with yearto where if I set yearto = 2014, I won't be able to select 2014 dates. This is a bug in datetimepicker. Currently, temporarily, we manually add 1 to the value if there are value set.
                        if (!$.isEmpty(self.options.yearto)) {
                            self.options.yearto = parseInt(self.options.yearto) + 1;
                        } else {
                            self.options.yearto = new Date().getFullYear() + 100
                        }

                        self.date()._datetimepicker({
                            component: "es",
                            format: self.options.calendarDateFormat,
                            minDate: self.options.yearfrom + '-01-01',
                            maxDate: self.options.yearto + '-12-31',
                            icons: {
                                time: 'glyphicon glyphicon-time',
                                date: 'glyphicon glyphicon-calendar',
                                up: 'glyphicon glyphicon-chevron-up',
                                down: 'glyphicon glyphicon-chevron-down'
                            },
                            sideBySide: false,
                            pickTime: self.options.allowTime,
                            useCurrent: false,
                            language: self.options.calendarLanguage == 'english' ? 'en-gb' : EasySocial.options.momentLang
                        });

                        // date value should always be in mysql datetime format
                        // YYYY-MM-DD HH:MM:SS
                        self.options.date = self.dateValue().val();

                        // If there is a date value, then we set it into the datetimepicker
                        if (!$.isEmpty(self.options.date)) {
                            // Datetimepicker is using moment.js, hence here we manually create a moment object to pass in instead of passing in date time string
                            // This is because datetimepicker.setDate function passes along the format from self.options.calendarDateFormat to generate the date object, which will render moment.js to generate an invalid dateobject
                            // self.options.calendarDateFormat is only for display purposes
                            // Raw date object is always in SQL format
                            var dateObj = $.moment(self.options.date);

                            self.datetimepicker('setDate', dateObj);
                            // self.setDateValue(dateObj);
                        }

                        if (self.options.allowTimezone) {
                            self.timezone().chosen({
                                search_contains: true
                            });
                        }
                    },

                    '{icon} click': function() {
                        self.datetimepicker('show');
                    },

                    '{date} dp.change': function(el, ev) {
                        self.setDateValue(ev.date.toDate());

                        self.form().addClass('has-datetime');

                        // Custom hack to ensure that the input box is really blurred
                        if (!self.options.allowTime) {
                            self.date().blur();
                        }
                    },

                    // Alias method to call the datetimepicker instance
                    datetimepicker: function(method, value) {
                        return self.date().data('DateTimePicker')[method](value);
                    },

                    setDateValue: function(date) {
                        // Convert the date object into sql format and set it into the input
                        self.dateValue().val(date.getFullYear() + '-' +
                                            ('00' + (date.getMonth()+1)).slice(-2) + '-' +
                                            ('00' + date.getDate()).slice(-2) + ' ' +
                                            ('00' + date.getHours()).slice(-2) + ':' +
                                            ('00' + date.getMinutes()).slice(-2) + ':' +
                                            ('00' + date.getSeconds()).slice(-2));
                    },

                    '{date} blur': function() {
                        self.validateCalendar();
                    },

                    validateCalendar: function() {
                        self.clearError();

                        if(self.options.required && $.isEmpty(self.dateValue().val())) {
                            self.raiseError($.language('PLG_FIELDS_DATETIME_VALIDATION_PLEASE_SELECT_DATETIME'));
                            return false;
                        }

                        return true;
                    },

                    raiseError: function(msg) {
                        self.trigger('error', [msg]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    },

                    "{self} onSubmit" : function(el, event, register) {
                        register.push(self.validateCalendar());
                        return;

                    },

                    '{clearButton} click': function(el, ev) {
                        self.form().removeClass('has-datetime');

                        self.datetimepicker('setValue', new $.moment());

                        self.date().val('');

                        self.dateValue().val('');
                    }
                }
            });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/datetime/display_content', function($) {
    var module = this;

    EasySocial.require().library('popbox', 'chosen').language('FIELDS_USER_DATETIME_LOCAL_TIMEZONE').done(function($) {

        EasySocial.Controller('Field.Datetime.Display', {
            defaultOptions: {
                userid: null,

                date: null,

                timezone: null,

                local: null,

                '{toggle}': '[data-popbox]',

                '{content}': '[data-popbox-content]',

                '{date}': '[data-date]',

                '{timezone}': '[data-timezone]',

                '{loading}': '[data-loading]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.options.timezone = self.timezone().data('timezone');

                    self.options.date = self.date().data('date-utc');

                    // Set the selected timezone with the displayed date
                    self.datetime(self.options.timezone, self.date().html());

                    // Get the local timezone first through client browser
                    self.options.local = -new Date().getTimezoneOffset()/60;

                    var content = self.content().html(),
                        position = self.toggle().data('popbox-position');

                    self.toggle().popbox({
                        content: content,
                        id: 'fd',
                        component: 'es',
                        type: 'timezone',
                        toggle: 'click',
                        position: position
                    }).attr('data-popbox', '');
                },

                '{toggle} popboxActivate': function(el, event, popbox) {
                    $(popbox.tooltip).addController('EasySocial.Controller.Field.Datetime.Display.Timezone', {
                        '{parent}': self
                    });
                },

                data: {},

                datetime: function(tz, value) {
                    // Getter
                    if (value === undefined) {
                        var dfd = $.Deferred();

                        if (self.data[tz] === undefined) {
                            self.loading().show();

                            EasySocial.ajax('fields/user/datetime/getDatetime', {
                                id: self.options.id,
                                userid: self.options.userid,
                                tz: tz,
                                local: self.options.local,
                                datetime: self.options.date
                            }).done(function(datetime) {

                                self.loading().hide();

                                dfd.resolve(self.datetime(tz, datetime));
                            });
                        } else {
                            dfd.resolve(self.data[tz]);
                        }

                        return dfd;
                    }

                    // Setter
                    self.data[tz] = value;
                    return value;
                },

                showDatetime: function(tz, datetime) {
                    if (tz === 'local') {
                        tz = $.language('FIELDS_USER_DATETIME_LOCAL_TIMEZONE');
                    }

                    self.timezone().html(tz);
                    self.date().html(datetime);
                }
            }
        });

        EasySocial.Controller('Field.Datetime.Display.Timezone', {
            defaultOptions: {
                '{timezones}': '[data-timezone-select]',
                '{reset}': '[data-timezone-reset]',
                '{local}': '[data-timezone-local]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.timezones().chosen({
                        search_contains: true
                    });
                },

                '{timezones} change': function(el, event) {
                    var key = el.val();

                    self.parent.date().hide();
                    self.parent.timezone().hide();

                    self.parent.datetime(key).done(function(value) {
                        self.parent.showDatetime(key, value);

                        self.parent.date().show();
                        self.parent.timezone().show();
                    });
                },

                '{reset} click': function() {
                    self.setTimezone(self.parent.options.timezone);
                },

                '{local} click': function() {
                    self.setTimezone('local')
                },

                setTimezone: function(tz) {
                    self.timezones()
                        .val(tz)
                        .trigger('liszt:updated')
                        .trigger('change');
                }
            }
        });
        module.resolve();
    });
});

EasySocial.module('apps/fields/user/datetime/dropdown', function($) {
    var module = this;

    EasySocial.require().language('PLG_FIELDS_DATETIME_DAY').done(function() {
        EasySocial.Controller('Field.Datetime.Dropdown', {
            defaultOptions: {
                required: false,
                allowTime: false,
                allowTimezone: false,
                yearfrom: null,
                yearto: null,

                '{dateValue}': '[data-field-datetime-value]',

                '{year}': '[data-field-datetime-year]',
                '{month}': '[data-field-datetime-month]',
                '{day}': '[data-field-datetime-day]',

                '{hour}': '[data-field-datetime-hour]',
                '{minute}': '[data-field-datetime-minute]',
                '{ampm}': '[data-field-datetime-ampm]'
            }
        }, function(self) {
            return {
                init: function()
                {

                },

                '{year} change': function(el, ev)
                {
                    self.setValue();
                },

                '{month} change': function(el, ev)
                {
                    // If year and month is provided, then we need to find the max day
                    var year = self.year().val(),
                        month = self.month().val();

                    if (year !== '' && month !== '') {
                        var maxDay = new Date(year, month, 0).getDate();

                        // See if there are days originally selected
                        var day = self.day().val();

                        if (day !== '') {
                            // If day value is more than current month maxday, then we use maxday
                            day = Math.min(day, maxDay);
                        }

                        self.day().empty();

                        self.day().append($('<option value="">' + $.language('PLG_FIELDS_DATETIME_DAY') + '</option>'));

                        for (i = 1; i <= maxDay; i++) {
                            $('<option value="' + i + '">' + i + '</option>').appendTo(self.day());
                        }

                        // Set back the original value
                        if (day !== '') {
                            self.day().val(day);
                        }
                    }

                    self.setValue();
                },

                '{day} change': function(el, ev)
                {
                    self.setValue();
                },

                '{hour} change': function(el, ev)
                {
                    self.setValue();
                },

                '{minute} change': function(el, ev)
                {
                    self.setValue();
                },

                '{ampm} change': function(el, ev)
                {
                    self.setValue();
                },

                setValue: function()
                {
                    var string;

                    var year = self.year().val(),
                        month = self.month().val(),
                        day = self.day().val();

                    if (year !== '' && month !== '' && day !== '') {
                        string = year + '-' + month + '-' + day;

                        if (self.options.allowTime) {
                            var hour = self.hour().val(),
                                minute = self.minute().val();

                            // If there is ampm, then we need to readjust the time a little bit
                            if (hour !== '' && self.ampm().length > 0 && self.ampm().val() == 'pm') {
                                hour = (parseInt(hour) + 12).toString();

                                if (hour === '24') {
                                    hour = '0';
                                }
                            }

                            if (minute === '') {
                                minute = '00';
                            }

                            string += ' ' + ('00' + hour).slice(-2) + ':' + ('00' + minute).slice(-2) + ':00';
                        }

                        self.dateValue().val(string);
                    }
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/datetime/sample_content', function($) {
    var module = this;

    EasySocial.require().library('ui/datepicker').done(function() {
        EasySocial.Controller('Field.Datetime.Sample', {
            defaultOptions: {
                '{yearPrivacy}'     : '[data-yearprivacy]',

                '{input}'           : '[data-field-datetime-select]',

                '{timezone}'        : '[data-field-datetime-timezone]'
            }
        }, function(self) {
            return {
                init: function() {
                },

                '{self} onConfigChange': function(el, event, name, value) {
                    switch(name) {
                        case 'year_privacy':
                            self.yearPrivacy().toggle(value);
                        break;

                        case 'allow_timezone':
                            self.timezone().toggle(value);
                        break;

                        case 'placeholder':
                            self.input().attr('placeholder', value);
                        break;
                    }
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/dropdown/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_DROPDOWN_VALIDATION_PLEASE_SELECT_A_VALUE')
        .done(function($) {
            EasySocial.Controller(
                'Field.Dropdown',
                {
                    defaultOptions:
                    {
                        required        : null,

                        "{field}"       : "[data-field-dropdown]",

                        "{item}"        : "[data-field-dropdown-item]",

                        "{option}"      : "[data-field-dropdown-item] option"
                    }
                },
                function( self )
                {
                    return {
                        init : function()
                        {
                        },

                        validateInput : function()
                        {
                            self.clearError();

                            if(self.options.required && $.isEmpty(self.item().val())) {
                                self.raiseError();
                                return false;
                            }

                            return true;
                        },

                        raiseError: function() {
                            self.trigger('error', [$.language('PLG_FIELDS_DROPDOWN_VALIDATION_PLEASE_SELECT_A_VALUE')]);
                        },

                        clearError: function() {
                            self.trigger('clear');
                        },

                        "{self} onSubmit": function(el, event, register) {
                            // If field is not required, skip the checks.

                            if(!self.options.required)
                            {
                                register.push(true);
                                return;
                            }

                            register.push(self.validateInput());

                            return;
                        },

                        '{self} onSample': function() {
                            if(self.option().length < 1) {
                                self.item().append($('<option></option>'));
                            }
                        },

                        '{self} onChoiceAdded': function(el, event, index) {
                            if(self.option().eq(index).length > 0) {
                                self.option().eq(index).before($('<option></option>'));
                            } else {
                                self.item().append($('<option></option>'));
                            }
                        },

                        '{self} onChoiceValueChanged': function(el, event, index, value) {
                            self.option().eq(index).val(value);
                        },

                        '{self} onChoiceTitleChanged': function(el, event, index, value) {
                            self.option().eq(index).text(value);
                        },

                        '{self} onChoiceRemoved': function(el, event, index) {
                            self.option().eq(index).remove();
                        },

                        '{self} onChoiceToggleDefault': function(el, event, index, value) {
                            self.option().removeAttr('selected');

                            if(value) {
                                self.option().eq(index).attr('selected', 'selected');
                            }
                        }
                    }
                });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/email/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_EMAIL_VALIDATION_REQUIRED', 'PLG_FIELDS_EMAIL_VALIDATION_INVALID_FORMAT')
        .done(function($) {
            EasySocial.Controller(
                'Field.Email',
                {
                    defaultOptions:
                    {
                        required        : false,

                        regex           : 0,

                        regexFormat     : '',

                        regexModifier   : '',

                        "{field}"       : "[data-field-email]",

                        "{input}"       : "[data-field-email-input]"
                    }
                },
                function( self )
                {
                    return {
                        init: function() {
                        },

                        validateInput: function() {
                            var value   = self.input().val();

                            if(self.options.required && $.isEmpty(value)) {
                                self.raiseError($.language('PLG_FIELDS_EMAIL_VALIDATION_REQUIRED'));
                                return false;
                            }

                            if(!$.isEmpty(value) && self.options.regex) {
                                var regex = new RegExp(self.options.regexFormat, self.options.regexModifier);

                                if(!regex.test(value)) {
                                    self.raiseError($.language('PLG_FIELDS_EMAIL_VALIDATION_INVALID_FORMAT'));
                                    return false;
                                }
                            }

                            return true;
                        },

                        raiseError: function(msg) {
                            self.trigger('error', [msg]);
                        },

                        clearError: function() {
                            self.trigger('clear');
                        },

                        "{self} onSubmit": function(el, event, register) {

                            register.push(self.validateInput());

                            return;
                        }
                    }
                });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/file/content', function($) {
    var module = this;

    EasySocial.require().library('ui/sortable').language('PLG_FIELDS_FILE_ERROR_UNKNOWN_ERROR_OCCURED', 'COM_EASYSOCIAL_WORKING').done(function($) {
        EasySocial.Controller('Field.File', {
            defaultOptions: {
                required: false,

                id: null,

                inputName: '',

                maxFile: 0,

                '{field}': '[data-field-file]',

                '{list}': '[data-field-file-list]',

                '{item}': '[data-field-file-item]',

                '{add}': '[data-field-file-add]',

                // file items
                '{dragPlaceholder}': '.data-field-file-item-drag',
                '{moveHandle}': '[data-field-file-move]'

            }
        }, function(self) {
            return {
                init: function() {
                    self.options.maxFile = self.field().data('maxfile');

                    self.item().addController('EasySocial.Controller.Field.File.Item', {
                        controller: {
                            parent: self
                        }
                    });

                    self.initSortable();
                },

                initSortable: function() {
                    self.list().sortable({
                        items: self.item.selector,
                        placeholder: 'data-field-file-item-drag',
                        handle: self.moveHandle.selector,
                        forcePlaceholderSize: true,
                        start: function(event, ui) {
                            self.dragPlaceholder().width(ui.item.find('.file-wrap').width());
                        }
                    })
                },

                '{add} click': function(el, ev) {
                    if(self.options.maxFile < 1 || (self.item().length < self.options.maxFile)) {
                        var key = self.item().length;

                        var item = $('<div class="data-field-file-item" data-field-file-item></div>');

                        item.data('key', key);

                        item.html($.language('COM_EASYSOCIAL_WORKING'));

                        item.addController('EasySocial.Controller.Field.File.Item', {
                            controller: {
                                parent: self
                            }
                        });

                        self.list().append(item);

                        EasySocial.ajax('fields/user/file/getUploadHtml', {
                            id: self.options.id,
                            key: key
                        }).done(function(html) {
                            item.html(html);
                        });

                        if(self.options.maxFile > 1 && self.item().length >= self.options.maxFile) {
                            el.hide();
                        }
                    }
                },

                '{item} uploadDone': function() {
                    self.add().click();
                }
            }
        });

        EasySocial.Controller('Field.File.Item', {
            defaultOptions: {
                required: false,

                key: null,

                '{upload}'      : '[data-field-file-upload]',

                '{progress}'    : '[data-field-file-progress]',

                '{delete}'      : '[data-field-file-delete]',

                '{clear}'       : '[data-field-file-clear]',

                '{id}'          : '[data-field-file-id]',

                '{tmp}'         : '[data-field-file-tmp]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.options.key = self.element.data('key');
                },

                '{upload} change': function(el, ev) {
                    self.element.html($.language('COM_EASYSOCIAL_WORKING'));

                    EasySocial.ajax('fields/user/file/upload', {
                        id: self.parent.options.id,
                        files: el,
                        key: self.options.key
                    }, {
                        type: 'iframe'
                    }).done(function(html) {
                        self.element.html(html);

                        self.trigger('uploadDone');
                    }).fail(function(msg) {
                        self.element.html(msg || self.getErrorMsg());
                    });
                },

                '{delete} click': function(el, ev) {
                    var tmp = self.tmp().val();
                    var id = self.id().val();

                    self.element.html($.language('COM_EASYSOCIAL_WORKING'));

                    EasySocial.ajax('fields/user/file/delete', {
                        id: self.parent.options.id,
                        key: self.options.key,
                        tmp: tmp,
                        fileid: id
                    }).done(function(html) {
                        self.element.html(html);

                        self.trigger('fileDeleted');
                    }).fail(function(msg) {
                        self.element.html(msg || self.getErrorMsg());
                    });
                },

                '{clear} click': function(el, ev) {
                    self.element.html($.language('COM_EASYSOCIAL_WORKING'));

                    EasySocial.ajax('fields/user/file/getUploadHtml', {
                        id: self.parent.options.id,
                        key: self.options.key
                    }).done(function(html) {
                        self.element.html(html);
                    });
                },

                getErrorMsg: function() {
                    msg = $('<span class="alert field-file-error">' + $.language('PLG_FIELDS_FILE_ERROR_UNKNOWN_ERROR_OCCURED') + '<button class="close" type="button" data-field-file-clear>×</button></span>');

                    return msg;
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/file/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.File', {
        defaultOptions: {
            '{sizeText}': '[data-field-file-size-text]',

            '{size}': '[data-field-file-size]',

            '{add}': '[data-field-file-add]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, ev, name, value) {
                switch(name) {
                    case 'size_limit':
                        self.size().text(value);
                        break;

                    case 'show_size_limit':
                        self.sizeText().toggle(!!value);
                        break;

                    case 'file_limit':
                        self.add().toggle((value < 1 || value > 1));
                        break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/gender/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_GENDER_VALIDATION_GENDER_REQUIRED')
        .done(function($) {
            EasySocial.Controller(
                'Field.Gender',
                {
                    defaultOptions:
                    {
                        required        : false,

                        '{field}'       : '[data-field-gender]',

                        '{selection}'   : '[data-field-gender-select]'
                    }
                },
                function( self )
                {
                    return {
                        init : function()
                        {
                        },

                        validateInput: function() {
                            if(!self.options.required) {
                                return true;
                            }

                            self.clearError();

                            var value = self.selection(':checked').val();

                            if($.isEmpty(value))
                            {
                                self.raiseError();
                                return false;
                            }

                            return true;
                        },

                        raiseError: function() {
                            self.trigger('error', [$.language('PLG_FIELDS_GENDER_VALIDATION_GENDER_REQUIRED')]);
                        },

                        clearError: function() {
                            self.trigger('clear');
                        },

                        '{self} onSubmit': function(el, event, register) {
                            register.push(self.validateInput());
                        },

                        '{selection} click': function() {
                            self.validateInput();
                        }
                    }
                });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/joomla_email/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language(
            'PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_REQUIRED',
            'PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_RECONFIRM_REQUIRED',
            'PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_NOT_MATCHING')
        .done(function($) {
            EasySocial.Controller('Field.Joomla_email', {
                defaultOptions: {
                    required    : true,

                    id          : null,

                    userid      : null,

                    reconfirm   : false,

                    event       : null,

                    '{input}'   : '[data-field-email-input]',

                    '{confirm}' : '[data-field-email-reconfirm-input]',

                    '{confirmFrame}'    : '[data-field-email-reconfirm-frame]'
                }
            }, function(self) {
                return {
                    init: function() {
                        self.origEmail = self.input().val();
                    },

                    '{input} blur': function(el, ev) {
                        var value = self.input().val();

                        if(self.options.reconfirm && value !== self.origEmail)
                        {
                            self.confirmFrame().show();
                        }

                        if(self.options.reconfirm && value === self.origEmail && (self.options.event === 'onEdit' || self.options.event === 'onAdminEdit'))
                        {
                            self.confirmFrame().hide();
                        }

                        self.validateInput();
                    },

                    '{confirm} blur': function(el, ev) {
                        self.validateInput();
                    },

                    validateInput: function() {
                        self.clearError();

                        var value = self.input().val();

                        if($.isEmpty(value)) {
                            if(!self.options.required) {
                                return true;
                            }

                            self.raiseError($.language('PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_REQUIRED'));
                            return false;
                        }

                        if(self.options.reconfirm)
                        {
                            var reconfirm = self.confirm().val();

                            if(value !== self.origEmail && $.isEmpty(reconfirm))
                            {
                                self.raiseError($.language('PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_RECONFIRM_REQUIRED'));
                                return false;
                            }

                            if(!$.isEmpty(reconfirm) && value !== reconfirm)
                            {
                                self.raiseError($.language('PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_NOT_MATCHING'));
                                return false;
                            }
                        }

                        return self.checkInput()
                            .done(function() {
                                self.clearError();
                            })
                            .fail(function(msg) {
                                self.raiseError(msg);
                            });
                    },

                    checkInput: function() {
                        return EasySocial.ajax('fields/user/joomla_email/isValid', {
                            id: self.options.id,
                            userid: self.options.userid,
                            email: self.input().val()
                        });
                    },

                    raiseError: function(msg) {
                        self.trigger('error', [msg]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    },

                    '{self} onSubmit': function(el, ev, register, mode) {
                        if (mode === 'onRegisterMini') {
                            return;
                        }

                        register.push(self.validateInput());
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/joomla_email/registermini_content', function($) {
    var module = this;

    EasySocial.require()
    .language(
        'PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_REQUIRED',
        'PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_RECONFIRM_REQUIRED',
        'PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_NOT_MATCHING',
        'PLG_FIELDS_JOOMLA_EMAIL_CHECKING',
        'PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_INVALID_FORMAT')
    .done(function() {
        EasySocial.Controller('Field.Joomla_email.Mini', {
            defaultOptions: {
                require: true,
                id: null,

                '{input}': '#email',

                '{confirm}' : '[data-field-email-reconfirm-input]'

            }
        }, function(self) {
            return {
                init: function() {
                    self.origEmail = self.input().val();
                },

                '{input} keyup': function(el) {
                    if(el.val().length > 0) {
                        self.delayedCheck();
                    }
                },

                '{confirm} blur': function(el, ev) {
                    self.checkEmail();
                },

                state: false,

                delayedCheck: $.debounce(function() {
                    self.checkEmail();
                }, 250),

                checkEmail: function() {

                    self.clearError();

                    var email = self.input().val();

                    if(self.options.required && email.length == 0) {
                        self.raiseError($.language('PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_REQUIRED'));
                        return false;
                    }

                    if(!$.isEmpty(email) && self.options.regex) {
                        var regex = new RegExp(self.options.regexFormat, self.options.regexModifier);

                        if(!regex.test(email)) {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_INVALID_FORMAT'));
                            return false;
                        }
                    }


                    if(self.options.reconfirm)
                    {
                        var reconfirm = self.confirm().val();

                        if(email !== self.origEmail && $.isEmpty(reconfirm))
                        {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_RECONFIRM_REQUIRED'));
                            return false;
                        }

                        if(!$.isEmpty(reconfirm) && email !== reconfirm)
                        {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_EMAIL_VALIDATION_NOT_MATCHING'));
                            return false;
                        }
                    }


                    if(email.length > 0) {
                        var state = $.Deferred();

                        self.setLoading($.language('PLG_FIELDS_JOOMLA_EMAIL_CHECKING'));

                        var email = self.input().val();

                        EasySocial.ajax('fields/user/joomla_email/isValid', {
                            id: self.options.id,
                            userid: 0,
                            email: email
                        }).done(function(msg) {

                            self.setLoaded();

                            state.resolve();

                        }).fail(function(msg) {

                            self.setLoaded();

                            self.raiseError(msg);

                            state.reject();
                        });

                        return state;
                    }

                    return true;
                },

                raiseError: function(msg) {
                    self.trigger('error', [msg]);
                },

                clearError: function() {
                    self.trigger('clear');
                },

                '{self} onSubmit': function(el, ev, register, mode) {
                    if (mode !== 'onRegisterMini') {
                        return;
                    }

                    if(self.options.required || self.input().val().length > 0) {
                        register.push(self.checkEmail());
                    }
                },

                setLoading: function(msg) {
                    self.trigger('loading', [msg]);
                },

                setLoaded: function() {
                    self.trigger('loaded');
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/joomla_email/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_email.Sample', {
        defaultOptions: {
            '{confirmEmail}'        : '[data-field-email-reconfirm-frame]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'reconfirm_email':
                        self.confirmEmail().toggle(value);
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/joomla_fullname/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_JOOMLA_FULLNAME_VALIDATION_EMPTY_NAME')
        .done(function($) {
            EasySocial.Controller('Field.Joomla_fullname', {
                defaultOptions: {
                    nameFormat      : 1,

                    max             : 0,

                    required        : true,

                    '{field}'       : '[data-field-joomla_fullname]',

                    '{firstName}'   : '[data-field-jname-first]',
                    '{middleName}'  : '[data-field-jname-middle]',
                    '{lastName}'    : '[data-field-jname-last]',
                    '{name}'        : '[data-field-jname-name]'
                }
            }, function(self) {
                return {
                    init : function()
                    {
                        self.options.nameFormat = self.field().data('name-format');
                        self.options.max = self.field().data('max');
                    },

                    validateInput : function()
                    {
                        self.clearError();

                        if(!self.options.required) {
                            return true;
                        }

                        // Name format
                        // 1 - first, middle, last
                        // 2 - last, middle, first
                        // 3 - single name
                        // 4 - first, last
                        // 5 - last, first

                        if(self.options.nameFormat == 3) {
                            if($.isEmpty(self.name().val())) {
                                self.raiseError();
                                return false;
                            }

                            return true;
                        }

                        if($.isEmpty(self.firstName().val())) {
                            self.raiseError();
                            return false;
                        }

                        return true;
                    },

                    raiseError: function() {
                        self.trigger('error', [$.language('PLG_FIELDS_JOOMLA_FULLNAME_VALIDATION_EMPTY_NAME')]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    },

                    "{firstName} blur" : function(el, event) {
                        self.validateInput();
                    },

                    "{name} blur": function(el, event) {
                        self.validateInput();
                    },

                    "{self} onError": function(el, event, type, field) {
                        self.raiseError();
                    },

                    "{self} onSubmit" : function(el, event, register) {
                        register.push(self.validateInput());

                        return;
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/joomla_fullname/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_fullname.Sample', {
        defaultOptions: {
            '{fullnameFormat}'      : '[data-fullname-format]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'format':
                        self.switchFormat(value);
                    break;
                }
            },

            switchFormat: function(value) {
                self.fullnameFormat().hide();

                self.fullnameFormat().eq(value - 1).show();
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/joomla_password/content', function($) {
    var module = this;

    EasySocial.require()
        .library( 'passwordstrength' )
        .language(
            'PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_PASSWORD',
            'PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_RECONFIRM_PASSWORD',
            'PLG_FIELDS_JOOMLA_PASSWORD_NOT_MATCHING',
            'PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_CHAR',
            'PLG_FIELDS_JOOMLA_PASSWORD_MAXIMUM_CHAR',
            'PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_INTEGER',
            'PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_SYMBOLS',
            'PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_UPPERCASE',
            'PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_VERY_WEAK',
            'PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_WEAK',
            'PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_NORMAL',
            'PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_STRONG',
            'PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_VERY_STRONG',
            'PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_ORIGINAL_PASSWORD'
        )
        .done(function(){

            EasySocial.Controller(
                'Field.Joomla_password',
                {
                    defaultOptions:
                    {
                        event               : null,
                        triggerError        : true,

                        required            : false,
                        passwordStrength    : false,
                        reconfirmPassword   : false,
                        requireOriginal     : false,

                        min : 4,

                        max : 0,

                        minInteger: 0,
                        minSymbol: 0,
                        minUpperCase: 0,

                        '{field}'       : '[data-field-joomla_password]',

                        '{original}'    : '[data-field-password-orig]',
                        '{input}'       : '[data-field-password-input]',
                        '{reconfirm}'   : '[data-field-password-confirm]',

                        '{pwResetSubmitButton}' : '[data-password-reset-submit]',

                        '{strength}'    : '[data-field-password-strength]',
                        '{warning}'    : '[data-field-password-warning]',

                        '{reconfirmNotice}' : '[data-reconfirmPassword-failed]'
                    }
                },
                function( self )
                {
                    return {
                        init : function()
                        {
                            if(self.options.passwordStrength) {
                                self.initPasswordStrength();
                            }
                        },

                        '{input} keyup': function() {
                            self.validatePassword();
                        },

                        '{input} blur': function() {
                            self.validatePassword();
                        },

                        '{reconfirm} keyup': function() {
                            self.validatePassword();
                        },

                        '{reconfirm} blur': function() {
                            self.validatePassword();
                        },

                        validatePassword: function()
                        {
                            self.clearError();

                            var input = self.input().val(),
                                reconfirm = self.reconfirm().val();

                            if(self.options.event === 'onRegister' && !self.validatePasswordInput() ) {
                                return false;
                            }

                            if(self.options.event === 'onEdit' && !self.validatePasswordEdit()) {
                                return false;
                            }

                            if(self.options.reconfirmPassword && !self.validatePasswordConfirm()) {
                                return false;
                            }

                            return true;
                        },

                        validatePasswordInput: function() {
                            var input = self.input().val();

                            // console.log(self.options.min, self.options.max, self.options.minInteger, self.options.minSymbol);

                            if($.isEmpty(input)) {
                                self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_PASSWORD'));
                                return false;
                            }

                            if(self.options.min > 0 && input.length < self.options.min) {
                                self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_CHAR', self.options.min));
                                return false;
                            }

                            if(self.options.max > 0 && input.length > self.options.max) {
                                self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_MAXIMUM_CHAR', self.options.max));
                                return false;
                            }

                            if(self.options.minInteger > 0) {
                                var test = input.match(/[0-9]/g);
                                if (!test || test.length < self.options.minInteger) {
                                    self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_INTEGER', self.options.minInteger));
                                    return false;
                                }
                            }

                            if(self.options.minSymbol > 0) {
                                var test = input.match(/[\W]/g);
                                if (!test || test.length < self.options.minSymbol) {
                                    self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_SYMBOLS', self.options.minSymbol));
                                    return false;
                                }
                            }

                            if(self.options.minUpperCase > 0) {
                                var test = input.match(/[A-Z]/g);
                                if (!test || test.length < self.options.minUpperCase) {
                                    self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_UPPERCASE', self.options.minUpperCase));
                                    return false;
                                }
                            }


                            return true;
                        },

                        validatePasswordEdit: function() {
                            var orig = self.original().val(),
                                input = self.input().val();

                            // If both original and input is empty, then we return true as it is not mandatory in edit
                            if($.isEmpty(input) && $.isEmpty(orig)) {
                                return true;
                            }

                            // Only original is empty
                            if($.isEmpty(orig) && self.options.requireOriginal) {
                                self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_ORIGINAL_PASSWORD'));
                                return false;
                            }

                            // Original is not empty, then we validate the new password
                            return self.validatePasswordInput();
                        },

                        validatePasswordConfirm: function() {
                            var input = self.input().val(),
                                reconfirm = self.reconfirm().val();

                            // Check if either input or reconfirm is not empty
                            if(!$.isEmpty(input) || !$.isEmpty(reconfirm)) {
                                if($.isEmpty(input)) {
                                    self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_PASSWORD'));
                                    return false;
                                }

                                if($.isEmpty(reconfirm)) {
                                    self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_RECONFIRM_PASSWORD'));
                                    return false;
                                }

                                if(input !== reconfirm) {
                                    self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_NOT_MATCHING'));
                                    return false;
                                }
                            }

                            return true;
                        },

                        initPasswordStrength: function() {
                            self.input().password_strength({
                                container: self.strength.selector,
                                minLength: self.options.min,
                                texts: {
                                    1: $.language('PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_VERY_WEAK'),
                                    2: $.language('PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_WEAK'),
                                    3: $.language('PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_NORMAL'),
                                    4: $.language('PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_STRONG'),
                                    5: $.language('PLG_FIELDS_JOOMLA_PASSWORD_STRENGTH_VERY_STRONG')
                                },
                                onCheck: function(level) {
                                    if(level <= 1) {
                                        self.strength()
                                            .removeClass('text-warning')
                                            .removeClass('text-success')
                                            .addClass('text-error small help-inline');
                                    }

                                    if(level > 1 && level <= 3) {
                                        self.strength()
                                            .removeClass('text-error')
                                            .removeClass('text-success')
                                            .addClass('text-warning small help-inline');
                                    }

                                    if(level >= 4) {
                                        self.strength()
                                            .removeClass('text-error')
                                            .removeClass('text-warning')
                                            .addClass('text-success small help-inline');
                                    }
                                }
                            })
                        },

                        raiseError: function(msg) {
                            if (self.options.triggerError) {
                                self.trigger('error', [msg]);
                            } else {
                                self.warning().show();
                                self.warning().text(msg);
                            }
                        },

                        clearError: function() {
                            if (self.options.triggerError) {
                                self.trigger('clear');
                            } else {
                                self.warning().hide();
                                self.warning().text('');
                            }
                        },

                        "{pwResetSubmitButton} click": function() {
                            return self.validatePassword();
                        },

                        "{self} onSubmit": function(el, event, register, mode) {

                            if (mode === 'onRegisterMini') {
                                return;
                            }

                            register.push(self.validatePassword());
                        }
                    }
                });

            module.resolve();

        });
});

EasySocial.module('apps/fields/user/joomla_password/registermini_content', function($) {
    var module = this;

    EasySocial.require()
    .language(
        'PLG_FIELDS_JOOMLA_PASSWORD_TOO_SHORT',
        'PLG_FIELDS_JOOMLA_PASSWORD_TOO_LONG',
        'PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_INTEGER',
        'PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_SYMBOLS',
        'PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_UPPERCASE',
        'PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_PASSWORD',
        'PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_RECONFIRM_PASSWORD',
        'PLG_FIELDS_JOOMLA_PASSWORD_NOT_MATCHING')
    .done(function() {
        EasySocial.Controller('Field.Joomla_password.Mini', {
            defaultOptions: {
                required: false,
                reconfirmPassword: false,
                min: 4,
                max: 0,

                '{input}': '[data-password]',
                '{reconfirm}'   : '[data-field-password-confirm]',

                '{reconfirmNotice}' : '[data-reconfirmPassword-failed]'
            }
        }, function(self) {
            return {
                init: function() {

                },

                '{input} keyup': function() {
                    self.checkPassword();
                },

                '{reconfirm} keyup': function() {
                    self.validatePassword();
                },

                '{reconfirm} blur': function() {
                    self.validatePassword();
                },

                checkPassword: function() {
                    self.clearError();

                    var value = self.input().val();

                    if(self.options.required && value.length == 0) {
                        self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_PASSWORD'));
                        return false;
                    }

                    if(self.options.min > 0 && value.length < self.options.min) {
                        self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_TOO_SHORT'));
                        return false;
                    }

                    if(self.options.max > 0 && value.length > self.options.max) {
                        self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_TOO_LONG'));
                        return false;
                    }

                    if(self.options.minInteger > 0) {
                        var test = value.match(/[0-9]/g);
                        if (!test || test.length < self.options.minInteger) {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_INTEGER', self.options.minInteger));
                            return false;
                        }
                    }

                    if(self.options.minSymbol > 0) {
                        var test = value.match(/[\W]/g);
                        if (!test || test.length < self.options.minSymbol) {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_SYMBOLS', self.options.minSymbol));
                            return false;
                        }
                    }

                    if(self.options.minUpperCase > 0) {
                        var test = value.match(/[A-Z]/g);
                        if (!test || test.length < self.options.minUpperCase) {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_MINIMUM_UPPERCASE', self.options.minUpperCase));
                            return false;
                        }
                    }

                    return true;
                },

                validatePassword: function()
                {
                    self.clearError();

                    var input = self.input().val(),
                        reconfirm = self.reconfirm().val();

                    if(self.options.reconfirmPassword && !self.validatePasswordConfirm()) {
                        return false;
                    }

                    return true;
                },

                validatePasswordConfirm: function() {
                    var input = self.input().val(),
                        reconfirm = self.reconfirm().val();

                    // Check if either input or reconfirm is not empty
                    if(!$.isEmpty(input) || !$.isEmpty(reconfirm)) {
                        if($.isEmpty(input)) {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_PASSWORD'));
                            return false;
                        }

                        if($.isEmpty(reconfirm)) {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_EMPTY_RECONFIRM_PASSWORD'));
                            return false;
                        }

                        if(input !== reconfirm) {
                            self.raiseError($.language('PLG_FIELDS_JOOMLA_PASSWORD_NOT_MATCHING'));
                            return false;
                        }
                    }

                    return true;
                },

                '{self} onSubmit': function(el, event, register, mode) {
                    if (mode !== 'onRegisterMini') {
                        return;
                    }

                    register.push(self.checkPassword());
                },

                clearError: function() {
                    self.trigger('clear');
                },

                raiseError: function(msg) {
                    self.trigger('error', [msg]);
                }
            }
        });

        module.resolve();
    });
})

EasySocial.module('apps/fields/user/joomla_password/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_password.Sample', {
        defaultOptions: {
            '{confirmPassword}'     : '[data-password-confirm]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'reconfirm_password':
                        self.confirmPassword().toggle(value);
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/joomla_timezone/content', function($) {
    var module = this;

    EasySocial
        .require()
        .library('chosen')
        .language('PLG_FIELDS_JOOMLA_TIMEZONE_VALIDATION_SELECT_TIMEZONE')
        .done(function($) {
            EasySocial.Controller('Field.Joomla_timezone', {
                defaultOptions: {
                    required        : false,

                    '{field}'       : '[data-field-joomla_timezone]',

                    '{input}'       : '[data-field-joomla_timezone-input]'
                }
            }, function(self) {
                return {
                    init : function() {
                        self.input().chosen({
                            allow_single_deselect: true,
                            search_contains: true
                        });
                    },

                    validateInput: function() {
                        if(!self.options.required) {
                            return true;
                        }

                        self.clearError();

                        var value = self.input().val();

                        if(value === 'null' || $.isEmpty(value)) {
                            self.raiseError();
                            return false;
                        }

                        return true;
                    },

                    raiseError: function() {
                        self.trigger('error', [$.language('PLG_FIELDS_JOOMLA_TIMEZONE_VALIDATION_SELECT_TIMEZONE')]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    },

                    '{input} change': function() {
                        self.validateInput();
                    },

                    "{self} onSubmit": function(el, event, register) {
                        register.push(self.validateInput());
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/joomla_username/content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_username', {
        defaultOptions: {
            event: null,

            id: null,

            userid: null,

            '{checkUsernameButton}': '[data-username-check]',

            '{input}': '[data-username-input]',

            '{available}': '[data-username-available]'
        }
    }, function(self) {
        return {
            state: false,

            init: function() {
            },

            '{checkUsernameButton} click': function() {
                self.delayedCheck();
            },

            '{input} keyup': function() {
                self.delayedCheck();
            },

            delayedCheck: $.debounce(function() {
                self.checkUsername();
            }, 250),

            checkUsername: function() {
                self.clearError();

                var state = $.Deferred();

                self.checkUsernameButton().addClass('btn-loading');

                var username = self.input().val();

                EasySocial.ajax('fields/user/joomla_username/isValid', {
                    id: self.options.id,
                    userid: self.options.userid,
                    username: username,
                    event: self.options.event
                }).done(function(msg) {

                    self.checkUsernameButton().removeClass('btn-loading');

                    self.available().show();

                    state.resolve();
                }).fail(function(msg) {

                    self.raiseError(msg);

                    self.checkUsernameButton().removeClass('btn-loading');

                    self.available().hide();

                    state.reject();
                });

                return state;
            },

            raiseError: function(msg) {
                self.trigger('error', [msg]);
            },

            clearError: function() {
                self.trigger('clear');
            },

            '{self} onSubmit': function(el, ev, register, mode) {
                if (mode === 'onRegisterMini') {
                    return;
                }

                register.push(self.checkUsername());
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/joomla_username/registermini_content', function($) {
    var module = this;

    EasySocial.require()
    .language(
        'PLG_FIELDS_JOOMLA_USERNAME_CHECKING',
        'PLG_FIELDS_JOOMLA_USERNAME_EMPTY_USERNAME')
    .done(function() {

        EasySocial.Controller('Field.Joomla_username.Mini', {
            defaultOptions: {
                id: null,

                required: false,

                '{input}': '#joomla_username'
            }
        }, function(self) {
            return {
                init: function() {

                },

                '{input} keyup': function(el) {
                    if(el.val().length > 0) {
                        self.delayedCheck();
                    }
                },

                state: false,

                delayedCheck: $.debounce(function() {
                    self.checkUsername();
                }, 250),

                checkUsername: function() {

                    var username = self.input().val();

                    if(self.options.required && username.length == 0) {
                        self.raiseError($.language('PLG_FIELDS_JOOMLA_USERNAME_EMPTY_USERNAME'));
                        return false;
                    }

                    if(username.length > 0) {
                        var state = $.Deferred();

                        self.clearError();

                        self.setLoading($.language('PLG_FIELDS_JOOMLA_USERNAME_CHECKING'));

                        EasySocial.ajax('fields/user/joomla_username/isValid', {
                            id: self.options.id,
                            userid: 0,
                            username: username
                        }).done(function(msg) {

                            self.setLoaded();

                            state.resolve();

                        }).fail(function(msg) {

                            self.setLoaded();

                            self.raiseError(msg);

                            state.reject();

                        });

                        return state;
                    }

                    return true;
                },

                raiseError: function(msg) {
                    self.trigger('error', [msg]);
                },

                clearError: function() {
                    self.trigger('clear');
                },

                '{self} onSubmit': function(el, ev, register, mode) {
                    if (mode !== 'onRegisterMini') {
                        return;
                    }

                    if(self.options.required || self.input().val().length > 0) {
                        register.push(self.checkUsername());
                    }
                },

                setLoading: function(msg) {
                    self.trigger('loading', [msg]);
                },

                setLoaded: function() {
                    self.trigger('loaded');
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('apps/fields/user/joomla_username/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_username.Sample', {
        defaultOptions: {
            '{checkUsername}'       : '[data-check-username]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_username':
                        self.checkUsername().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/multidropdown/content', function($) {
    var module = this;

    EasySocial.require().library('ui/sortable').language('PLG_FIELDS_MULTIDROPDOWN_VALIDATION_REQUIRED_FIELD').done(function() {
            EasySocial.Controller('Field.Multidropdown', {
                defaultOptions: {
                    required: false,

                    id: null,

                    inputName: '',

                    max: 0,

                    '{field}': '[data-field-multidropdown]',

                    '{list}': '[data-field-multidropdown-list]',

                    '{item}': '[data-field-multidropdown-item]',

                    '{input}': '[data-field-multidropdown-input]',

                    '{add}': '[data-field-multidropdown-add]',

                    '{delete}': '[data-field-multidropdown-delete]',

                    '{move}': '[data-field-multidropdown-move]'
                }
            }, function(self) {
                return {
                    init: function() {
                        self.options.max = self.field().data('max');

                        self.initSortable();
                    },

                    initSortable: function() {
                        self.list().sortable({
                            items: self.item.selector,
                            handle: self.move.selector
                        });
                    },

                    '{add} click': function(el) {
                        if (self.options.max < 1 || self.item().length < self.options.max)
                        {
                            var item = self.item().eq(0).clone();

                            item.find(self.input.selector)
                                .attr('value', '')
                                .val('');

                            self.list().append(item);
                        }

                        if(self.options.max > 0 && self.item().length >= self.options.max)
                        {
                            el.hide();
                        }
                    },

                    '{delete} click': function(el) {
                        var item = el.parents(self.item.selector);

                        if (self.item().length > 1) {
                            item.remove();
                        } else {
                            item.find(self.input.selector).val('');
                        }

                        if (self.options.max > 0 && self.item().length < self.options.max) {
                            self.add().show();
                        }
                    },

                    '{self} onConfigChange': function(el, ev, name, value) {
                        switch (name) {
                            case 'add_button_text':
                                self.add().text(value);
                            break;
                        }
                    },

                    raiseError: function() {
                        self.trigger('error', [$.language('PLG_FIELDS_MULTIDROPDOWN_VALIDATION_REQUIRED_FIELD')]);
                    },

                    '{self} onSubmit': function(el, ev, register) {
                        if (!self.options.required) {
                            register.push(true);
                            return;
                        }

                        var state = false;

                        $.each(self.input(), function(i, element) {
                            if (!$.isEmpty($(element).val())) {
                                state = true;

                                return false;
                            }
                        });

                        if (!state) {
                            self.raiseError();
                        }

                        register.push(state);
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/multilist/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_MULTILIST_VALIDATION_PLEASE_SELECT_A_VALUE')
        .done(function($) {
            EasySocial.Controller(
                'Field.Multilist',
                {
                    defaultOptions:
                    {
                        required        : null,
                        multiple        : null,

                        "{field}"       : "[data-field-multilist]",

                        "{item}"        : "[data-field-multilist-item]",

                        "{option}"      : "[data-field-multilist-item] option"
                    }
                },
                function( self )
                {
                    return {
                        init : function()
                        {
                        },

                        validateInput : function()
                        {
                            self.clearError();

                            if(self.options.multiple && self.item().children(':selected').length <= 0) {
                                self.raiseError();
                                return false;
                            }

                            // The only way to test for an empty value is when the value is empty and it's required.
                            if(self.item().children(':selected' ).val() == '') {
                                self.raiseError();
                                return false;
                            }

                            return true;
                        },

                        raiseError: function() {
                            self.trigger('error', [$.language('PLG_FIELDS_MULTILIST_VALIDATION_PLEASE_SELECT_A_VALUE')]);
                        },

                        clearError: function() {
                            self.trigger('clear');
                        },

                        "{self} onSubmit": function(el, event, register) {
                            // If field is not required, skip the checks.

                            if(!self.options.required)
                            {
                                register.push(true);
                                return;
                            }

                            register.push(self.validateInput());

                            return;
                        },

                        '{self} onSample': function() {
                            if(self.option().length < 1) {
                                self.item().append($('<option></option>'));
                            }
                        },

                        '{self} onChoiceAdded': function(el, event, index) {
                            if(self.option().eq(index).length > 0) {
                                self.option().eq(index).before($('<option></option>'));
                            } else {
                                self.item().append($('<option></option>'));
                            }
                        },

                        '{self} onChoiceValueChanged': function(el, event, index, value) {
                            self.option().eq(index).val(value);
                        },

                        '{self} onChoiceTitleChanged': function(el, event, index, value) {
                            self.option().eq(index).text(value);
                        },

                        '{self} onChoiceRemoved': function(el, event, index) {
                            self.option().eq(index).remove();
                        },

                        '{self} onChoiceToggleDefault': function(el, event, index, value) {
                            if(value) {
                                self.option().eq(index).attr('selected', 'selected');
                            } else {
                                self.option().eq(index).removeAttr('selected');
                            }
                        }
                    }
                });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/multitextbox/content', function($) {
    var module = this;

    EasySocial
        .require()
        .library('ui/sortable')
        .language('PLG_FIELDS_MULTITEXTBOX_VALIDATION_REQUIRED_FIELD')
        .done(function() {
            EasySocial.Controller('Field.Multitextbox', {
                defaultOptions: {
                    required: false,

                    id: null,

                    inputName: '',

                    max: 0,

                    '{field}': '[data-field-multitextbox]',

                    '{list}': '[data-field-multitextbox-list]',

                    '{item}': '[data-field-multitextbox-item]',

                    '{input}': '[data-field-multitextbox-input]',

                    '{add}': '[data-field-multitextbox-add]',

                    '{delete}': '[data-field-multitextbox-delete]',

                    '{move}': '[data-field-multitextbox-move]'
                }
            }, function(self) {
                return {
                    init: function() {
                        self.options.max = self.field().data('max');

                        self.initSortable();
                    },

                    initSortable: function() {
                        self.list().sortable({
                            items: self.item.selector,
                            handle: self.move.selector
                        });
                    },

                    '{add} click': function(el) {
                        if (self.options.max < 1 || self.item().length < self.options.max)
                        {
                            var item = self.item().eq(0).clone();

                            item.find(self.input.selector)
                                .attr('value', '')
                                .val('');

                            self.list().append(item);
                        }

                        if(self.options.max > 0 && self.item().length >= self.options.max)
                        {
                            el.hide();
                        }
                    },

                    '{delete} click': function(el) {
                        var item = el.parents(self.item.selector);

                        if (self.item().length > 1) {
                            item.remove();
                        } else {
                            item.find(self.input.selector).val('');
                        }

                        if (self.options.max > 0 && self.item().length < self.options.max) {
                            self.add().show();
                        }
                    },

                    '{self} onConfigChange': function(el, ev, name, value) {
                        switch (name) {
                            case 'add_button_text':
                                self.add().text(value);
                            break;
                        }
                    },

                    raiseError: function() {
                        self.trigger('error', [$.language('PLG_FIELDS_MULTITEXTBOX_VALIDATION_REQUIRED_FIELD')]);
                    },

                    '{self} onSubmit': function(el, ev, register) {
                        if(!self.options.required) {
                            register.push(true);
                            return;
                        }

                        var state = false;

                        $.each(self.input(), function(i, element) {
                            if(!$.isEmpty($(element).val())) {
                                state = true;

                                return false;
                            }
                        });

                        if (!state) {
                            self.raiseError();
                        }

                        register.push(state);
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/permalink/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language(
            'PLG_FIELDS_PERMALINK_EXCEEDED_MAX_LENGTH',
            'PLG_FIELDS_PERMALINK_REQUIRED')
        .done(function($) {
            EasySocial.Controller('Field.Permalink', {
                defaultOptions:
                {
                    required: false,

                    max     : 0,

                    id      : null,
                    userid  : null,

                    '{field}'           : '[data-field-permalink]',

                    '{checkButton}'     : '[data-permalink-check]',
                    '{input}'           : '[data-permalink-input]',
                    '{available}'       : '[data-permalink-available]'
                }
            },
            function(self)
            {
                return {
                    state: false,

                    init: function()
                    {
                        self.options.max = self.field().data('max');
                    },

                    "{checkButton} click" : function()
                    {
                        self.delayedCheck();
                    },

                    "{input} keyup" : function()
                    {
                        self.delayedCheck();
                    },

                    delayedCheck: $.debounce(function() {
                        self.checkPermalink();
                    }, 250),

                    checkPermalink: function()
                    {
                        self.clearError();

                        var permalink   = self.input().val();

                        self.available().hide();

                        if(self.options.max > 0 && permalink.length > self.options.max) {
                            self.raiseError($.language('PLG_FIELDS_PERMALINK_EXCEEDED_MAX_LENGTH'));
                            return false;
                        }

                        if(!$.isEmpty(permalink))
                        {
                            self.checkButton().addClass('btn-loading');

                            var state = $.Deferred();

                            EasySocial.ajax('fields/user/permalink/isValid',
                            {
                                "id"        : self.options.id,
                                "userid"    : self.options.userid,
                                "permalink" : permalink
                            })
                            .done(function(msg)
                            {
                                self.checkButton().removeClass( 'btn-loading' );

                                self.available().show();

                                state.resolve();
                            })
                            .fail(function(msg)
                            {
                                self.raiseError(msg);

                                self.checkButton().removeClass('btn-loading');

                                self.available().hide();

                                state.reject();
                            });

                            return state;
                        }

                        if(self.options.required && $.isEmpty(permalink))
                        {
                            self.available().hide();

                            self.raiseError($.language('PLG_FIELDS_PERMALINK_REQUIRED'));
                            return false;
                        }

                        return true;
                    },

                    raiseError: function(msg)
                    {
                        self.trigger('error', [msg]);
                    },

                    clearError: function()
                    {
                        self.trigger('clear');
                    },

                    '{self} onSubmit': function(el, ev, register)
                    {
                        register.push(self.checkPermalink());
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/relationship/content', function($) {
    var module = this;

    EasySocial
        .require()
        .script( 'site/friends/suggest' )
        .language(
            'PLG_FIELDS_RELATIONSHIP_APPROVE_CONFIRM',
            'PLG_FIELDS_RELATIONSHIP_ACTION_APPROVE',
            'COM_EASYSOCIAL_CANCEL_BUTTON')
        .done(function($) {

            EasySocial.Controller('Field.Relationship', {
                defaultOptions: {
                    required: false,

                    id: null,

                    types: null,

                    fieldname: null,

                    actor: null,
                    target: null,

                    '{field}'   : '[data-field-relationship]',

                    '{display}' : '[data-relationship-display]',
                    '{form}'    : '[data-relationship-form]',

                    '{confirm}' : '[data-relationship-display-confirm]',
                    '{pending}' : '[data-relationship-display-pending]',

                    '{actions}' : '[data-relationship-display-actions]',

                    '{pendingTitle}'    : '[data-relationship-pending-title]'
                }
            }, function(self) {
                return {
                    init: function() {
                        EasySocial.module('field.relationship/' + self.options.id).done(function(types) {
                            self.options.types = types;
                        });

                        self.display().addController('EasySocial.Controller.Field.Relationship.Display', {
                            controller: {
                                parent: self
                            }
                        });

                        self.addPlugin('form');
                    },

                    '{self} relationshipDeleted': function() {
                        self.confirm().hide();

                        self.form().show();
                    }
                }
            });

            EasySocial.Controller('Field.Relationship.Form', {
                defaultOptions: {
                    origType            : null,
                    origTarget          : null,
                    origApproved        : null,

                    '{form}'            : '[data-relationship-form]',

                    '{type}'            : '[data-relationship-form-type]',
                    '{connectWord}'     : '[data-relationship-form-connectwords]',
                    '{connectWords}'    : '[data-relationship-form-connectwords] span',

                    '{input}'           : '[data-relationship-form-input]',

                    '{target}'          : '[data-relationship-form-target]',

                    '{targetAvatar}'    : '[data-relationship-form-target-avatar]',
                    '{targetName}'      : '[data-relationship-form-target-name]',

                    '{targetPending}'   : '[data-relationship-form-target-pending]',

                    '{targetDelete}'    : '[data-relationship-form-target-delete]',

                    '{textboxlistDelete}': '[data-textboxlist-itemRemoveButton]'
                }
            }, function(self) {
                return {
                    init: function() {
                        self.input().addController(EasySocial.Controller.Friends.Suggest, {
                            max: 1,
                            name: self.parent.options.fieldname + '[target][]'
                        });

                        self.options.origType = self.form().data('orig-type');
                        self.options.origTarget = self.form().data('orig-target');
                        self.options.origApproved = self.form().data('orig-approved');
                    },

                    '{type} change': function(el) {
                        var name = el.val();

                        var isConnect = self.parent.options.types[name].connect;

                        var items = self.input().controller('Textboxlist').getAddedItems();

                        var isSelected = items.length > 0;

                        var element = isSelected ? self.target() : self.input();

                        var selected = isSelected ? items[0] : false;

                        if(isConnect) {
                            element.show();

                            if(isSelected && self.options.origApproved && selected.id == self.options.origTarget && name == self.options.origType) {
                                self.targetPending().hide();
                            } else {
                                self.targetPending().show();
                            }
                        } else {
                            element.hide();
                        }

                        self.connectWords().hide();

                        self.connectWords().filterBy('relationship-form-connectword', name).show();
                    },

                    '{input} addItem': function(el, ev, item) {
                        if(item.avatar) {
                            self.targetAvatar().attr('src', item.avatar);
                        }

                        if(item.screenName) {
                            self.targetName().text(item.screenName);
                        }

                        if(item.id) {
                            self.targetDelete().data('id', item.id);
                        }

                        self.input().hide();

                        self.target().show();

                        if(self.options.origApproved && item.id == self.options.origTarget && self.type().val() == self.options.origType) {
                            self.targetPending().hide();
                        } else {
                            self.targetPending().show();
                        }
                    },

                    '{targetDelete} click': function(el, ev) {
                        var id = el.data('id');

                        self.input().controller('Textboxlist').removeItem(id);

                        self.input().show();

                        self.target().hide();
                    },

                    '{parent} relationshipApproved': function(el, ev, target) {

                        self.type().val(target.type);

                        var item = {
                            avatar: target.avatar,
                            html: target.name + '<input type="hidden" name="' + self.parent.options.fieldname + '[target][]" value="' + target.id + '"/>',
                            id: target.id,
                            key: target.name,
                            menuHtml: undefined,
                            name: self.parent.options.fieldname + '[target]',
                            screenName: target.name,
                            title: target.name
                        }

                        self.input().controller('Textboxlist').addItem(item);

                        self.connectWords().hide();

                        self.connectWords().filterBy('relationshipFormConnectword', target.type);
                    }
                }
            });

            EasySocial.Controller('Field.Relationship.Display', {
                defaultOptions: {
                    id                  : null,

                    '{pendingFrame}'    : '[data-relationship-display-pending-text]',
                    '{loadingFrame}'    : '[data-relationship-display-loading]',
                    '{errorFrame}'      : '[data-relationship-display-error]',

                    '{actionsFrame}'    : '[data-relationship-display-actions]',

                    '{deleteButton}'    : '[data-relationship-display-actions-delete]',

                    '{approveButton}'   : '[data-relationship-display-actions-approve]',
                    '{rejectButton}'    : '[data-relationship-display-actions-reject]'
                }
            }, function(self) {
                return {
                    init: function() {

                        self.options.id = self.element.data('id');

                    },

                    '{deleteButton} click': function() {

                        self.parent.trigger('relationshipDeleted');

                        self.element.hide();
                    },

                    '{approveButton} click': function() {
                        EasySocial.dialog({
                            width: 500,
                            content: $.language('PLG_FIELDS_RELATIONSHIP_APPROVE_CONFIRM'),
                            selectors: {
                                '{approveButton}': '[data-approve-button]',
                                '{cancelButton}': '[data-cancel-button]'
                            },
                            bindings: {
                                '{approveButton} click': function() {
                                    this.parent.close();

                                    self.approveRelationship();
                                },

                                '{cancelButton} click': function() {
                                    this.parent.close();
                                }
                            },
                            buttons: '<button data-cancel-button type="button" class="btn btn-es">' + $.language('COM_EASYSOCIAL_CANCEL_BUTTON') + '</button><button data-approve-button type="button" class="btn btn-es-primary">' + $.language('PLG_FIELDS_RELATIONSHIP_ACTION_APPROVE') + '</button>'
                        })
                    },

                    approveRelationship: function() {
                        self.actionsFrame().hide();

                        self.loadingFrame().show();

                        EasySocial.ajax('fields/user/relationship/approve', {
                            id: self.parent.options.id,
                            relid: self.options.id
                        })
                            .done(function(target) {
                                self.parent.display().hide();

                                self.element.show();

                                self.element.removeAttr('data-relationship-display-pending');
                                self.element.attr('data-relationship-display-confirm', '');

                                self.parent.form().before(self.element);

                                self.parent.form().hide();

                                if(self.parent.pending().length < 1) {
                                    self.parent.pendingTitle().hide();
                                }

                                self.loadingFrame().remove();

                                self.pendingFrame().remove();

                                self.approveButton().remove();

                                self.rejectButton().remove();

                                self.actionsFrame().show();

                                self.deleteButton().show();

                                self.parent.trigger('relationshipApproved', [target]);
                            })
                            .fail(function(msg) {
                                self.loadingFrame().hide();

                                self.errorFrame().show().find('span').text(msg);
                            });
                    },

                    '{rejectButton} click': function() {
                        self.actionsFrame().hide();

                        self.loadingFrame().show();

                        EasySocial.ajax('fields/user/relationship/reject', {
                            id: self.parent.options.id,
                            relid: self.options.id
                        })
                            .done(function() {
                                // self.parent.trigger('relationshipRejected');

                                self.element.remove();

                                if(self.parent.pending().length < 1) {
                                    self.parent.pendingTitle().hide();
                                }
                            })
                            .fail(function(msg) {
                                self.parent.trigger('relationshipActionError', [msg]);
                            });
                    }
                }
            });

            module.resolve();

        });
});

EasySocial.module('site/friends/suggest', function($){

	var module 	= this;

	EasySocial.require()
	.view('site/friends/suggest.item')
	.library('textboxlist')
	.language('COM_EASYSOCIAL_FRIENDS_REQUEST_SENT')
	.done(function($) {


		EasySocial.Controller('Friends.Suggest.User', {
			defaultOptions: {
				"{addButton}": "[data-friend-suggest-add]",
				"{button}": "[data-friend-suggest-button]"
			}
		}, function(self, opts, base) { return {

			init: function() {
				opts.uid = self.element.data('uid');
			},

			"{addButton} click" : function(el) {

				// Implement controller on add friend.
				EasySocial.ajax('site/controllers/friends/request', {
					"id": opts.uid
				}).done(function(friendId) {
					// replace the button with done message.
					self.button().html($.language('COM_EASYSOCIAL_FRIENDS_REQUEST_SENT'));

				}).fail(function(obj) {

					EasySocial.dialog({
						width: 450,
						height: 180,
						content: obj.message
					});
				});
			}

			}
		});

		EasySocial.Controller('Friends.Suggest', {
			defaultOptions: {
				max: null,
				exclusive: true,
				exclusion: [],
				minLength: 1,
				highlight: true,
				name: "uid[]",
				type: "",

				// Search for friend list as well
				friendList: false,
				friendListName: "",

				includeSelf: false,
				showNonFriend: false,

				view: {
					suggestItem: "site/friends/suggest.item"
				}
			}
		}, function(self, opts, base) { return {

			init: function() {

				// Implement the textbox list on the implemented element.
				self.element
					.textboxlist({
						component: 'es',
						name: opts.name,
						max: opts.max,
						plugin: {
							autocomplete: {
								exclusive: opts.exclusive,
								minLength: opts.minLength,
								highlight: opts.highlight,
								showLoadingHint	: true,
								showEmptyHint	: true,

								query: function(keyword) {

									var suggestOptions = {
															"search": keyword,
															"type": opts.type,
															"showNonFriend": opts.showNonFriend
														};

									if (opts.includeSelf) {
										suggestOptions.includeme = true;
									}

									if (!opts.friendList) {
										return EasySocial.ajax('site/controllers/friends/suggest', suggestOptions);
									}

									return EasySocial.ajax('site/controllers/friends/suggestWithList', {
										"search": keyword,
										"inputName": opts.name,
										"friendListName": opts.friendListName,
										"showNonFriend": opts.showNonFriend
									});
								}
							}
						}
					})
					.textboxlist("enable");
			},

			"{self} filterItem": function(el, event, item) {
				
				// If this suggest searches for friend list, we don't want to format the item result here.
				if (opts.friendList) {
					return;
				}

				var html = self.view.suggestItem(true, {
							item: item,
							name: self.options.name
						});

				item.title = item.screenName;
				item.menuHtml = html;
				item.html = html;

				return item;
			},

			"{self} filterMenu": function(el, event, menu, menuItems, autocomplete, textboxlist) {
				
				// If this suggest searches for friend list, we don't want to format the item result here.
				if (opts.friendList) {
					return;
				}

				// Get list of excluded users
				var items = textboxlist.getAddedItems(),
					users = $.pluck(items, "id"),
					users = users.concat(self.options.exclusion);

				menuItems.each(function(){

					var menuItem = $(this),
						item = menuItem.data("item");

					// If this user is excluded, hide the menu item
					menuItem.toggleClass("hidden", $.inArray(item.id.toString(), users) > -1);
				});
			}

		}});

		module.resolve();
	});

});


EasySocial.module('apps/fields/user/separator/sample', function($) {
    var module = this;

    EasySocial.Controller( 'Field.Separator.Sample',
    {
        defaultOptions:
        {
            "{items}"   : "[data-separator-type]"
        }
    },
    function( self )
    {
        return {
            "{self} onConfigChange" : function( el , event , name , value )
            {
                if( name == 'type' )
                {
                    var itemToShow  = $( '[data-separator-' + value + ']' );

                    // Hide all separators
                    self.items().hide();

                    // Only show the correct separator
                    itemToShow.show();
                }

            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/terms/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_TERMS_VALIDATION_REQUIRED')
        .done(function($) {
            EasySocial.Controller('Field.Terms',
            {
                defaultOptions:
                {
                    event           : null,

                    required        : false,

                    '{textbox}'     : '[data-field-terms-textbox]',
                    '{checkbox}'    : '[data-field-terms-checkbox]'
                }
            },
            function(self)
            {
                return {
                    init : function() {
                    },

                    validateInput: function() {
                        self.clearError();

                        if(self.options.event == 'onAdminEdit') {
                            return true;
                        }

                        if(self.options.required && !self.checkbox().is(':checked'))
                        {
                            self.raiseError();
                            return false;
                        }

                        return true;
                    },

                    '{checkbox} change': function() {
                        self.validateInput();
                    },

                    raiseError: function() {
                        self.trigger('error', [$.language('PLG_FIELDS_TERMS_VALIDATION_REQUIRED')]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    },

                    '{self} onSubmit': function(el, event, register) {
                        register.push(self.validateInput());
                    },

                    '{self} onConfigChange': function(el, event, name, value) {
                        switch(name) {
                            case 'message':
                                self.textbox().val(value);
                                break;
                        }
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/textarea/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language(
            'PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_REQUIRED',
            'PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_TOO_SHORT',
            'PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_TOO_LONG')
        .done(function($) {
            EasySocial.Controller('Field.Textarea', {
                defaultOptions: {
                    required        : false,

                    min: 0,
                    max: 0,

                    '{field}'       : '[data-field-textarea]',

                    '{input}'       : '[data-field-textarea-input]'
                }
            }, function( self ) {
                return {
                    init : function() {
                        self.options.min = self.field().data('min');
                        self.options.max = self.field().data('max');
                    },

                    validateInput : function()
                    {
                        self.clearError();

                        var val     = self.input().val();

                        if(self.options.required && $.isEmpty(val)) {
                            self.raiseError($.language('PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_REQUIRED'));
                            return false;
                        }

                        if(!$.isEmpty(val) && self.options.min > 0 && val.length < self.options.min) {
                            self.raiseError($.language('PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_TOO_SHORT'));
                            return false;
                        }

                        if(self.options.max > 0 && val.length > self.options.max) {
                            self.raiseError($.language('PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_TOO_LONG'));
                            return false;
                        }

                        return true;
                    },

                    raiseError: function(msg) {
                        self.trigger('error', [msg]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    },

                    '{self} onSubmit': function(el, event, register) {
                        register.push(self.validateInput());
                    },

                    '{self} onError': function(el, ev, type) {
                        if(type === 'required') {
                            self.raiseError($.language('PLG_FIELDS_TEXTAREA_VALIDATION_INPUT_REQUIRED'));
                        }
                    },

                    '{input} keyup': function() {
                        self.validateInput();
                    },

                    '{self} onConfigChange': function(el, event, name, value) {
                        switch(name) {
                            case 'default':
                                self.input().val(value);
                                break;

                            case 'placeholder':
                                self.input().attr('placeholder', value);
                                break;

                            case 'readonly':
                                if(value) {
                                    self.input().attr('readonly', 'readonly');
                                } else {
                                    self.input().removeAttr('readonly');
                                }
                                break;
                        }
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/textbox/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language(
            'PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_REQUIRED',
            'PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_TOO_SHORT',
            'PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_TOO_LONG',
            'PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_INVALID_FORMAT')
        .done(function($) {
            EasySocial.Controller('Field.Textbox', {
                defaultOptions: {
                    required: false,

                    min: 0,
                    max: 0,

                    '{field}': '[data-field-textbox]',

                    '{input}': '[data-field-textbox-input]',

                    '{notice}': '[data-check-notice]'
                }
            }, function(self) {
                return {
                    init: function() {
                        self.options.min = self.field().data('min');
                        self.options.max = self.field().data('max');
                    },

                    '{input} keyup': function()
                    {
                        self.validateInput();
                    },

                    '{input} blur': function()
                    {
                        self.validateInput();
                    },

                    validateInput: function()
                    {
                        self.clearError();

                        var value = self.input().val();

                        if(self.options.required && $.isEmpty(value)) {
                            self.raiseError($.language('PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_REQUIRED'));
                            return false;
                        }

                        if(!$.isEmpty(value) && self.options.min > 0 && value.length < self.options.min) {
                            self.raiseError($.language('PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_TOO_SHORT'));
                            return false;
                        }

                        if(self.options.max > 0 && value.length > self.options.max) {
                            self.raiseError($.language('PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_TOO_LONG'));
                            return false;
                        }

                        return true;
                    },

                    raiseError: function(msg) {
                        self.trigger('error', [msg]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    },

                    '{self} onError': function(el, ev, type) {
                        if(type === 'required') {
                            self.raiseError($.language('PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_REQUIRED'));
                        }

                        if(type === 'validate') {
                            self.raiseError($.language('PLG_FIELDS_TEXTBOX_VALIDATION_INPUT_INVALID_FORMAT'));
                        }
                    },

                    '{self} onSubmit': function(el, ev, register) {
                        register.push(self.validateInput());
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/textbox/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Textbox.Sample', {
        defaultOptions: {
            '{input}'           : '[data-input]',

            'min'                   : '',
            'max'                   : '',
            'regex_validate'        : false,
            'regex_format'          : '',
            'regex_modifier'        : ''
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'placeholder':
                        self.input().attr('placeholder', value);
                    break;

                    case 'default':
                        self.input().val(value);
                    break;

                    case 'readonly':
                        if(value) {
                            self.input().attr('disabled', 'disabled');
                        } else {
                            self.input().removeAttr('disabled');
                        }
                        break;
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/fields/user/url/content', function($) {
    var module = this;

    EasySocial
        .require()
        .language('PLG_FIELDS_URL_VALIDATION_EMPTY_URL')
        .done(function($) {
            EasySocial.Controller('Field.Url', {
                defaultOptions: {
                    required        : false,

                    '{input}'       : '[data-field-url-input]'
                }
            }, function( self ) {
                return {
                    init: function() {
                    },

                    '{input} blur': function() {
                        self.validateInput();
                    },

                    validateInput: function() {
                        self.clearError();

                        var value = self.input().val();

                        if(self.options.required && $.isEmpty(value)) {
                            self.raiseError($.language('PLG_FIELDS_URL_VALIDATION_EMPTY_URL'));
                            return false;
                        }

                        return true;
                    },

                    raiseError: function(msg) {
                        self.trigger('error', [msg]);
                    },

                    clearError: function() {
                        self.trigger('clear');
                    },

                    '{self} onError': function(el, event, type, field) {
                        self.raiseError($.language('PLG_FIELDS_URL_VALIDATION_EMPTY_URL'));
                    }
                }
            });

            module.resolve();
        });
});

EasySocial.module('apps/fields/user/url/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Url.Sample', {
        defaultOptions: {
            '{urlInput}': '[data-url-input]'
        }
    }, function(self) {
        return {
            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'placeholder':
                        self.urlInput().attr('placeholder', value);
                    break;

                    case 'default':
                        self.urlInput().val(value);
                    break;
                }
            }
        }
    });

    module.resolve();
});

EasySocial.module('apps/group/feeds', function($) {

    var module  = this;

    EasySocial.Controller('Groups.Apps.Feeds',
        {
            defaultOptions: {
                "{browser}": "[data-feeds-browser]",
                "{sources}": "[data-feeds-sources]",
                "{item}": "[data-feeds-list-item]",
                "{create}" : "[data-feeds-create]",
                "{list}": "[data-feeds-list]",
                "{remove}": "[data-feeds-remove]"
            }
        }, function(self) {

            return {

                init: function()
                {
                    self.options.id = self.element.data('groupid');
                    self.options.appId = self.element.data('appid');

                    self.list().implement(EasySocial.Controller.Groups.Apps.Feeds.List);
                },

                "{remove} click": function(el)
                {
                    var feedId = $(el).data('id'),
                        item = self.item.of(el);

                    EasySocial.dialog({
                        content: EasySocial.ajax('apps/group/feeds/controllers/feeds/confirmDelete', {"groupId" : self.options.id}),
                        bindings: {
                            "{deleteButton} click": function() {

                                EasySocial.ajax('apps/group/feeds/controllers/feeds/delete', {
                                    "appId": self.options.appId,
                                    "feedId": feedId,
                                    "groupId": self.options.id
                                })
                                .done(function(){

                                    // Remove the feed source
                                    item.remove();

                                    // Determine if there's no more item to be displayed
                                    if (self.sources().children().length == 0) {
                                        self.browser().addClass('is-empty');
                                    }

                                    EasySocial.dialog().close();
                                });
                            }
                        }
                    });
                },

                "{create} click": function()
                {
                    EasySocial.dialog({
                        content: EasySocial.ajax('apps/group/feeds/controllers/feeds/create', {"id" : self.options.id}),
                        bindings: {
                            "{saveButton} click": function() {


                                var title = this.title().val(),
                                    url = this.url().val();

                                var notice = $('[data-feeds-form-notice]');

                                // first remove all the alert styling.
                                notice.removeClass('alert alert-error');
                                notice.addClass('hide');


                                if (title.trim().length == 0) {
                                    notice.text( $.language('Please enter title.') );
                                    notice.addClass('alert alert-error');
                                    notice.removeClass('hide');
                                    return;
                                }

                                if (url.trim().length == 0) {
                                    notice.text( $.language('Please enter URL.') );
                                    notice.addClass('alert alert-error');
                                    notice.removeClass('hide');
                                    return;
                                }


                                EasySocial.ajax('apps/group/feeds/controllers/feeds/save', {
                                    "title": this.title().val(),
                                    "url": this.url().val(),
                                    "appId": self.options.appId,
                                    "groupId": self.options.id
                                })
                                .done(function(output){

                                    // Whenever a new feed item is created, it should never be empty.
                                    self.browser().removeClass('is-empty');

                                    // Append output to the list
                                    self.sources().append(output);

                                    EasySocial.dialog().close();
                                });
                            }
                        }
                    });
                }
            }
        });

    EasySocial.Controller('Groups.Apps.Feeds.List', {
        defaultOptions: {
            "{item}": "[data-feed-item]",
            "{openPreview}" : "[data-feed-open]",
            "{preview}": "[data-feed-preview]"
        }
    }, function(self) {
        return {
            init: function()
            {
            },

            "{openPreview} click": function(el)
            {
                var item = self.item.of(el),
                    preview = item.find(self.preview.selector);

                // If it's already open, hide it
                if (!preview.hasClass('hide')) {
                    preview.addClass('hide');
                } else {
                    // Hide all items first
                    self.preview().addClass('hide');

                    // Only display the clicked item
                    preview.removeClass('hide');
                }
            }
        }
    });
    module.resolve();
});


EasySocial.module( 'apps/group/tasks' , function($)
{
    var module  = this;

    EasySocial.Controller(
        'Groups.Apps.Tasks.Milestones.Browse',
        {
            defaultOptions:
            {
                "{milestone}"   : "[data-group-tasks-milestone-item]"
            }
        },
        function(self)
        {
            return {
                init: function()
                {
                    self.options.groupId    = self.element.data( 'groupid' );

                    self.milestone().implement( EasySocial.Controller.Groups.Apps.Tasks.Milestones.Item ,
                        {
                            "{parent}"  : self
                        });
                }
            }
        });

    EasySocial.Controller(
        'Groups.Apps.Tasks.Milestones.Item',
        {
            defaultOptions:
            {
                "{complete}"    : "[data-milestone-mark-complete]",
                "{uncomplete}"  : "[data-milestone-mark-uncomplete]",
                "{delete}"      : "[data-milestone-delete]",
                "{milestone}"   : "[data-group-tasks-milestone-item]"
            }
        },
        function(self)
        {
            return {
                init: function()
                {
                    self.options.id     = self.element.data( 'id' );
                },

                "{uncomplete} click" : function()
                {
                    EasySocial.ajax( 'apps/group/tasks/controllers/milestone/unresolve' ,
                    {
                        id      : self.options.id,
                        groupId : self.parent.options.groupId
                    })
                    .done(function()
                    {
                        self.element.removeClass( 'is-due' ).removeClass( 'is-completed' );
                    });
                },

                "{complete} click" : function()
                {
                    EasySocial.ajax( 'apps/group/tasks/controllers/milestone/resolve' ,
                    {
                        id      : self.options.id,
                        groupId : self.parent.options.groupId
                    })
                    .done(function()
                    {
                        self.element.removeClass( 'is-due' ).addClass( 'is-completed' );
                    });
                },

                "{delete} click" : function()
                {
                    EasySocial.dialog(
                    {
                        content : EasySocial.ajax( 'apps/group/tasks/controllers/milestone/confirmDelete' ,
                        {
                            id          : self.options.id,
                            groupId     : self.parent.options.groupId
                        }),
                        bindings:
                        {
                            '{deleteButton} click' : function()
                            {
                                EasySocial.ajax( 'apps/group/tasks/controllers/milestone/delete' ,
                                {
                                    id  : self.options.id,
                                    groupId : self.parent.options.groupId
                                })
                                .done(function()
                                {
                                    EasySocial.dialog().close();

                                    self.element.remove();
                                });
                            }
                        }
                    });
                }
            }
        });

    EasySocial.Controller(
        'Groups.Apps.Tasks',
        {
            defaultOptions:
            {
                '{form}'    : '[data-group-tasks-form]',
                '{formWrapper}' : '[data-group-tasks-form-wrapper]',
                '{taskList}': '[data-group-tasks-list]',
                '{item}'    : '[data-group-tasks-list-item]',
                '{completedList}'   : '[data-group-tasks-completed]',
                '{openCounter}'     : '[data-tasks-open-counter]',
                '{closedCounter}'   : '[data-tasks-closed-counter]',
                "{completeMilestone}"   : "[data-milestone-mark-complete]",
                "{uncompleteMilestone}" : "[data-milestone-mark-uncomplete]",
                "{deleteMilestone}"     : "[data-milestone-delete]",
                "{wrapper}"             : "[data-group-tasks-wrapper]"
            }
        },
        function( self )
        {
            return {
                init: function()
                {
                    self.options.id         = self.element.data( 'id' );
                    self.options.groupId    = self.element.data( 'groupid' );
                    self.options.milestoneId    = self.element.data( 'milestoneid' );

                    // Implement form controller
                    self.form().implement( EasySocial.Controller.Groups.Apps.Tasks.Form , { "{parent}" : self });

                    // Implement task item controller
                    self.implementItemController();
                },
                implementItemController: function()
                {
                    self.item().implement( EasySocial.Controller.Groups.Apps.Tasks.Item , { "{parent}" : self } );
                },
                updateOpenCounter: function( total )
                {
                    self.openCounter().html( total );
                },
                updateClosedCounter: function( total )
                {
                    self.closedCounter().html( total );
                },
                insertCompleted: function( taskItem )
                {
                    $( taskItem ).appendTo( self.completedList() );
                },
                insertTask: function( taskItem )
                {
                    self.formWrapper().after(taskItem);

                    self.implementItemController();
                },
                "{uncompleteMilestone} click" : function()
                {
                    EasySocial.ajax( 'apps/group/tasks/controllers/milestone/unresolve' ,
                    {
                        id      : self.options.milestoneId,
                        groupId : self.options.groupId
                    })
                    .done(function()
                    {
                        self.wrapper().removeClass( 'is-due' ).removeClass( 'is-completed' );
                    });
                },
                "{completeMilestone} click" : function()
                {
                    EasySocial.ajax( 'apps/group/tasks/controllers/milestone/resolve' ,
                    {
                        id      : self.options.milestoneId,
                        groupId : self.options.groupId
                    })
                    .done(function()
                    {
                        self.wrapper().removeClass( 'is-due' ).addClass( 'is-completed' );
                    });
                },

                "{deleteMilestone} click" : function()
                {
                    EasySocial.dialog(
                    {
                        content : EasySocial.ajax( 'apps/group/tasks/controllers/milestone/confirmDelete' ,
                        {
                            id          : self.options.milestoneId,
                            groupId     : self.options.groupId
                        }),
                        bindings:
                        {
                            '{deleteButton} click' : function()
                            {
                                EasySocial.ajax( 'apps/group/tasks/controllers/milestone/delete' ,
                                {
                                    id  : self.options.id,
                                    groupId : self.options.groupId
                                })
                                .done(function()
                                {
                                    EasySocial.dialog().close();

                                    window.location = self.options.redirect;
                                });
                            }
                        }
                    });
                }
            }
        }
    );

    EasySocial.Controller(
        'Groups.Apps.Tasks.Item',
        {
            defaultOptions:
            {
                '{checkbox}'    : '[data-item-checkbox]',
                '{delete}'      : '[data-tasks-item-remove]'
            }
        },
        function( self )
        {
            return {
                init: function()
                {
                    self.options.id     = self.element.data( 'id' );
                },
                '{delete} click' : function()
                {
                    EasySocial.dialog(
                    {
                        content     : EasySocial.ajax( 'apps/group/tasks/controllers/tasks/confirmDelete' , { 'groupId' : self.parent.options.groupId }),
                        bindings    :
                        {
                            '{deleteButton} click' : function()
                            {
                                EasySocial.ajax( 'apps/group/tasks/controllers/tasks/delete' ,
                                {
                                    id  : self.options.id,
                                    groupId : self.parent.options.groupId
                                })
                                .done(function()
                                {
                                    EasySocial.dialog().close();

                                    var total   = parseInt( self.parent.openCounter().html() );

                                    self.parent.updateOpenCounter( total - 1 );

                                    self.element.remove();
                                });
                            }
                        }
                    });

                },
                '{checkbox} change': function( el , event )
                {
                    var checked = $( el ).is( ':checked' );

                    if( checked )
                    {
                        EasySocial.ajax( 'apps/group/tasks/controllers/tasks/resolve' ,
                        {
                            id          : self.options.id,
                            groupId     : self.parent.options.groupId
                        })
                        .done(function()
                        {
                            // Decrease the open counter
                            var total   = parseInt( self.parent.openCounter().html() );

                            self.parent.updateOpenCounter( total - 1 );

                            var total   = parseInt( self.parent.closedCounter().html() );

                            self.parent.updateClosedCounter( total + 1 );

                            self.parent.insertCompleted( self.element );
                        });

                    }
                    else
                    {
                        EasySocial.ajax( 'apps/group/tasks/controllers/tasks/unresolve' ,
                        {
                            id          : self.options.id,
                            groupId     : self.parent.options.groupId
                        })
                        .done(function($)
                        {
                            // Decrease the open counter
                            var total   = parseInt( self.parent.openCounter().html() );

                            self.parent.updateOpenCounter( total + 1 );

                            var total   = parseInt( self.parent.closedCounter().html() );

                            self.parent.updateClosedCounter( total - 1 );

                            self.parent.insertTask( self.element );
                        });
                    }
                }
            }
        });

    EasySocial.Controller(
        'Groups.Apps.Tasks.Form',
        {
            defaultOptions:
            {
                '{title}'   : "[data-form-tasks-title]",
                '{create}'  : "[data-form-tasks-create]",
                '{assignee}': "[data-form-tasks-assignee]",
                '{due}'     : "[data-form-tasks-due]",
                '{error}'   : "[data-group-tasks-form-error]"
            }
        },
        function(self)
        {
            return {
                init: function()
                {

                },

                resetForm: function()
                {
                    self.element[0].reset();
                },

                "{title} keyup" : function( el , event )
                {
                    // Enter key
                    if(event.keyCode == 13)
                    {
                        self.create().click();
                    }
                },

                "{create} click" : function()
                {
                    if( self.title().val() == '' )
                    {
                        self.error().removeClass( 'hide' );

                        return false;
                    }

                    self.error().addClass( 'hide' );

                    EasySocial.ajax( 'apps/group/tasks/controllers/tasks/save' ,
                    {
                        title       : self.title().val(),
                        assignee    : self.assignee().val(),
                        due         : self.due().val(),
                        groupId     : self.parent.options.groupId,
                        milestoneId : self.parent.options.id
                    })
                    .done(function( content )
                    {
                        // Reset the form
                        self.resetForm();

                        // Increment the counter
                        var total   = parseInt( self.parent.openCounter().html() );

                        self.parent.updateOpenCounter( total + 1 );

                        self.parent.insertTask( content );
                    });
                }
            }
        });

    module.resolve();
});


EasySocial.module( 'avatar' , function($){

var module = this;

EasySocial.require()
.script('utilities/webcam')
.done(function($) {

	EasySocial.Controller('Avatar', {
		defaultOptions: {
			uid: null,
			type: null,
			redirectUrl: null,
			"{menu}": "[data-avatar-menu]",

			"{takePictureButton}": "[data-avatar-webcam]",
			"{uploadButton}": "[data-avatar-upload-button]",
			"{selectButton}": "[data-avatar-select-button]",
			"{removeButton}": "[data-avatar-remove-button]"
		}
	}, function(self) {
		return {

			init: function() {

				// Implement the webcam js on the take picture button
				var hasFlash = self.hasFlash();
			},

			"{uploadButton} click": function() {
				EasySocial.dialog({
					content: EasySocial.ajax('site/views/avatar/upload', { 
						'uid' : self.options.uid, 'type': self.options.type 
					})
				});
			},

			hasFlash: function() {

				// method to check if web browser installed with flash plugin or not.
				var hasFlash = false;

				try {
				  var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
				  if (fo) {
				    hasFlash = true;
				  }
				} catch (e) {
				  if (navigator.mimeTypes
				        && navigator.mimeTypes['application/x-shockwave-flash'] != undefined
				        && navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
				    hasFlash = true;
				  }
				}

				return hasFlash;
			},

			hideWebcamCanvas: function() {
				// Instead of hiding the canvas, we reposition the webcam canvas
				$('[data-canvas-webcam]')
					.css('position', 'absolute')
					.css('left', '-9999px');

				// $('[data-canvas-webcam]').addClass('hidden');
			},

			showWebcamCanvas: function() {
				// Instead of hiding the canvas, we reposition the webcam canvas
				$('[data-canvas-webcam]')
					.css('position', 'relative')
					.css('left', '0');
			},

			webcamStarted : false,
			"{takePictureButton} click": function() {

				var pos = 0, ctx = null, saveCB, image = [];

				var canvas = document.createElement("canvas");
				canvas.setAttribute('width', 320);
				canvas.setAttribute('height', 240);
				
				ctx = canvas.getContext("2d");

				image = ctx.getImageData(0, 0, 320, 240);

				saveCB = function(data) {

					var col = data.split(";");
					var img = image;

					for(var i = 0; i < 320; i++) {
						var tmp = parseInt(col[i]);
						img.data[pos + 0] = (tmp >> 16) & 0xff;
						img.data[pos + 1] = (tmp >> 8) & 0xff;
						img.data[pos + 2] = tmp & 0xff;
						img.data[pos + 3] = 0xff;
						pos+= 4;
					}

					if (pos >= 4 * 320 * 240) {
						ctx.putImageData(img, 0, 0);

						EasySocial.ajax('site/views/profile/saveCamPicture', {
							type: "data",
							image: canvas.toDataURL('image/png')
						}).done(function(result){
							var source = result.url;
							var image = new Image();

							preview = $('[data-photo-camera-preview]');

							preview.removeClass('hidden');

							$(image).attr('src', source)
								.appendTo(preview);

							$('[data-save-button]').removeClass('hidden');
							
							// Instead of hiding the canvas, we reposition the webcam canvas
							self.hideWebcamCanvas();

							// Hide the capture picture button now
							$('[data-capture-button]').addClass('hidden');
							$('[data-recapture-button]').removeClass('hidden');

							$('[data-photo-filename]').val(result.file);
						});

						pos = 0;
					}
				};


				if (!self.webcamStarted) {

					EasySocial.dialog({
						content: EasySocial.ajax('site/views/profile/takePicture', {}),
						
						afterHide: function() {
							// After the webcam dialog is hidden, we need to reset the state
							self.webcamStarted = false;
						},

						bindings: {
							init: function() {

								$('[data-canvas-webcam]').webcam({
									onSave: saveCB,
									onCapture: function () {
										webcam.save();
									},
									debug: function(type, message) {

										// User denied access to the camera
										if (type == 'notify' && message == 'Camera stopped') {
											self.webcamStarted = false;
											EasySocial.dialog().close();
											return;
										}
									}
								});

								self.webcamStarted = true;
							},

							"{captureButton} click": function() {
								webcam.capture();
							},
							
							"{recaptureButton} click": function(el, event) {
								$('[data-capture-button]').removeClass('hidden');
								$('[data-recapture-button]').addClass('hidden');
								$('[data-save-button]').addClass('hidden');
									
								// Display the webcam canvas again.
								self.showWebcamCanvas();

								preview.find('img').remove();
								preview.addClass('hidden');
							},

							"{saveButton} click": function(el, event) {
								file = $('[data-photo-filename]').val();
								uid = $('[data-photo-uid]').val();

								EasySocial.ajax('site/controllers/photos/createAvatarFromWebcam', {
									uid 	: uid,
									type	: "user",
									file	: file
								}).done(function(result){
									EasySocial.dialog().close();
									location.reload();
								});
								
							}
						}
					})
				}
			},

			"{selectButton} click": function() {
				
				EasySocial.photos.selectPhoto({
					uid : self.options.uid,
					type : self.options.type,
					bindings: {
						"{self} photoSelected": function(el, event, photos) {

							// Photo selection dialog returns an array,
							// so just pick the first one.
							var photo = photos[0];

							// If no photo selected, stop.
							if (!photo) {
								return;
							}

							EasySocial.photos.createAvatar(photo.id , { "uid" : self.options.uid , "type" : self.options.type , "redirectUrl" : self.options.redirectUrl } );
						},

						"{cancelButton} click": function() {
							this.parent.close();
						}
					}
				});
			},

            "{menu} shown.bs.dropdown": function() {
                 self.element.addClass("show-all");
            },

            "{menu} hidden.bs.dropdown": function() {
                 self.element.removeClass("show-all");
            },

			"{removeButton} click": function() {
				EasySocial.dialog({
					"content": EasySocial.ajax('site/views/profile/confirmRemoveAvatar')
				});
			}

		}
	});

	module.resolve();
});


});
EasySocial.module('utilities/webcam', function($){

var module 	= this;


/**
 * @license jQuery webcam plugin v1.0.0 09/12/2010
 * http://www.xarg.org/project/jquery-webcam-plugin/
 *
 * Copyright (c) 2010, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/

(function ($) {

    var webcam = {

	"extern": null, // external select token to support jQuery dialogs
	"append": true, // append object instead of overwriting

	"width": 320,
	"height": 240,

	"mode": "callback", // callback | save | stream

	"swffile": $.rootPath + '/media/com_easysocial/scripts/utilities/jscam.swf',
	"quality": 85,

	"debug":	function () {},
	"onCapture":	function () {},
	"onTick":	function () {},
	"onSave":	function () {},
	"onLoad":	function () {}
    };

    window["webcam"] = webcam;

    $["fn"]["webcam"] = function(options) {

	if (typeof options === "object") {
	    for (var ndx in webcam) {
		if (options[ndx] !== undefined) {
		    webcam[ndx] = options[ndx];
		}
	    }
	}

	var source = '<object id="XwebcamXobjectX" type="application/x-shockwave-flash" data="'+webcam["swffile"]+'" width="'+webcam["width"]+'" height="'+webcam["height"]+'"><param name="movie" value="'+webcam["swffile"]+'" /><param name="FlashVars" value="mode='+webcam["mode"]+'&amp;quality='+webcam["quality"]+'" /><param name="allowScriptAccess" value="always" /></object>';

	if (null !== webcam["extern"]) {
	    $(webcam["extern"])[webcam["append"] ? "append" : "html"](source);
	} else {
	    this[webcam["append"] ? "append" : "html"](source);
	}

	var run = 3;
	(_register = function() {
	    var cam = document.getElementById('XwebcamXobjectX');

	    if (cam && cam["capture"] !== undefined) {

		/* Simple callback methods are not allowed :-/ */
		webcam["capture"] = function(x) {
		    try {
			return cam["capture"](x);
		    } catch(e) {}
		}
		webcam["save"] = function(x) {
		    try {
			return cam["save"](x);
		    } catch(e) {}
		}
		webcam["setCamera"] = function(x) {
		    try {
			return cam["setCamera"](x);
		    } catch(e) {}
		}
		webcam["getCameraList"] = function() {
		    try {
			return cam["getCameraList"]();
		    } catch(e) {}
		}
		webcam["pauseCamera"] = function() {
		    try {
			return cam["pauseCamera"]();
		    } catch(e) {}
		}
		webcam["resumeCamera"] = function() {
		    try {
			return cam["resumeCamera"]();
		    } catch(e) {}
		}
		webcam["onLoad"]();
	    } else if (0 == run) {
		webcam["debug"]("error", "Flash movie not yet registered!");
	    } else {
		/* Flash interface not ready yet */
		run--;
		window.setTimeout(_register, 1000 * (4 - run));
	    }
	})();
    }

})($);


module.resolve();

}); 

EasySocial.module('cover', function($) {

var module = this;

EasySocial.require()
    .library("image")
    .done(function(){

        EasySocial.Controller('Cover', {
            defaultOptions: {
                uid                 : null,
                type                : null,
                "{image}"           : "[data-cover-image]",
                "{editButton}"      : "[data-cover-edit-button]",
                "{doneButton}"      : "[data-cover-done-button]",
                "{cancelButton}"    : "[data-cover-cancel-button]",
                "{uploadButton}"    : "[data-cover-upload-button]",
                "{selectButton}"    : "[data-cover-select-button]",
                "{removeButton}"    : "[data-cover-remove-button]",
                "{menu}"            : "[data-cover-menu]",

                // Hack to disable click that causes photo popup on the flyout
                "{flyout}"          : ".es-flyout-content"
            }
        },
        function(self, opts, base) { return {

            init: function() {

                // Automatically enable cover editing if not manually disabled
                // if (!self.options.disabled) { self.start("url"); }

                self.setLayout();

                if (self.element.hasClass("editing")) {
                    self.enable();
                }
            },

            "{editButton} click": function() {
                self.enable();

                // Mark a flag as repositioning only
                self.reposition = true;

                // After enabling, manually get the position from self.element and apply it
                self.image().css('backgroundPosition', self.element.css('backgroundPosition'));
            },

            "{cancelButton} click": function(el, ev) {
                self.disable();
            },

            reposition: false,

            ready: false,

            disabled: true,

            toggle: function() {
                self[(self.disabled) ? "enable" : "disable"]();
            },

            enable: function() {
                self.setLayout();
                self.disabled = false;
                self.element.addClass("editing");
                base.attr("data-es-photo-disabled", 1);
            },

            disable: function() {
                self.reposition = false;
                self.disabled = true;
                self.element.removeClass("editing");

                // Allow some time before enabling photo popup
                setTimeout(function(){
                    base.attr("data-es-photo-disabled", 0);
                }, 1);

                var profileUrl =
                    $.uri(window.location.href)
                        .deleteQueryParam("cover_id")
                        .toString();

                History.pushState({state: 0}, window.title, profileUrl);
            },

            imageLoaders: {},

            setLayout: function() {

                var cover = self.image(),
                    image = self.setLayout.image;

                if (!image) {

                    // Extract image url from cover
                    var url = $.uri(cover.css("backgroundImage")).extract(0);

                    // If no url given, stop.
                    if (!url) return;

                    // Load image
                    var imageLoaders = self.imageLoaders,
                        imageLoader =
                            (imageLoaders[url] || (imageLoaders[url] = $.Image.get(url)))
                                .done(function(image) {

                                    // Set it as current image
                                    self.setLayout.image = image;

                                    // Then set layout again
                                    self.setLayout();
                                });

                        return;
                }

                // Get measurements
                var imageWidth  = image.data("width"),
                    imageHeight = image.data("height"),
                    coverWidth  = cover.width(),
                    coverHeight = cover.height(),
                    size = $.Image.resizeProportionate(
                        imageWidth, imageHeight,
                        coverWidth, coverHeight,
                        "outer"
                    );

                self.availableWidth  = coverWidth  - size.width;
                self.availableHeight = coverHeight - size.height;
            },

            setCover: function(id, url) {

                // Show loading indicator
                self.element.addClass("loading");

                // Make sure the image has been properly loading
                $.Image.get(url)
                    .done(function(){

                        self.image()
                            .data("photoId", id)
                            .css({
                                backgroundImage: $.cssUrl(url),
                                backgroundPosition: "50% 50%"
                            });

                        // Reset position
                        self.x = 0.5;
                        self.y = 0.5;

                        self.enable();
                    })
                    .fail(function(){
                        self.disable();
                    })
                    .always(function(){

                        self.element.removeClass("loading");
                    });
            },

            drawing: false,

            moveCover: function(dx, dy, image) {

                // Optimization: Pass in reference to image
                // so we don't have to query all the time.
                if (!image) { image = self.image(); }

                var w = self.availableWidth,
                    h = self.availableHeight,
                    x = (w==0) ? 0 : self.x + ((dx / w) || 0),
                    y = (h==0) ? 0 : self.y + ((dy / h) || 0);

                // Always stay within 0 to 1.
                if (x < 0) x = 0; if (x > 1) x = 1;
                if (y < 0) y = 0; if (y > 1) y = 1;

                // Set position on cover
                image.css("backgroundPosition",
                    ((self.x = x) * 100) + "% " +
                    ((self.y = y) * 100) + "% "
                );
            },

            x: 0.5,

            y: 0.5,

            "{image} click": function(el, event) {
                if (!self.disabled) {
                    event.stopPropagation();
                }
            },

            "{image} mousedown": function(selection, event) {

                if (self.disabled || self.drawing) return;

                if (event.target === self.image()[0]) {
                    event.preventDefault();
                }

                self.drawing = true;
                base.addClass("active");

                // Initial cover position
                var image = self.image(),
                    position = self.image().css("backgroundPosition").split(" ");
                    self.x = parseInt(position[0]) / 100;
                    self.y = parseInt(position[1]) / 100;

                // Initial cursor position
                var x = event.pageX,
                    y = event.pageY;

                $(document)
                    .on("mousemove.movingCover mouseup.movingCover", function(event) {

                        if (!self.drawing) return;

                        self.moveCover(
                            (x - (x = event.pageX)) * -1,
                            (y - (y = event.pageY)) * -1,
                            image
                        );
                    })
                    .on("mouseup.movingCover", function(event) {
                        $(document).off("mousemove.movingCover mouseup.movingCover");

                        base.removeClass("active");

                        self.drawing = false;
                    });
            },

            "{image} touchstart": function(selection, event) {

                if (self.disabled || self.drawing) return;

                self.drawing = true;
                base.addClass("active");

                // Initial cover position
                var image = self.image(),
                    position = self.image().css("backgroundPosition").split(" ");
                    self.x = parseInt(position[0]) / 100;
                    self.y = parseInt(position[1]) / 100;

                // Initial touch position
                var touch = event.originalEvent.targetTouches[0],
                    x = event.pageX,
                    y = event.pageY;

                $(document)
                    .on("touchmove.movingCover", function(event) {

                        if (!self.drawing) return;

                        var touch = event.originalEvent.targetTouches[0];

                        self.moveCover(
                            (x - (x = touch.pageX)) * -1,
                            (y - (y = touch.pageY)) * -1,
                            image
                        );

                        event.preventDefault();
                    })
                    .on("touchend.movingCover", function(){

                        $(document).off("touchstart.movingCover touchend.movingCover");

                        base.removeClass("active");

                        self.drawing = false;
                    });
            },

            save: function() {

                var photoId = self.image().data("photoId");

                var task =
                    EasySocial.ajax(
                        "site/controllers/cover/create",
                        {
                            uid: self.options.uid,
                            type: self.options.type,
                            id: photoId,
                            x: self.x,
                            y: self.y,
                            reposition: self.reposition ? 1 : 0
                        }
                    )
                    .done(function(cover)
                    {
                        // Set cover
                        base
                            .attr("data-es-photo", photoId)
                            .css({
                                backgroundImage: $.cssUrl(cover.url),
                                backgroundPosition: cover.position
                            })
                            .removeClass("no-cover");

                        // Disable editing
                        self.disable();
                    });

                return task;
            },

            "{doneButton} click": function(el, event) {
                self.save();
            },

            "{menu} shown.bs.dropdown": function() {
                 self.element.addClass("show-all");
            },

            "{menu} hidden.bs.dropdown": function() {
                 self.element.removeClass("show-all");
            },

            "{selectButton} click": function() {

                base.attr('data-es-photo-disabled', 1);

                EasySocial.photos.selectPhoto(
                {
                    uid     : self.options.uid,
                    type    : self.options.type,
                    bindings:
                    {
                        "{self} photoSelected": function(el, event, photos) {

                            // Photo selection dialog returns an array,
                            // so just pick the first one.
                            var photo = photos[0];

                            // If no photo selected, stop.
                            if (!photo) return;

                            // Set it as cover to reposition
                            self.setCover(photo.id, photo.sizes.large);

                            this.parent.close();

                            base.attr('data-es-photo-disabled', 0);
                        },

                        "{cancelButton} click": function(el, event) {
                            this.parent.close();

                            base.attr('data-es-photo-disabled', 0);
                        }
                    }
                });
            },

            "{uploadButton} click": function() {
                base.attr('data-es-photo-disabled', 1);

                EasySocial.dialog({
                    content: EasySocial.ajax("site/views/cover/uploadDialog", { "uid" : self.options.uid , "type" : self.options.type }),
                    bindings: {
                        "{self} upload": function(el, event, task, filename) {

                            task.done(function(photo){
                                // Set cover
                                self.setCover(photo.id, photo.sizes.large.url);
                            });
                        },

                        "{cancelButton} click": function() {
                            this.parent.close();

                            base.attr('data-es-photo-disabled', 0);
                        }
                    }
                });
            },

            "{removeButton} click": function() {
                // We should check if there's anything to delete.

                EasySocial.ajax("site/controllers/cover/remove", { "uid" : self.options.uid , "type" : self.options.type })
                    .done(function(defaultCoverUrl)
                    {
                        base.css({
                                backgroundImage: $.cssUrl(defaultCoverUrl),
                                backgroundPosition: "50% 50%"
                            })
                            .addClass("no-cover")
                            .removeAttr("data-es-photo");

                        self.disable();
                    });
            },

            "{flyout} click": function(el, ev) {
                if (el.is($(ev.target))) {
                    ev.stopPropagation();
                }
            }
        }});

        module.resolve();

    });
});

EasySocial.require()
	.script(
		"site/likes/likes",
		"site/reports/reports",
		"site/blocks/blocks",
		"site/repost/repost",
		"site/share/share",
		"site/layout/dialog",
		"site/layout/responsive",
		"site/layout/elements",
		"site/photos/photos",
		"site/users/login",
		"site/profile/popbox",
		"site/privacy/privacy",
		"site/locations/popbox",
		"site/sidebar/sidebar",
		"site/friends/api",
		"site/popbox/popbox",
		"site/conversations/api",
		"site/groups/api",
		"site/followers/api",
		"site/stream/video",
		"oauth/facebook"
	)
	.library("history")
	.done();

EasySocial.module('site/likes/likes', function($){

	var module = this;

	$(document)
		.on("click.es.likes.action", "[data-likes-action]", function(){

			var button = $(this),
				data = {
					id   : button.data("id"),
					type : button.data("type"),
					group: button.data("group"),
					verb: button.data("verb"),
					streamid : button.data("streamid")
				},
				key = data.type + "-" + data.group + "-" + data.id;

			EasySocial.ajax("site/controllers/likes/toggle", data)
				.done(function(content, label, showOrHide, actionVerb, count) {

					// Update like label
					button.text(label);

					//streamid
					id = button.data("streamid");

					// Update like content
					$("[data-likes-" + key + "]")
						.html(content)
						.toggleClass("hide", showOrHide)
						.toggle(!showOrHide);

					// Furnish data with like count
					data.uid   = data.id; // inconsistency
					data.count = count;

					// verb = like/unlike
					button.trigger((actionVerb=="like") ? "onLiked" : "onUnliked", [data]);

					if( actionVerb == 'like' && id != "" )
					{
						//update excludeids

						ids = $('[data-streams-wrapper]').data( 'excludeids' );

						newIds = '';
						if( ids != '' && ids != undefined )
						{
							newIds = ids + ',' + id;
						}
						else
						{
							newIds = id;
						}

						$('[data-streams-wrapper]').data( 'excludeids', newIds );
					}
				})
				.fail(function(message) {

					console.log(message);
				});
		})
		.on("click.es.likes.others", "[data-likes-others]", function(){

			var button = $(this),
				content = button.parents("[data-likes-content]"),
				data = {
					uid    : content.data("id"),
					type   : content.data("type"),
					verb   : content.data('verb'),
					group  : content.data('group'),
					exclude: button.data("authors")
				};

			EasySocial.dialog({
				content: EasySocial.ajax("site/controllers/likes/showOthers", data)
			});
		});

	module.resolve();
});

EasySocial.module("site/reports/reports", function($) {

	$(document).on("click.es.reports.link", "[data-reports-link]", function(){

		var button = $(this);
		var props = "url,extension,uid,type,object,title,description".split(",");
		var data = {};

		$.each(props, function(i, prop){
			data[prop] = button.data(prop);
		});
		
		EasySocial.dialog({

			content: EasySocial.ajax("site/views/reports/confirmReport", {
					title: data.title,
					description: data.description
			}),
			selectors: {
				"{message}": "[data-reports-message]",
				"{reportButton}": "[data-report-button]",
				"{cancelButton}": "[data-cancel-button]"
			},
			bindings: {

				"{reportButton} click": function() {

					var message	= this.message().val();

					EasySocial.dialog({
						content: EasySocial.ajax("site/controllers/reports/store", {
								url      : data.url,
								extension: data.extension,
								uid      : data.uid,
								type     : data.type,
								title    : data.object,
								message  : message
							})
					});
				},

				"{cancelButton} click": function() {
					EasySocial.dialog().close();
				}		
			}	
		});
	});

	this.resolve();

});

EasySocial.module("site/blocks/blocks", function($) {

	$(document).on("click.es.blocks.link", "[data-blocks-link]", function(){

		var target = $(this).data('target');

		EasySocial.dialog({

			content: EasySocial.ajax(
				"site/views/blocks/confirmBlock",
				{
					"target": target
				}),

				selectors: {
					"{reason}": "[data-block-reason]",
					"{blockButton}": "[data-block-button]",
					"{cancelButton}": "[data-cancel-button]"
				},

				bindings: {

					"{blockButton} click": function() {

						var reason = this.reason().val();

						EasySocial.dialog({
							content: EasySocial.ajax(
								"site/controllers/blocks/store",
								{
									"target": target,
									"reason": reason
								})
							});
					},

					"{cancelButton} click": function() {
						EasySocial.dialog().close();
					}
				}
		});
	});


	$(document).on("click.es.unblock.link", "[data-unblock-link]", function(){

		var target = $(this).data('target');

		EasySocial.dialog({

			content: EasySocial.ajax(
				"site/views/blocks/confirmUnblock",
				{
					"target": target
				}),

				selectors: {
					"{unblockButton}": "[data-unblock-button]",
					"{cancelButton}": "[data-cancel-button]"
				},

				bindings: {

					"{unblockButton} click": function() {

						EasySocial.dialog({
							content: EasySocial.ajax(
								"site/controllers/blocks/unblock",
								{
									"target": target
								})
								.done(function() {

									// remove the user from the listing page.
									$('[data-blocked-user-' + target + ']').remove();

								}),

							selectors: {
								"{cancelButton}": "[data-cancel-button]"
							},

							bindings: {
								"{cancelButton} click": function() {
									EasySocial.dialog().close();
								}
							}
						});
					},

					"{cancelButton} click": function() {
						EasySocial.dialog().close();
					}
				}
		});
	});

	this.resolve();

});

EasySocial.module("site/repost/repost", function($){

	var module 	= this;

	EasySocial.require()
	.view(
		"site/friends/suggest.item",
		"site/friends/suggest.hint.search",
		"site/friends/suggest.hint.empty",
		"site/hashtags/suggest.item",
		"site/hashtags/suggest.hint.search",
		"site/hashtags/suggest.hint.empty"
	)
	.library( 'mentions' )
	.done(function()
	{
		$(document)
			.on("click.es.repost.action", "[data-repost-action]", function(){

				var button = $(this),
					data = {
						id     : button.data('id'),
						element: button.data('element'),
						group  : button.data('group'),
						clusterId  : button.data('clusterid'),
						clusterType  : button.data('clustertype'),
					},
					key = data.element + '-' + data.group + '-' + data.id;


				EasySocial.dialog(
				{
					content	: EasySocial.ajax( 'site/views/repost/form' , data ),
					bindings:
					{
						init: function()
						{
							this.setMentionsLayout();
						},
						setMentionsLayout: function()
						{
							var textbox		= this.textbox(),
								mentions	= textbox.controller("mentions");

							if (mentions)
							{
								mentions.cloneLayout();
								return;
							}

							var header = this.header();

							textbox
								.mentions({
									triggers: {
									    "@": {
											type: "entity",
											wrap: false,
											stop: "",
											allowSpace: true,
											finalize: true,
											query: {
												loadingHint: true,
												searchHint: $.View("easysocial/site/friends/suggest.hint.search"),
												emptyHint: $.View("easysocial/site/friends/suggest.hint.empty"),
												data: function(keyword) {

													var task = $.Deferred();

													EasySocial.ajax("site/controllers/friends/suggest", {search: keyword})
														.done(function(items){

															if (!$.isArray(items)) task.reject();

															var items = $.map(items, function(item){
																item.title = item.screenName;
																item.type = "user";
																item.menuHtml = $.View( 'easysocial/site/friends/suggest.item' , true, { item: item, name: "uid[]" });
																return item;
															});

															task.resolve(items);
														})
														.fail(task.reject);

													return task;
												},
												use: function(item) {
													return item.type + ":" + item.id;
												}
										    }
										},
										"#": {
										    type: "hashtag",
										    wrap: true,
										    stop: " #",
										    allowSpace: false,
											query: {
												loadingHint: true,
												searchHint: $.View("easysocial/site/hashtags/suggest.hint.search"),
												emptyHint: $.View("easysocial/site/hashtags/suggest.hint.empty"),
												data: function(keyword) {

													var task = $.Deferred();

													EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
														.done(function(items){

															if (!$.isArray(items)) task.reject();

															var items = $.map(items, function(item){
																item.title = "#" + item.title;
																item.type = "hashtag";
																item.menuHtml = $.View( 'easysocial/site/hashtags/suggest.item' , true, { item: item, name: "uid[]" });
																return item;
															});

															task.resolve(items);
														})
														.fail(task.reject);

													return task;
												}
										    }
										}
									},
									plugin: {
										autocomplete: {
											id: "fd",
											component: "es",
											modifier: "es-story-mentions-autocomplete",
											sticky: true,
											shadow: true,
											position: {
												my: 'left top',
												at: 'left bottom',
												of: header,
												collision: 'none'
											},
											size: {
												width: function() {
													return header.outerWidth(true);
												}
											}
										}
									}
								});
						},
						"{sendButton} click": function(sendButton)
						{
							var dialog = this.parent,
								content = $.trim(this.repostContent().val());

							// Add data content
							data.content = content;

							var mentions = this.textbox().mentions("controller").toArray();

							data.mentions = $.map(mentions, function(mention){
								if (mention.type==="hashtag" && $.isPlainObject(mention.value)) {
									mention.value = mention.value.title.slice(1);
								}
								return JSON.stringify(mention);
							});

							dialog.loading( true );

							EasySocial.ajax("site/controllers/repost/share", data )
								.done(function(content, isHidden, count, streamHTML)
								{
									var content = $.buildHTML(content);

									actionContent =
										$('[data-repost-' + key + ']')
											.toggleClass("hide", isHidden)
											.toggle(!isHidden);

									actionContent.find("span.repost-counter")
										.html(content);

									button.trigger("create", [streamHTML]);
								})
								.fail(function(message)
								{
									dialog.clearMessage();
									dialog.setMessage( message );
								})
								.always(function()
								{
									dialog.loading( false );
									dialog.close();
								});
						}
					}
				});
			});

		EasySocial.module("repost/authors", function(){

			this.resolve(function(popbox){

				var repost = popbox.button.parents("[data-repost-content]")
					data = {
						id     : repost.data("id"),
						element: repost.data("element")
					};

				return {
					content: EasySocial.ajax('site/controllers/repost/getSharers', data),
					id: "fd",
					component: "es",
					type: "repost",
					position: "bottom-right"
				}
			});
		});

		module.resolve();
	});
});

EasySocial.module("site/share/share", function($){

	$(document)
		.on("click.es.share.button", "[data-es-share-button]", function(){

			var button = $(this);

			EasySocial.dialog({
				title: button.text(),
				width:500,
				content:
					EasySocial.ajax(
						"site/views/sharing/shareDialog",
						{
							url: button.data("url"),
							title: button.data("title")
						})
			});
		});

	this.resolve();
});

EasySocial.module( 'site/layout/dialog' , function($){

	var module = this;

	// Dialog
	EasySocial.require()
		.library('dialog')
		.view('site/dialog/default')
		.done(function($){

			EasySocial.dialog = function(options) {

				// TODO: Isolate this from global dialog
				if (window.parentDialog) {
					return window.parentDialog.update(options);
				}

				// Normalize arguments
				if (typeof options === "string" || $.isDeferred(options)) {
					var afterShow = arguments[1];
					options = {
						content: options,
						afterShow: ($.isFunction(afterShow)) ? afterShow : $.noop
					}
				}

				var dialogElement = $('[id=fd].es-dialog.global');

				if (dialogElement.length < 1) {

					dialogElement =
						$(EasySocial.View('site/dialog/default'))
							.addClass('global')
							.appendTo('body');
				};

				var defaultOptions = {
						showOverlay: false
					},
					options = $.extend(defaultOptions, options);

				var dialogController = dialogElement.controller("Dialog");

				if (!dialogController) {
					dialogController = dialogElement.addController("Dialog", options);
				} else {
					dialogController.update(options);
				}

				return dialogController;
			}

			module.resolve();
		});
});

EasySocial.module('site/layout/responsive', function($){

    var module = this;

    $(function(){

        $.responsive(".es-responsive", [
            {at: 2500, switchTo: 'extra-wide wide'}, // http://stackideas.com/forums/profile-layout-breaks-when-resizing-back-up
            {at: 1200, switchTo: 'wide'},
            {at: 960,  switchTo: 'wide w960'},
            {at: 818,  switchTo: 'wide w960 w768'},
            {at: 600,  switchTo: 'wide w960 w768 w600'},
            {at: 560,  switchTo: 'wide w960 w768 w600 w480'},
            {at: 480,  switchTo: 'wide w960 w768 w600 w480 w320'}
        ]);

        $(document).on("responsive", $.debounce(function(){
            ESImageRefresh();
        }, 500));
    });

    module.resolve();

});

EasySocial.module('site/layout/elements', function($){

	var module = this;
	var tooltipLoaded = false;

	// Initialize yes/no buttons.
	$(document).on( 'click.button.data-bs-api', '[data-bs-toggle-value]', function() {

		var button = $(this),
			siblings = button.siblings("[data-bs-toggle-value]"),
			parent = button.parents('[data-bs-toggle="radio-buttons"]');

		if(parent.hasClass('disabled')) {
			return;
		}

		// This means that this toggle value belongs to a radio button
		if (parent.length > 0) {

			// Get the current button that's clicked.
			var value = $(this).data('bs-toggle-value');

			button.addClass("active");
			siblings.removeClass("active");

			// Set the value here.
			// Have to manually trigger the change event on the input
			parent.find('input[type=hidden]').val(value).trigger('change');
			return;
		}
	});


	function isMobile() {
	  try{ document.createEvent("TouchEvent"); return true; }
	  catch(e){ return false; }
	}

	// Tooltips
	// detect if mouse is being used or not.
	var mouseCount = 0;
	window.onmousemove = function() {

		mouseCount++;

		addTooltip();
	};

	var addTooltip = $.debounce(function(){

	    if (!tooltipLoaded && mouseCount > 10) {

			tooltipLoaded = true;
			mouseCount = 0;

			$(document).on('mouseover.tooltip.data-es-api', '[data-es-provide=tooltip]', function() {

				$(this)
					.tooltip({
						delay: {
							show: 200,
							hide: 100
						},
						animation: false,
						template: '<div id="fd" class="es tooltip tooltip-es"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
						container: 'body'
					})
					.tooltip("show");
			});
	    } else {
	    	mouseCount = 0;
	    }
	}, 500);

	// TODO: Update to [data-es-provide=tooltip]
	if (! isMobile()) {
		$(document).on('mouseover.tooltip.data-es-api', '[data-es-provide=tooltip]', function() {

			$(this)
				.tooltip({
					delay: {
						show: 200,
						hide: 100
					},
					animation: false,
					template: '<div id="fd" class="es tooltip tooltip-es"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
					container: 'body'
				})
				.tooltip("show");
		});
	}

	// Popovers
	// TODO: Update to [data-es-provide=popover]
	$(document).on('mouseover.popover.data-es-api', '[data-es-provide=popover]', function() {
		$(this)
			.popover({
				delay: {
					show: 200,
					hide: 100
				},
				animation: false,
				trigger: 'hover',
				container: 'body'
			})
			.popover("show");
	});


	var ly = function(yr) { return (yr%400)?((yr%100)?((yr%4)?false:true):false):true; };

	$(document).on("keyup", "[data-date-form] [data-date-day]", function(){

		if (!$.trim($(this).val())) return;

		var year   = parseInt($(this).siblings("[data-date-year]").val()  || $(this).siblings("[data-date-year]").data("dateDefault")),

		    month  = parseInt($(this).siblings("[data-date-month]").val() || $(this).siblings("[data-date-month]").data("dateDefault")),

		    day    = parseInt($(this).val() || $(this).data("dateDefault")),

			maxDay = /1|3|5|7|8|10|12/.test(month) ? 31 : 30;

			if (month==2) maxDay = ly(year) ? 29 : 28;

			if (day < 1) day = 1;

			if (day > maxDay) day = maxDay;

			if ($.isNumeric(day)) {
				$(this).val(day);
			} else {
				$(this).val("");
			}
	});

	$(document).on("keyup", "[data-date-form] [data-date-year]", function(){

		if (!$.trim($(this).val())) return;

		var year = parseInt($(this).val());
		if (year < 1) year = 1;

		if ($.isNumeric(year)) {
			$(this).val(year);
		} else {
			$(this).val("");
		}
	});

	module.resolve();

});

EasySocial.module("site/photos/photos", function($){

var module = this;

// Non-essential dependencies
EasySocial.require()
	.script(
		"site/photos/popup",
		"site/photos/dialog",
		"site/photos/avatar"
	)
	.done();

EasySocial.Controller("Photos",
{
	defaultOptions: {
	}
},
function(self) { return {

	init: function() {

		// Extend EasySocial object
		EasySocial.photos = self;

		// Popup plugin
		EasySocial.module("site/photos/popup")
			.done(function(PopupController){
				self.popup = self.addPlugin("popup", PopupController);
			});

		// Dialog plugin
		EasySocial.module("site/photos/dialog")
			.done(function(DialogController){
				self.dialog = self.addPlugin("dialog", DialogController);
			});

		// Avatar plugin
		EasySocial.module("site/photos/avatar")
			.done(function(AvatarController){
				self.avatar = self.addPlugin("avatar", AvatarController);
			});
	}

}});

// Add this controller to the html body;
$(function(){
	$("body").addController("EasySocial.Controller.Photos");
});

module.resolve();

});
EasySocial.module("site/photos/popup", function($){

var module = this;

// Album playlist
//
// <div data-es-photo-group="album:4">
//     <a data-es-photo="499">
// </div>

// Element-based playlist
//
// <div data-es-photo-group>
//     <a data-es-photo="1">
//     <a data-es-photo="2">
//     <a data-es-photo="3">
// </div>

// Custom playlist
// Ideal for large playlist where not all items are shown.
//
// <div data-es-photo-group="photos:400,401,402,403,405,406,407,408">
//     <a data-es-photo="400">
//     <a data-es-photo="401">
//     <a data-es-photo="402">
//     <a data-es-photo="403">
//     <a data-es-photo="404">
//     <!-- The rest of the thumbnails not shown, but the popup will have it. -->
// </div>

// TODO: Move this away
$.fn.at = function(key) {
	return this.find("[data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + "]");
}


EasySocial.require()
.view("site/photos/popup")
.done(function(){

	var controller =
	EasySocial.Controller("Photos.Popup",
	{
		defaultOptions: {

			view: {
				popup:  "site/photos/popup"
			},

			"{popup}"   : "[data-photo-popup]",
			"{viewport}": "[data-popup-viewport]",
			"{handle}"  : "[data-popup-handle]",

			"{photoGroup}": "[data-es-photo-group]",
			"{photo}"     : "[data-es-photo]",

			"{photoHeader}": "[data-photo-popup] [data-photo-header]",
			"{photoContent}": "[data-photo-popup] [data-photo-content]",

			"{navButton}" : ".es-photo-nav-button",
			"{closeButton}": "[data-popup-close-button]",

			"{photoItem}": "[data-photo-popup] [data-photo-item]",

			'{desTagItem}': '[data-photo-des-tag-item]'
		}
	},
	function(self, opts, base, body) { return {

		init: function() {

			body = $("body");

			self.bodyOverflow = {
				overflow: body.css("overflow"),
				overflowX: body.css("overflowX"),
				overflowY: body.css("overflowY")
			};
		},

		setLayout: function() {

			// Disable body scrollbar on narrow layout
			var popup = self.popup();

			if (popup.is(":visible")) {

				// Set image size again
				var image = self.viewport().find("img[data-photo-image]")[0];
				if (image) ESImage(image);

				body.css({
					overflow: "hidden",
					overflowX: "hidden",
					overflowY: "hidden"
				});

				var photoItem = self.photoItem();

				// Update tag position
				var tags = photoItem.controller("EasySocial.Controller.Photos.Tags");
				tags && tags.setLayout();

				// Disable navigation controller if there's only one photo or tagging is active
				var navigation = photoItem.controller("EasySocial.Controller.Photos.Navigation"),
					tagger = photoItem.controller("EasySocial.Controller.Photos.Tagger");

				navigation && navigation[
					(tagger && !tagger.disabled) || (self.playlist.length < 2) ? "disable" : "enable"]();

			} else {

				body.css(self.bodyOverflow);
			}
		},

		'{desTagItem} mouseover': function(el, ev) {
			var tags = self.photoItem().controller("EasySocial.Controller.Photos.Tags");

			tags && tags.getTagItem(el.data('photoDesTagId'))
				.addClass('focus');
		},

		'{desTagItem} mouseout': function(el, ev) {
			var tags = self.photoItem().controller("EasySocial.Controller.Photos.Tags");

			tags && tags.getTagItem(el.data('photoDesTagId'))
				.removeClass('focus');
		},

		"{window} resize": $.debounce(function() {

			self.setLayout();

		}, 250),

		"{self} responsive": function() {

			self.setLayout();
		},

		playlist: [],

		show: function() {

			var popup,
				node = self.popup.node;

			// Create node if not exists
			if (!node) {
				popup = self.view.popup();
				node  = self.popup.node = popup[0];
			}

			// Append node if detached
			if (!$.contains(base, node)) {
				popup = $(node).addClass("is-loading").appendTo(base);
			}

			if (!popup.is(":visible")) {

				// Show popup
				popup.show();

				// Trigger responsive event
				$(window).trigger("resize.responsive");

				// Trigger show event
				popup.trigger("show");
			}
		},

		hide: function() {

			self.popup()
				.hide()
				.trigger("hide")
				.detach();

			// Restore body layout
			body.css(self.bodyOverflow);
		},

		// open(photoId)
		// open(albumId, photoId)
		// open(type, id)
		// open([photoId, photoId, photoId], photoId)
		open: function() {

			// Normalize arguments
			var args = arguments, albumId, photoId, playlist = [];

			// open(photoId)
			if (args.length===1) {
				photoId = args[0];
				playlist = [photoId];
			}

			// open([photoId, photoId, photoId], photoId)
			// open([photoId, photoId, photoId])
			if ($.isArray(args[0])) {
				playlist = args[0];
				photoId = args[1] || playlist[0];

			// open(albumId, photoId)
			// open(type, id)
			} else if (args.length===2) {

				var type = args[0],
					autoplay = true,
					albumId;

				// open(albumId, photoId)
				if ($.isNumeric(type)) {
					type = "album";
					autoplay = false;
					albumId = args[0];
					photoId = args[1];
					playlist = [photoId];
				}

				// open("photo", 32)
				if (type=="photo") {
					photoId = args[1];
					playlist = [photoId];
				}

				// open("album", 64)
				if (type=="album") {

					// Get the playlist
					EasySocial.ajax("site/controllers/albums/playlist", {albumId: albumId || args[1]})
						.done(function(photos){

							// Update the playlist afterwards
							self.playlist = $.map(photos, function(photo){
								return photo.id;
							});

							// Play the first playlist
							if (autoplay) {
								self.display(playlist[0]);
							}

							// This ensure navigation is reenabled
							self.setLayout();
						})
						.fail(function(){
							// TODO: Make this nicer.
							alert("Error. Could not get album playlist.");
							self.hide();
						});
				}
			}

			self.playlist = playlist;

			// Show popup if hidden
			self.show();

			self.display(photoId);
		},

		handles: {},

		display: function(photoId) {

			if (!photoId) return;

			var previousId = self.currentPhotoId;

			self.currentPhotoId = photoId;

			var handle = self.handles[photoId];

			// Detach any existing views
			self.handle().detach();

			if (!handle) {

				var popup = self.popup();

				popup.addClass("is-loading");

				EasySocial.ajax(
					"site/views/photos/item",
					{
						id: photoId,
						browser: 0,
						popup: 1,
					})
					.done(function(html){

						var handle = $.buildHTML('<div class="es-popup-handle" data-popup-handle>' + html + "</div>");

						self.handles[photoId] = handle;

						self.display(photoId);
					})
					.fail(function(){
						alert("There was a problem loading this photo.");
						self.display(previousId);
					})
					.always(function(){
						popup.removeClass("is-loading");
					});

				return;
			} else {
				self.popup().removeClass("is-loading");
			}

			// Show current handle
			self.viewport().empty().append(handle);

			// Only store the node of the photo handle, discarding scripts.
			if (handle instanceof $) {
				self.handles[photoId] = handle.filter("[data-popup-handle]")[0];
			}

			// Set layout
			self.setLayout();
		},

		current: function() {

			var id = self.currentPhotoId,
				playlist = self.playlist,
				i = $.indexOf(playlist, id);

			// No matching item, revert to 0.
			if (i < 0) i = 0;

			return i;
		},

		next: function() {

			var playlist = self.playlist;

			if (playlist.length < 2) return;

			var i = self.current() + 1;

			// Cycle to the beginning
			if (i > playlist.length - 1) i = 0;

			self.display(playlist[i]);
		},

		prev: function() {

			var playlist = self.playlist;

			if (playlist.length < 2) return;

			var i = self.current() - 1;

			// Cycle to the end
			if (i < 0) i = playlist.length - 1;

			self.display(playlist[i]);
		},

		"{self} click": function(el, event) {

			if (event.target===self.popup()[0]) {
				self.hide();
			}
		},

		"{photo} click": function(photo, event) {
			// If this photo is disabled, stop.
			if (photo.attr("data-es-photo-disabled")=="1") return;

			var target = $(event.target),
				targetTree = target.parents().andSelf();

			// Quick fix
			if (target.filter("[data-es-photo]").length < 1 &&
				targetTree.filter("[data-photo-menu], [data-cover-menu]").length > 0) return;

			// Retrieve photo id and photo group
			var photoId = photo.attr("data-es-photo"),
				photoGroup = self.photoGroup.of(photo);

			// If this is not part of any photo group, don't show popup.
			if (photoGroup.length < 0) return;

			// Stop browser from loading full page photo
			event.preventDefault();

			// Retrieve playlist from photo group
			var data = (photoGroup.attr("data-es-photo-group") || "element").split(":"),
				type = data[0];

			switch (type) {

				// Album playlist
				case "album":
					var albumId = data[1];
					self.open(albumId, photoId);
					break;

				// Custom playlist
				case "photos":
					var list = data[1].split(",");
					self.open(list, photoId);
					break;

				// Element-based playlist
				case "element":
					var list = [];

					photoGroup.at("esPhoto").each(function(){
						list.push($(this).attr("data-es-photo"));
					});

					self.open(list, photoId);
					break;
			}
		},


		"{photoItem} directionmove": function(photoItem, event, offset, direction) {

			// Don't show navigation buttons when playlist still loading,
			// or when there's only a single photo in this playlist.
			if (self.playlist.length < 2) {
				self.navButton().removeClass("active");
			}
		},

		"{photoItem} directionstop": function() {

			// self.photoHeader().removeClass("active");
		},

		"{photoItem} photoNext": function() {

			self.next();
		},

		"{photoItem} photoPrev": function() {

			self.prev();
		},

		"{photoItem} photoDelete": function(el, event, photoItem) {

			if (self.playlist.length < 2) {
				self.hide();
			} else {
				self.next();

			}

			self.playlist = $.without(self.playlist, photoItem.id);
		},

		"{closeButton} click": function() {

			self.hide();
		}

	}});

	module.resolve(controller);
});

});

EasySocial.module("site/photos/dialog", function($){

var module = this;

var controller =
EasySocial.Controller("Photos.Dialog",
{
	defaultOptions: {
	}
},
function(self) { return {

	init: function() {

		// Legacy compatiblity
		// Old: EasySocial.photos.selectPhoto()
		// New: EasySocial.photos.dialog.show();
		EasySocial.photos.selectPhoto = self.show;
	},

	show: function(options) {

		var task	= $.Deferred(),
			dialog	= EasySocial.ajax( "site/views/albums/dialog" , { "uid" : options.uid , "type" : options.type }),
			browser = EasySocial.require().script( "albums/browser" ).done();

		// Show a loading indicator first
		EasySocial.dialog(
			$.extend({
			    content: task
			}, options)
		);

		$.when(browser, dialog)
			.done(function(){
				dialog.done(function(html){
					task.resolve(html);
				});
			});
	}

}});

module.resolve(controller);

});

EasySocial.module("site/photos/avatar", function($){

var module = this;

var controller =
EasySocial.Controller("Photos.Avatar",
{
	defaultOptions: {
	}
},
function(self) { return {

	init: function() {

		// Legacy compatiblity
		// Old: EasySocial.photos.createAvatar();
		// New: EasySocial.photos.avatar.crop();
		EasySocial.photos.createAvatar = self.crop;
	},

	crop: function(id, options) {

		if( id == undefined )
		{
			return;
		}

		if( !options )
		{
			options 	= {};
		}

		var avatarOptions = { "id" : id };

		if( options.uid )
		{
			avatarOptions.uid 	= options.uid;
			delete options.uid;
		}

		if( options.type )
		{
			avatarOptions.type 	= options.type;
			delete options.type;
		}

		if( options.redirect )
		{
			avatarOptions.redirect = options.redirect;
			delete options.redirect;
		}

		EasySocial.dialog(
			$.extend(
				{
					content: EasySocial.ajax( 'site/views/avatar/crop' , avatarOptions )
				},
				options
			)
		);
	}

}});

module.resolve(controller);

});

EasySocial.module('site/users/login', function($){

	var module = this;

	EasySocial.require()
		.library('dialog')
		.script('site/dashboard/dashboard.guest.login')
		.view('site/loading/small')
		.done(function(){

			EasySocial.login = function() {
				EasySocial.ajax('site/views/login/form')
					.done(function(content) {
						var dialog = EasySocial.dialog({
							content: content,
							afterShow: function() {
								this.element.find('[data-guest-login]').addController('EasySocial.Controller.Dashboard.Guest.Login');
							}
						});
					});
			}

			module.resolve();
		});
});

EasySocial.module('site/dashboard/dashboard.guest.login', function($) {
	var module = this;

	EasySocial.require().script('field', 'validate').done(function() {

		EasySocial.Controller('Dashboard.Guest.Login', {
			defaultOptions: {
				'{fieldItem}': '[data-registermini-fields-item]',

				'{submit}': '[data-registermini-submit]',

				'{form}': '[data-registermini-form]'
			}
		}, function(self) {
			return {
				init: function() {
					self.fieldItem().addController('EasySocial.Controller.Field.Base', {
						userid: 0,
						mode: 'registermini'
					});
				},

				'{submit} click': function(el) {

					if(el.enabled()) {
						el.disabled(true);

						self.form()
							.validate({mode: 'onRegisterMini'})
							.done(function() {
								el.enabled(true);
								self.form().submit();
							})
							.fail(function() {
								el.enabled(true);
							});
					}

				}
			}
		});

		module.resolve();
	});
});

EasySocial.module('validate', function ($) {
/*
<div data-check>
	<div>
		<label>Text</label>
		<input data-check-type="text" data-check-field />
	</div>
	<div data-check-notice></div>
</div>
<div data-check>
	<div>
		<label>Checkboxes</label>
		<div data-check-type="checkbox" data-check-field data-check-required>
			<input type="checkbox" name="group[]" value="1" />
			<input type="checkbox" name="group[]" value="1" />
		</div>
	</div>
</div>
<div data-check>
	<div>
		<label>Validate format</label>
		<input data-check-field data-check-validate="regex" />
	</div>
	<div data-check-notice></div>
</div>
*/

	var module = this;

	if(!$.isController('EasySocial.Controller.Validator')) {
		EasySocial.Controller('Validator', {
			defaultOptions: {
				mode			: null,

				checks			: ['required', 'validate'],

				typeAttr		: 'data-check-type',
				formatAttr		: 'data-check-format',
				modifierAttr	: 'data-check-modifier',

				errorTrigger	: 'onError',
				submitTrigger	: 'onSubmit',

				'{container}'	: '[data-check]',
				'{notice}'		: '[data-check-notice]',

				'{required}'	: '[data-check-required]',
				'{validate}'	: '[data-check-validate]',
			}
		}, function(self) {
			return {
				// temporary variables
				vars		: {},

				// register of elements returned by fields
				register	: [],

				// deferreds return by elements
				deferreds	: [],

				// errors return by elements
				errors		: [],

				// state of validator
				state		: $.Deferred(),

				init: function () {

				},

				reset: function() {
					self.vars		= {};

					self.register	= [];
					self.deferreds	= [];
					self.errors		= [];

					self.state		= $.Deferred();

					self.container().removeClass('error');
				},

				start: function() {
					self.reset();

					$.each(self.container(), function(i, container) {
						self.vars.container = container = $(container);

						container.trigger(self.options.submitTrigger, [self.register, self.options.mode]);

						$.each(self.getFields(), function(j, field) {
							self.vars.field = field = $(field);

							$.each(self.options.checks, function(i, check) {
								self.vars.check = check;

								self[check + 'Check']();
							});
						});
					});

					$.each(self.register, function(i, result) {
						if($.isDeferred(result)) {
							self.deferreds.push(result);
						} else if($.isPlainObject(result)) {
							$.each(result, function(key, value) {
								if(value === false) {
									self.errors.push(i);
									return true;
								}
							})
						} else {
							if(result === false) {
								self.errors.push(i);
								return true;
							}
						}
					});

					// If have static errors, then reject state
					if(self.errors.length > 0) {
						self.state.reject();
					} else {
						// If no static errors, then check if have deferreds
						if(self.deferreds.length > 0) {
							// This is because $.when accepts n amount of parameters instead of array, so we use .apply to pass in the array
							$.when.apply(null, self.deferreds)
								.done(function() {
									self.state.resolve();
								})
								.fail(function() {
									self.state.reject();
								});
						} else {
							// If no deferreds, then just resolve
							self.state.resolve();
						}
					}

					return self.state;
				},

				getFields: function() {
					return $.merge(self.vars.container.find(self.required.selector), self.vars.container.find(self.validate.selector));
				},

				requiredCheck: function() {
					if(self.vars.field.is(self.required.selector)) {
						var fieldType = self.vars.field.attr(self.options.typeAttr) || self.vars.field.attr('type') || 'text';

						if(fieldType === 'text' && $.trim(self.vars.field.val()) == '' ) {
							self.raiseError();
						}

						if(fieldType === 'checkbox' && self.vars.field.find('input[type="checkbox"]').filter(':checked').length < 1) {
							self.raiseError();
						}
					}
				},

				validateCheck: function() {
					if(self.vars.field.attr(self.options.formatAttr) !== undefined) {

						var value = self.vars.field.val();

						if($.isEmpty(value)) {
							return;
						}

						var format = self.vars.field.attr(self.options.formatAttr) || '';

						var modifier = self.vars.field.attr(self.options.modifierAttr) || '';

						var regex = new RegExp(format, modifier);

						if(!regex.test(value)) {
							self.raiseError();
						}
					}
				},

				raiseError: function () {
					self.vars.container.addClass('has-error');

					self.vars.container.trigger(self.options.errorTrigger, [self.vars.check, self.vars.field]);

					self.register.push(false);
				}
			};
		});
	}

	$.fn.validate = function(options){
		var element = this;

		if(element.length > 0) {
			var controller = this.addController("EasySocial.Controller.Validator", options);
			return controller.start();
		}

		return false;
	};

	module.resolve();
});

EasySocial.module("site/profile/popbox", function($) {

	var module = this;

	EasySocial.require()
		.library("popbox")
		.done(function(){

			// We should check if popbox should be initialized or not.
			var initPopbox = (EasySocial.options.lockdown && !EasySocial.options.guest) || !EasySocial.options.lockdown

			if (initPopbox) {
				EasySocial.module("profile/popbox", function($) {

					this.resolve(function(popbox){

						var id = popbox.button.data("userId");
						var position = popbox.button.attr('data-popbox-position') || 'top-left';

						return {
							content: EasySocial.ajax("site/views/profile/popbox", {id: id}),
							id: "fd",
							component: "es",
							type: "profile",
							position: position
						}
					})
				});
			}

		});

	// Non-essential dependency
	EasySocial.require()
		.script("site/conversations/composer")
		.done();

	EasySocial.Controller("Profile.Popbox", {
		defaultOptions: {
			// The current user being viewed
			id: null,

			"{addButton}"	    : "[data-popbox-friends-add]",
			"{friendsButton}"	: "[data-popbox-friends-friends]",
			"{respondButton}"	: "[data-popbox-friends-respond]",
			"{requestedButton}"	: "[data-popbox-friends-requested]",
			"{messageButton}"	: "[data-popbox-message]",
			"{friendsSubmenu}"	: "[data-friends-submenu]",

			"{cancelFriend}"	: "[data-popbox-friends-friends-cancel]",
			"{cancelFriendRequest}" : "[data-popbox-friends-requested-cancel]",
			"{approveFriend}"	: "[data-popbox-friends-respond-approve]",
			"{rejectFriend}"	: "[data-popbox-friends-respond-reject]"
		}
	},
	function(self) { return {

		init: function() {

			self.options.id = self.element.find("[data-user-id]").data("userId");

			EasySocial.module("site/conversations/composer")
				.done(function(){
					self.messageButton()
						.implement( EasySocial.Controller.Conversations.Composer.Dialog, { "recipient" : { "id" : self.options.id } } );
				});
		},

		"{self} popboxActivate": function() {

			self.friendsSubmenu().parent().removeClass("open");
		},

		"{addButton} click": function() {

			EasySocial.ajax("site/controllers/friends/request",
			{
				"id"	: self.options.id
			})
			.done(function()
			{
				// Add a loader
				// self.addButton().html( self.view.loader() );

				// Replace the button
				EasySocial.ajax( 'site/views/profile/getButton' , { "button" : "button.requested" , "id" : self.options.id } )
				.done(function( button )
				{
					// We know that the existing button is a request button
					self.addButton().replaceWith( button );
				});
				
			}).fail(function()
			{
				EasySocial.dialog(
				{
					content 	: EasySocial.ajax( 'site/views/friends/exceeded' )
				});
			});
		},

		"{cancelFriend} click": function(el, event) {

			var friendId = $( el ).data( 'friendid' );

			EasySocial.dialog(
			{
				content		: EasySocial.ajax( 'site/views/profile/confirmRemoveFriend' , { "id" : self.options.id } ),
				bindings	:
				{
					"{confirmButton} click" : function()
					{
						EasySocial.ajax( 'site/controllers/friends/unfriend' , { "id" : friendId } )
						.done(function()
						{
							// Display tot he user that they are no longer friends now.
							EasySocial.dialog(
							{
								content 	: EasySocial.ajax( 'site/views/profile/friendRemoved' , { "id" : self.options.id } )
							});

							// Replace the button
							EasySocial.ajax( 'site/views/profile/getButton' , { "button" : "button.add" } )
							.done(function( button )
							{
								self.friendsSubmenu().remove();

								self.friendsButton().replaceWith( button );
							});
						});
					}
				}
			});

		},

		"{cancelFriendRequest} click": function(el, event) {

			var friendId = $( el ).data( 'friendid' );

			EasySocial.dialog(
			{
				content: EasySocial.ajax( 'site/views/profile/confirmCancelRequest' ,
							{
								"id"	: friendId
							}),
				bindings:
				{
					"{confirmButton} click" : function()
					{
						// Close the dialog
						EasySocial.dialog().close();

						EasySocial.ajax( 'site/controllers/friends/cancelRequest' , { "id" : friendId } )
						.done(function()
						{
							// Replace the button
							EasySocial.ajax( 'site/views/profile/getButton' , { "button" : "button.add" } )
							.done(function( button )
							{
								// Hide the submenu
								self.friendsSubmenu().remove();

								// We know that the existing button is a request button
								self.requestedButton().replaceWith( button );
							});
						});
					}
				}
			});

		},

		"{approveFriend} click": function( el , event ) {

			var friendId = $( el ).data( 'friendid' );

			EasySocial.ajax( 'site/controllers/friends/approve' , { "id" : friendId } )
			.done(function()
			{
				EasySocial.dialog(
				{
					content: EasySocial.ajax( 'site/views/profile/confirmFriends' , { "id" : self.options.id } )
				});

				// Replace the button
				EasySocial.ajax( 'site/views/profile/getButton' , { "button" : "button.friends" } )
				.done(function( button )
				{
					// Hide the submenu
					self.friendsSubmenu().remove();

					// We know that the existing button is a request button
					self.respondButton().replaceWith( button );
				});
			});
		},

		"{rejectFriend} click" : function(el, event) {

			var friendId = $( el ).data( 'friendid' );

			EasySocial.ajax("site/controllers/friends/reject",
			{
				id: friendId
			})
			.done(function(){

				EasySocial.dialog({
					content: EasySocial.ajax("site/views/profile/rejected", { "id" : self.options.id } )
				});

				// Replace the button
				EasySocial.ajax("site/views/profile/getButton",
				{
					"button" : "button.add"
				})
				.done(function(button){

					// Hide the submenu
					self.friendsSubmenu().remove();

					// We know that the existing button is a request button
					self.respondButton().replaceWith( button );
				});
			});
		}

	}});

	// Popovers can implement themselves
	$(document).on("mouseover.es.profile.popbox", "[data-popbox-tooltip=profile]", function(){
		$(this).addController("EasySocial.Controller.Profile.Popbox");
	});

	module.resolve();

});

EasySocial.module( 'site/conversations/composer' , function($){

	var module 	= this;

	EasySocial.require()
	.library('mentions')
	.script('site/friends/suggest', 'uploader/uploader')
	.view(
		"site/friends/suggest.item",
		"site/friends/suggest.hint.search",
		"site/friends/suggest.hint.empty",
		"site/hashtags/suggest.item",
		"site/hashtags/suggest.hint.search",
		"site/hashtags/suggest.hint.empty"
	)
	.language(
		'COM_EASYSOCIAL_CONVERSATIONS_ERROR_EMPTY_RECIPIENTS',
		'COM_EASYSOCIAL_CONVERSATIONS_ERROR_EMPTY_MESSAGE'
	)
	.done(function($){

		EasySocial.Controller('Conversations.Composer', {
				defaultOptions: {

					// Determines if these features should be enabled.
					attachments 		: true,
					location 			: true,
					showNonFriend		: false,

					// Uploader properties.
					extensionsAllowed	: "",

					// File uploads
					"{uploader}"		: "[data-composer-attachment]",

					// Location service.
					"{location}"		: "[data-composer-location]",

					// The text editor.
					"{editorHeader}"	: "[data-composer-editor-header]",
					"{editorArea}"		: "[data-composer-editor-area]",
					"{editor}"			: "[data-composer-editor]",

					// Wrapper for suggest to work.
					"{friendSuggest}"		: "[data-friends-suggest]",

					"{recipients}"		: "input[name=uid\\[\\]],input[name=list_id\\[\\]]",

					"{recipientRow}"	: "[data-composer-recipients]",
					"{messageRow}"		: "[data-composer-message]",

					// Submit button
					"{submit}"			: "[data-composer-submit]",

					view:
					{
						suggestItem: "site/friends/suggest.item",
						tagSuggestItem: "site/hashtags/suggest.item"
					}
				}
			}, function(self) { return {

					init: function() {

						// Initialize the participants textbox.
						self.initSuggest();

						// Initialize uploader
						if (self.options.attachments) {
							self.initUploader();
						}

						self.setMentionsLayout();
					},

					resetForm: function() {
						self.editor().val('');
					},

					setMentionsLayout: function() {

						var editor = self.editorArea();
						var mentions = editor.controller("mentions");

						if (mentions) {
							mentions.cloneLayout();
							return;
						}

						var header = self.editorHeader();

						editor
							.mentions({
								
								triggers: {
								    
								    "@": {
										type			: "entity",
										wrap			: false,
										stop			: "",
										allowSpace		: true,
										finalize		: true,
										query:
										{
											loadingHint	: true,
											searchHint	: $.View("easysocial/site/friends/suggest.hint.search"),
											emptyHint	: $.View("easysocial/site/friends/suggest.hint.empty"),

											data: function( keyword )
											{

												var task = $.Deferred();

												EasySocial.ajax( "site/controllers/friends/suggest" , { search: keyword })
												.done(function(items)
												{
													if (!$.isArray(items)) task.reject();

													var items = $.map(items, function(item)
													{
														item.title	= item.screenName;
														item.type	= "user";

														item.menuHtml = self.view.suggestItem(true, {
															item: item,
															name: "uid[]"
														});

														return item;
													});

													task.resolve(items);
												})
												.fail(task.reject);

												return task;
											},
											use: function(item) {
												return item.type + ":" + item.id;
											}
									    }
									},
									"#":
									{
									    type		: "hashtag",
									    wrap		: true,
									    stop		: " #",
									    allowSpace	: false,
										query:
										{
											loadingHint	: false,
											searchHint	: $.View("easysocial/site/hashtags/suggest.hint.search"),
											emptyHint	: $.View("easysocial/site/hashtags/suggest.hint.empty"),
											data: function(keyword)
											{

												var task = $.Deferred();

												EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
													.done(function(items)
													{
														if (!$.isArray(items)) task.reject();

														var items = $.map(items, function(item){
															item.title = "#" + item.title;
															item.type = "hashtag";
															item.menuHtml = self.view.tagSuggestItem(true, {
																item: item,
																name: "uid[]"
															});
															return item;
														});

														task.resolve(items);
													})
													.fail(task.reject);

												return task;
											}
									    }
									}
								},
								plugin:
								{
									autocomplete:
									{
										id			: "fd",
										component	: "es",
										position	:
										{
											my: 'left top',
											at: 'left bottom',
											of: header,
											collision: 'none'
										},
										size:
										{
											width: function()
											{
												return header.width();
											}
										}
									}
								}
							});
					},

					initUploader: function() {
						// Implement uploader controller.
						self.uploader().implement( EasySocial.Controller.Uploader , {
							// We want the uploader to upload automatically.
							temporaryUpload	: true,
							query 			: "type=conversations",
							type 				: 'conversations',
							extensionsAllowed : self.options.extensionsAllowed
						});
					},

					initSuggest: function() {
						self.friendSuggest()
							.addController(EasySocial.Controller.Friends.Suggest,
								{
									friendList		: true,
									friendListName	: "list_id[]",
									showNonFriend : self.options.showNonFriend
								});
					},

					initEditor : function() {
						self.editor().expandingTextarea();
					},

					/**
					 * Check for errors on the conversation form.
					 */
					checkErrors: function()
					{
						if( self.recipients().length <= 0 )
						{
							self.recipientRow().addClass( 'error' );
							self.clearMessage();
							self.setMessage( $.language( 'COM_EASYSOCIAL_CONVERSATIONS_ERROR_EMPTY_RECIPIENTS' ) , 'error' );

							return true;
						}
						else
						{
							self.recipientRow().removeClass( 'error' );
						}

						if( self.editor().val() == '' )
						{
							self.messageRow().addClass( 'error' );
							self.clearMessage();
							self.setMessage( $.language( 'COM_EASYSOCIAL_CONVERSATIONS_ERROR_EMPTY_MESSAGE' ) , 'error' );

							return true;
						}
						else
						{
							self.messageRow().removeClass( 'error' );
						}

						return false;
					},

					/**
					 * Submit button.
					 */
					"{submit} click" : function( el , event )
					{
						// Prevent form submission since this is a submit button.
						event.preventDefault();

						// Check for errors on this page.
						if( self.checkErrors() )
						{
							return false;
						}

						if( self.options.attachments )
						{
							var uploaderController 	= self.uploader().controller();

							// Do not allow user to submit this when the items are still being uploaded.
							if( uploaderController.options.uploading && uploaderController.hasFiles() )
							{
								return false;
							}
						}

						var mentions = self.editorArea().mentions("controller").toArray();

						// Reconstruct the inputs
						$( mentions ).each(function( i , item )
						{
							$( '<input>' )
								.attr( 'type' , 'hidden')
								.attr( 'name' , 'tags[]' )
								.attr( 'value' , JSON.stringify( item ) )
								.appendTo( self.element );
						});

						// Submit the form when we're ready.
						self.element.submit();
					}
				}
			}
		);

		EasySocial.Controller('Conversations.Composer.Dialog', {
			defaultOptions: {
				recipient: {},
			}
		}, function(self) { return {

			"{self} click" : function() {
				EasySocial.dialog({
					"content"	: EasySocial.ajax( 'site/views/conversations/composer' , { "id" : self.options.recipient.id } ),
					"bindings"	: {
						"{sendButton} click" : function(el) {

							var dialog = this.parent;
							var recipient = $('[data-composer-recipient]').val();
							var message = $('[data-composer-message]').val();

							// disable the send button so that user cannot click again.
							el.disabled(true);

							EasySocial.ajax( 'site/controllers/conversations/store', {
								"uid"		: recipient,
								"message"	: message
							}).done(function(link) {

								EasySocial.dialog({
									"content": EasySocial.ajax( 'site/views/conversations/sent' , { "id" : self.options.recipient.id }),
									"bindings": {
										"{viewButton} click" : function() {
											document.location 	= link;
										}
									}
								});
							}).fail(function(message) {
								dialog.setMessage(message);
								el.disabled(false);
							});
						}
					}
				});
			}
		}});

		module.resolve();
	});

});


EasySocial.module("site/privacy/privacy", function($){

	var module	= this;

	EasySocial.require()
	.library("textboxlist")
	.language(
		'COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_PUBLIC',
		'COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_MEMBER',
		'COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_FRIENDS_OF_FRIEND',
		'COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_FRIEND',
		'COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_ONLY_ME',
		'COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_CUSTOM'
	)
	.done(function($){

		EasySocial.Controller("Privacy", {
			defaultOptions: {
				"{menu}": "[data-privacy-menu]",
				"{privacyItem}": "[data-privacy-item]",
				"{icon}": "[data-privacy-icon]",
				"{button}": "[data-privacy-toggle]",
				"{tooltip}": "[data-original-title]",
				"{key}": "[data-privacy-hidden]"
			}
		}, function(self) { return {

			init: function() {
				self.instanceId = $.uid();

				self.addPlugin("custom");
			},

			getData: function(item) {
				return $._.pick(item.data(), "uid", "utype", "value", "pid", "privacyicon", "streamid", "pitemid", "userid");
			},

			"{self} click" : function(el, event) {

				var target = $(event.target);
				var button = self.button();

				// If the area being clicked is the toggle button,
				if (target.parents().andSelf().filter(button).length > 0) {

					// then we toggle privacy menu.
					self.toggle();
				}
			},

			"{privacyItem} click" : function(item) {

				// Retrieve data from this privacy item
				var data = self.getData(item);

				// Trigger privacy changed event
				self.trigger("privacyChange", [data]);

				if (!data.preventSave) {

					// Save new privacy settings
					self.save(data);

					// Deactivate menu
					self.deactivate();
				}
			},

			"{self} privacyChange": function(el, event, data) {

				// Deactivate other privacy item
				self.privacyItem()
					.removeClass("active")

					// and activate current privacy item.
					.filter("[data-value=" + data.value + "]")
					.addClass("active");
			},

			toggle: function() {

				var isActive = self.element.hasClass("active");
				self[(isActive) ? "deactivate" : "activate"]();
			},

			activate: function() {

				self.element.addClass("active");

				self.trigger("activate", [self]);
				$(window).trigger("activatePrivacy", [self]);

				var windowClick = "click.privacy." + self.instanceId;

				$(document).on(windowClick, function(event){

					var clickedTarget = $(event.target);

					// Don't do anything if we're clicking ourself
					if (clickedTarget.parents().andSelf().filter(self.element).length > 0
						|| clickedTarget.parents('[data-textboxlist-autocomplete]').length > 0
						|| clickedTarget.parents('[data-textboxlist-item]').length > 0 )
					{
						return;
					}

					$(document).off(windowClick);
					self.deactivate();
				});
			},

			deactivate: function() {

				self.element.removeClass("active");

				self.trigger("deactivateAllPrivacy", [self]);
				$(window).trigger("deactivatePrivacy", [self]);
			},

			"{window} activatePrivacy": function(el, event, instance) {
				if (instance!==self) {
					self.deactivate();
				}
			},

			save: function(data) {

				// Set privacy value
				self.key().val(data.value);

				// Set privacy icon
				self.icon().attr("class", data.privacyicon);

				// Trigger save event
				self.trigger("privacySave", [data]);

				// update tooltips
				self.element.attr('data-original-title', $.language( 'COM_EASYSOCIAL_PRIVACY_TOOLTIPS_SHARED_WITH_' + data.value.toUpperCase() ) );

				// If saving is done via ajax, save now.
				if (self.element.data("privacyMode")=="ajax") {

					EasySocial.ajax("site/controllers/privacy/update",
						{
							uid 	: data.uid,
							utype	: data.utype,
							value 	: data.value,
							pid 	: data.pid,
							custom 	: data.custom,
							streamid: data.streamid,
							userid	: data.userid,
							pitemid	: data.pitemid
						})
						.done(function(){

						})
						.fail(function(){
							// Unable to set privacy settings
						});
				}
			}
		}});


		EasySocial.Controller("Privacy.Custom", {
			defaultOptions: {
				"{textField}"   : "[data-textfield]",
				"{saveButton}" 	: "[data-save-button]",
				"{cancelButton}": "[data-cancel-button]",
				"{customItem}"  : "[data-privacy-item][data-value=custom]",
				"{customKey}"   : "[data-privacy-custom-hidden]"
			}
		}, function(self) { return {

				init: function() {

					self.textField()
						.textboxlist({
							component: 'es',
							unique: true,
							plugin: {
								autocomplete: {
									exclusive: true,
									minLength: 1,
									cache: false,
									query: function(keyword) {

										var users = self.getIds();

										var ajax = EasySocial.ajax("site/views/privacy/getfriends", {
												q: keyword,
												exclude: users
											});
										return ajax;
									}
								}
							}
						});

					self.textboxlist = self.textField().controller("TextboxList");
				},

				getIds: function() {

					var items =
						self.textField()
							.textboxlist("controller")
							.getAddedItems();

					return $.map(items, function(item, idx) {
						return item.id;
					});
				},

				updateIds: function() {

					var ids = self.getIds();
					self.customKey().val(ids.join(","));
				},

				"{parent} privacyChange": function(el, event, data) {

					var isCustomPrivacy = (data.value=="custom");

					self.element.toggleClass("custom-privacy", isCustomPrivacy);

					// If user no longer selects custom privacy
					if (!isCustomPrivacy) {

						// Clear any existing custom privacy
						self.textField()
							.textboxlist("controller")
							.clearItems();
					} else {

						// Prevent privacy from saving
						data.preventSave = true;
					}
				},

				"{parent} privacySave": function(el, event, data) {
					// for now do nothing.
				},

				"{parent} deactivateAllPrivacy": function(el, event) {

					self.textboxlist.autocomplete.hide();
				},

				"{cancelButton} click" : function(){
					self.element.removeClass("custom-privacy");
					self.textboxlist.autocomplete.hide();
				},

				"{saveButton} click" : function(){

					var parent = self.parent,
						customItem = self.customItem();

					var data = parent.getData(customItem);
					data.custom = self.customKey().val();

					self.parent.save(data );
					self.parent.deactivate();
				},

				// event listener for adding new name
				"{textField} addItem": function() {
					self.updateIds();
				},

				// event listener for removing name
				"{textField} removeItem": function() {
					self.updateIds();
				}
		}});

		// Implement privacy button upon clicking on the button
		$(document).on('click.es.privacy',  '[data-es-privacy-container]', function() {

			var privacyButton = $(this);
			var privacyController = "EasySocial.Controller.Privacy";

			// If controller is already implemented on the button, just skip implementation
			if (privacyButton.hasController(privacyController)) {
				return;
			}

			// Run the toggle.
			privacyButton.addController(privacyController)
				.toggle();
		});

		module.resolve();
	});

});

EasySocial.module('site/locations/popbox', function($){

	EasySocial.module("locations/popbox", function($){

		this.resolve(function(popbox){

			var button = popbox.button,
				lat = button.data("lat"),
				lng = button.data("lng"),
				link = "//maps.google.com/?q=" + lat + "," + lng,
				language = $('meta[property="foundry:location:language"]').attr("content") || 'en',
				url = "//maps.googleapis.com/maps/api/staticmap?size=400x200&sensor=true&zoom=15&center=" + lat + "," + lng + "&markers=" + lat + "," + lng + "&language=" + language;

			return {
				id: "fd",
				component: "es",
				type: "location",
				content: '<a href="' + link + '" target="_blank"><img src="' + url + '" width="400" height="200" /></a>'
			}
		});

	});

	this.resolve();

});

EasySocial.module('site/sidebar/sidebar', function($) {

	var module = this;

	$(document).on("click.es.sidebar", "[data-sidebar-toggle]", function(){

		// Prefer sidebar from siblings
		var button = $(this),
			selector = "[data-sidebar]",
			sidebar = button.siblings(selector);

		// If not find closest sidebar
		if (sidebar.length < 1) {
			sidebar = button.closest(selector);
		}

		// If not find any sidebar
		if (sidebar.length < 1) {
			sidebar = $(selector);
		}

		sidebar
			.toggleClass("sidebar-open")
			.trigger("sidebarToggle");
	});

	module.resolve();
});

EasySocial.module('site/friends/api', function($){

	var module = this;

	EasySocial.require()
		.library('dialog', 'popbox' )
		.done(function(){

			$( document )
				.on( 'click.es.friends.cancel' , '[data-es-friends-cancel]', function()
				{
					var element 	= $(this),
						friendId 	= element.data( 'es-friends-id' );

						// Show confirmation dialog
						EasySocial.dialog({
							content: EasySocial.ajax( 'site/views/friends/confirmCancel' ),
							bindings:
							{
								"{confirmButton} click": function()
								{
									EasySocial.ajax( 'site/controllers/friends/cancelRequest' ,
									{
										"id"	: friendId
									})
									.done( function()
									{
										// Hide the dialog once the request has been cancelled.
										EasySocial.dialog().close();
									});
								}
							}
						});
				});

			// Data API
			$(document)
				.on('click.es.friends.add', '[data-es-friends-add]', function(){

					var element = $(this);
					var userId = element.data( 'es-friends-id');
					var popboxContent = $.Deferred();
					var popboxOptions = {
						"content": popboxContent,
						"id" : "fd",
						"component": "es",
						"type": "api-friends",
						"toggle": "click"
					};

					// Display the popbox
					element.popbox('destroy');

					// Generate a new popbox instance
					element.popbox(popboxOptions);

					// Display the popbox
					element.popbox('show');

					// Run an ajax call now to perform the add friend request.
					EasySocial.ajax( 'site/controllers/friends/request' , {
						"viewCallback": "popboxRequest",
						"id": userId
					}).done(function(content) {

						popboxContent.resolve(content);

					});
				})

			module.resolve();
		});
});

EasySocial.module('site/popbox/popbox', function($) {
	var module = this;

	EasySocial.module("notifications/popbox", function($){

		this.resolve(function(popbox) {
			
			var autoread = popbox.button.data('autoread');

			return {
				
				content: EasySocial.ajax( "site/controllers/notifications/getSystemItems", {
					layout	: "popbox.notifications"
				}).done(function(){

					if (autoread) {
						$('[data-notificationSystem-counter]').parents('li').removeClass('has-notice');
						$('[data-notificationSystem-counter]').html(0);
					}
				}),
				id: "fd",
				component: "es",
				type: "notifications",
				cache: false
			};
		});
	});

	EasySocial.module("conversations/popbox", function($){

		this.resolve(function(popbox)
		{
			return {
				content: EasySocial.ajax( "site/controllers/notifications/getConversationItems",
				{
					usemax 	: "1",
					layout	: "popbox.conversations"
				}),
				id: "fd",
				component: "es",
				type: "notifications",
				cache: false
			};
		});
	});

	EasySocial.module("friends/popbox", function($){

		this.resolve(function(popbox){

			return {
				content: EasySocial.ajax( "site/controllers/notifications/friendsRequests",
				{
					layout	: "popbox.friends"
				}),
				id: "fd",
				component: "es",
				type: "notifications",
				cache: false
			};
		});
	});

	module.resolve();
});

EasySocial.module('site/conversations/api', function($){

	var module = this;

	EasySocial.require()
		.library('dialog')
		.done(function(){

			// Data API
			$(document)
				.on('click.es.conversations.compose', '[data-es-conversations-compose]', function(){

					

					var element 	= $(this),
						userId 		= element.data( 'es-conversations-id'),
						listId 		= element.data( 'es-conversations-listid' );


					EasySocial.dialog(
					{
						"content"	: EasySocial.ajax( 'site/views/conversations/composer' , { "id" : userId , "listId" : listId } ),
						"bindings"	:
						{
							"{sendButton} click" : function()
							{
								var recipients 	= $( 'input[name=recipient\\[\\]]' ),
									message 	= $( '[data-composer-message]' ).val(),
									uids 		= new Array,
									dialog 		= this.parent;

								$( recipients ).each( function()
								{
									uids.push( $( this ).val() );
								});
								
								EasySocial.ajax( 'site/controllers/conversations/store' ,
								{
									"uid"		: uids,
									"message"	: message
								})
								.done(function( link )
								{
									if( userId )
									{
										EasySocial.dialog(
										{
											"content"	: EasySocial.ajax( 'site/views/conversations/sent' , { "id" : userId }),
											"bindings"	:
											{
												"{viewButton} click" : function()
												{
													document.location 	= link;
												}
											}
										});
									}

									if( listId )
									{
										EasySocial.dialog(
										{
											"content"	: EasySocial.ajax( 'site/views/conversations/sentList' , { "id" : listId }),
											"bindings"	:
											{
												"{viewButton} click" : function()
												{
													document.location 	= link;
												}
											}
										});
									}
								})
								.fail(function(message) {
									dialog.setMessage(message);
								});
							}
						}
					});
				});

			module.resolve();
		});
});
EasySocial.module('site/groups/api', function($){

	var module = this;

	EasySocial.require()
	.library('dialog')
	.done(function() {

		// Data API
		$(document)
			.on('click.es.groups.join', '[data-es-groups-join]', function() {

				var element = $(this);
				var groupId = element.data('id');

				EasySocial.dialog({
					"content": EasySocial.ajax('site/controllers/groups/joinGroup', {"api": 1, "id": groupId}),
					"bindings": {}
				});
			});

		module.resolve();
	});
});
EasySocial.module('site/followers/api', function($){

	var module = this;

	EasySocial.require()
		.library('dialog', 'popbox')
		.done(function(){


			// Data API
			$(document)
				.on('click.es.followers.follow', '[data-es-followers-follow]', function(){

					var element 		= $(this),
						userId 			= element.data('es-followers-id'),
						popboxContent 	= $.Deferred(),
						showPopbox 		= element.data('es-show-popbox') == undefined || element.data('es-show-popbox') == "true" ? true : false;


						if (showPopbox) {
							element.popbox(
							{
								content	: popboxContent,
								id 		: "fd",
								component   : "es",
								type 	: "followers",
								toggle 	: "click"
							});

							element.popbox( 'show' );
						}

						// Let's do an ajax call to follow the user.
						EasySocial.ajax( 'site/controllers/profile/follow' ,
						{
							"id"	: userId,
							"type"	: 'user'
						})
						.done(function( button )
						{
							$(element).trigger('following', button);

							if (showPopbox) {
								EasySocial.ajax( 'site/views/profile/popboxFollow' , { "id" : userId } )
								.done(function(content)
								{
									popboxContent.resolve( content );
								});
							}
						});
				})

			// Data API
			$(document)
				.on('click.es.followers.unfollow', '[data-es-followers-unfollow]', function(){

					var element 		= $(this),
						userId 			= element.data( 'es-followers-id'),
						popboxContent 	= $.Deferred();

						element.popbox(
						{
							content	: popboxContent,
							id 		: "fd",
							component   : "es",
							type 	: "followers",
							toggle 	: "click"
						});

						element.popbox( 'show' );

						// Let's do an ajax call to follow the user.
						EasySocial.ajax( 'site/controllers/profile/unfollow' ,
						{
							"id"	: userId,
							"type"	: 'user'
						})
						.done(function( button )
						{
							EasySocial.ajax( 'site/views/profile/popboxUnfollow' , { "id" : userId } )
							.done(function(content)
							{
								popboxContent.resolve( content );
							});

						});
				});

			module.resolve();
		});
});

EasySocial.module("site/stream/video", function($){

	$(document).on("click", "[data-es-links-embed-item]", function() {

        var button = $(this);
        var player = $('<div>').html(button.data('es-stream-embed-player'));
        var embed = '<div class="video-container">' + player.html() + '</div>';

        button.replaceWith(embed);
	});

    // Processes stream items containing videojs embed codes
    $(document).on('click', '[data-es-video-embed]', function() {
        var button = $(this);
        var embed = button.siblings('[data-es-video-embed-player]');

        button.replaceWith(embed);
        embed.removeClass('hide');
    });

	this.resolve();
});

EasySocial.module( 'oauth/facebook', function($) {
	
	var module = this;

	$(document).on("click", "[data-oauth-facebook-login]", function(){

		var button = $(this),
			parent = button.parents("[data-oauth-facebook]"),
			controller = "EasySocial.Controller.OAuth.Facebook";

		if (parent.length < 1) return;
		if (parent.hasController(controller)) return;

		parent
			.addController(controller, {
				url: button.data("oauth-facebook-url"),
				appId: button.data("oauth-facebook-appid")
			})
			.openDialog();
	});


	EasySocial.Controller( 'OAuth.Facebook',
	{
		defaultOptions :
		{
			appId: null,
			url: "",
			"{login}"	: "[data-oauth-facebook-login]",
			"{revoke}"	: "[data-oauth-facebook-revoke]",

			"{pushInput}"	: "[data-oauth-facebook-push]"
		}
	},
	function( self )
	{
		return {
			init : function()
			{
			},

			openDialog : function()
			{
				var url = self.options.url,
					left	= (screen.width/2)-( 300 /2),
					top		= (screen.height/2)-( 300 /2);
					
				window.open( url , "" , 'scrollbars=no,resizable=no,width=300,height=300,left=' + left + ',top=' + top );
			},

			"{pushInput} change" : function( el )
			{
				var enabled 	= $(el).val();
				
				if( enabled == 1 && self.options.requestPush )
				{
					self.openDialog( self.options.addPublishURL )
				}

				if( enabled == 0 )
				{
					self.openDialog( self.options.revokePublishURL );
				}
			},

			"{login} click" : function()
			{
				self.openDialog();
			},

			"{revoke} click" : function()
			{
				var callback 	= self.element.data( 'callback' );
				
				EasySocial.dialog(
				{
					content 	: EasySocial.ajax( 'site/views/oauth/confirmRevoke' , { "client" : 'facebook' , "callbackUrl" : callback } )
				});
			}
		}
	});

	module.resolve();

}); // module end

EasySocial.module('groups/suggest', function($) {
	var module = this;


	EasySocial.require()
	.view('site/groups/suggest.item')
	.library('textboxlist')
	.done(function($) {

		EasySocial.Controller('Groups.Suggest', {
			defaultOptions: {
				max: null,
				exclusive: true,
				exclusion: [],
				minLength: 1,
				highlight: true,
				name: "uid[]",
				type: "",

				view: {
					suggestItem: "site/groups/suggest.item"
				}
			}
		}, function(self) { return {
			init: function() {

				var options = self.options;

				// Implement the textboxlist on the current element.
				self.element
					.textboxlist({
						component: 'es',
						name: options.name,
						max: options.max,
						plugin: {
							autocomplete: {
								exclusive: options.exclusive,
								minLength: options.minLength,
								highlight: options.highlight,
								showLoadingHint: true,
								showEmptyHint: true,

								query: function(keyword) {

									// Run an ajax call to retrieve suggested groups
									var result = EasySocial.ajax('site/controllers/groups/suggest', {
													"search": keyword,
													"exclusion": options.exclusion
												});

									return result;
								}
							}
						}
					})
					.textboxlist("enable");
			},

			"{self} filterItem": function(el, event, item) {

				var html =
					self.view.suggestItem(true, {
						item: item,
						name: self.options.name
					});

				item.menuHtml = html;
				item.html     = html;

				return item;
			},

			"{self} filterMenu": function(el, event, menu, menuItems, autocomplete, textboxlist) {
				// If this suggest searches for friend list, we don't want to format the item result here.
				if( self.options.friendList )
				{
					return;
				}

				// Get list of excluded users
				var items = textboxlist.getAddedItems(),
					users = $.pluck(items, "id"),
					users = users.concat(self.options.exclusion);

				menuItems.each(function(){

					var menuItem = $(this),
						item = menuItem.data("item");

					// If this user is excluded, hide the menu item
					menuItem.toggleClass("hidden", $.inArray(item.id.toString(), users) > -1);
				});
			}
		}});
		
		module.resolve();
	});

});
var rootDoc = this;

EasySocial.module('libraries/lightbox', function($) {

  var module = this;
  var jQuery = $;

    /*!
    * Lightbox v2.8.1
    * by Lokesh Dhakar
    *
    * More info:
    * http://lokeshdhakar.com/projects/lightbox2/
    *
    * Copyright 2007, 2015 Lokesh Dhakar
    * Released under the MIT license
    * https://github.com/lokesh/lightbox2/blob/master/LICENSE
    */

    // Uses Node, AMD or browser globals to create a module.
    (function (root, factory) {
      rootDoc.lightbox = factory(jQuery);
        // if (typeof define === 'function' && define.amd) {
        //     // AMD. Register as an anonymous module.
        //     define(['jquery'], factory);
        // } else {
        //     // Browser globals
        //     factory(jQuery);
        // }
      // if (typeof define === 'function' && define.amd) {
      //     // AMD. Register as an anonymous module.
      //     define(['jquery'], factory);
      // } else if (typeof exports === 'object') {
      //     // Node. Does not work with strict CommonJS, but
      //     // only CommonJS-like environments that support module.exports,
      //     // like Node.
      //     module.exports = factory(require('jquery'));
      // } else {
      //     // Browser globals (root is window)
      //     root.lightbox = factory(root.jQuery);
      // }
    }(this, function ($) {

        function Lightbox(options) {
          this.album = [];
          this.currentImageIndex = void 0;
          this.init();

          // options
          this.options = $.extend({}, this.constructor.defaults);
          this.option(options);
        }

        // Descriptions of all options available on the demo site:
        // http://lokeshdhakar.com/projects/lightbox2/index.html#options
        Lightbox.defaults = {
          albumLabel: 'Image %1 of %2',
          alwaysShowNavOnTouchDevices: false,
          fadeDuration: 500,
          fitImagesInViewport: true,
          // maxWidth: 800,
          // maxHeight: 600,
          positionFromTop: 50,
          resizeDuration: 700,
          showImageNumberLabel: true,
          wrapAround: false
        };

        Lightbox.prototype.option = function(options) {
          $.extend(this.options, options);
        };

        Lightbox.prototype.imageCountLabel = function(currentImageNum, totalImages) {
          return this.options.albumLabel.replace(/%1/g, currentImageNum).replace(/%2/g, totalImages);
        };

        Lightbox.prototype.init = function() {
          this.enable();
          this.build();
        };

        // Loop through anchors and areamaps looking for either data-lightbox attributes or rel attributes
        // that contain 'lightbox'. When these are clicked, start lightbox.
        Lightbox.prototype.enable = function() {
          var self = this;
          $('body').on('click', 'a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]', function(event) {
            self.start($(event.currentTarget));
            return false;
          });
        };

        // Build html for the lightbox and the overlay.
        // Attach event handlers to the new DOM elements. click click click
        Lightbox.prototype.build = function() {
          var self = this;
          $('<div id="lightboxOverlay" class="lightboxOverlay"></div><div id="lightbox" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" /><div class="lb-nav"><a class="lb-prev" href="" ></a><a class="lb-next" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo($('body'));

          // Cache jQuery objects
          this.$lightbox       = $('#lightbox');
          this.$overlay        = $('#lightboxOverlay');
          this.$outerContainer = this.$lightbox.find('.lb-outerContainer');
          this.$container      = this.$lightbox.find('.lb-container');

          // Store css values for future lookup
          this.containerTopPadding = parseInt(this.$container.css('padding-top'), 10);
          this.containerRightPadding = parseInt(this.$container.css('padding-right'), 10);
          this.containerBottomPadding = parseInt(this.$container.css('padding-bottom'), 10);
          this.containerLeftPadding = parseInt(this.$container.css('padding-left'), 10);

          // Attach event handlers to the newly minted DOM elements
          this.$overlay.hide().on('click', function() {
            self.end();
            return false;
          });

          this.$lightbox.hide().on('click', function(event) {
            if ($(event.target).attr('id') === 'lightbox') {
              self.end();
            }
            return false;
          });

          this.$outerContainer.on('click', function(event) {
            if ($(event.target).attr('id') === 'lightbox') {
              self.end();
            }
            return false;
          });

          this.$lightbox.find('.lb-prev').on('click', function() {
            if (self.currentImageIndex === 0) {
              self.changeImage(self.album.length - 1);
            } else {
              self.changeImage(self.currentImageIndex - 1);
            }
            return false;
          });

          this.$lightbox.find('.lb-next').on('click', function() {
            if (self.currentImageIndex === self.album.length - 1) {
              self.changeImage(0);
            } else {
              self.changeImage(self.currentImageIndex + 1);
            }
            return false;
          });

          this.$lightbox.find('.lb-loader, .lb-close').on('click', function() {
            self.end();
            return false;
          });
        };

        // Show overlay and lightbox. If the image is part of a set, add siblings to album array.
        Lightbox.prototype.start = function($link) {
          var self    = this;
          var $window = $(window);

          $window.on('resize', $.proxy(this.sizeOverlay, this));

          $('select, object, embed').css({
            visibility: 'hidden'
          });

          this.sizeOverlay();

          this.album = [];
          var imageNumber = 0;

          function addToAlbum($link) {
            self.album.push({
              link: $link.attr('href'),
              title: $link.attr('data-title') || $link.attr('title')
            });
          }

          // Support both data-lightbox attribute and rel attribute implementations
          var dataLightboxValue = $link.attr('data-lightbox');
          var $links;

          if (dataLightboxValue) {
            $links = $($link.prop('tagName') + '[data-lightbox="' + dataLightboxValue + '"]');
            for (var i = 0; i < $links.length; i = ++i) {
              addToAlbum($($links[i]));
              if ($links[i] === $link[0]) {
                imageNumber = i;
              }
            }
          } else {
            if ($link.attr('rel') === 'lightbox') {
              // If image is not part of a set
              addToAlbum($link);
            } else {
              // If image is part of a set
              $links = $($link.prop('tagName') + '[rel="' + $link.attr('rel') + '"]');
              for (var j = 0; j < $links.length; j = ++j) {
                addToAlbum($($links[j]));
                if ($links[j] === $link[0]) {
                  imageNumber = j;
                }
              }
            }
          }

          // Position Lightbox
          var top  = $window.scrollTop() + this.options.positionFromTop;
          var left = $window.scrollLeft();
          this.$lightbox.css({
            top: top + 'px',
            left: left + 'px'
          }).fadeIn(this.options.fadeDuration);

          this.changeImage(imageNumber);
        };

        // Hide most UI elements in preparation for the animated resizing of the lightbox.
        Lightbox.prototype.changeImage = function(imageNumber) {
          var self = this;

          this.disableKeyboardNav();
          var $image = this.$lightbox.find('.lb-image');

          this.$overlay.fadeIn(this.options.fadeDuration);

          $('.lb-loader').fadeIn('slow');
          this.$lightbox.find('.lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption').hide();

          this.$outerContainer.addClass('animating');

          // When image to show is preloaded, we send the width and height to sizeContainer()
          var preloader = new Image();
          preloader.onload = function() {
            var $preloader;
            var imageHeight;
            var imageWidth;
            var maxImageHeight;
            var maxImageWidth;
            var windowHeight;
            var windowWidth;

            $image.attr('src', self.album[imageNumber].link);

            $preloader = $(preloader);

            $image.width(preloader.width);
            $image.height(preloader.height);

            if (self.options.fitImagesInViewport) {
              // Fit image inside the viewport.
              // Take into account the border around the image and an additional 10px gutter on each side.

              windowWidth    = $(window).width();
              windowHeight   = $(window).height();
              maxImageWidth  = windowWidth - self.containerLeftPadding - self.containerRightPadding - 20;
              maxImageHeight = windowHeight - self.containerTopPadding - self.containerBottomPadding - 120;

              // Check if image size is larger then maxWidth|maxHeight in settings
              if (self.options.maxWidth && self.options.maxWidth < maxImageWidth) {
                maxImageWidth = self.options.maxWidth;
              }
              if (self.options.maxHeight && self.options.maxHeight < maxImageWidth) {
                maxImageHeight = self.options.maxHeight;
              }

              // Is there a fitting issue?
              if ((preloader.width > maxImageWidth) || (preloader.height > maxImageHeight)) {
                if ((preloader.width / maxImageWidth) > (preloader.height / maxImageHeight)) {
                  imageWidth  = maxImageWidth;
                  imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10);
                  $image.width(imageWidth);
                  $image.height(imageHeight);
                } else {
                  imageHeight = maxImageHeight;
                  imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10);
                  $image.width(imageWidth);
                  $image.height(imageHeight);
                }
              }
            }
            self.sizeContainer($image.width(), $image.height());
          };

          preloader.src          = this.album[imageNumber].link;
          this.currentImageIndex = imageNumber;
        };

        // Stretch overlay to fit the viewport
        Lightbox.prototype.sizeOverlay = function() {
          this.$overlay
            .width($(window).width())
            .height($(document).height());
        };

        // Animate the size of the lightbox to fit the image we are showing
        Lightbox.prototype.sizeContainer = function(imageWidth, imageHeight) {
          var self = this;

          var oldWidth  = this.$outerContainer.outerWidth();
          var oldHeight = this.$outerContainer.outerHeight();
          var newWidth  = imageWidth + this.containerLeftPadding + this.containerRightPadding;
          var newHeight = imageHeight + this.containerTopPadding + this.containerBottomPadding;

          function postResize() {
            self.$lightbox.find('.lb-dataContainer').width(newWidth);
            self.$lightbox.find('.lb-prevLink').height(newHeight);
            self.$lightbox.find('.lb-nextLink').height(newHeight);
            self.showImage();
          }

          if (oldWidth !== newWidth || oldHeight !== newHeight) {
            this.$outerContainer.animate({
              width: newWidth,
              height: newHeight
            }, this.options.resizeDuration, 'swing', function() {
              postResize();
            });
          } else {
            postResize();
          }
        };

        // Display the image and its details and begin preload neighboring images.
        Lightbox.prototype.showImage = function() {
          this.$lightbox.find('.lb-loader').stop(true).hide();
          this.$lightbox.find('.lb-image').fadeIn('slow');

          this.updateNav();
          this.updateDetails();
          this.preloadNeighboringImages();
          this.enableKeyboardNav();
        };

        // Display previous and next navigation if appropriate.
        Lightbox.prototype.updateNav = function() {
          // Check to see if the browser supports touch events. If so, we take the conservative approach
          // and assume that mouse hover events are not supported and always show prev/next navigation
          // arrows in image sets.
          var alwaysShowNav = false;
          try {
            document.createEvent('TouchEvent');
            alwaysShowNav = (this.options.alwaysShowNavOnTouchDevices) ? true : false;
          } catch (e) {}

          this.$lightbox.find('.lb-nav').show();

          if (this.album.length > 1) {
            if (this.options.wrapAround) {
              if (alwaysShowNav) {
                this.$lightbox.find('.lb-prev, .lb-next').css('opacity', '1');
              }
              this.$lightbox.find('.lb-prev, .lb-next').show();
            } else {
              if (this.currentImageIndex > 0) {
                this.$lightbox.find('.lb-prev').show();
                if (alwaysShowNav) {
                  this.$lightbox.find('.lb-prev').css('opacity', '1');
                }
              }
              if (this.currentImageIndex < this.album.length - 1) {
                this.$lightbox.find('.lb-next').show();
                if (alwaysShowNav) {
                  this.$lightbox.find('.lb-next').css('opacity', '1');
                }
              }
            }
          }
        };

        // Display caption, image number, and closing button.
        Lightbox.prototype.updateDetails = function() {
          var self = this;

          // Enable anchor clicks in the injected caption html.
          // Thanks Nate Wright for the fix. @https://github.com/NateWr
          if (typeof this.album[this.currentImageIndex].title !== 'undefined' &&
            this.album[this.currentImageIndex].title !== '') {
            this.$lightbox.find('.lb-caption')
              .html(this.album[this.currentImageIndex].title)
              .fadeIn('fast')
              .find('a').on('click', function(event) {
                if ($(this).attr('target') !== undefined) {
                  window.open($(this).attr('href'), $(this).attr('target'));
                } else {
                  location.href = $(this).attr('href');
                }
              });
          }

          if (this.album.length > 1 && this.options.showImageNumberLabel) {
            var labelText = this.imageCountLabel(this.currentImageIndex + 1, this.album.length);
            this.$lightbox.find('.lb-number').text(labelText).fadeIn('fast');
          } else {
            this.$lightbox.find('.lb-number').hide();
          }

          this.$outerContainer.removeClass('animating');

          this.$lightbox.find('.lb-dataContainer').fadeIn(this.options.resizeDuration, function() {
            return self.sizeOverlay();
          });
        };

        // Preload previous and next images in set.
        Lightbox.prototype.preloadNeighboringImages = function() {
          if (this.album.length > this.currentImageIndex + 1) {
            var preloadNext = new Image();
            preloadNext.src = this.album[this.currentImageIndex + 1].link;
          }
          if (this.currentImageIndex > 0) {
            var preloadPrev = new Image();
            preloadPrev.src = this.album[this.currentImageIndex - 1].link;
          }
        };

        Lightbox.prototype.enableKeyboardNav = function() {
          $(document).on('keyup.keyboard', $.proxy(this.keyboardAction, this));
        };

        Lightbox.prototype.disableKeyboardNav = function() {
          $(document).off('.keyboard');
        };

        Lightbox.prototype.keyboardAction = function(event) {
          var KEYCODE_ESC        = 27;
          var KEYCODE_LEFTARROW  = 37;
          var KEYCODE_RIGHTARROW = 39;

          var keycode = event.keyCode;
          var key     = String.fromCharCode(keycode).toLowerCase();
          if (keycode === KEYCODE_ESC || key.match(/x|o|c/)) {
            this.end();
          } else if (key === 'p' || keycode === KEYCODE_LEFTARROW) {
            if (this.currentImageIndex !== 0) {
              this.changeImage(this.currentImageIndex - 1);
            } else if (this.options.wrapAround && this.album.length > 1) {
              this.changeImage(this.album.length - 1);
            }
          } else if (key === 'n' || keycode === KEYCODE_RIGHTARROW) {
            if (this.currentImageIndex !== this.album.length - 1) {
              this.changeImage(this.currentImageIndex + 1);
            } else if (this.options.wrapAround && this.album.length > 1) {
              this.changeImage(0);
            }
          }
        };

        // Closing time. :-(
        Lightbox.prototype.end = function() {
          this.disableKeyboardNav();
          $(window).off('resize', this.sizeOverlay);
          this.$lightbox.fadeOut(this.options.fadeDuration);
          this.$overlay.fadeOut(this.options.fadeDuration);
          $('select, object, embed').css({
            visibility: 'visible'
          });
        };

        return new Lightbox();
    }));

    module.resolve();

});

EasySocial.module("locations", function($){

	var module = this;

	EasySocial
		.require()
		.library("scrollTo", "image", "gmaps")
		.view("site/location/story.suggestion")
		.language("COM_EASYSOCIAL_AT_LOCATION")
		.done(function(){

			// Constants
			var KEYCODE = {
				BACKSPACE: 8,
				COMMA: 188,
				DELETE: 46,
				DOWN: 40,
				ENTER: 13,
				ESCAPE: 27,
				LEFT: 37,
				RIGHT: 39,
				SPACE: 32,
				TAB: 9,
				UP: 38
			};

			EasySocial.Controller("Locations", {
				defaultOptions: {

					view: {
						suggestion: "site/location/story.suggestion"
					},

					map: {
						lat: 0,
						lng: 0
					},

					latitude: null,
					longitude: null,

					"{textField}": "[data-location-textField]",
					"{detectLocationButton}": "[data-detect-location-button]",

					'{autocomplete}'    : '[data-location-autocomplete]',
					"{suggestions}": "[data-location-suggestions]",
					"{suggestion}": "[data-story-location-suggestion]",

					"{mapImage}": "[data-location-map-image]",

					"{latitude}" : "[data-location-lat]",
					"{longitude}": "[data-location-lng]",

					"{removeButton}": "[data-location-remove-button]"
				}
			}, function(self, opts, base) { return {

				init: function() {

					// I have access to:
					// self.panelButton()
					// self.panelContent()

					// Only show auto-detect button if the browser supports geolocation
					if (navigator.geolocation) {
						self.detectLocationButton().show();
					}

					// Allow textfield input only when controller is implemented
					EasySocial.require().library("gmaps")
						.done(function(){
							self.textField().removeAttr("disabled");
						});


					// If caller specified a latitude or longitude, navigate the map
				    setTimeout(function() {
				        if (opts.latitude && opts.longitude) {
				            self.navigate(opts.latitude, opts.longitude);

				            self.detectLocationButton().hide();
				        }
				    }, 1);
				},

				navigate: function(lat, lng) {

					var mapImage = self.mapImage();
					var width = mapImage.width();
					var height = mapImage.height();

					var	url =
							$.GMaps.staticMapURL({
								size: [width, height],
								lat: lat,
								lng: lng,
								sensor: true,
								scale: 2,
								markers: [
									{lat: lat, lng: lng}
								]
							});

					$.Image.get(url)
						.done(function() {
							mapImage.css({
								"backgroundImage": $.cssUrl(url),
								"backgroundSize": "cover",
								"backgroundPosition": "center center"
							});

							base.addClass("has-location");
						});
				},

				// Memoized locations
				locations: {},

				lastQueryAddress: null,

				"{textField} keypress": function(textField, event) {

					switch (event.keyCode) {

						case KEYCODE.UP:

							var prevSuggestion = $(
								self.suggestion(".active").prev(self.suggestion.selector)[0] ||
								self.suggestion(":last")[0]
							);

							// Remove all active class
							self.suggestion().removeClass("active");

							prevSuggestion
								.addClass("active")
								.trigger("activate");

							self.suggestions()
								.scrollTo(prevSuggestion, {
									offset: prevSuggestion.height() * -1
								});

							event.preventDefault();

							break;

						case KEYCODE.DOWN:

							var nextSuggestion = $(
								self.suggestion(".active").next(self.suggestion.selector)[0] ||
								self.suggestion(":first")[0]
							);

							// Remove all active class
							self.suggestion().removeClass("active");

							nextSuggestion
								.addClass("active")
								.trigger("activate");

							self.suggestions()
								.scrollTo(nextSuggestion, {
									offset: nextSuggestion.height() * -1
								});

							event.preventDefault();

							break;

						case KEYCODE.ENTER:

							var activeSuggestion = self.suggestion(".active"),
								location = activeSuggestion.data("location");
								self.set(location);

							// self.suggestions().hide();
							break;

						case KEYCODE.ESCAPE:
							break;
					}

				},

				"{textField} keyup": function(textField, event) {

					switch (event.keyCode) {

						case KEYCODE.UP:
						case KEYCODE.DOWN:
						case KEYCODE.ENTER:
						case KEYCODE.ESCAPE:
							// Don't repopulate if these keys were pressed.
							break;

						default:
							var address = $.trim(textField.val());

							if (address==="") {
								// self.suggestions().hide();

							}

							if (address==self.lastQueryAddress) {
								return;
							}

							var locations = self.locations[address];

							// If this location has been searched before
							if (locations) {

								// Just use cached results
								self.suggest(locations);

								// And set our last queried address to this address
								// so that it won't repopulate the suggestion again.
								self.lastQueryAddress = address;

							// Else ask google to find it out for us
							} else {

								self.lookup(address);
							}
							break;
					}
				},

				lookup: $._.debounce(function(address){

					// TODO: difine is-busy

					EasySocial.ajax('site/controllers/location/suggestLocations', {
						"address": address,
					}).done(function(locations) {

						// Store a copy of the results
						self.locations[address] = locations;

						self.suggest(locations);
						self.textField().focus();
						self.element.addClass("has-suggested");
					});

				}, 250),

				suggest: function(locations) {

					var suggestions = self.suggestions();
					
					// Clear location suggestions
					suggestions.empty();

					$.each(locations, function(i, location) {

						// Create suggestion and append to list
						self.view.suggestion({
								"location": location
							})
							.data("location", location)
							.appendTo(suggestions);
					});

					self.autocomplete().addClass("active");
				},

				"{suggestion} activate": function(suggestion, event) {

					var location = suggestion.data("location");

					self.navigate(location.latitude, location.longitude);
				},

				"{suggestion} mouseover": function(suggestion) {

					// Remove all active class
					self.suggestion().removeClass("active");

					suggestion
						.addClass("active")
						.trigger("activate");
				},

				"{suggestion} click": function(suggestion, event) {

					var location = suggestion.data("location");

					self.set(location);

					// Remove active class on the auto complete
					self.autocomplete().removeClass('active');
					
					// self.suggestions().hide();
				},

				set: function(location) {

					self.currentLocation = location;

					var address = location.name;

					self.textField().val(address);

					self.latitude()
						.val(location.latitude);

					self.longitude()
						.val(location.longitude);

					self.detectLocationButton().hide();
					
					self.trigger("locationChange", [location]);

				},

				unset: function() {
                    self.currentLocation = null;

                    self.textField().val('');

                    self.mapImage().attr("src", "");

                    self.element.removeClass("has-location");

                    self.detectLocationButton().show();
				},

				"{detectLocationButton} click": function() {

					var map = self.map;

					self.element.addClass("is-busy");

					$.GMaps.geolocate({
						success: function(position) {
							EasySocial.ajax('site/controllers/location/getLocations', {
								latitude: position.coords.latitude,
								longitude: position.coords.longitude
							}).done(function(locations) {

								self.element.removeClass("is-busy");

								self.element.addClass("has-suggested");

								self.suggest(locations);
								self.textField().focus();
							});
						},
						error: function(error) {
							// error.message
						},
						always: function() {

						}
					});
				},

				"{removeButton} click": function(removeButton, event) {
					self.unset();
				},

				"{story} save": function(el, element, save) {

					var currentLocation = self.currentLocation;

					if (!currentLocation) {
						return;
					}

					save.addData(self, {
						short_address    : currentLocation.name,
						formatted_address: currentLocation.address,
						lat              : currentLocation.latitude,
						lng              : currentLocation.longitude
					});
				},

				"{story} clear": function() {
					self.unset();
				}

			}});

			// Resolve module
			module.resolve();

		});

});

EasySocial.module( 'pagination' , function(){

var module	= this;


// Module begins here.
EasySocial.require()
.done(function($){

	EasySocial.Controller(
		'Pagination',
		{
			defaultOptions:
			{
				"{pages}"		: ".pageItem",
				"{limitstart}"	: "#limitstart",
				"{previousItem}": ".previousItem",
				"{nextItem}"	: ".nextItem"
			}
		},
		function(self)
		{
			return {
				init: function()
				{
					// Implement page item controller.
					self.pages().implement( EasySocial.Controller.Pagination.Page , {
						pagination : self
					});
				},

				"{previousItem} click" : function( elem )
				{
					var limitstart 	= $( elem ).data( 'limitstart' );

					if( $( elem ).hasClass( 'disabled' ) )
					{
						return;
					}
					
					self.submitForm( limitstart );
				},

				"{nextItem} click" : function( elem )
				{
					var limitstart 	= $( elem ).data( 'limitstart' );

					if( $( elem ).hasClass( 'disabled' ) )
					{
						return;
					}

					self.submitForm( limitstart );
				},

				submitForm: function( limitstart )
				{
					// Update the limitstart value in the page.
					self.limitstart().val( limitstart );

					// Send a submit for the form.
					$.Joomla( 'submitform' , [] );
				}
			} }

		);


	EasySocial.Controller(
		'Pagination.Page',
		{
			defaultOptions:
			{
				pagination	: null,
				limitstart	: 0
			}
		},
		function( self )
		{
			return {
				init: function()
				{
					self.options.limitstart 	= self.element.data( 'limitstart' );
				},

				"{self} click" : function()
				{
					// If the page is currently active, we can just ignore this.
					if( self.element.hasClass( 'active' ) )
					{
						return false;
					}

					// Submit the form.
					self.options.pagination.submitForm( self.options.limitstart );
				}
			}
		}
	);

	// Once require is done, we mark this module as resolved.
	module.resolve();

});


});

EasySocial.module("photos/avatar", function($){

	var module = this;

	EasySocial.require()
		.library(
			"imgareaselect"
		)
		.stylesheet(
			"imgareaselect/default"
		)
		.done(function(){

			EasySocial.Controller("Photos.Avatar",
			{
				defaultOptions:
				{
					view:
					{
						selection: "site/photos/avatar.selection"
					},

					uid 		: null,
					type 		: null,
					redirect	: true,
					redirectUrl	: "",
					"{image}"   : "[data-photo-image]",
					"{viewport}": "[data-photo-avatar-viewport]",
					"{photoId}" : "[data-photo-id]",
					"{userId}"  : "[data-user-id]",
					"{createButton}": "[data-create-button]",
					"{selection}"   : "[data-selection-box]",
					"{loadingIndicator}": "[data-photos-avatar-loading]"
				}
			},
			function(self) { return {

				init: function() {

					self.setLayout();
				},

				data: function()
				{

					var viewport = self.viewport(),

						width  = viewport.width(),

						height = viewport.height(),

						selection =
							viewport
								.imgAreaSelect({instance: true})
								.getSelection(),

						data = {
									id    	: self.photoId().val(),
									uid 	: self.options.uid,
									type 	: self.options.type,
									top   	: selection.y1 / height,
									left  	: selection.x1 / width,
									width 	: selection.width / width,
									height	: selection.height / height
								};

					return data;
				},

				imageLoaders: {},

				setLayout: function() {

					var imageHolder   = self.image(),
						// Using this instead of the other one above for urls that may have /*/ in it.
					    // imageUrl      = $.uri(imageHolder.css("backgroundImage")).extract(0),
					    imageUrl      = imageHolder.css("backgroundImage").replace(/^url\(['"]?/,'').replace(/['"]?\)$/,''),
					    imageLoaders  = self.imageLoaders,
					    imageLoader   = imageLoaders[imageUrl] || (self.imageLoaders[imageUrl] = $.Image.get(imageUrl));


					imageLoader
					    .done(function(imageEl, image){

							var size = $.Image.resizeWithin(
									image.width,
									image.height,
									imageHolder.width(),
									imageHolder.height()
								),
								min = Math.min(size.width, size.height),
								x1  = Math.floor((size.width  - min) / 2),
								y1  = Math.floor((size.height - min) / 2),
								x2  = x1 + min,
								y2  = y1 + min;

							self.createButton().enabled(true);

							self.viewport()
								.css(size)
								.imgAreaSelect({
									handles: true,
									aspectRatio: "1:1",
									parent: self.image(),
									x1: x1,
									y1: y1,
									x2: x2,
									y2: y2,
									onSelectEnd: function(viewport, selection) {
										var hasSelection = !(selection.width=="0" && selection.height=="0");
										self.createButton().enabled(hasSelection);
									}
								});
					    });
				},

				"{createButton} click": function( createButton )
				{
					var data = self.data(),

						task =
							EasySocial.ajax(
								"site/controllers/photos/createAvatar",
								data
								)
								.done(function( photo, user )
								{
									if (self.options.redirect)
									{
										window.location = self.options.redirectUrl;
									}
								})
								.fail(function(message, type)
								{
									self.setMessage(message, type);
								});

					self.trigger("avatarCreate", [task, data, self]);
				}

			}});

			module.resolve();

		});
});

EasySocial.module("photos/browser", function($){

	var module = this;

	EasySocial.require()
		.library(
			"history"
		)
		.done(function(){

			EasySocial.Controller("Photos.Browser",
			{
				defaultOptions: {

					// For masonry
					tilesPerRow: 4,

					"{sidebar}": "[data-photo-browser-sidebar]",
					"{content}": "[data-photo-browser-content]",

					"{backButton}"    : "[data-photo-back-button]",
					"{backButtonLink}": "[data-photo-back-button-link]",

					"{listItemGroup}" : "[data-photo-list-item-group]",
					"{listItem}"      : "[data-photo-list-item]",
					"{listItemLink}"  : "[data-photo-list-item] > a",
					"{listItemTitle}" : "[data-photo-list-item-title]",
					"{listItemCover}" : "[data-photo-list-item-cover]",
					"{listItemImage}" : "[data-photo-list-item-image]",

					"{featuredListItem}"      : "[data-photo-list-item].featured",
					"{featuredListItemImage}" : "[data-photo-list-item].featured [data-photo-list-item-image]",

					"{photoItem}": "[data-photo-item]"
				}
			},
			function(self) { return {

				init: function() {

					// Load masonry and set layout
					EasySocial.require()
						.library("masonry")
						.done(function(){
							self.setLayout();
						});
				},

				setLayout: function() {

					var listItemGroup = self.listItemGroup(),
						masonry = $.data(listItemGroup[0], "masonry");

					// Ensure group width is divisible by 4
					listItemGroup.width(Math.floor(listItemGroup.width() / 4) * 4);						

					if (masonry) {

						listItemGroup
							.masonry("reloadItems")
							.masonry("layout");

					// Else recalculate sizes
					} else {

						listItemGroup
							.masonry({
								columnWidth: ".es-thumb.grid-sizer",
								itemSelector: self.listItem.selector
							});
					}

					// Save current layout
					self.setLayout.seed = listItemGroup.width();
				},

				open: function(view) {

					var args = $.makeArray(arguments);

					self.trigger("contentLoad", args);

					var method = "view" + $.String.capitalize(view),
						loader = self[method].apply(self, args.slice(1));

					loader
						.done(self.displayContent(function(){
							self.trigger("contentDisplay", args);
							return arguments;
						}))
						.fail(function(){
							self.trigger("contentFail", args);
						})
						.always(function(){
							self.trigger("contentComplete", args);
						});

					return loader;
				},

				displayContent: $.Enqueue(function(html){

					var scripts = [],
						content = $($.buildFragment([html], document, scripts));

					// Insert content
					self.content().html(content);

					// Remove scripts
					$(scripts).remove();
				}),

				viewPhoto: function(photoId) {

					var state = "active loading",

						listItem =
							self.listItem()
								.removeClass(state)
								.filterBy("photoId", photoId)
								.addClass(state),

						loader =
							EasySocial.ajax(
								"site/views/photos/item",
								{
									id: photoId,
									browser: false
								})
								.fail(function(){
								})
								.always(function(){
									listItem.removeClass("loading");
								});

					return loader;
				},

				"{listItem} click": function(listItem) {

					var photoId = listItem.data("photoId");

					// Load album
					self.open("Photo", photoId);

					// Change address bar url
					listItem.find("> a").route();
				},

				"{listItemLink} click": function(listItemLink, event) {

					// Progressive enhancement, no longer refresh the page.
					event.preventDefault();

					// Prevent item from getting into :focus state
					listItemLink.blur();
				},

				"{backButtonLink} click": function(albumsButtonLink, event) {

					var browser = self.browser;

					// If albums browser exists, use it to load album
					if (browser) {

						var albumId = self.element.data("albumId");

						browser.open("album", albumId);

						event.preventDefault();

						albumsButtonLink.route();

						// To quickly change back to album
						browser.setLayout("album");

						self.element.remove();
					}
				},

				getListItem: function(photoId, context) {

					var listItem =
						(!photoId) ?
							self.listItem(".new") :
							self.listItem().filterBy("photoId", photoId);

					if (!context) return listItem;

					return listItem.find(self["listItem" + $.String.capitalize(context)].selector);
				},

				getNextListItem: function(photoId) {

					var listItem =
						self.getListItem(photoId)
							.next(self.listItem.selector);

					if (listItem.length < 1) {
						listItem = self.listItem(":first");
					}

					return listItem;
				},

				getPrevListItem: function(photoId) {

					var listItem =
						self.getListItem(photoId)
							.prev(self.listItem.selector);

					if (listItem.length < 1) {
						listItem = self.listItem(":last");
					}

					return listItem;
				},

				removeListItem: function(photoId, loadPreviousItem) {

					var listItem = self.getListItem(photoId),
						prevListItem = self.getPrevListItem(photoId);

					// Remove list item
					listItem.remove();

					// Reset list item masonry layout
					self.setLayout();

					// If there are no more items on the list
					if (self.listItem().length < 1) {

						self.element.addClass("loading");

						// Go back to albums
						return window.location = self.backButtonLink().attr("href");
					}

					// Else load previous item
					if (loadPreviousItem) {

						prevListItem.click();
					}
				},

				"{photoItem} init.photos.item": function(el, event, photoItem) {

					// Attach browser plugin to album
					self.addSubscriber(photoItem);
				},

				"{photoItem} photoSave": function(el, event, task) {

					// Update list item title when photo is updated.
					task.done(function(photo, html){

						self.getListItem(photo.id, "title")
							.html(photo.title);
					});
				},

				"{photoItem} photoNext": function(el, event, photo) {

					var listItem = self.getNextListItem(photo.id);
					listItem.click();
				},

				"{photoItem} photoPrev": function(el, event, photo) {

					var listItem = self.getPrevListItem(photo.id);
					listItem.click();
				},

				"{photoItem} photoMove": function(el, event, task, photo, targetAlbumId) {

					task
						.done(function(){
							self.removeListItem(photo.id, true);
						});
				},

				"{photoItem} photoDelete": function(el, event, task, photo) {

					task
						.done(function(){
							self.removeListItem(photo.id, true);
						});
				},

				"{photoItem} photoFeature": function(el, event, task, photo, featured) {

					var item = self.getListItem(photo.id);

					item.toggleClass("featured", featured);
					self.setLayout();

					task
						.fail(function(){
							item.toggleClass("featured", !featured);
							self.setLayout();
						});
				},

				"{sidebar} sidebarToggle": function() {

					self.setLayout();
				}

			}});

			module.resolve();

		});
});
EasySocial.module("photos/editor", function($){

	var module = this;

	EasySocial.require()
		.done(function(){

			var Controller =
			EasySocial.Controller("Photos.Editor",
			{
				defaultOptions: {

					view: {
						uploadItem: "upload.item",
						photoForm : "site/albums/photo.form"
					},

					"{titleField}"  : "[data-photo-title-field]",
					"{captionField}": "[data-photo-caption-field]",

					"{location}"          : "[data-photo-location]",
					"{locationCaption}"   : "[data-photo-location-caption]",
					"{addLocationButton}" : "[data-photo-addLocation-button]",
					"{date}"              : "[data-photo-date]",
					"{dateCaption}"       : "[data-photo-date-caption]",
					"{addDateCaption}"    : "[data-photo-adddate-button]",

					"{locationWidget}"  : ".es-photo-location-form .es-locations",
					"{latitude}"        : "[data-location-lat]",
					"{longitude}"       : "[data-location-lng]",

					"{dateDay}"  : "[name=date-day]",
					"{dateMonth}": "[name=date-month]",
					"{dateYear}" : "[name=date-year]",

					"{actionsMenu}"  : "[data-item-actions-menu]",
					"{featureButton}": "[data-photo-feature-button]",
					"{coverButton}"  : "[data-photo-cover-button]",

					"{editButton}"    : "[data-photo-edit-button]",
					"{editButtonLink}": "[data-photo-edit-button] > a",

					"{cancelButton}"   : "[data-photo-cancel-button]",

					"{doneButton}"     : "[data-photo-done-button]",
					"{doneButtonLink}" : "[data-photo-done-button] > a",

					"{moveButton}"  : "[data-photo-move-button]",
					"{deleteButton}": "[data-photo-delete-button]",

					"{rotateLeftButton}": "[data-photo-rotateLeft-button]",
					"{rotateRightButton}": "[data-photo-rotateRight-button]",

					"{profileAvatarButton}": "[data-photo-profileAvatar-button]",
					"{profileCoverButton}": "[data-photo-profileCover-button]"
				}
			},
			function(self, opts, base) { return {

				init: function() {
				},

				data: function() {

					return {
						id        : self.photo.id,
						title     : self.titleField().val(),
						caption   : self.captionField().val(),
						date      : self.formatDate(),
						address   : self.locationCaption().html(),
						latitude  : self.latitude().val(),
						longitude : self.longitude().val()
					}
				},

				save: function() {

					var data = self.data();

					self.clearMessage();

					var task =
						EasySocial.ajax(
							"site/controllers/photos/update",
							data
						)
						.done(function(photo){

							self.photo.setLayout("item");
						})
						.fail(function(){

							self.setMessage(message, "error");
						})
						.progress(function(message, type){

							if (type=="success") {
								self.setMessage(message);
							}
						});

					self.trigger("photoSave", [task, self]);

					return task;
				},

				enable: function() {

					self.photo.setLayout("form");

					// If we are running under an album frame
					var album = self.photo.album;

					if (album) {
						base.addClass("active");
					}

					self.trigger("enabled", [self]);
				},

				disable: function() {

					self.photo.setLayout("item");

					// If we are running under an album frame
					var album = self.photo.album;

					if (album) {
						base.removeClass("active");
					}

					self.trigger("disabled", [self]);
				},

				imageLoader: {},

				setImage: function(type) {

					var image = self.photo.image(),
						imageCss = self.photo.imageCss(),
						imageSource = image.data(type + "Src"),
						imageLoader = self.imageLoader[imageSource];

					// If this image hasn't been loaded before
					if (!imageLoader) {

						// Create an image loader
						imageLoader = $.Image.get(imageSource);

						// Store a reference of the loader within the element
						self.imageLoader[imageSource] = imageLoader;
					}

					imageLoader
						.done(function(){
							image.attr("src", imageSource);
							imageCss.css({
								backgroundImage: $.cssUrl(imageSource)
							});
						});

					return imageLoader;
				},

				"{featureButton} click": function(featureButton, event) {

					event.stopPropagation();

					var isPopup =
						self.photo.element.parents("[data-photo-popup]").length > 0 ||
						self.photo.element.parents("[data-photo-browser-content]").length > 0;

					var isFeatured = base.hasClass("featured");

					base.toggleClass("featured", !isFeatured);

					!isPopup && self.setImage((isFeatured) ? "thumbnail" : "featured");

					// Perform an ajax call to mark the photo as featured
					var task =
						EasySocial.ajax(
							"site/controllers/photos/feature", {
								id: self.photo.id
							}
						)
						.done(function( message , isFeatured ) {

							// If this is not under album, show a message
							// if (!self.photo.album) {
							// 	self.clearMessage();
							// 	self.setMessage( message );
							// }

							featureButton.toggleClass('btn-es-primary', isFeatured);
						})
						.fail(function() {

							base.removeClass("featured");
							!isPopup && self.setImage((!isFeatured) ? "thumbnail" : "featured");
						});

					self.trigger("photoFeature", [task, self.photo, !isFeatured]);
				},

				"{coverButton} click": function() {

					var album = self.photo.album;

					// When viewing photos invidually,
					// there is no reference to album,
					// the button itself should't be visible anyway.
					if (!album) return;

					// If the editor is available, set cover.
					album.editor && album.editor.setCover(self.photo.id);
				},

				"{dateDay} keyup": function() {
					self.updateDate();
				},

				"{dateMonth} change": function() {
					self.updateDate();
				},

				"{dateYear} keyup": function() {
					self.updateDate();
				},

				updateDate: function() {

					setTimeout(function(){
						self.date().addClass("has-data");
						var dateCaption = self.dateDay().val() + ' ' + $.trim(self.dateMonth().find(":selected").text() + ' ' + self.dateYear().val());
						self.dateCaption().html(dateCaption);
					}, 1);
				},

				formatDate: function() {
					var day = self.dateDay().val() || self.dateDay().data('date-default'),
						month = self.dateMonth().val() || self.dateMonth().data('date-default'),
						year = self.dateYear().val() || self.dateYear().data('date-default');

					return year + '-' + month + '-' + day;
 				},

				"{locationWidget} locationChange": function(el, event, location) {

					var address = location.address || location.fulladdress || location.formatted_address;
					self.locationCaption().html(address);
					self.location().addClass("has-data");
				},

				rotate: function(angle) {

					var photo = self.photo;

					self.rotateLeftButton().disabled(true);
					self.rotateRightButton().disabled(true);

					// Show loading indicator
					photo.content().addClass("loading");

					var task =
						EasySocial.ajax(
							"site/controllers/photos/rotate",
							{
								id: photo.id,
								angle: angle
							}
						)
						.done(function(photoObj) {

							var url;

							if (self.photo.album) {
								url = photoObj.sizes.thumbnail.url;
							} else {
								url = photoObj.sizes.large.url;
							}

							// So that it actual loads a new one
							url += "?" + $.uid();

							// Replace image url
							photo.image()
								.attr("src", url);

							photo.imageCss()
								.css({
									backgroundImage: $.cssUrl(url)
								});

							base
								.addTransitionClass("rotating-ready", 150)
								.removeClass("rotating-right rotating-left");
						})
						.fail(function(message, type) {

							self.setMessage(message, type);
						})
						.always(function(){

							photo.content().removeClass("loading");
							self.rotateLeftButton().disabled(false);
							self.rotateRightButton().disabled(false);
						});

					self.trigger("photoRotate", [task, angle, photo])
				},

				"{rotateRightButton} click": function() {

					base.addClass("rotating-right");
					self.rotate(90);
				},

				"{rotateLeftButton} click": function() {

					base.addClass("rotating-left");
					self.rotate(-90);
				},

				"{moveButton} click": function() {

					var photo = self.photo;

					var dialog =
						EasySocial.dialog({
							content: EasySocial.ajax(
								"site/views/photos/moveToAnotherAlbum",
								{
									id: photo.id
								}
							),
							bindings: {
								"{moveButton} click": function() {

									var targetAlbumId = this.albumSelection().val();

									var task =
										EasySocial.ajax(
											"site/controllers/photos/move",
											{
												id: photo.id,
												albumId: targetAlbumId
											}
										)
										.always(function(){
											dialog.close();
										});

									self.trigger("photoMove", [task, photo, targetAlbumId]);
								}
							}
						});
				},

				"{deleteButton} click": function() {

					var photo = self.photo;

					EasySocial.dialog({
						content: EasySocial.ajax(
							"site/views/photos/confirmDelete",
							{
								id: photo.id
							}
						),
						bindings: {
							"{deleteButton} click": function(deleteButton) {

								var dialog = this.parent;

								deleteButton.disabled(true);

								var task =
									EasySocial.ajax(
										"site/controllers/photos/delete",
										{
											id: photo.id
										}
									)
									.always(function(){
										dialog.close();
									});

								self.trigger("photoDelete", [task, photo]);
							}
						}
					});
				},

				"{editButton} click": function() {

					// Change viewer layout
					self.photo.setLayout("form");

					// Change address bar url
					self.editButtonLink().route();
				},

				"{editButtonLink} click": function(editButtonLink, event) {

					event.preventDefault();
				},

				"{cancelButton} click": function()
				{
					// Change album layout
					self.photo.setLayout("item");

					// Change address bar url
					self.doneButtonLink().route();
				},

				"{doneButton} click": function() {

					self.save()
						.done(function(){

							// Change album layout
							self.photo.setLayout("item");

							// Change address bar url
							self.doneButtonLink().route();
						})
						.fail(function(){

						});
				},

				"{doneButtonLink} click": function(doneButtonLink, event) {
					event.preventDefault();
				},

				"{profileAvatarButton} click": function() {
					EasySocial.photos.createAvatar(self.photo.id);
				}
			}});

			module.resolve(Controller);

		});
});

EasySocial.module("photos/item", function($){

	var module = this;

	// Non-essential dependencies
	EasySocial.require()
		.script(
			"photos/tags",
			"photos/editor",
			"photos/tagger",
			"photos/navigation"
		)
		.done();

	// Essential dependencies
	EasySocial.require()
		.library(
			"image"
		)
		.done(function(){

			var Controller =
			EasySocial.Controller("Photos.Item",
			{
				hostname: "photo",

				defaultOptions: {

					editable: false,
					taggable: false,
					navigation: false,

					"{header}"            : "[data-photo-header]",
					"{content}"           : "[data-photo-content]",
					"{footer}"            : "[data-photo-footer]",
					"{viewport}"          : "[data-photo-viewport]",

					"{info}"              : "[data-photo-info]",
					"{title}"             : "[data-photo-title]",
					"{titleLink}"         : "[data-photo-title-link]",
					"{caption}"           : "[data-photo-caption]",

					"{image}"             : "[data-photo-image]",
					"{imageCss}"          : "[data-photo-image-css]",
					"{imageLink}"         : "[data-photo-image-link]",

					"{menu}"              : "[data-photo-menu]",
					"{actions}"           : "[data-item-actions]",
					"{actionsMenu}"       : "[data-item-actions-menu]",

					"{comments}"          : "[data-comments]",
					"{share}"			  : "[data-repost-action]",
					"{likes}"			  : "[data-likes-action]",
					"{likeContent}" 	  : "[data-likes-content]",
					"{repostContent}" 	  : "[data-repost-content]",
					"{counterBar}"	  	  : "[data-stream-counter]",

					"{privacy}"           : "[data-es-privacy-container]",

					"{likeCount}"    : "[data-photo-like-count]",
					"{commentCount}" : "[data-photo-comment-count]",
					"{tagCount}"     : "[data-photo-tag-count]"
				}
			},
			function(self) { return {

				init: function() {

					self.id = self.element.data("photoId");

					// Also implement tags when it is available
					EasySocial.module("photos/tags")
						.done(function(TagsController){
							self.tags = self.addPlugin("tags", TagsController);
						});

					// If this photos is editable, load & implement editor.
					if (self.options.editable) {
						EasySocial.module("photos/editor")
							.done(function(EditorController){
								self.editor = self.addPlugin("editor", EditorController);
							});
					}

					if (self.options.taggable) {
						EasySocial.module("photos/tagger")
							.done(function(TaggerController){
								self.tagger = self.addPlugin("tagger", TaggerController);
							});
					}

					if (self.options.navigation) {
						EasySocial.module("photos/navigation")
							.done(function(NavigationController){
								self.navigation = self.addPlugin("navigation", NavigationController);
							});
					}
				},

				data: function() {

					var image = self.image();

					return {
						id        : self.id,
						title     : $.trim(self.title().text()),
						caption   : $.trim(self.caption().text()),
						sizes: {
							thumbnail: image.data("thumbnailSrc"),
							featured : image.data("featuredSrc"),
							large    : image.data("largeSrc")
						}
					}
				},

				setLayout: function(layoutName) {

					// Switch layout
					self.element
						.data("photoLayout", layoutName)
						.switchClass("layout-" + layoutName);

					// Trigger layout change event
					self.trigger("layoutChange", [layoutName, self]);
				},

				"{self} click": function(el, event) {

					// If using photo popup, stop.
					if (!el.data("esPhotoDisabled")) return;

					var target = $(event.target),
						menu = self.menu();

					// If the area being click is the photo menu, stop.
					if (target.parents().andSelf().filter(menu).length > 0) return;

					// Activate item
					self.trigger("activate", [self]);
				},

				"{self} photoSave": function(el, event, task) {

					task
						.done(function(photo, html){
							self.info().replaceWith(html);
						});
				},

				"{self} photoDelete": function(el, event, task) {

					task
						.done(function(){
						})
						.fail(function(message, type){
							self.setMessage(message, type);
						});
				},

				"{imageLink} click": function(imageLink, event) {

					event.preventDefault();
				},

				"{titleLink} click": function(titleLink, event) {

					// event.preventDefault();
				},

                "{self} shown.bs.dropdown": function() {
                     self.element.addClass("show-all");
                },

                "{self} hidden.bs.dropdown": function() {
                     self.element.removeClass("show-all");
                },

                "{share} create": function(el, event, itemHTML) {
                	self.counterBar().removeClass('hide');
                },

 				"{likes} onLiked": function(el, event, data) {

					//need to make the data-stream-counter visible
					self.counterBar().removeClass( 'hide' );
					self.count("like", 1, true);
				},

				"{likes} onUnliked": function(el, event, data) {

					var isLikeHide 		= self.likeContent().hasClass('hide');
					var isRepostHide 	= self.repostContent().hasClass('hide');

					if( isLikeHide && isRepostHide )
					{
						self.counterBar().addClass( 'hide' );
					}

					self.count("like", -1, true);
				},

				"{self} tagAdd": function() {
					self.count("tag", 1, true);
				},

				"{self} tagRemove": function() {
					self.count("tag", -1, true);
				},

				"{comments} newCommentSaved": function() {
					self.count("comment", 1, true);
				},

				"{comments} commentDeleted": function() {
					self.count("comment", -1, true);
				},

				"{privacy} activate": function() {
					setTimeout(function(){
						self.element.addClass("show-all")
					}, 0);
				},

				"{privacy} deactivate": function() {
					self.element.removeClass("show-all");
				},

				count: function(subject, val, append) {

					var statSelector = self[subject + "Count"];

					if (!$.isFunction(statSelector)) return;

					// Get stat element
					var stat = statSelector();

					// If no stat element found, stop.
					if (stat.length < 0) return;

					// Get current stat count
					var statCount;

					if (append) {
						statCount = (parseInt(stat.text()) || 0) + (parseInt(val) || 0);
					} else {
						statCount = val;
					}

					// Always stays at 0 if less than that
					if (statCount < 0) statCount = 0;

					// Update stat count
					stat.text(statCount);
				}

			}});

			module.resolve(Controller);

		});
});

EasySocial.module("photos/tags", function($){

	var module = this;

	// Non essential dependencies
	EasySocial.require()
		.library("scrollTo")
		.done();

	EasySocial.require()
		.done(function(){

			var Controller =
			EasySocial.Controller("Photos.Tags",
			{
				hostname: "tags",

				defaultOptions: {

					"{viewport}"    : "[data-photo-tag-viewport]",
					"{tagItem}"     : "[data-photo-tag-item]",
					"{tagButton}"   : "[data-photo-tag-button]",
					"{tagLink}"     : "[data-photo-tag-link]",

					"{infoTagListItemGroup}": "[data-photoinfo-tag-list-item-group]",
					"{infoTagListItem}": "[data-photo-tags-user]",

					"{tagListItemGroup}": "[data-photo-tag-list-item-group]",
					"{tagListItem}"     : "[data-photo-tag-list-item]",

					"{descTagItem}": "[data-photo-tags-user]"
				}
			},
			function(self) { return {

				init: function() {
					self.setLayout();
				},

				imageLoaders: {},

				setLayout: function(callback) {

					var viewport     = self.photo.viewport(),
						image        = self.photo.image(),
						imageUrl     = image.attr("src"),
						imageLoaders = self.imageLoaders,
						imageLoader  = imageLoaders[imageUrl] || (self.imageLoaders[imageUrl] = $.Image.get(imageUrl));

					imageLoader
						.done(function(){

							var imageOffset = image.offset(),
								viewportOffset = viewport.offset();

							self.viewport()
								.css({
									top: imageOffset.top - viewportOffset.top,
									left: imageOffset.left - viewportOffset.left,
									width: image.width(),
									height: image.height()
								});

							callback && callback();
						});
				},

				"{window} resize": $.debounce(function(){

					self.setLayout();

				}, 1000),

				getTagItem: function(tagId) {
					return self.tagItem().filterBy("photoTagId", tagId);
				},

				getTagListItem: function(tagId) {
					return self.tagListItem().filterBy("photoTagId", tagId);
				},

				getInfoTagListItem: function(tagId) {
					return self.infoTagListItem().filterBy("photoTagId", tagId);
				},

				getTaggedUsers: function() {

					var users = [];

					self.tagListItem("[data-photo-tag-uid]")
						.each(function(){
							users.push($(this).data("photoTagUid"));
						});

					return $.uniq(users);
				},

				activateTag: function(tagId) {

					self.getTagItem(tagId)
						.addClass("active");

					self.getTagListItem(tagId)
						.addClass("active");
				},

				deactivateTag: function(tagId) {

					self.getTagItem(tagId)
						.removeClass("active");

					self.getTagListItem(tagId)
						.removeClass("active");
				},

				"{tagLink} click": function(el, event) {

					event.stopPropagation();
				},

				"{tagListItem} click": function(el) {

					var method = (el.hasClass('active') ? "deactivate" : "activate") + "Tag",
						tagId  = el.data("photoTagId");

					// Toggle tag
					self[method](tagId);
				},

				"{tagListItem} mouseover": function(el) {

					self.getTagItem(el.data("photoTagId"))
						.addClass("focus");
				},

				"{tagListItem} mouseout": function(el) {

					self.getTagItem(el.data("photoTagId"))
						.removeClass("focus");
				},

				"{descTagItem} mouseover": function(el) {
					self.getTagItem(el.data("photoTagId"))
						.addClass("focus");
				},

				"{descTagItem} mouseout": function(el) {
					self.getTagItem(el.data("photoTagId"))
						.removeClass("focus");
				},

				"{self} tagCreate": function(el, event, task) {

					task.done(function(){

					})
					.always(function(){
						setTimeout(function(){
							self.tagListItemGroup()
								.toggleClass("empty-tags", self.tagListItem().length < 1);
						}, 1);
					});
				},

				"{self} tagRemove": function(el, event, task, tagId) {

					task.done(function(){

						// Remove tag item
						self.getTagItem(tagId).remove();

						// Remove tag list item
						self.getTagListItem(tagId).remove();

						// Remove info's tag list item
						self.getInfoTagListItem(tagId).remove();

						// if length is zero, lets clear the html content.
						var taglen = self.infoTagListItemGroup().children().length;

						if (taglen == 0) {
							self.infoTagListItemGroup().html('');
						}

						if (taglen == 1) {
							var tag = self.infoTagListItemGroup().children().first();
							var tagcontent = tag.text();
							tagcontent = tagcontent.replace(',', '');

							tag.text(tagcontent);
						}

					})
					.always(function(){

						self.tagListItemGroup()
							.toggleClass("empty-tags", self.tagListItem().length < 1);
					});
				},

				"{self} photoRotate": function(el, event, task, angle, photo) {

					task.done(function(photoObj, tags){

						setTimeout(function(){

							self.setLayout(function(){

								var tagItems = self.tagItem();

								$.each(tags, function(i, tag){

									var tagItem = tagItems.filterBy("photoTagId", tag.id);

									tagItem
										.css({
											width : (tag.width  * 100) + "%",
											height: (tag.height * 100) + "%",
											top   : (tag.top    * 100) + "%",
											left  : (tag.left   * 100) + "%"
										});
								});

							});

						}, 1);

					});

				}
			}});

			module.resolve(Controller);

		});
});


EasySocial.module("photos/tagger", function($){

	var module = this;

	var KEYCODE = {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		ENTER: 13,
		ESCAPE: 27,
		LEFT: 37,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	};

	// Non essential dependencies
	EasySocial.require()
		.library("scrollTo")
		.done();

	EasySocial.require()
		.view(
			"site/photos/tags.item",
			"site/photos/tags.menu.item"
		)
		.done(function(){

			var Controller =
			EasySocial.Controller("Photos.Tagger",
			{
				hostname: "tagger",

				defaultOptions: {

					view: {
						tagItem: "site/photos/tags.item"
					},

					width: 100,
					height: 100,

					drawTolerance: 30,

					"{viewport}"    : "[data-photo-tag-viewport]",
					"{tagItem}"     : "[data-photo-tag-item]",
					"{tagSelection}": "[data-photo-tag-item].new",
					"{tagButton}"   : "[data-photo-tag-button]",

					"{infoTagListItemGroup}": "[data-photoinfo-tag-list-item-group]",
					"{tagListItemGroup}": "[data-photo-tag-list-item-group]",
					"{tagListItem}"     : "[data-photo-tag-list-item]",

					"{tagRemoveButton}" : "[data-photo-tag-remove-button]"
				}
			},
			function(self) { return {

				init: function() {
				},

				newTagItem: function() {

					// Use existing tag item if created
					var viewport = self.viewport(),
						newTagItem = self.tagItem(".new");

					// Else create one
					if (newTagItem.length < 1) {
						newTagItem =
							self.view.tagItem()
								.addClass("new")
								.appendTo(viewport);

						self.addSubscriber(
							newTagItem.addController("EasySocial.Controller.Photos.Tag")
						);
					}

					return newTagItem;
				},

				"{tagButton} click": function(tagButton) {

					self[tagButton.data("photoTagButton") || "toggle"]();
				},

				disabled: true,

				enable: function() {

					// This prevents image link from being clicked
					self.photo.imageLink()
						.on("click.tagger", function(event){
							event.preventDefault();
						});

					self.disabled = false;
					self.element.addClass("tagging");

					// If there is scrollTo
					if ($.scrollTo) {
						$.scrollTo(self.photo.content(), 250, {offset: {top: -100}});
					}

					self.trigger("tagEnter");
				},

				disable: function() {

					self.photo.imageLink()
						.off("click.tagger");

					// Remove tag selection
					self.tagSelection().remove();

					// Unfocus any tags which are in focus
					self.tagItem(".focus").removeClass("focus");

					self.disabled = true;
					self.element.removeClass("tagging");

					self.trigger("tagLeave");
				},

				toggle: function() {

					self[(self.disabled) ? "enable" : "disable"]();
				},

				area: {},

				calculateArea: function(collision, offset) {

					// Normalize arguments
					if (!collision) { collision = "clip" };
					if (!offset)    { offset = {x: 0, y: 0} };

					// Calculate image area
					var viewportEl   = self.viewport(),
						viewport        = viewportEl.offset();
						viewport.width  = viewportEl.width();
						viewport.height = viewportEl.height();
						viewport.right  = viewport.width  + viewport.left;
						viewport.bottom = viewport.height + viewport.top;

					// Calculate area relative to screen
					// top, left, width, height, right, bottom
					var area = self.area;
					area.top    = ((area.startY <= area.endY) ? area.startY : area.endY) + offset.y;
					area.left   = ((area.startX <= area.endX) ? area.startX : area.endX) + offset.x;
					area.width  = Math.abs(area.endX - area.startX);
					area.height = Math.abs(area.endY - area.startY);
					area.right  = area.width  + area.left;
					area.bottom = area.height + area.top;

					// Collision handling
					if (collision=="clip") {

						// Cap area within image boundaries
						if (area.top    <= viewport.top   ) {area.top    = viewport.top;   }
						if (area.bottom >= viewport.bottom) {area.bottom = viewport.bottom;}
						if (area.left   <= viewport.left  ) {area.left   = viewport.left;  }
						if (area.right  >= viewport.right ) {area.right  = viewport.right; }

						// Resize tag
						area.width  = area.right  - area.left;
						area.height = area.bottom - area.top;
					}

					// Reposition tag
					if (collision=="flip") {

						if (area.top <= viewport.top) {
							area.top = viewport.top;
						}

						if (area.left <= viewport.left) {
							area.left = viewport.left;
						}

						if (area.right >= viewport.right) {
							area.right = viewport.right;
							area.left  = area.right - area.width;
						}

						if (area.bottom >= viewport.bottom) {
							area.bottom = viewport.bottom;
							area.top    = area.bottom - area.height;
						}
					}

					// Pixel unit
					area.pixel = {
						top   : area.top  - viewport.top,
						left  : area.left - viewport.left,
						width : area.width,
						height: area.height
					};

					// Decimal unit
					area.decimal = {
						top   : area.pixel.top  / viewport.height,
						left  : area.pixel.left / viewport.width,
						width : area.width      / viewport.width,
						height: area.height     / viewport.height
					}

					// Percentage unit
					area.percentage = {
						top   : (area.decimal.top    * 100) + "%",
						left  : (area.decimal.left   * 100) + "%",
						width : (area.decimal.width  * 100) + "%",
						height: (area.decimal.height * 100) + "%"
					};

					// Decide whether tag should be on custom size
					var tolerance = self.options.drawTolerance;

					self.autodraw =
						(area.width  < tolerance &&
						 area.height < tolerance);

					return area;
				},

				setPivot: function(type, x, y) {

					var area = self.area;
						area[type + "X"] = x;
						area[type + "Y"] = y;
				},

				drawing: false,

				autodraw: false,

				drawTag: function() {

					var area = self.calculateArea();
						options = self.options;

					if (self.autodraw) {

						area.endX = area.startX + options.width;
						area.endY = area.startY + options.height;

						self.calculateArea("flip", {
							x: options.width / -2,
							y: options.height / -2
						});
					}

					self.newTagItem()
						.css(area.percentage)
						.trigger("focusInput");
				},

				"{viewport} mousedown": function(viewport, event) {

					if (self.disabled) return;

					if (event.target!==viewport[0]) return;

					event.preventDefault();

					// Hide last created tag item which are currently in focus
					self.tagItem(".focus").removeClass("focus");

					self.drawing = true;
					self.setPivot("start", event.pageX, event.pageY);

					$(document)
						.on("mousemove.tagger", function(event) {
							if (!self.drawing) return;
							self.setPivot("end", event.pageX, event.pageY);
							self.drawTag();
						})
						.on("mouseup.tagger", function(event) {
							self.setPivot("end", event.pageX, event.pageY);
							self.drawTag();
							$(document).off("mousemove.tagger mouseup.tagger");
						});
				},

				createTag: function(data) {

					var data = $.extend(
						{photo_id: self.photo.id}, data, self.area.decimal
					);

					var task = EasySocial.ajax("site/controllers/photos/createTag", data);

					self.trigger("tagCreate", [task, data, self]);

					return task;
				},

				removeTag: function(id) {

					var task = EasySocial.ajax("site/controllers/photos/removeTag", {id: id});

					self.trigger("tagRemove", [task, id, self]);

					return task;
				},

				addTag: function(data, tagItemHtml, tagListItemHtml, infoTagListItemHtml) {

					// Add tag to viewport and focus on tag
					var tagItem =
						$.buildHTML(tagItemHtml)
							.addClass("focus")
							.appendTo(self.viewport());

					// Add tag list item to tag list
					var tagListItem =
						$.buildHTML(tagListItemHtml)
							.appendTo(self.tagListItemGroup());

					//before we append the tag into info, we need to check if there is any tags or not. if not, we will apend a dash
					var taglen = self.infoTagListItemGroup().children().length;

					if (taglen == 0) {
						self.infoTagListItemGroup().append(' - ');
					}

					// Add tag list item to tag list at info section
					var infoTagListItem =
						$.buildHTML(infoTagListItemHtml)
							.appendTo(self.infoTagListItemGroup());

					self.trigger("tagAdd", [data, tagItem, tagListItem, self]);
				},

				"{self} avatarEnter": function() {

					// When entering avatar mode, hide all tags.
					self.tagItem().hide();

					// Disable tagging mode
					self.disable();
				},

				"{self} avatarLeave": function() {

					// When leaving avatar mode, display all tags.
					self.tagItem().show();
				},

				"{tagRemoveButton} click": function(button, event) {

					var tagId = button.data("photoTagId");

					self.removeTag(tagId);

					event.stopPropagation();
				},

				// Give priority to remove button,
				// make tag viewport appear above of
				// navigation buttons when they are hovered.
				"{tagRemoveButton} mouseover": function() {

					self.viewport().addClass("active");
				},

				"{tagRemoveButton} mouseout": function() {

					self.viewport().removeClass("active");
				}

			}});

			EasySocial.Controller("Photos.Tag",
			{
				defaultOptions: {

					view: {
						menuItem: "site/photos/tags.menu.item"
					},

					"{form}"        : "[data-photo-tag-form]",
					"{title}"       : "[data-photo-tag-title]",
					"{removeButton}": "[data-photo-tag-remove-button]",
					"{textField}"   : "[data-photo-tag-input]",
					"{menu}"        : "[data-photo-tag-menu]",
					"{menuItem}"    : "[data-photo-tag-menu-item]"
				}
			},
			function(self) { return {

				init: function() {

					self.data = self.options.data;
				},

				"{self} focusInput": function() {

					self.textField().focus();
				},

				"{textField} keyup": $._.debounce(function(el, event) {

					var keyword = $.trim(self.textField().val());

					switch (event.keyCode) {

						case KEYCODE.UP:
						case KEYCODE.DOWN:
						case KEYCODE.ENTER:
						case KEYCODE.ESCAPE:
							// Don't repopulate if these keys were pressed.
							break;

						default:
							// Build a list of users to exclude
							var users = self.tagger.photo.tags.getTaggedUsers();

							EasySocial.ajax(
							   "site/controllers/friends/suggestPhotoTagging",
							   {
							   	   search: keyword,
							   	   exclude: users,
							   	   includeme: '1'
							   })
								.done(self.render());
							break;
					}

				}, 250),

				"{textField} keypress": function(textField, event) {

					var keyword = $.trim(self.textField().val());

					// Get active menu item
					var activeMenuItem = self.menuItem(".active");

					switch (event.keyCode) {

						// If up key is pressed
						case KEYCODE.UP:

							// Deactivate all menu item
							self.menuItem().removeClass("active");

							// If no menu items are activated,
							if (activeMenuItem.length < 1) {

								// activate the last one.
								self.menuItem(":last").addClass("active");

							// Else find the menu item before it,
							} else {

								// and activate it.
								activeMenuItem.prev(self.menuItem.selector)
									.addClass("active");
							}

							event.preventDefault();
							break;

						// If down key is pressed
						case KEYCODE.DOWN:

							// Deactivate all menu item
							self.menuItem().removeClass("active");

							// If no menu items are activated,
							if (activeMenuItem.length < 1) {

								// activate the first one.
								self.menuItem(":first").addClass("active");

							// Else find the menu item after it,
							} else {

								// and activate it.
								activeMenuItem.next(self.menuItem.selector)
									.addClass("active");
							}

							event.preventDefault();
							break;

						// If enter is pressed
						case KEYCODE.ENTER:

							// Use menu item
							if (activeMenuItem.length > 0) {

 								activeMenuItem.trigger("click");

 							// Create custom label
 							} else {
								self.create({
									type: "label",
									label: keyword
								});
 							};

							self.menu().hide();
							break;

						// If escape is pressed,
						case KEYCODE.ESCAPE:

							// hide menu.
							self.menu().hide();
							break;
					}
				},

				"{menuItem} mouseover": function(menuItem) {

					self.menuItem().removeClass("active");

					menuItem.addClass("active");
				},

				"{menuItem} mouseout": function(menuItem) {

					self.menuItem().removeClass("active");
				},

				render: $.Enqueue(function(items) {

					var menu = self.menu();

					if (!items || items.length < 1) {
						menu.hide();
						return;
					}

					menu.empty();

					$.each(items, function(i, item) {

						self.view.menuItem({item: item})
							.data("item", item)
							.appendTo(menu);

						menu.show();
					});
				}),

				create: function(data) {

					var tag = self.element;

					// Store tag data
					self.data = data;

					// Update tag title
					self.title()
						.html(data.label);

					// Do not submit empty label
					if ($.trim(data.label)==="") return;

					// Create tag
					self.tagger.createTag(data)
						.done(function(tag, tagItemHtml, tagListItemHtml, infoTagListItemHtml){

							// Add new tag
							self.tagger.addTag(tag, tagItemHtml, tagListItemHtml, infoTagListItemHtml);

							// Destroy myself
							self.element.remove();
						})
						.fail(function(message){
							alert(message.message);
							tag.remove();
						});
				},

				remove: function() {

					var tag = self.element,
						tagId = (self.data || {}).id;

					// If this is a new tag, just remove element;
					if (!tagId) return tag.remove();

					// Remove tag
					self.tagger.removeTag(tagId)
						.done(function(){
							tag.remove();
						});
				},

				"{menuItem} click": function(menuItem) {

					var item = menuItem.data("item");

					self.create({
						uid  : item.id,
						type : "person",
						label: item.screenName,
					});
				},

				"{removeButton} click": function() {

					self.remove();
				}

			}});

			module.resolve(Controller);

		});
});

EasySocial.module("photos/navigation", function($){


	$.fn.intersectsWith = function(top, left, width, height) {

		var offset = this.offset(),

			reference = {
				top   : offset.top,
				left  : offset.left,
				bottom: offset.top  + (sourceHeight = this.height()),
				right : offset.left + (sourceWidth  = this.width()),
				width : sourceWidth,
				height: sourceHeight
			},

			subject = {
				top   : top,
				left  : left,
				bottom: top  + (height || (height = 0)),
				right : left + (width  || (width  = 0)),
				width : width,
				height: height
			},

			intersects = (
				reference.left <= subject.right    &&
				subject.left   <= reference.right  &&
	          	reference.top  <= subject.bottom   &&
	          	subject.top    <= reference.bottom
			);

		return (intersects) ? {reference: reference, subject: subject} : false;
	};

	var module = this;

	var Controller =

		EasySocial.Controller("Photos.Navigation",
		{
			hostname: "navigation",

			defaultOptions: {
				"{navButton}" : ".es-photo-nav-button",
				"{nextButton}": "[data-photo-next-button]",
				"{prevButton}": "[data-photo-prev-button]"
			}
		},
		function(self, opts, base) { return {

			init: function() {

				self.setDirection(window.esPhotosNavigationLastDirection);
			},

			disabled: false,

			disable: function() {
				self.disabled = true;
				self.navButton().addClass("disabled");
			},

			enable: function() {
				self.disabled = false;
				self.navButton().removeClass("disabled");
			},

			setDirection: function(direction) {

				self.navButton().removeClass("active");

				window.esPhotosNavigationLastDirection = self.currentDirection = direction;

				if (direction) {
					// Show button
					self[direction + "Button"]().addClass("active");
				}
			},

			"{window} mousemove": function(el, event) {

				// If navigation is disabled, don't do anything.
				if (self.disabled) return;

				self.setDirection(null);
				self.photo.trigger("directionstop");

				// If user is not moving within the photo content, stop.
				if ($(event.target).parents().filter(self.photo.content.selector).length < 1) return;

				var offset =
						self.photo.content()
							.intersectsWith(event.pageY, event.pageX);

				if (offset) {

					var direction =
						(offset.subject.left < (offset.reference.right - (offset.reference.width / 2))) ?
							"prev" : "next";

					self.setDirection(direction);

					self.photo.trigger("directionmove", [offset, direction]);
				}
			},

			"{self} tagEnter": function() {
				self.disable();
			},

			"{self} tagLeave": function() {
				self.enable();
			},

			"{self} click": function(el, event) {

				if (self.disabled) return;

				// If user is not clicking within the photo content, stop.
				if ($(event.target).parents().filter(self.photo.content.selector).length < 1) return;

				var direction = self.currentDirection;

				if (!direction) return;

				self.trigger("photo" + $.String.capitalize(direction), [self.photo]);
			},

			"{self} photoNext": function() {
				// Photo browser handles this
			},

			"{self} photoPrev": function() {
				// Photo browser handles this
			}

		}});

	module.resolve(Controller);

});

EasySocial.module( "prism", function($){

var module = this;

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */(function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var r={};for(var i in e)e.hasOwnProperty(i)&&(r[i]=t.util.clone(e[i]));return r;case"Array":return e.slice()}return e}},languages:{extend:function(e,n){var r=t.util.clone(t.languages[e]);for(var i in n)r[i]=n[i];return r},insertBefore:function(e,n,r,i){i=i||t.languages;var s=i[e],o={};for(var u in s)if(s.hasOwnProperty(u)){if(u==n)for(var a in r)r.hasOwnProperty(a)&&(o[a]=r[a]);o[u]=s[u]}return i[e]=o},DFS:function(e,n){for(var r in e){n.call(e,r,e[r]);t.util.type(e)==="Object"&&t.languages.DFS(e[r],n)}}},highlightAll:function(e,n){var r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code');for(var i=0,s;s=r[i++];)t.highlightElement(s,e===!0,n)},highlightElement:function(r,i,s){var o,u,a=r;while(a&&!e.test(a.className))a=a.parentNode;if(a){o=(a.className.match(e)||[,""])[1];u=t.languages[o]}if(!u)return;r.className=r.className.replace(e,"").replace(/\s+/g," ")+" language-"+o;a=r.parentNode;/pre/i.test(a.nodeName)&&(a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+o);var f=r.textContent;if(!f)return;f=f.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ");var l={element:r,language:o,grammar:u,code:f};t.hooks.run("before-highlight",l);if(i&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){l.highlightedCode=n.stringify(JSON.parse(e.data),o);t.hooks.run("before-insert",l);l.element.innerHTML=l.highlightedCode;s&&s.call(l.element);t.hooks.run("after-highlight",l)};c.postMessage(JSON.stringify({language:l.language,code:l.code}))}else{l.highlightedCode=t.highlight(l.code,l.grammar,l.language);t.hooks.run("before-insert",l);l.element.innerHTML=l.highlightedCode;s&&s.call(r);t.hooks.run("after-highlight",l)}},highlight:function(e,r,i){return n.stringify(t.tokenize(e,r),i)},tokenize:function(e,n,r){var i=t.Token,s=[e],o=n.rest;if(o){for(var u in o)n[u]=o[u];delete n.rest}e:for(var u in n){if(!n.hasOwnProperty(u)||!n[u])continue;var a=n[u],f=a.inside,l=!!a.lookbehind,c=0;a=a.pattern||a;for(var h=0;h<s.length;h++){var p=s[h];if(s.length>e.length)break e;if(p instanceof i)continue;a.lastIndex=0;var d=a.exec(p);if(d){l&&(c=d[1].length);var v=d.index-1+c,d=d[0].slice(c),m=d.length,g=v+m,y=p.slice(0,v+1),b=p.slice(g+1),w=[h,1];y&&w.push(y);var E=new i(u,f?t.tokenize(d,f):d);w.push(E);b&&w.push(b);Array.prototype.splice.apply(s,w)}}}return s},hooks:{all:{},add:function(e,n){var r=t.hooks.all;r[e]=r[e]||[];r[e].push(n)},run:function(e,n){var r=t.hooks.all[e];if(!r||!r.length)return;for(var i=0,s;s=r[i++];)s(n)}}},n=t.Token=function(e,t){this.type=e;this.content=t};n.stringify=function(e,r,i){if(typeof e=="string")return e;if(Object.prototype.toString.call(e)=="[object Array]")return e.map(function(t){return n.stringify(t,r,e)}).join("");var s={type:e.type,content:n.stringify(e.content,r,i),tag:"span",classes:["token",e.type],attributes:{},language:r,parent:i};s.type=="comment"&&(s.attributes.spellcheck="true");t.hooks.run("wrap",s);var o="";for(var u in s.attributes)o+=u+'="'+(s.attributes[u]||"")+'"';return"<"+s.tag+' class="'+s.classes.join(" ")+'" '+o+">"+s.content+"</"+s.tag+">"};if(!self.document){self.addEventListener("message",function(e){var n=JSON.parse(e.data),r=n.language,i=n.code;self.postMessage(JSON.stringify(t.tokenize(i,t.languages[r])));self.close()},!1);return}var r=document.getElementsByTagName("script");r=r[r.length-1];if(r){t.filename=r.src;document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)}})();;
Prism.languages.markup={comment:/&lt;!--[\w\W]*?-->/g,prolog:/&lt;\?.+?\?>/,doctype:/&lt;!DOCTYPE.+?>/,cdata:/&lt;!\[CDATA\[[\w\W]*?]]>/i,tag:{pattern:/&lt;\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|\w+))?\s*)*\/?>/gi,inside:{tag:{pattern:/^&lt;\/?[\w:-]+/i,inside:{punctuation:/^&lt;\/?/,namespace:/^[\w-]+?:/}},"attr-value":{pattern:/=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi,inside:{punctuation:/=|>|"/g}},punctuation:/\/?>/g,"attr-name":{pattern:/[\w:-]+/g,inside:{namespace:/^[\w-]+?:/}}}},entity:/&amp;#?[\da-z]{1,8};/gi};Prism.hooks.add("wrap",function(e){e.type==="entity"&&(e.attributes.title=e.content.replace(/&amp;/,"&"))});;
Prism.languages.css={comment:/\/\*[\w\W]*?\*\//g,atrule:{pattern:/@[\w-]+?.*?(;|(?=\s*{))/gi,inside:{punctuation:/[;:]/g}},url:/url\((["']?).*?\1\)/gi,selector:/[^\{\}\s][^\{\};]*(?=\s*\{)/g,property:/(\b|\B)[\w-]+(?=\s*:)/ig,string:/("|')(\\?.)*?\1/g,important:/\B!important\b/gi,ignore:/&(lt|gt|amp);/gi,punctuation:/[\{\};:]/g};Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{style:{pattern:/(&lt;|<)style[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/style(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)style[\w\W]*?(>|&gt;)|(&lt;|<)\/style(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.css}}});;
Prism.languages.css.selector={pattern:/[^\{\}\s][^\{\}]*(?=\s*\{)/g,inside:{"pseudo-element":/:(?:after|before|first-letter|first-line|selection)|::[-\w]+/g,"pseudo-class":/:[-\w]+(?:\(.*\))?/g,"class":/\.[-:\.\w]+/g,id:/#[-:\.\w]+/g}};Prism.languages.insertBefore("css","ignore",{hexcode:/#[\da-f]{3,6}/gi,entity:/\\[\da-f]{1,8}/gi,number:/[\d%\.]+/g,"function":/(attr|calc|cross-fade|cycle|element|hsla?|image|lang|linear-gradient|matrix3d|matrix|perspective|radial-gradient|repeating-linear-gradient|repeating-radial-gradient|rgba?|rotatex|rotatey|rotatez|rotate3d|rotate|scalex|scaley|scalez|scale3d|scale|skewx|skewy|skew|steps|translatex|translatey|translatez|translate3d|translate|url|var)/ig});;
Prism.languages.clike={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|(^|[^:])\/\/.*?(\r?\n|$))/g,lookbehind:!0},string:/("|')(\\?.)*?\1/g,"class-name":{pattern:/((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/ig,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/g,"boolean":/\b(true|false)\b/g,"function":{pattern:/[a-z0-9_]+\(/ig,inside:{punctuation:/\(/}}, number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g,operator:/[-+]{1,2}|!|&lt;=?|>=?|={1,3}|(&amp;){1,2}|\|?\||\?|\*|\/|\~|\^|\%/g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\];(),.:]/g};
;
Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(var|let|if|else|while|do|for|return|in|instanceof|function|new|with|typeof|try|throw|catch|finally|null|break|continue)\b/g,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?|NaN|-?Infinity)\b/g});Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,lookbehind:!0}});Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(&lt;|<)script[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/script(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)script[\w\W]*?(>|&gt;)|(&lt;|<)\/script(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript}}});
;
Prism.languages.php=Prism.languages.extend("clike",{keyword:/\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|extends|private|protected|parent|static|throw|null|echo|print|trait|namespace|use|final|yield|goto|instanceof|finally|try|catch)\b/ig, constant:/\b[A-Z0-9_]{2,}\b/g});Prism.languages.insertBefore("php","keyword",{delimiter:/(\?>|&lt;\?php|&lt;\?)/ig,variable:/(\$\w+)\b/ig,"package":{pattern:/(\\|namespace\s+|use\s+)[\w\\]+/g,lookbehind:!0,inside:{punctuation:/\\/}}});Prism.languages.insertBefore("php","operator",{property:{pattern:/(->)[\w]+/g,lookbehind:!0}}); Prism.languages.markup&&(Prism.hooks.add("before-highlight",function(a){"php"===a.language&&(a.tokenStack=[],a.code=a.code.replace(/(?:&lt;\?php|&lt;\?|<\?php|<\?)[\w\W]*?(?:\?&gt;|\?>)/ig,function(b){a.tokenStack.push(b);return"{{{PHP"+a.tokenStack.length+"}}}"}))}),Prism.hooks.add("after-highlight",function(a){if("php"===a.language){for(var b=0,c;c=a.tokenStack[b];b++)a.highlightedCode=a.highlightedCode.replace("{{{PHP"+(b+1)+"}}}",Prism.highlight(c,a.grammar,"php"));a.element.innerHTML=a.highlightedCode}}), Prism.hooks.add("wrap",function(a){"php"===a.language&&"markup"===a.type&&(a.content=a.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g,'<span class="token php">$1</span>'))}),Prism.languages.insertBefore("php","comment",{markup:{pattern:/(&lt;|<)[^?]\/?(.*?)(>|&gt;)/g,inside:Prism.languages.markup},php:/\{\{\{PHP[0-9]+\}\}\}/g}));;
Prism.languages.insertBefore("php","variable",{"this":/\$this/g,global:/\$_?(GLOBALS|SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/g,scope:{pattern:/\b[\w\\]+::/g,inside:{keyword:/(static|self|parent)/,punctuation:/(::|\\)/}}});;
Prism.languages.coffeescript=Prism.languages.extend("javascript",{"block-comment":/([#]{3}\s*\r?\n(.*\s*\r*\n*)\s*?\r?\n[#]{3})/g,comment:/(\s|^)([#]{1}[^#^\r^\n]{2,}?(\r?\n|$))/g,keyword:/\b(this|window|delete|class|extends|namespace|extend|ar|let|if|else|while|do|for|each|of|return|in|instanceof|new|with|typeof|try|catch|finally|null|undefined|break|continue)\b/g});Prism.languages.insertBefore("coffeescript","keyword",{"function":{pattern:/[a-z|A-z]+\s*[:|=]\s*(\([.|a-z\s|,|:|{|}|\"|\'|=]*\))?\s*-&gt;/gi,inside:{"function-name":/[_?a-z-|A-Z-]+(\s*[:|=])| @[_?$?a-z-|A-Z-]+(\s*)| /g,operator:/[-+]{1,2}|!|=?&lt;|=?&gt;|={1,2}|(&amp;){1,2}|\|?\||\?|\*|\//g}},"attr-name":/[_?a-z-|A-Z-]+(\s*:)| @[_?$?a-z-|A-Z-]+(\s*)| /g});;
Prism.languages.scss=Prism.languages.extend("css",{comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*?(\r?\n|$))/g,lookbehind:!0},atrule:/@[\w-]+(?=\s+(\(|\{|;))/gi,url:/([-a-z]+-)*url(?=\()/gi,selector:/([^@;\{\}\(\)]?([^@;\{\}\(\)]|&amp;|\#\{\$[-_\w]+\})+)(?=\s*\{(\}|\s|[^\}]+(:|\{)[^\}]+))/gm});Prism.languages.insertBefore("scss","atrule",{keyword:/@(if|else if|else|for|each|while|import|extend|debug|warn|mixin|include|function|return)|(?=@for\s+\$[-_\w]+\s)+from/i});Prism.languages.insertBefore("scss","property",{variable:/((\$[-_\w]+)|(#\{\$[-_\w]+\}))/i});Prism.languages.insertBefore("scss","ignore",{placeholder:/%[-_\w]+/i,statement:/\B!(default|optional)\b/gi,"boolean":/\b(true|false)\b/g,"null":/\b(null)\b/g,operator:/\s+([-+]{1,2}|={1,2}|!=|\|?\||\?|\*|\/|\%)\s+/g});
;
Prism.languages.bash=Prism.languages.extend("clike",{comment:{pattern:/(^|[^"{\\])(#.*?(\r?\n|$))/g,lookbehind:!0},string:{pattern:/("|')(\\?[\s\S])*?\1/g,inside:{property:/\$([a-zA-Z0-9_#\?\-\*!@]+|\{[^\}]+\})/g}},keyword:/\b(if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)\b/g});Prism.languages.insertBefore("bash","keyword",{property:/\$([a-zA-Z0-9_#\?\-\*!@]+|\{[^}]+\})/g});Prism.languages.insertBefore("bash","comment",{important:/(^#!\s*\/bin\/bash)|(^#!\s*\/bin\/sh)/g});
;
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/g,operator:/[-+]{1,2}|!=?|&lt;{1,2}=?|&gt;{1,2}=?|\-&gt;|={1,2}|\^|~|%|(&amp;){1,2}|\|?\||\?|\*|\//g});Prism.languages.insertBefore("c","keyword",{property:/#\s*[a-zA-Z]+/g});
;
Prism.languages.cpp=Prism.languages.extend("c",{keyword:/\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|delete\[\]|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|new\[\]|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/g,
operator:/[-+]{1,2}|!=?|&lt;{1,2}=?|&gt;{1,2}=?|\-&gt;|:{1,2}|={1,2}|\^|~|%|(&amp;){1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/g});
;
Prism.languages.sql={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|((--)|(\/\/)).*?(\r?\n|$))/g,lookbehind:!0},string: /("|')(\\?.)*?\1/g,keyword:/\b(ACTION|ADD|AFTER|ALGORITHM|ALTER|ANALYZE|APPLY|AS|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADE|CASCADED|CASE|CHAIN|CHAR VARYING|CHARACTER VARYING|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATA|DATABASE|DATABASES|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DOUBLE PRECISION|DROP|DUMMY|DUMP|DUMPFILE|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE|ESCAPED BY|EXCEPT|EXEC|EXECUTE|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR|FOR EACH ROW|FORCE|FOREIGN|FREETEXT|FREETEXTTABLE|FROM|FULL|FUNCTION|GEOMETRY|GEOMETRYCOLLECTION|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY|IDENTITY_INSERT|IDENTITYCOL|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEY|KEYS|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONGBLOB|LONGTEXT|MATCH|MATCHED|MEDIUMBLOB|MEDIUMINT|MEDIUMTEXT|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTILINESTRING|MULTIPOINT|MULTIPOLYGON|NATIONAL|NATIONAL CHAR VARYING|NATIONAL CHARACTER|NATIONAL CHARACTER VARYING|NATIONAL VARCHAR|NATURAL|NCHAR|NCHAR VARCHAR|NEXT|NO|NO SQL|NOCHECK|NOCYCLE|NONCLUSTERED|NULLIF|NUMERIC|OF|OFF|OFFSETS|ON|OPEN|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPTIMIZE|OPTION|OPTIONALLY|ORDER|OUT|OUTER|OUTFILE|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC|PROCEDURE|PUBLIC|PURGE|QUICK|RAISERROR|READ|READS SQL DATA|READTEXT|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURN|RETURNS|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROWCOUNT|ROWGUIDCOL|ROWS?|RTREE|RULE|SAVE|SAVEPOINT|SCHEMA|SELECT|SERIAL|SERIALIZABLE|SESSION|SESSION_USER|SET|SETUSER|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START|STARTING BY|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLE|TABLES|TABLESPACE|TEMPORARY|TEMPTABLE|TERMINATED BY|TEXT|TEXTSIZE|THEN|TIMESTAMP|TINYBLOB|TINYINT|TINYTEXT|TO|TOP|TRAN|TRANSACTION|TRANSACTIONS|TRIGGER|TRUNCATE|TSEQUAL|TYPE|TYPES|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNPIVOT|UPDATE|UPDATETEXT|USAGE|USE|USER|USING|VALUE|VALUES|VARBINARY|VARCHAR|VARCHARACTER|VARYING|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH|WITH ROLLUP|WITHIN|WORK|WRITE|WRITETEXT)\b/gi,boolean:/\b(TRUE|FALSE|NULL)\b/gi,number:/\b-?(0x)?\d*\.?[\da-f]+\b/g,operator:/\b(ALL|AND|ANY|BETWEEN|EXISTS|IN|LIKE|NOT|OR|IS|UNIQUE|CHARACTER SET|COLLATE|DIV|OFFSET|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b|[-+]{1}|!|=?&lt;|=?&gt;|={1}|(&amp;){1,2}|\|?\||\?|\*|\//gi,ignore:/&(lt|gt|amp);/gi,punctuation:/[;[\]()`,.]/g};;
Prism.languages.http={"request-line":{pattern:/^(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\b\shttps?:\/\/\S+\sHTTP\/[0-9.]+/g,inside:{property:/^\b(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\b/g,"attr-name":/:\w+/g}},"response-status":{pattern:/^HTTP\/1.[01] [0-9]+.*/g,inside:{property:/[0-9]+[A-Z\s-]+$/g}},keyword:/^[\w-]+:(?=.+)/gm};var httpLanguages={"application/json":Prism.languages.javascript,"application/xml":Prism.languages.markup,"text/xml":Prism.languages.markup,"text/html":Prism.languages.markup};for(var contentType in httpLanguages){if(httpLanguages[contentType]){var options={};options[contentType]={pattern:new RegExp("(content-type:\\s*"+contentType+"[\\w\\W]*?)\\n\\n[\\w\\W]*","gi"),lookbehind:true,inside:{rest:httpLanguages[contentType]}};Prism.languages.insertBefore("http","keyword",options)}}
;
Prism.languages.ruby=Prism.languages.extend("clike",{comment:/#[^\r\n]*(\r?\n|$)/g,keyword:/\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/g,builtin:/\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Fload|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,constant:/\b[A-Z][a-zA-Z_0-9]*[?!]?\b/g});Prism.languages.insertBefore("ruby","keyword",{regex:{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,lookbehind:true},variable:/[@$&]+\b[a-zA-Z_][a-zA-Z_0-9]*[?!]?\b/g,symbol:/:\b[a-zA-Z_][a-zA-Z_0-9]*[?!]?\b/g})
;
Prism.languages.csharp=Prism.languages.extend("clike",{keyword:/\b(abstract|as|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b/g,string:/@?("|')(\\?.)*?\1/g,preprocessor:/^\s*#.*/gm,number:/\b-?(0x)?\d*\.?\d+\b/g});
	
	Prism.highlightAll();
	
	module.resolve();
});
EasySocial.module( 'privacy' , function($) {

var module = this;

	EasySocial.require()
	.library( 'dialog' )
	.view( 'admin/profiles/form.privacy.custom.item' )
	.done(function($){

		EasySocial.Controller(
				'Profiles.Form.Privacy',
				{
					defaultOptions: {

						path: 'admin',

						// Elements
						"{selection}"			: ".privacySelection",
						"{browseButton}"    	: ".browseButton",
						"{userDeleteButton}"	: ".userDeleteButton",
						"{customContainer}"		: ".customContainer",

						view: {
							customItem : 'admin/profiles/form.privacy.custom.item'
						}

					}
				},
				function( self ){

					return {

						init: function()
						{

						},

						/**
						 * Binds the privacy's rule type select.
						 */
						"{selection} change" : function( el , event ){

							var selected	= $(el).val();
							var eleName		= $(el).attr( 'name' );

							if( selected == 'custom' )
							{
								self.customContainer().show();
							}
							else
							{
								self.customContainer().hide();
							}

						},

						"{userDeleteButton} click" : function( el, event ) {
							$(el).parents('li').remove();
						},

						"{browseButton} click" : function( el, event ) {


							var eleId		= $(el).attr( 'id' );
							var eleIndex 	= $(el).data('index');

							var userlistingpath = $.rootPath + 'administrator/index.php?option=com_easysocial&view=users&layout=listing&show=iframe';

							if( self.options.path == 'site' )
								userlistingpath = $.rootPath + 'index.php?option=com_easysocial&view=friends&layout=listing&show=iframe';

 							$.dialog({
 								title: 'Browse Users & Groups',
 								content: userlistingpath,
					            body: {
					                css: {
					                    width: 400,
					                    height: 300
					                }
					            },
								buttons: [
									{
										name : 'Assign',
										click : function(){

											var users = $('.foundryDialog').find('iframe').contents().find('input:checked');

											if( users.length > 0 )
											{
												for(var i = 0; i < users.length; i++)
												{
													var eleName = $(users[i]).attr('name');

													if( eleName == 'toggle')
														continue;

													var userId = $(users[i]).val();
													var userName = $('.foundryDialog').find('iframe').contents().find('input[name="user_' +userId+ '"]').val();

													var addedUsers = $('ul#privacy_ul' + eleIndex + ' input:hidden');
													var doAdd      = true;

													if( addedUsers.length > 0 )
													{
														for( var j=0; j < addedUsers.length; j++ )
														{
															if( $(addedUsers[j]).val() == userId )
															{
																doAdd = false;
																break;
															}
														}
													}

													if( doAdd )
													{
														html = self.view.customItem({
														 	userName : userName,
															eleName : eleId,
															userId  : userId
														});

														$('ul#privacy_ul' + eleIndex ).append( html );
													}
												}
											}

											//$("#google").contents().find("#hplogo").remove());

											$.dialog().close();
										}
									},
									{
										name : 'Close',
										click : function(){
											$.dialog().close();
										}
									}

								]
 							});



						}


					} //end return
				}//end function(self)
		);

		module.resolve();
	});

});

EasySocial.module('sharing', function($) {

	var module = this;

	EasySocial.require().library('textboxlist').done(function() {

		EasySocial.Controller('Sharing', {
			defaultOptions: {
				'{vendors}'		: '[data-sharing-vendor]',

				'{emailForm}'	: '[data-sharing-email]'
			}
		}, function(self) {
			return {
				init: function() {
					self.initLinks();

					self.initEmail();
				},

				initLinks: function() {
					$.each(self.vendors(), function(i, vendor) {

						vendor = $(vendor);

						if(!vendor.data('loaded')) {

							// Extract the href
							var link = vendor.attr('href');

							// Assign it to a data
							vendor.data('href', link);

							// Assign a void to the href
							vendor.attr('href', 'javascript:void(0);');

							// Assign loaded state
							vendor.attr('loaded', true);
						}
					});
				},

				initEmail: function() {
					$.each(self.emailForm(), function(i, form) {

						form = $(form);

						if(!form.data('loaded')) {

							// Implement email form controller
							self.addPlugin('email');

							// Assign loaded state
							form.attr('loaded', true);
						}
					});
				},

				'{vendors} click': function(el, ev) {
					var optionString = el.data('options') || '';

					window.open(el.data('href'), '', optionString);
				}
			}
		});

		$.template('sharing/recipientContent', '[%= title %]<input type="hidden" name="items" value="[%= title %]" />');

		EasySocial.Controller('Sharing.Email', {
			defaultOptions: {
				token			: '',

				'{container}'	: '[data-sharing-email]',

				'{frames}'		: '[data-sharing-email-frame]',

				'{recipients}'	: '[data-sharing-email-recipients]',

				'{input}'		: '[data-sharing-email-input]',

				'{content}'		: '[data-sharing-email-content]',

				'{send}'		: '[data-sharing-email-send]',

				// Frames
				'{frames}'		: '[data-sharing-email-frame]',

				'{frameForm}'	: '[data-sharing-email-form]',

				'{frameSending}': '[data-sharing-email-sending]',

				'{frameDone}'	: '[data-sharing-email-done]',

				'{frameFail}'	: '[data-sharing-email-fail]',

				'{failMsg}'		: '[data-sharing-email-fail-msg]'
			}
		}, function(self) {
			return {
				init: function() {

					self.options.token = self.container().data('token');

					// Initiate textboxlist plugin
					var test = self.recipients().textboxlist({
						component: 'es',
						view: {
							itemContent: 'sharing/recipientContent'
						}
					});

					self.originalPosition = self.container().css('position');
				},

				getRecipients: function() {
					var items = self.recipients().controller('textboxlist').getAddedItems();

					var recipients = [];

					$.each(items, function(i, item) {
						recipients.push(item.title);
					});

					var input = self.input().val();

					if(recipients.length < 1 && !$.isEmpty(input)) {
						recipients.push(input);
					}

					return recipients;
				},

				getContent: function() {
					return self.content().val();
				},

				'{send} click': function(el, ev) {
					if(el.enabled()) {
						el.disabled(true);

						// Control frames
						self.frames().hide();
						self.frameSending().show();

						// Get the data
						var token = self.options.token,
							recipients = self.getRecipients(),
							content = self.getContent();

						/// Make the ajax call
						self.submitForm(token, recipients, content)
							.done(function() {
								// Control frames
								self.frames().hide();
								self.frameDone().show();

								// Show the form after 1 second
								setTimeout(function() {
									// Clear recipients
									self.recipients().controller('textboxlist').clearItems();

									// Clear content
									self.content().val('');

									// Control frames
									self.frameDone().hide();
									self.frameForm().show();
								}, 1000);
							})
							.fail(function(msg) {
								// Control frames
								self.frames().hide();
								self.frameFail().show();
								self.frameForm().show();

								if(msg !== undefined) {
									self.failMsg().html(msg);
								}
							})
							.always(function() {
								el.enabled(true);
							});
					}

				},

				// Add email address in if comma is pressed
				'{input} keypress': function(el, ev) {
					if(ev.which === 44) {
						self.recipients().controller('textboxlist').addItem(el.val());
						el.val('');
						return false;
					}
				},

				submitForm: function(token, recipients, content) {
					return EasySocial.ajax('site/controllers/sharing/send', {
						token: token,
						recipients: recipients,
						content: content
					});
				}
			}
		});

		module.resolve();

	});
});

EasySocial.module( 'site/activities/activities' , function($){

	var module	= this;

	EasySocial.require()
	.script( 'site/activities/sidebar', 'site/activities/sidebar.item' )
	.view( 'site/loading/small' )
	.done(function($){

		EasySocial.Controller(
		'Activities',
		{
			defaultOptions:
			{
				// Properties
				items		: null,

				// Elements
				"{container}"	: "[data-activities]",

				"{contentTitle}": "[data-activities-content-title]",
				"{content}"		: "[data-activities-content]",
				"{sidebar}"		: "[data-activities-sidebar]",


				"{sidebarItem}"	: "[data-sidebar-item]",

				view :
				{
					loadingContent 	: "site/loading/small"
				}
			}
		},
		function( self ){
			return {

				init : function()
				{
					// Implement sidebar controller.
					self.sidebar().implement( EasySocial.Controller.Activities.Sidebar ,
					{
						"{parent}"	: self
					});

					self.sidebarItem().implement( EasySocial.Controller.Activities.Sidebar.Item ,
					{
						"{parent}"	: self
					});					
				},


				/**
				 * Add a loading icon on the content layer.
				 */
				updatingContents: function()
				{
					self.content().html( self.view.loadingContent() );
				},				

				updateContent: function( content, title )
				{
					self.content().html( content );
					self.contentTitle().html( title );
				}
							
			}
		});

		module.resolve();
	});

});
EasySocial.module( 'site/activities/sidebar' , function($){

	var module	= this;

	EasySocial.require()
	.done(function($){

		EasySocial.Controller(
			'Activities.Sidebar',
			{
				defaultOptions:
				{
					"{menuItem}"	: "[data-sidebar-menu]"
				}
			},
			function( self ){
				return {

					init: function()
					{
					},

					"{menuItem} click" : function( el , event )
					{
						// Remove all active class.
						self.menuItem().removeClass( 'active' );

						// Add active class on this item.
						$( el ).addClass( 'active' );
					}
				}
			});

		module.resolve();
	});

});
EasySocial.module( 'site/activities/sidebar.item' , function($){

	var module	= this;

	EasySocial.require()
	.library( 'history' )
	.done(function($){

		EasySocial.Controller(
			'Activities.Sidebar.Item',
			{
				defaultOptions:
				{
				}
			},
			function( self ){
				return {

					init: function()
					{
					},

					"{self} click" : function( el , event )
					{

						var type 	= self.element.data( 'type' ),
							url 	= self.element.data( 'url' ),
							title 	= self.element.data( 'title' ),
							desc 	= self.element.data( 'description' );

						// If this is an embedded layout, we need to play around with the push state.
						History.pushState( {state:1} , title , url );

						self.parent.updatingContents();

						//ajax call here.
						EasySocial.ajax( 'site/controllers/activities/getActivities',
						{
							"type"		: type
						})
						.done(function( html )
						{
							self.parent.updateContent( html, title );	
						})
						.fail(function( message ){
							console.log( message );
						});

						self.parent.updateContent();
					}
				}
			});

		module.resolve();
	});

});
EasySocial.module( 'site/activities/apps' , function($){

	var module	= this;

	EasySocial.require()
	.view( 'site/loading/small' )
	.language( 'COM_EASYSOCIAL_ACTIVITY_APPS_UNHIDE_SUCCESSFULLY', 'COM_EASYSOCIAL_ACTIVITY_USERS_UNHIDE_SUCCESSFULLY' )
	.done(function($){


		EasySocial.Controller(
			'Activities.Apps.List',
			{
				defaultOptions:
				{
					// Elements
					"{item}"	: "[data-hidden-app-item]",

					"{actorItem}"	: "[data-hidden-actor-item]",


					// loading gif
					view :
					{
						loadingContent 	: "site/loading/small"
					}

				}
			},
			function( self ){
				return {

					init : function()
					{
						self.item().implement( EasySocial.Controller.Activities.Apps.Item );
						self.actorItem().implement( EasySocial.Controller.Activities.Actors.Item );
					}

				}
			});

		EasySocial.Controller(
			'Activities.Actors.Item',
			{
				defaultOptions:
				{
					// Properties
					id 			: "",
					actor 	: "",

					"{unhideLink}" : "[data-hidden-actor-unhide]",

					"{content}" : "[data-hidden-actor-content]",

					// loading gif
					view :
					{
						loadingContent 	: "site/loading/small"
					}

				}
			},
			function( self ){
				return {

					init : function()
					{
						self.options.id 	= self.element.data( 'id' );
						self.options.actor 	= self.element.data( 'actor' );
					},

					"{unhideLink} click" : function(){

						EasySocial.ajax( 'site/controllers/activities/unhideactor',
						{
							"actor"		: self.options.actor,
							"id" 		: self.options.id
						})
						.done(function()
						{
							self.content().html( $.language( 'COM_EASYSOCIAL_ACTIVITY_USERS_UNHIDE_SUCCESSFULLY' ) );

						})
						.fail(function( message ){
							console.log( message );
						});

					}

				}
			});


		EasySocial.Controller(
			'Activities.Apps.Item',
			{
				defaultOptions:
				{
					// Properties
					id 			: "",
					context 	: "",

					"{unhideLink}" : "[data-hidden-app-unhide]",

					"{content}" : "[data-hidden-app-content]",

					// loading gif
					view :
					{
						loadingContent 	: "site/loading/small"
					}

				}
			},
			function( self ){
				return {

					init : function()
					{
						self.options.id 		= self.element.data( 'id' );
						self.options.context 	= self.element.data( 'context' );
					},

					"{unhideLink} click" : function(){

						EasySocial.ajax( 'site/controllers/activities/unhideapp',
						{
							"context"		: self.options.context,
							"id" 			: self.options.id
						})
						.done(function()
						{
							self.content().html( $.language( 'COM_EASYSOCIAL_ACTIVITY_APPS_UNHIDE_SUCCESSFULLY' ) );

						})
						.fail(function( message ){
							console.log( message );
						});

					}

				}
			});



		module.resolve();
	});

});

EasySocial.module( 'site/activities/item' , function($){

	var module	= this;

	EasySocial.require()
	.script()
	.done(function($){

		EasySocial.Controller(
			'Activities.Item',
			{
				defaultOptions:
				{
					// Elements
					"{toggle}"		: "[data-activity-toggle]",
					"{deleteBtn}"	: "[data-activity-delete]"

				}
			},
			function( self ){
				return {

					init : function()
					{
						// Implement sidebar controller.
					},

					"{toggle} click" : function( el , event )
					{
						EasySocial.ajax( 'site/controllers/activities/toggle',
						{
							"id"		: self.element.data('id'),
							"curState" 	: self.element.data('current-state')
						})
						.done(function( lbl, isHidden)
						{
							$( el ).text( lbl );
							self.element.data('current-state', isHidden);

							if( isHidden )
							{
								self.element.children( "div.es-stream" ).addClass( 'isHidden' );
							}
							else
							{
								self.element.children( "div.es-stream" ).removeClass( 'isHidden' );
							}
						})
						.fail(function( message ){

							console.log( message );
						});
					},

					"{deleteBtn} click" : function()
					{
						var uid = self.element.data('id');

						EasySocial.dialog({
							content		: EasySocial.ajax( 'site/views/activities/confirmDelete' ),
							bindings	:
							{
								"{deleteButton} click" : function()
								{
									EasySocial.ajax( 'site/controllers/activities/delete',
									{
										"id"		: uid,
									})
									.done(function( html )
									{
										self.element.fadeOut();

										// close dialog box.
										EasySocial.dialog().close();
									});
								}
							}
						});

					}


				}
			});

		module.resolve();
	});

});

EasySocial.module( 'site/activities/list' , function($){

	var module	= this;

	EasySocial.require()
	.view( 'site/loading/small', 'site/activities/loadbutton' )
	.language( 'COM_EASYSOCIAL_ACTIVITY_LOG_LOAD_PREVIOUS_STREAM_ITEMS' )
	.script('site/activities/item')
	.done(function($){

		EasySocial.Controller(
			'Activities.List',
			{
				defaultOptions:
				{
					// Elements
					"{item}"	: "[data-activity-item]",


					"{pagination}"  : "[data-activity-pagination]",

					// loading gif
					view :
					{
						loadingContent 	: "site/loading/small",
						loadmoreContent :"site/activities/loadbutton"
					}

				}
			},
			function( self ){
				return {

					init : function()
					{
						// self.item()
						// 	.addController(
						// 		"EasySocial.Controller.Activities.Item"
						// 	);

						self.item().implement( EasySocial.Controller.Activities.Item );

						self.on("scroll.activities", window, $._.debounce(function(){

							if (self.loading) return;

							if (self.pagination().visible()) {

								self.loadMore();
							}

						}, 250));
					},

					"{pagination} click" : function() {
						self.loadMore();
					},

					loadMore: function() {

						var type 		= $("[data-sidebar-menu].active").data( 'type' );
						var startlimit 	= self.pagination().data('startlimit');

						if( startlimit == '')
						{
							return;
						}

						self.loading = true;

						self.pagination().html( self.view.loadingContent({content: ""}) );

						EasySocial.ajax( 'site/controllers/activities/getActivities' ,
						{
							"limitstart" : startlimit,
							"loadmore" : '1',
							"type" : type
						})
						.done(function( contents, startlimit ) {
							// update next start date
							self.pagination().data('startlimit', startlimit );

							// append stream into list.
							self.pagination().before( contents );

							//re-implement controller on new items
							self.item().implement( EasySocial.Controller.Activities.Item );

							if (startlimit=="") {
								self.pagination().html('');
							} else {
								//append the anchor link.
								self.pagination().html( self.view.loadmoreContent() );
							}

						})
						.fail( function( messageObj ){
							return messageObj;
						})
						.always(function(){
							self.loading = false;
						});
					}




				}
			});

		module.resolve();
	});

});

EasySocial.module( 'site/albums/all' , function($){

	var module 				= this;

	EasySocial.require()
	.library( 'history' )
	.done(function($){

		EasySocial.Controller( 'Albums.All.Browser',
		{
			defaultOptions:
			{
				"{sort}"	: "[data-albums-sort]",
				"{contents}": "[data-albums-content]"
			}
		},
		function( self )
		{
			return{ 

				init: function() {
				},

				setActiveSort: function(el) {
					self.sort().removeClass('active');

					$(el).addClass('active');
				},

				"{sort} click" : function(el, event) {
					event.preventDefault();
						
					self.setActiveSort(el);

					$(el).route();

					// Set loading state for the content
					self.contents().addClass('is-loading');
					self.contents().html('&nbsp;');

					var sorting = el.data('albums-sort-type');

					// Run the ajax call now
					EasySocial.ajax('site/controllers/albums/getAlbums', {
						"sort": sorting
					}).done(function(contents) {
						self.contents().html(contents);
					});
				}
			}
		});

		module.resolve();
	
	});


});

EasySocial.module( 'site/apps/apps' , function($){

	var module 				= this;

	EasySocial.require()
	.library( 'history' )
	.view(
		'site/loading/small'
	)
	.done(function($){

		EasySocial.Controller(
			'Apps',
			{
				defaultOptions :
				{
					requireTerms	: true,
					"{content}"	: "[data-apps-listing]",
					"{sort}"	: "[data-apps-sort]",
					"{filter}"	: "[data-apps-filter]",
					"{filterLink}" : "[data-apps-filter-link]",
					"{item}"	: "[data-apps-item]",
					"{sorting}"	: "[data-apps-sorting]",
					"{title}"	: "[data-page-apps-title]",

					view :
					{
						loading 	: 'site/loading/small'
					}
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						// Implement apps item controller.
						self.initAppItem();
					},

					initAppItem : function()
					{
						self.item().implement( EasySocial.Controller.Apps.Item ,
						{
							requireTerms 	: self.options.requireTerms
						});
					},

					"{filterLink} click": function( el , event )
					{
						event.preventDefault();
					},

					"{filter} click" : function( el , event )
					{
						// Remove all active classes on the left
						self.sort().removeClass('active');
						self.filter().removeClass('active');

						// Add active class to the current filter item.
						el.addClass( 'active' );

						el.find( 'a' ).route();

						// Get the sort type.
						var filter 	= el.data( 'apps-filter-type' );

						// Get the sort group
						var group = el.data( 'apps-filter-group' );

						// Set the title.
						var title 	= el.find( 'a' ).attr( 'title' );
						self.title().html( title );

						// Set the current active filter
						self.options.filter 	= filter;

						// If the filter is 'mine' , we don't want to show the sorting options
						if (filter == 'mine') {
							self.sorting().hide();
						} else {
							self.sorting().show();
						}

						EasySocial.ajax( 'site/controllers/apps/getApps', {
							"filter": filter,
							"group": group
						}, {
							
							beforeSend: function() {
								// Set the default sorting type to alphabetically ordered.
								self.sort('.alphabetical').addClass('active');

								self.content().html( self.view.loading() );
							}
						}).done(function(output) {

							// Set is-empty class on the content so the empty message will be displayed
							self.content().toggleClass("is-empty", $(output).hasClass("empty"));

							// Append the output back.
							self.content().html(output);

							// Reapply the item controller
							self.initAppItem();
						});
					},

					"{sort} click" : function( el , event )
					{
						// Get the sort type and filter type.
						var type = el.data('apps-sort-type'),
							url = el.data('apps-sort-url'),
							group = el.data('apps-sort-group');

						History.pushState({state:1}, '' , url);

						// Add the active state on the current element.
						self.sort().removeClass( 'active' );

						el.addClass( 'active' );

						EasySocial.ajax( 'site/controllers/apps/getApps',
						{
							"sort"	: type,
							"filter": self.options.filter,
							"group"	: group
						},
						{
							beforeSend: function()
							{
								self.content().html( self.view.loading() );
							}
						})
						.done( function( output )
						{

							// Append the output back.
							self.content().html( output );

							// Reapply the item controller
							self.initAppItem();
						});
					}
				}
			});

		EasySocial.Controller(
			'Apps.Item',
			{
				defaultOptions :
				{
					id				: null,
					requireTerms 	: true,

					"{install}"		: "[data-apps-item-install]",
					"{installed}"	: "[data-apps-item-installed]",
					"{settings}"	: "[data-apps-item-settings]",

					view :
					{
						installAppForm : "site/apps/dialog.install",
						uninstallAppForm: "site/apps/dialog.uninstall"
					}
				}
			},
			function( self ) {
				return {

					init : function() {
						if(self.element.data('id')) {
							self.options.id = self.element.data('id');
						}
					},

					"{install} click" : function( el )
					{
						EasySocial.dialog({
							content: EasySocial.ajax('site/views/apps/getTnc' ),
							bindings:
							{
								'{cancelButton} click': function() {
									EasySocial.dialog().close();
								},

								'{installButton} click': function(el)
								{
									var agreed = !self.options.requireTerms || this.agreeCheckbox().is(':checked');

									if( agreed )
									{
										this.termsError().hide();

										self.installApp();
									}
									else
									{
										this.termsError().show();
									}
								}
							}
						});
					},

					installApp: function()
					{

						var installing = EasySocial.ajax('site/controllers/apps/installApp', {
							id: self.options.id
						});

						EasySocial.dialog({
							content: installing,
							bindings:
							{
								"{closeButton} click" : function(){
									EasySocial.dialog().close();
								}
							}
						});

						installing.done(function()
						{
							self.install().enabled(true);

							self.install().hide();

							self.installed().show();

							self.settings().hide();
						});
					},

					"{settings} click" : function( el , event )
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( "site/views/apps/settings" , { "id" : self.options.id } ),
							bindings	:
							{
							}
						})
					},

					'{installed} click': function(el) {
						if(el.enabled()) {

							el.disabled(true);

							EasySocial.dialog({
								content		: EasySocial.ajax('site/views/apps/confirmUninstall'),
								bindings	:
								{
									'{parent.closeButton} click': function() {
										self.installed().enabled(true);
									},

									'{cancelButton} click': function() {
										self.installed().enabled(true);

										EasySocial.dialog().close();
									},

									'{uninstallButton} click': function()
									{
										self.uninstallApp();
									}
								}
							});
						}
					},

					uninstallApp: function() {
						var uninstalling = EasySocial.ajax('site/controllers/apps/uninstallApp', {
							id: self.options.id
						});

						EasySocial.dialog({
							content: uninstalling,
							bindings:
							{
								'{closeButton} click' : function()
								{
									EasySocial.dialog().close();
								}
							}
						});

						uninstalling.done(function()
						{
							self.installed().enabled(true);

							self.installed().hide();

							self.settings().hide();

							self.install().show();
						});
					}
				}
			});

		module.resolve();
	});


});

EasySocial.module('site/badges/badge', function($) {
	var module = this;

	EasySocial.Controller('Badges.Badge', {
		defaultOptions: {
			id					: 0,
			total				: 0,

			'{achieversList}'	: '[data-badge-achievers-list]',

			'{achiever}'		: '[data-badge-achievers-achiever]',

			'{loadIndicator}'	: '[data-badge-achievers-loading]',

			'{loadButton}'		: '[data-badge-achievers-load]',
		}
	}, function(self) {
		return {
			init: function() {
				self.options.id = self.element.data('id');
				self.options.total = self.element.data('total-achievers');
			},

			'{loadButton} click': function(el) {
				var current = self.achiever().length;

				if(el.enabled() && current < self.options.total) {
					el.disabled(true);

					el.hide();

					self.loadIndicator().show();

					EasySocial.ajax('site/controllers/badges/loadAchievers', {
						id: self.options.id,
						start: current
					}).done(function(html) {

						self.achieversList().append(html);

						el.enabled(true);

						self.loadIndicator().hide();

						if(self.achiever().length < self.options.total) {
							el.show();
						}

					}).fail(function(msg) {

					});
				}
			},

			loadAchievers: function() {

			}
		}
	});

	module.resolve();
});

EasySocial.module('site/comments/control', function($) {
	var module = this;

	/**
	 *	Comments update controller
	 *	Should only exist once on the page
	 *	Act as a data handler between server and client for comments update (add/delete/edit etc)
	 *	Global functions should be here as well
	 */

	EasySocial.Controller('CommentsControl', {
		defaultOptions: {
			interval: 30
		}
	}, function(self) { return {
		init: function() {
			self.startUpdate();
		},

		// Comments block registry
		$Blocks: {},

		startUpdate: function() {
			self.options.monitoring = true;
			self.updateBlocks();
		},

		stopUpdate: function() {
			self.options.monitoring = false;
		},

		updateBlocks: function(){

			(self.updateBlocks = $._.debounce(function() {

				var data = self.populate();

				if (!self.options.monitoring) {
					return false;
				}

				EasySocial.ajax('site/controllers/comments/getUpdates', {
					data: data
				}).done(function(result) {

					// Push updates to each comment block
					$.each(result, function(element, block) {
						$.each(block, function(uid, comments) {

							var comment = self.$Blocks[element][uid];

							if (comment._destroyed) return;

							comment.updateComment(comments);
						});
					});

				}).always(function() {

					self.updateBlocks();
				});
			}, self.options.interval * 1000))();
		},

		register: function(instance) {
			var group = instance.options.group,
				element = instance.options.element,
				streamid = instance.options.streamid,
				uid = instance.options.uid,
				verb = instance.options.verb;

			if (streamid == '') {
				streamid = '0';
			}

			var key = element + '.' + group + '.' + verb;

			if(self.$Blocks[key] === undefined) {
				self.$Blocks[key] = {};
			}

			// we need to use the stream id + uid so that for those aggregated items,
			// we can still get the comments correctly for each individual items. E.g. upload mulitple photos will create same stream id for each photo items.
			var blockkey = streamid + '.' + uid;

			self.$Blocks[key][blockkey] = instance;

			instance.trigger('commentBlockRegistered');
		},

		populate: function() {
			var data = {};

			$.each(self.$Blocks, function(key, block) {
				data[key] = {};

				$.each(block, function(blockkey, comments) {
					data[key][blockkey] = comments._export();
				});
			});

			return data;
		}
	} });


	EasySocial.ready(function(){

		// Implement this controller on to es-wrap
		EasySocial.Comments = $('body').addController('EasySocial.Controller.CommentsControl');

		module.resolve();
	});

});

EasySocial.module('site/comments/frame', function($) {
	var module = this;

	EasySocial
		.require()
		.library('mentions')
		.script('site/comments/item', 'uploader/uploader')
		.view(
			"site/friends/suggest.item",
			"site/friends/suggest.hint.search",
			"site/friends/suggest.hint.empty",
			"site/hashtags/suggest.item",
			"site/hashtags/suggest.hint.search",
			"site/hashtags/suggest.hint.empty"
		)
		.language(
			'COM_EASYSOCIAL_COMMENTS_LOADED_OF_TOTAL',
			'COM_EASYSOCIAL_COMMENTS_STATUS_SAVING',
			'COM_EASYSOCIAL_COMMENTS_STATUS_SAVED'
		)
		.done(function() {

			EasySocial.Controller('Comments', {
				defaultOptions: {

					'group': 'user',
					'element': 'stream',
					'verb': 'null',
					'uid': 0,
					'enterkey': 'submit',
					'url': '',
					'streamid': '',

					'{actionContent}': '[data-action-contents-comments]',
					'{actionLink}': '[data-stream-action-comments]',
					'{stat}': '[data-comments-stat]',
					'{load}': '[data-comments-load]',
					'{list}': '[data-comments-list]',
					'{item}': '[data-comments-item]',
					'{form}': '[data-comments-form]'
				}
			}, function(self) { return {

				// List all the triggers here made to parent
				// newCommentSaving
				// newCommentSaved(comment)
				// newCommentSaveError(errormsg)
				// oldCommentsLoaded(comments)
				// oldCommentsLoadError(errormsg)
				// commentDeleted(id)

				// Item triggers
				// commentEditLoading(id)
				// commentEditLoaded(id, rawcomment)
				// commentEditLoadError(id, errormsg)
				// commentEditSaving(id, newcomment)
				// commentEditSaved(id, newcomment)
				// commentEditSaveError(id, errormsg)
				// commentDeleting(id)
				// commentDeleteError(id, errormsg)

				init: function() {
					// Initialise uid
					self.options.uid = self.element.data('uid') || self.options.uid;

					// Initialise element
					self.options.element = self.element.data('element') || self.options.element;

					// Initialise group
					self.options.group = self.element.data('group') || self.options.group;

					// Initialise verb
					self.options.verb = self.element.data('verb') || self.options.verb;

					// Initialise url
					self.options.url = self.element.data('url') || self.options.url;

					// Initialise streamid
					self.options.streamid = self.element.data('streamid') || self.options.streamid;

					self.$Stat = self.addPlugin('stat');
					self.$Load = self.addPlugin('load');
					self.$List = self.addPlugin('list');
					self.$Form = self.addPlugin('form');

					// Comment Control needs to be required once when there is a frame on the page
					EasySocial.require().script('site/comments/control').done(function() {

						// This block needs to be registered
						EasySocial.Comments.register(self);
					});

					// Trigger commentInit on self
					self.trigger('commentInit', [self]);
				},

				// Create a registry of items
				$Comments: {},

				registerComment: function(instance) {
					var id = instance.options.id;

					self.$Comments[id] = instance;
				},

				'{actionLink} click' : function(){
					self.actionContent().toggle();
				},

				_export: function() {
					var data = {
						total: self.$Stat.total(),
						count: self.$Stat.count(),
						ids: $._.keys(self.$Comments)
					};

					return data;
				},

				updateComment: function(comments) {
					var newComments = [];

					$.each(comments['ids'], function(commentid, state) {
						if(state !== true) {
							if(state === false) {

								// Trigger commentDeleted event on self (as parent)
								self.trigger('commentDeleted', [commentid]);

							} else {
								var appended = false;

								// Search for the next larger id as the node to insert before
								$.each(self.$Comments, function(id, comment) {
									if(id > commentid) {
										self.$List.addToList(state, id, false);

										appended = true;
										return false;
									}
								});

								// If no node found, then just append it to the list
								if(!appended) {
									self.$List.addToList(state, 'append', false);
								}

								// Add this comment into the list of new comments
								newComments.push(state);
							}
						}
					});

					// Update the new total count
					self.$Stat.total(comments['total']);

					// Trigger oldCommentsLoaded event
					self.trigger('oldCommentsLoaded', [newComments]);
				},

				'{self} show': function() {
					self.element.show();

					self.$Form.input().focus();
				}
			} });
			/**
			 *	List controller
			 */
			EasySocial.Controller('Comments.List', {
				defaultOptions: {
					'{list}': '[data-comments-list]',

					'{item}': '[data-comments-item]'
				}
			}, function(self) { return {
				init: function() {
					// Multiple instances of items
					self.initItemController(self.item(), false);
				},

				initItemController: function(item, isNew) {
					item.addController('EasySocial.Controller.Comments.Item', {
						controller: {
							parent: self.parent
						},

						isNew: isNew
					});

					return item;
				},

				'{parent} newCommentSaved': function(el, event, comment) {
					// Add the comment to the list
					self.addToList(comment);
				},

				addToList: function(comment, type, isNew) {
					// Set type to append by default
					type = type === undefined ? 'append' : type;

					// Set isNew to true by default
					isNew = isNew === undefined ? true : isNew;

					// Wrap comment in jQuery
					comment = $(comment);

					// Implement item controller on comment
					self.initItemController(comment, isNew);

					// Check if type is append/prepend
					if(type == 'append' || type == 'prepend') {

						// Prepare function values based on type (append/prepend)
						var filter = type == 'append' ? ':last' : ':first',
							action = type == 'append' ? 'after' : 'before';

						// Add the comment item into list
						if(self.item().length === 0) {
							// If no comments yet then add the html into the list
							self.list().html(comment);
						} else {
							// If there are existing comments, then append/prepend comment into the list
							self.item(filter)[action](comment);
						}
					} else {

						// If type is neither append or prepend, then type could be the comment id
						var item = self.parent.$Comments[type];

						// Check if type is a valid comment, if it is then by this means prepend on top
						if(item !== undefined) {
							item.element.before(comment);
						}
					}

					// Show the whole comment block because the block could be hidden
					self.parent.actionContent().show();
				},

				'{parent} commentDeleted': function(el, event, id) {
					// Remove this comment from comment registry
					if(self.parent.$Comments[id] !== undefined) {

						// Remove the element
						self.parent.$Comments[id].element.remove();

						// Remove the controller reference in the registry
						delete self.parent.$Comments[id];
					}
				}
			} });

			/**
			 *	Statistic controller
			 */
			EasySocial.Controller('Comments.Stat', {
				defaultOptions: {
					'{stats}'	: '[data-comments-stats]',

					count	: 0,
					total	: 0,

					limit	: 10
				}
			}, function(self) { return {
				init: function() {
					self.options.count = self.element.data('count');
					self.options.total = self.element.data('total');
				},

				// Get / set total comments
				total: function(count) {
					if(count !== undefined) {
						self.options.total = parseInt(count);
						self.stats().text($.language('COM_EASYSOCIAL_COMMENTS_LOADED_OF_TOTAL', self.count(), self.total()));
					}

					return self.options.total;
				},

				// Get / set current comments
				count: function(count) {
					if(count !== undefined) {
						self.options.count = parseInt(count);
						self.stats().text($.language('COM_EASYSOCIAL_COMMENTS_LOADED_OF_TOTAL', self.count(), self.total()));
					}

					return self.options.count;
				},

				getNextCycle: function() {
					var start = Math.max(self.total() - self.count() - self.options.limit, 0);

					var limit = self.total() - self.count() - start;

					return {
						start: start,
						limit: limit
					}
				},

				'{parent} oldCommentsLoaded': function(el, event, comments) {
					var count = comments.length;

					self.count(self.count() + count);
				},

				'{parent} newCommentSaved': function() {
					self.total(self.total() + 1);

					self.count(self.count() + 1);
				},

				'{parent} commentDeleted': function() {
					self.total(self.total() - 1);

					self.count(self.count() - 1);
				}
			} });

			EasySocial.Controller('Comments.Load', {
				defaultOptions: {
					'{load}'		: '[data-comments-load]',
					'{loadMore}'	: '[data-comments-load-loadMore]'
				}
			}, function(self) { return {
				init: function() {

				},

				'{loadMore} click': function(el, event) {
					if(el.enabled()) {

						// Disable the button
						el.disabled(true);

						// Get boundary details
						var cycle = self.parent.$Stat.getNextCycle();

						// If limit is 0, means no comment to load
						if(cycle.limit == 0) {
							return false;
						}

						// Send load comments command to the server
						self.loadComments(cycle.start, cycle.limit)
							.done(function(comments) {
								// Comments come in with chronological order array
								// Hence need to reverse comment and prepend from bottom

								// Create a copy of reverse comments to not affect the original array
								// Slice is to create a non reference copy of the array
								var reversedComments = comments.slice().reverse();

								$.each(reversedComments, function(index, comment) {
									self.parent.$List.addToList(comment, 'prepend', false);
								});

								// Trigger oldCommentsLoaded event
								self.parent.trigger('oldCommentsLoaded', [comments]);

								// Enable the button
								el.enabled(true);

								// If start is 0, means this is the last round of comments to load
								cycle.start == 0 && self.load().hide();
							})
							.fail(function(msg) {

								// Trigger oldCommentsLoadError event
								self.parent.trigger('oldCommentsLoadError', [msg]);
							});
					}
				},

				loadComments: function(start, limit) {
					limit = limit || 10;
					return EasySocial.ajax('site/controllers/comments/load', {
						uid: self.parent.options.uid,
						element: self.parent.options.element,
						group: self.parent.options.group,
						verb: self.parent.options.verb,
						start: start,
						length: limit
					});
				}
			} });

			/**
			 *	Form controller
			 */
			EasySocial.Controller('Comments.Form', {
				
				defaultOptions: {
					'{editorHeader}': '[data-comment-form-header]',
					'{editorArea}': '[data-comment-form-editor-area]',
					'{input}': '[data-comments-form-input]',
					'{submit}': '[data-comments-form-submit]',
					'{status}': '[data-comments-form-status]',
					
					// Smileys
					"{smileyLink}": "[data-comment-smileys]",
					"{smileyItem}": "[data-comment-smiley-item]",

					// Attachments
					"{attachmentQueue}": "[data-comment-attachment-queue]",
					"{attachmentProgress}": "[data-comment-attachment-progress-bar]",
					"{attachmentBackground}": "[data-comment-attachment-background]",
					"{attachmentRemove}": "[data-comment-attachment-remove]",
					"{attachmentItem}": "[data-comment-attachment-item]",

					"{attachmentDelete}": "[data-comment-attachment-delete]",

					"{uploaderForm}": "[data-uploader-form]",
					"{itemTemplate}": "[data-comment-attachment-template]",

					attachmentIds:[],

					view: {
						suggestItem: "site/friends/suggest.item",
						tagSuggestItem: "site/hashtags/suggest.item"
					}
				}
			}, function(self, opts, base, parent) { return {

				init: function() {

					// Assign the parent
					parent = self.parent;

					// Apply the mentions on the comment form
					self.setMentionsLayout();

					// Implement attachments on the comment form.
					if (parent.options.attachments) {
						self.implementAttachments();
					}

				},

				attachmentTemplate: null,

				getAttachmentTemplate: function() {

					if (!self.attachmentTemplate) {
						self.attachmentTemplate = self.itemTemplate().detach();
					}

					var tpl = $(self.attachmentTemplate).clone().html();

					return $(tpl);
				},
				
				implementAttachments: function() {

					// Implement uploader controller
					self.editorArea().implement(EasySocial.Controller.Uploader, {
						'temporaryUpload': true,
						'query': 'type=comments',
						'type': 'comments',
						extensionsAllowed: 'jpg,png,gif'
					});

				},

				"{smileyItem} click": function(smileyItem, event) {

					var value = smileyItem.data('comment-smiley-value');
					var isEditing = smileyItem.parents('[data-comments-item-editframe]').length > 0;
					var currentInput = self.input();

					if (isEditing) {
						currentInput = smileyItem.parents('[data-comments-item-editframe]').find('[data-comments-item-edit-input]');
					}
						
					var currentValue = currentInput.val();
					currentValue += " " + value;

					// Update the comment form with the smiley
					currentInput.val(currentValue);
				},

				"{smileyLink} click": function(smileyLink, event) {

					if (smileyLink.hasClass('active')) {
						smileyLink.removeClass('active');

						return;
					}

					smileyLink.addClass('active');
				},

				"{attachmentDelete} click": function(deleteLink, event) {

					var attachmentId = deleteLink.data('id');
					
					EasySocial.dialog({
						content: EasySocial.ajax('site/views/comments/confirmDeleteCommentAttachment', {
										"id": attachmentId
									}),
						bindings: {
							"{deleteButton} click": function() {

								// Perform an ajax call to the server
								EasySocial.ajax('site/controllers/comments/deleteAttachment', {
									"id": attachmentId
								})
								.done(function() {
									// Remove the dom from the page
									var item = deleteLink.parents(self.attachmentItem.selector);
									item.remove();

									EasySocial.dialog().close();
								});
							}
						}
					});

				},

				"{attachmentRemove} click": function(removeLink, event) {
					var item = removeLink.parents(self.attachmentItem.selector);

					// Remove the item from the attachment ids
					opts.attachmentIds = $.without(opts.attachmentIds, item.data('id'));

					// Remove the item
					item.remove();

					if (self.attachmentItem().length < 1) {
						self.attachmentQueue().removeClass('has-attachments');
					}
				},

				// When a new item is added, we want to display
				"{uploaderForm} FilesAdded": function(el, event, uploader, files) {

					$.each(files, function(index, file) {
						// Get the attachment template
						var item = self.getAttachmentTemplate();

						// Set the queue to use has-attachments class
						self.attachmentQueue()
							.addClass('has-attachments');

						// Insert the item into the queue
						item.attr('id', file.id)
							.addClass('is-uploading')
							.prependTo(self.attachmentQueue());
					});
				},

				// When the file is uploaded, we need to remove the uploading state
				"{uploaderForm} FileUploaded": function(el, event, uploader, file, response) {

					var item = $('#' + file.id);

					// Add preview
					self.attachmentBackground.inside(item)
						.css('background-image', 'url(' + response.preview + ')');

					// Remove the is-uploading state on the upload item
					item.removeClass('is-uploading');

					// Push the id
					item.data('id', response.id);

					opts.attachmentIds.push(response.id);
				},

				// When item is being uploaded
				"{uploaderForm} UploadProgress" : function(el, event, uploader, file) {

					var item = $('#' + file.id);
					var progress = self.attachmentProgress.inside(item);

					progress.css('width', file.percent + '%');
				},

				'{input} keypress': function(el, event) {

					if (event.keyCode == 13) {
						if(self.parent.options.enterkey === 'submit' && !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey)) {
							self.submitComment();
						}

						if(self.parent.options.enterkey === 'newline' && (event.shiftKey || event.altKey || event.ctrlKey || event.metaKey)) {
							self.submitComment();
						}
					}
				},

				'{submit} click': function(el, event) {
					if (el.enabled()) {
						self.submitComment();
					}
				},

				setMentionsLayout: function() {
					var loader = $.Deferred();

					var editor		= self.editorArea(),
						mentions	= editor.controller("mentions");


					if (mentions) {
						mentions.cloneLayout();
						return;
					}

					var header = self.editorHeader();

					editor
						.mentions({
							triggers: {
							    
							    "@": {
									type: "entity",
									wrap: false,
									stop: "",
									allowSpace: true,
									finalize: true,
									query: {
										loadingHint	: true,
										searchHint	: $.View("easysocial/site/friends/suggest.hint.search"),
										emptyHint	: $.View("easysocial/site/friends/suggest.hint.empty"),

										data: function(keyword) {

											var task = $.Deferred();

											EasySocial.ajax( "site/controllers/friends/suggest" , { search: keyword })
											.done(function(items) {
												if (!$.isArray(items)) task.reject();

												var items = $.map(items, function(item)
												{
													item.title	= item.screenName;
													item.type	= "user";

													item.menuHtml = self.view.suggestItem(true, {
														item: item,
														name: "uid[]"
													});

													return item;
												});

												task.resolve(items);
											})
											.fail(task.reject);

											return task;
										},
										use: function(item) {
											return item.type + ":" + item.id;
										}
								    }
								},
								"#": {
								    type: "hashtag",
								    wrap: true,
								    stop: " #",
								    allowSpace: false,
									query: {
										loadingHint: true,
										searchHint: $.View("easysocial/site/hashtags/suggest.hint.search"),
										emptyHint: $.View("easysocial/site/hashtags/suggest.hint.empty"),
										data: function(keyword) {

											var task = $.Deferred();

											EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
												.done(function(items) {

													if (!$.isArray(items)) {
														task.reject();
													}

													var items = $.map(items, function(item){
														item.title = "#" + item.title;
														item.type = "hashtag";
														item.menuHtml = self.view.tagSuggestItem(true, {
															item: item,
															name: "uid[]"
														});
														return item;
													});

													task.resolve(items);
												})
												.fail(task.reject);

											return task;
										}
								    }
								}
							},
							plugin: {
								autocomplete: {
									id: "fd",
									component: "es",
									position: {
										my: 'left top',
										at: 'left bottom',
										of: header,
										collision: 'none'
									},
									size: {
										width: function() {
											return header.width();
										}
									}
								}
							}
						});
				},

				submitComment: function() {
					var comment = self.input().val();

					// If comment value is empty, then don't proceed
					if ($.trim(comment) == '') {
						return false;
					}

					// Trigger newCommentSaving event
					self.parent.trigger('newCommentSaving');

					// Execute save
					self.save()
						.done(function(comment) {
							// Rather than using commentItem ejs, let PHP return a full block of HTML codes
							// This is to unify 1 single theme file to use loading via static or ajax

							// trigger parent's commentSaved event
							self.parent.trigger('newCommentSaved', [comment]);

							// Enable the submit button
							self.submit().enabled(true);

							var editor = self.editorArea();
							var mentions = editor.controller("mentions");

							// Reset the mentions upon saving.
							mentions && mentions.reset();

							// Update the stream exclude id if applicable
							if (self.parent.options.streamid != '') {
								self.updateStreamExcludeIds(self.parent.options.streamid);
							}

						}).fail(function(msg) {
							self.parent.trigger('newCommentSaveError', [msg.message]);
						});
				},

				save: function() {
					var mentions = self.editorArea().controller("mentions");

					var data = {
						url: self.parent.options.url,
						mentions: mentions ? mentions.toArray() : []
					};

					data.mentions = $.map(data.mentions, function(mention){

						if (mention.type==="hashtag" && $.isPlainObject(mention.value)) {
							mention.value = mention.value.title.slice(1);
						}
						return JSON.stringify(mention);
					});

					return EasySocial.ajax('site/controllers/comments/save', {
						uid: self.parent.options.uid,
						element: self.parent.options.element,
						group: self.parent.options.group,
						verb: self.parent.options.verb,
						streamid: self.parent.options.streamid,
						input: self.input().val(),
						attachmentIds: opts.attachmentIds,
						data: data
					});
				},

				updateStreamExcludeIds: function(id) {
					// ids = self.element.data('excludeids' );
					ids = $('[data-streams-wrapper]').data( 'excludeids' );

					newIds = '';

					if (ids != '' && ids != undefined) {
						newIds = ids + ',' + id;
					} else {
						newIds = id;
					}

					$('[data-streams-wrapper]').data('excludeids', newIds);
				},

				disableForm: function() {
					// Disable input
					self.input().attr('disabled', true);

					// Disable submit button
					self.submit().disabled(true);
				},

				enableForm: function() {
					// Enable and reset input
					self.input().removeAttr('disabled');

					// Enable submit button
					self.submit().enabled(true);
				},

				'{parent} newCommentSaving': function() {
					// Show the status as it could be hidden by other actions
					self.status().show();

					// Set the status as success
					self.status().removeClass('label-important label-success label-info');
					self.status().addClass('label-info');

					// Set the status
					self.status().text($.language('COM_EASYSOCIAL_COMMENTS_STATUS_SAVING'));

					// Disable comment form
					self.disableForm();
				},

				'{parent} newCommentSaved': function() {
					// Show the status bar of the form
					self.status().show();

					// Set the text of the status bar
					self.status().text($.language('COM_EASYSOCIAL_COMMENTS_STATUS_SAVED'));

					// Set the status as success
					self.status().removeClass('label-important label-success label-info');
					self.status().addClass('label-success');

					// Fade out the status bar after 2 second
					setTimeout(function() {
						self.status().fadeOut('fast');
					}, 2000);

					// Enable comment form
					self.enableForm();

					// Reset the attachments
					opts.attachmentIds = [];

					// Get all the attachment items in the queue
					var attachmentItems = self.attachmentItem.inside(self.attachmentQueue.selector);
					attachmentItems.remove();
					
					self.attachmentQueue().removeClass('has-attachments');

					// Reset comment input
					self.input().val('');
				},

				'{parent} newCommentSaveError': function(el, event, msg) {
					// Show the status bar of the form
					self.status().show();

					// Set the status as error
					self.status().removeClass('label-important label-success label-info');
					self.status().addClass('label-important');

					// Add the error message
					self.status().text(msg);

					// Enable comment form
					self.enableForm();
				}
			} });

			module.resolve();
		});
})

EasySocial.module('site/comments/item', function($) {
	var module = this;

	EasySocial.require()
		.library('mentions')
		.view(
			"site/friends/suggest.item",
			"site/friends/suggest.hint.search",
			"site/friends/suggest.hint.empty",
			"site/hashtags/suggest.item",
			"site/hashtags/suggest.hint.search",
			"site/hashtags/suggest.hint.empty"
		)
		.language(
			'COM_EASYSOCIAL_COMMENTS_STATUS_SAVE_ERROR',
			'COM_EASYSOCIAL_COMMENTS_STATUS_LOADING',
			'COM_EASYSOCIAL_COMMENTS_STATUS_LOAD_ERROR',
			'COM_EASYSOCIAL_COMMENTS_STATUS_DELETING',
			'COM_EASYSOCIAL_COMMENTS_STATUS_DELETE_ERROR',
			'COM_EASYSOCIAL_LIKES_LIKE',
			'COM_EASYSOCIAL_LIKES_UNLIKE'
		)
		.done(function() {
			/**
			 *	Item controller
			 */
			EasySocial.Controller('Comments.Item', {
				defaultOptions: {
					'id'			: 0,

					'child'			: 0,

					'loadedChild'	: 0,

					'limit'			: 10,

					'isNew'			: false,

					'{frame}'		: '[data-comments-item-frame]',

					'{avatar}'		: '[data-comments-item-avatar]',

					'{commentFrame}': '[data-comments-item-commentFrame]',

					'{author}'		: '[data-comments-item-author]',

					'{action}'		: '[data-comments-item-actions]',
					'{edit}'		: '[data-comments-item-actions-edit]',
					'{delete}'		: '[data-comments-item-actions-delete]',
					'{spam}'		: '[data-comments-item-actions-spam]',

					'{comment}'		: '[data-comments-item-comment]',

					'{meta}'		: '[data-comments-item-meta]',

					'{date}'		: '[data-comments-item-date] a',

					'{like}'		: '[data-comments-item-like]',
					'{likeCount}'	: '[data-comments-item-likeCount]',

					'{editFrame}'	: '[data-comments-item-editFrame]',
					'{editInput}'	: '[data-comments-item-edit-input]',
					'{editCancel}'	: '[data-comments-item-edit-cancel]',
					'{editSubmit}'	: '[data-comments-item-edit-submit]',
					'{editStatus}'	: '[data-comments-item-edit-status]',

					'{statusFrame}'	: '[data-comments-item-statusFrame]',

					'{loadReplies}'	: '[data-comments-item-loadReplies]',

					'{readMore}'	: '[data-es-comment-readmore]',

					'{fullContent}'	: '[data-es-comment-full]',

					view: {
						suggestItem: "site/friends/suggest.item",
						tagSuggestItem: "site/hashtags/suggest.item"
					}
				}
			}, function(self) { return {
				init: function() {
					// Initialise comment id
					self.options.id = self.element.data('id');

					// Initialise child count
					self.options.child = self.element.data('child');

					// Register self into the registry of comments
					self.parent.registerComment(self);

					// Add the status plugin
					// self.status = self.addPlugin('status');

					// Using add Controller instead of addPlugin because the parent should reference the item's parent, not the item itself
					self.status = self.element.addController('EasySocial.Controller.Comments.Item.Status', {
						controller: {
							parent: self.parent,
							item: self
						}
					})
				},

				'{like} click': function(el) {
					if(el.enabled()) {
						// Disable the like button
						el.disabled(true);

						// Send the like to the server
						self.likeComment()
							.done(function(liked, count, string) {

								// Enable the button
								el.enabled(true);

								// Set the likes count
								self.likeCount().text(count);

								// Strip off tags from the like text
								string = $('<div></div>').html(string).text();

								// Set the like text
								self.likeCount().attr('data-original-title', string);

								// Set the like button text
								self.like().find('a').text($.language(liked ? 'COM_EASYSOCIAL_LIKES_UNLIKE' : 'COM_EASYSOCIAL_LIKES_LIKE'));
							})
							.fail(function() {

							});
					}
				},

				likeComment: function() {
					return EasySocial.ajax('site/controllers/comments/like', {
						id: self.options.id
					});
				},

				'{likeCount} click': function() {
					EasySocial.dialog({
						content: self.getLikedUsers()
					});
				},

				getLikedUsers: function() {
					return EasySocial.ajax('site/controllers/comments/likedUsers', {
						id: self.options.id
					});
				},

				'{edit} click': function(el) {
					if(el.enabled()) {

						var editor = self.editFrame(),
							mentions = editor.controller("mentions");

						// Manually clear out the html and destroy the mentions controller to prevent conflict of loading the editFrame again.
						editor.html('');
						if (mentions) {
							mentions.destroy();
						}

						// Disable the edit button
						el.disabled(true);

						// Trigger commentEditLoading event
						self.trigger('commentEditLoading', [self.options.id]);

						self.getEditComment()
							.done(function(html) {
								self.trigger('commentEditLoaded', [self.options.id, html]);

								self.editFrame().html(html).show();

								self.setMentionsLayout();

								// Focus on the editor
								self.editInput().focus();
							})
							.fail(function(msg) {

								// Trigger commentEditLoadError event
								self.trigger('commentEditLoadError', [self.options.id, msg]);
							});
					}
				},

				setMentionsLayout: function() {
					var editor = self.editFrame();
					var mentions = editor.controller("mentions");


					if (mentions) {
						mentions.cloneLayout();
						return;
					}

					var header = self.editFrame();

					editor
						.mentions(
						{
							triggers:
							{
								"@":
								{
									type			: "entity",
									wrap			: false,
									stop			: "",
									allowSpace		: true,
									finalize		: true,
									query:
									{
										loadingHint	: true,
										searchHint	: $.View("easysocial/site/friends/suggest.hint.search"),
										emptyHint	: $.View("easysocial/site/friends/suggest.hint.empty"),

										data: function( keyword )
										{

											var task = $.Deferred();

											EasySocial.ajax( "site/controllers/friends/suggest" , { search: keyword })
											.done(function(items)
											{
												if (!$.isArray(items)) task.reject();

												var items = $.map(items, function(item)
												{
													item.title	= item.screenName;
													item.type	= "user";

													item.menuHtml = self.view.suggestItem(true, {
														item: item,
														name: "uid[]"
													});

													return item;
												});

												task.resolve(items);
											})
											.fail(task.reject);

											return task;
										},
										use: function(item) {
											return item.type + ":" + item.id;
										}
									}
								},
								"#":
								{
									type		: "hashtag",
									wrap		: true,
									stop		: " #",
									allowSpace	: false,
									query:
									{
										loadingHint	: false,
										searchHint	: $.View("easysocial/site/hashtags/suggest.hint.search"),
										emptyHint	: $.View("easysocial/site/hashtags/suggest.hint.empty"),
										data: function(keyword)
										{

											var task = $.Deferred();

											EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
												.done(function(items)
												{
													if (!$.isArray(items)) task.reject();

													var items = $.map(items, function(item){
														item.title = "#" + item.title;
														item.type = "hashtag";
														item.menuHtml = self.view.tagSuggestItem(true, {
															item: item,
															name: "uid[]"
														});
														return item;
													});

													task.resolve(items);
												})
												.fail(task.reject);

											return task;
										}
									}
								}
							},
							plugin:
							{
								autocomplete:
								{
									id			: "fd",
									component	: "es",
									position	:
									{
										my: 'left top',
										at: 'left bottom',
										of: header,
										collision: 'none'
									},
									size:
									{
										width: function()
										{
											return header.width();
										}
									}
								}
							}
						});
				},

				getRawComment: function() {
					return EasySocial.ajax('site/controllers/comments/getRawComment', {
						id: self.options.id
					});
				},

				getEditComment: function() {
					return EasySocial.ajax('site/controllers/comments/getEditComment', {
						id: self.options.id
					});
				},

				'{editCancel} click': function() {
					self.trigger('commentEditCancel', [self.options.id]);

					self.edit().enabled(true);
				},

				'{editSubmit} click': function() {
					self.submitEdit();
				},

				submitEdit: function() {
					// Get and trim the edit value
					var input = self.editInput().val();

					// Do not proceed if value is empty
					if(input == '') {
						return false;
					}

					// Trigger commentEditSaving event
					self.trigger('commentEditSaving', [self.options.id, input]);

					// Send the edit to the server
					self.saveEdit()
						.done(function(comment) {

							// Trigger commentEdited event
							self.trigger('commentEditSaved', [self.options.id, comment]);

							// Update the comment content
							self.comment().html(comment);

							self.edit().enabled(true);
						})
						.fail(function(msg) {

							// Trigger commentEditError event
							self.trigger('commentEditSaveError', [self.options.id, msg]);
						});
				},

				saveEdit: function() {
					var mentions = self.editFrame().mentions("controller");

					return EasySocial.ajax('site/controllers/comments/update', {
						id: self.options.id,
						input: self.editInput().val(),
						mentions: mentions ? mentions.toArray() : []
					});
				},

				'{delete} click': function(el) {
					// Prepare the item properly first
					self.frame().hide();
					self.commentFrame().show();

					// Clone the whole item to place in the dialog
					// var comment = self.element.clone();

					EasySocial.dialog({
						content: EasySocial.ajax('site/views/comments/confirmDelete', {
							id: self.options.id
						}),
						selectors: {
							"{deleteButton}"  : "[data-delete-button]",
							"{cancelButton}"  : "[data-cancel-button]"
						},
						bindings: {
							"{deleteButton} click": function() {

								// Close the dialog
								EasySocial.dialog().close();

								// Trigger commentDeleting event on parent to announce to sibling frames
								self.parent.trigger('commentDeleting', [self.options.id]);

								// Trigger commentDeleting event on self to announce to child frames
								self.trigger('commentDeleting');

								// Send delete command to server
								self.deleteComment()
									.done(function() {

										// Trigger commentDeleted event on parent, since this element will be remove, no point triggering on self
										self.parent.trigger('commentDeleted', [self.options.id]);
									})
									.fail(function(msg) {

										// Trigger commentDeleteError event on parent to announce to sibling frames
										self.parent.trigger('commentDeleteError', [self.options.id, msg]);

										// Trigger commentDeleteError event on self to announce to child frames
										self.trigger('commentDeleteError', [self.options.id, msg]);
									});
							},

							"{cancelButton} click": function() {

								// Close the dialog
								EasySocial.dialog().close();
							}
						}
					});
				},

				deleteComment: function() {
					return EasySocial.ajax('site/controllers/comments/delete', {
						id: self.options.id
					});
				},

				'{loadReplies} click': function(el) {
					// Hide the loadReplies button
					el.hide();

					// Add a loader after this comment first

					// Calculate the start
					var start = Math.max(self.options.child - self.options.loadedChild - self.options.limit, 0);

					// Get the child comments
					EasySocial.ajax()
						.done(function(comments) {

							// Append the comments below the current comment item
							$.each(comments, function(index, comment) {
								self.parent.$List.addToList(comment, 'child', false);
							});

							// Trigger oldCommentsLoaded event
							self.parent.trigger('oldCommentsLoaded', [comments]);

							// Check if we need to show the load more replies button in the current item
							start > 0 && self.loadMoreReplies().show();
						});
				},

				'{readMore} click': function(el, ev) {
					self.comment().html(self.fullContent().html());
				}
			} });

			/**
			 *	Status frame controller
			 */
			EasySocial.Controller('Comments.Item.Status', {
				defaultOptions: {
					'{frame}'		: '[data-comments-item-frame]',

					'{statusFrame}'	: '[data-comments-item-statusFrame]',

					'{statusContent}': '[data-comments-item-statusFrame] div',

					'{commentFrame}': '[data-comments-item-commentFrame]',

					'{editFrame}'	: '[data-comments-item-editFrame]'
				}
			}, function(self) { return {

				// commentEditLoading(id)
				// commentEditLoaded(id, rawcomment)
				// commentEditLoadError(id, errormsg)
				// commentEditCancel(id)
				// commentEditSaving(id, newcomment)
				// commentEditSaved(id, newcomment)
				// commentEditSaveError(id, errormsg)
				// commentDeleting(id)
				// commentDeleted(id)
				// commentDeleteError(id, errormsg)

				init: function() {

				},

				setStatus: function(html) {
					self.frame().hide();

					if ($.isPlainObject(html) && html.message !== undefined) {
						html = html.message;
					}

					self.statusContent().html(html);

					self.statusFrame().show();
				},

				'{self} commentEditLoading': function() {
					self.setStatus($.language('COM_EASYSOCIAL_COMMENTS_STATUS_LOADING'));
				},

				'{self} commentEditLoaded': function() {
					self.frame().hide();

					self.editFrame().show();
				},

				'{self} commentEditLoadError': function() {
					self.setStatus($.language('COM_EASYSOCIAL_COMMENTS_STATUS_LOAD_ERROR'));
				},

				'{self} commentEditCancel': function() {
					self.frame().hide();

					self.commentFrame().show();
				},

				'{self} commentEditSaving': function() {
					self.setStatus($.language('COM_EASYSOCIAL_COMMENTS_STATUS_SAVING'));
				},

				'{self} commentEditSaved': function() {
					self.frame().hide();

					self.commentFrame().show();
				},

				'{self} commentEditSaveError': function() {
					self.setStatus($.language('COM_EASYSOCIAL_COMMENTS_STATUS_SAVE_ERROR'));
				},

				'{self} commentDeleting': function() {
					self.setStatus($.language('COM_EASYSOCIAL_COMMENTS_STATUS_DELETING'));
				},

				'{self} commentDeleteError': function(el, event, id, msg) {
					msg = msg || $.language('COM_EASYSOCIAL_COMMENTS_STATUS_DELETE_ERROR');
					self.setStatus(msg);
				}
			} });

			module.resolve();
		});
});

EasySocial.module( 'site/conversations/conversations' , function($){

	var module 	= this;


	EasySocial.require()
	.script( 'site/conversations/mailbox' , 'site/conversations/item' , 'site/conversations/filter' )
	.language( 'COM_EASYSOCIAL_NO_BUTTON' )
	.done( function($){

		EasySocial.Controller(
			'Conversations',
			{
				defaultOptions:
				{
					"{mailbox}"	: "[data-conversations-mailbox]",
					"{list}"	: "[data-conversations-list]",
					"{content}"	: "[data-conversations-content]",

					"{item}"		: "[data-conversations-item]",

					// Conversation actions
					"{actions}"		: "[data-conversations-actions]",

					// Conversations filter
					"{filterItem}"	: "[data-conversations-filter]",

					// Check All
					"{checkAll}"	: "[data-conversations-checkAll]",
					"{checkbox}"	: "[data-conversationItem-checkbox]",

					// Actions that can be performed on the conversations
					"{delete}"		: "[data-conversations-delete]",
					"{archive}"		: "[data-conversations-archive]",
					"{unarchive}"	: "[data-conversations-unarchive]",
					"{unread}"		: "[data-conversations-unread]",
					"{read}"		: "[data-conversations-read]"
				}
			},
			function( self ){

				return {

					init: function()
					{
						// Implement mailbox controller.
						self.mailbox().implement( EasySocial.Controller.Conversations.Mailbox ,
						{
							"{parent}"	: self
						});

						self.item().implement( EasySocial.Controller.Conversations.Item , {
							"{parent}"	: self
						});

						self.filterItem().implement( EasySocial.Controller.Conversations.Filter ,
						{
							"{parent}"	: self
						});
					},

					"{filterItem} click" : function( el )
					{
						// Remove all active classes on filter link.
						self.filterItem().removeClass( 'active' );

						// Add active class on active element.
						$( el ).addClass( 'active' );
					},

					"{checkbox} change" : function( el )
					{
						// See if there's any more checked items.
						if( self.checkbox( ':checked' ).length <= 0 && !el.is( ':checked' ) )
						{
							return self.actions().removeClass( 'is-checked' );
						}

						self.actions().addClass( 'is-checked' );
					},

					/**
					 * Checks all checkbox on the page.
					 */
					"{checkAll} click" : function( el )
					{
						// If there's nothing to check, we do not let them to check anything.
						if( self.checkbox().length <= 0 )
						{
							// Uncheck this.
							$( el ).prop( 'checked' , false );
							
							return false;
						}

						if( el.is( ':checked' ) )
						{
							// We don't want to trigger the checked items since they are already checked.
							self.checkbox( ':not(:checked)' ).click();
						}
						else
						{
							self.checkbox( ':checked' ).click();
						}
					},

					/**
					 * Allows caller to add an is-empty to the list.
					 */
					showEmpty: function()
					{
						self.content().addClass( 'is-empty' );
					},

					/**
					 * Allows caller to add an is-empty to the list.
					 */
					hideEmpty: function()
					{
						self.content().removeClass( 'is-empty' );
					},

					/**
					 * Toggles the loading class on the content.
					 */
					toggleLoading: function()
					{
						self.content().removeClass( 'is-empty' )
							.toggleClass( 'is-loading' );
					},

					/**
					 * Allows caller to trigger this method to update the conversations content.
					 */
					updateContent : function( content , mailbox )
					{
						if( mailbox != undefined )
						{
							self.content().addClass( 'layout-' + mailbox );
						}
						else
						{
							self.content().removeClass( 'layout-archives' );
						}
						// Whenever updateContent is called, we need to hide the actions
						self.actions().removeClass('is-checked');
						self.checkAll().removeAttr( 'checked' );
						
						self.list().html( content );
					},

					getSelectedConversations : function()
					{
						// Let's see if there's any checked items.
						if( self.checkbox(':checked').length <= 0 )
						{
							return false;
						}

						var selected	= new Array;
						self.checkbox(':checked').each( function( i , checkedItem ){
							selected.push( $( checkedItem ).val() );
						});

						return selected;
					},

					"{archive} click" : function()
					{
						var selected	= self.getSelectedConversations();

						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/conversations/confirmArchive' , { "ids" : selected } ),
							bindings 	:
							{
								"{confirmButton} click" : function()
								{
									$( '[data-conversation-archive-form]' ).submit();
								}
							}
						});
					},

					"{unarchive} click" : function()
					{
						var selected	= self.getSelectedConversations();

						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/conversations/confirmUnarchive' , { "ids" : selected } ),
							bindings 	:
							{
								"{confirmButton} click" : function()
								{
									$( '[data-conversation-archive-form]' ).submit();
								}
							}
						})
					},

					"{delete} click" : function()
					{
						var selected	= self.getSelectedConversations();

						EasySocial.dialog(
						{
							content		: EasySocial.ajax( 'site/views/conversations/confirmDelete' , { "ids" : selected }),
							bindings	:
							{
								"{deleteButton} click" : function()
								{
									$( '[data-conversation-delete-form]' ).submit();
								}
							}
						});

					},

					"{read} click" : function()
					{
						// If there's nothing to mark as unread, just ignore.
						if( self.checkbox( ':checked' ).length <= 0 )
						{
							return false;
						}
						
						var ids = new Array();

						// Loop through each checked items.
						self.checkbox( ':checked' ).each( function( i , checkedItem ){
							ids.push( $( checkedItem ).val() );
						});

						EasySocial.ajax( 'site/controllers/conversations/markRead' , 
						{
							"ids"	: ids
						})
						.done( function(){
							
							// Add unread class on the items.
							self.checkbox()
								.parents( '[data-conversations-item]' )
								.removeClass( 'unread' )
								.addClass( 'read' );

							// We need to tell the mailbox controller to update the count.
							self.mailbox().controller().updateCounters();
						})
						.fail(function( message )
						{
							self.setMessage( message );
						});

					},

					"{unread} click" : function()
					{
						// If there's nothing to mark as unread, just ignore.
						if( self.checkbox( ':checked' ).length <= 0 )
						{
							return false;
						}
						
						var ids = new Array();

						// Loop through each checked items.
						self.checkbox( ':checked' ).each( function( i , checkedItem ){
							ids.push( $( checkedItem ).val() );
						});

						EasySocial.ajax( 'site/controllers/conversations/markUnread' , 
						{
							"ids"	: ids
						})
						.done( function(){
							
							// Add unread class on the items.
							self.checkbox()
								.parents( '[data-conversations-item]' )
								.removeClass( 'read' )
								.addClass( 'unread' );

							// We need to tell the mailbox controller to update the count.
							self.mailbox().controller().updateCounters();

						})
						.fail(function( message ){
							console.log( message );
						});

					}
				}
			}
		);

		module.resolve();
	});

});


EasySocial.module( 'site/conversations/mailbox' , function($){

	var module 	= this;


	EasySocial.require()
	.library( 'history' )
	.done( function($){

		EasySocial.Controller(
			'Conversations.Mailbox',
			{
				defaultOptions:
				{
					"{item}"	: "[data-mailboxItem]"
				}
			},
			function( self ){

				return {

					init: function()
					{
						self.item().implement( EasySocial.Controller.Conversations.Mailbox.Item ,
						{
							"{parent}"	: self
						});
					},

					updateCounters: function()
					{
						self.item( '.active' ).controller().updateCounter();
					},

					updateContent : function( items , mailbox )
					{
						// Request the parent to update the contents.
						self.parent.updateContent( items , mailbox );
					},

					showEmpty: function()
					{
						self.parent.showEmpty();
					},

					hideEmpty: function()
					{
						self.parent.hideEmpty();
					},

					toggleLoading: function()
					{
						self.parent.toggleLoading();
					}
				}
			}
		);

		EasySocial.Controller(
			'Conversations.Mailbox.Item',
			{
				defaultOptions:
				{
					"{counter}"	: "[data-mailboxItem-counter]",

					view :
					{
						emptyTemplate : "site/conversations/default.item.empty"
					}
				}
			},
			function( self ){
				return {

					init: function()
					{

					},

					updateCounter: function()
					{
						EasySocial.ajax( 'site/controllers/conversations/getCount' ,
						{
							"mailbox"	: self.element.data( 'mailbox' )
						})
						.done(function( total ){

							// If there's no more new items, hide it.
							if( total <= 0 )
							{
								self.counter().html( '' );

								return;
							}

							self.counter().html( '(' + total + ')' );
						})
					},

					toggleLoading: function()
					{
						self.element.toggleClass( 'loading' );
					},

					"{self} click" : function()
					{
						var url 	= self.element.data( 'url' ),
							title 	= self.element.data( 'title' ),
							mailbox	= self.element.data( 'mailbox' );

						// Remove active class on all mailboxes.
						self.parent.item().removeClass( 'active' );

						// Add active class to this.
						self.element.addClass( 'active' );

						History.pushState( {state:1} , title , url );

						// Get contents via ajax.
						EasySocial.ajax( 'site/views/conversations/getItems' ,
						{
							"mailbox"	: mailbox,
							"limitstart" : 0
						},
						{
							beforeSend: function()
							{
								// Add loading indicator to the mailbox list.
								self.toggleLoading();

								// Add loading indicator.
								self.parent.toggleLoading();
							}
						})
						.done(function( content , empty ){

							// Remove loading class on the element.
							self.toggleLoading();

							// Remove loading class on the content.
							self.parent.toggleLoading();

							if( content.length <= 0 )
							{
								// Empty the contents too to maintain the integrity of the checkbox
								self.parent.updateContent( '' );
								return self.parent.showEmpty();
							}

							// Hide empty class if it has items.
							self.parent.hideEmpty();

							// Now we'd need to update the content.
							self.parent.updateContent( content , self.element.data( 'mailbox' ) );

						});
					}
				}
		});

		module.resolve();
	});


});


EasySocial.module( 'site/conversations/item' , function($){

	var module 	= this;


	EasySocial.require()
	.script( 'site/conversations/mailbox' )
	.done( function($){

		EasySocial.Controller(
			'Conversations.Item',
			{
				defaultOptions:
				{
					"{checkbox}"	: "[data-conversationItem-checkbox]"
				}
			},
			function( self ){

				return {

					init: function()
					{
					},

					"{checkbox} change": function( el ){

						var checked = $( el ).is( ':checked' );

						if( checked )
						{
							return self.element.addClass( 'selected' );
						}

						return self.element.removeClass( 'selected' );
					}
				}
			}
		);

		module.resolve();
	});

});


EasySocial.module( 'site/conversations/filter' , function($){

	var module 	= this;


	EasySocial.require()
	.done( function($){

		EasySocial.Controller(
			'Conversations.Filter',
			{
				defaultOptions:
				{
				}
			},
			function( self ){

				return {

					init: function()
					{
					},

					"{self} click" : function()
					{
						var type 		= self.element.data( 'filter' ),
							selector	= '.' + type,
							total 		= self.parent.item( selector ).length;

						if( $("[data-mailboxitem]").filter(".active").length == 1 )
						{
							var curActiveMenu = $("[data-mailboxitem]").filter(".active");

							var url 	= curActiveMenu.data( 'url' ),
								title 	= curActiveMenu.data( 'title' ),
								mailbox	= curActiveMenu.data( 'mailbox' );


							History.pushState( {state:1} , title , url );

							// Get contents via ajax.
							EasySocial.ajax( 'site/views/conversations/getItems' ,
							{
								"mailbox"	: mailbox,
								"filter" 	: type,
								"limitstart": 0
							},
							{
								beforeSend: function()
								{
									// Add loading indicator.
									self.parent.toggleLoading();
								}
							})
							.done(function( content , empty ){


								// Remove loading class on the content.
								self.parent.toggleLoading();

								if( content.length <= 0 )
								{
									// Empty the contents too to maintain the integrity of the checkbox
									self.parent.updateContent( '' );
									return self.parent.showEmpty();
								}

								// Hide empty class if it has items.
								self.parent.hideEmpty();

								// Now we'd need to update the content.
								self.parent.updateContent( content , mailbox );

							});



						}

						// if( type == 'all' )
						// {
						// 	if( self.parent.item().length == 0 )
						// 	{
						// 		self.parent.showEmpty();
						// 	}
						// 	else
						// 	{
						// 		self.parent.hideEmpty();
						// 	}

						// 	self.parent.item().show();
						// }
						// else
						// {

						// 	// Hide all conversations initially.
						// 	self.parent.item().hide();


						// 	if( total == 0 )
						// 	{
						// 		// Show empty.
						// 		self.parent.showEmpty();
						// 	}
						// 	else
						// 	{
						// 		// Always hide empty when there are items.
						// 		self.parent.hideEmpty();
						// 	}

						// 	// Only show the necessary item.
						// 	self.parent.item( "." + type ).show();
						// }
					}
				}
			}
		);

		module.resolve();
	});

});


EasySocial.module( 'site/conversations/read' , function($){

	var module 	= this;

	EasySocial.require()
	.library( 'dialog' )
	.script( 'site/conversations/composer' , 'site/friends/suggest' )
	.language(
		'COM_EASYSOCIAL_CONVERSATION_REPLY_POSTED_SUCCESSFULLY',
		'COM_EASYSOCIAL_CONVERSATION_REPLY_FORM_EMPTY'
	)
	.done(function($){

		EasySocial.Controller(
			'Conversations.Read',
			{
				defaultOptions:
				{
					// Conversation id.
					id 	: "",

					// Determines if these features should be enabled.
					attachments 		: true,
					location 			: false,
					maxSize 			: "3mb",

					extensionsAllowed	 : "",
					attachmentController : null,
					composerController	 : null,

					// Conversation items.
					"{item}"		: "[data-readConversation-item]",
					"{items}"		: "[data-readConversation-items]",

					// Form composer
					"{composer}"	: "[data-readConversation-composer]",

					// Buttons
					"{replyButton}"	: "[data-readConversation-replyButton]",

					// Add participant to a conversation.
					"{addParticipant}"	: "[data-readConversation-addParticipant]",

					// Leave conversation.
					"{leaveConversation}"	: "[data-readConversation-leaveConversation]",

					// Delete conversation.
					"{delete}"			: "[data-readConversation-delete]",

					// Attachments
					"{attachments}"		: "[data-uploaderQueue-id]",

					// Notice message on reply form.
					"{replyNotice}"		: "[data-readConversation-replyNotice]",

					// Load previous message button.
					"{readLoadMore}"		: "[data-readconversation-load-more]",


					// Views
					view	:
					{
						messageItem		: 'site/conversations/read.message'
					}
				}
			},
			function( self ){
				return {

					init: function()
					{
						// Implement the composer on the reply form
						self.composer().implement( EasySocial.Controller.Conversations.Composer ,
						{
							"{uploader}"		: "[data-readConversation-attachment]",
							"{location}"		: "[data-readConversation-location]",
							maxSize 			: self.options.maxSize,
							extensionsAllowed	: self.options.extensionsAllowed
						});

						// Get the composer controller.
						self.options.composerController 	= self.composer().controller();

						if( self.options.attachments )
						{
							// Get the uploader controller.
							self.options.attachmentController = self.options.composerController.uploader().controller();
						}

						if( self.options.location )
						{
							// Get the location controller.
							self.options.locationController = self.options.composerController.location().controller();
						}

						// Initialize message item.
						self.item().implement( EasySocial.Controller.Conversations.Read.Item );

						// Set the conversation id.
						self.options.id 	= self.element.data( 'id' );
					},

					resetForm: function()
					{
						// Reset the editor form.
						self.options.composerController.resetForm();

						var mentions = self.composer().controller().editorArea().mentions( 'controller' );

						mentions.reset();

						if( self.options.location )
						{
							// Reset the location.
							self.options.locationController.removeLocation();
						}

						if( self.options.attachments )
						{
							// Reset the uploader.
							self.options.attachmentController.reset();
						}
					},

					"{readLoadMore} click" : function( el )
					{
						var id = $( el ).data( 'id' ),
							limitstart = $(el).data( 'limitstart' );

						self.readLoadMore().hide();
						$( '.loading-indicator' ).show();

						var options 	=	{
												"id"			: id,
												"limitstart"	: limitstart
											};

						// Do an ajax call to submit the reply.
						EasySocial.ajax( 'site/controllers/conversations/loadPrevious' , options )
						.done(function( html, nextlimit )
						{
							$.buildHTML(html)
								.prependTo(self.items())
								.addController("EasySocial.Controller.Conversations.Read.Item");

							if( nextlimit == 0 )
							{
								self.readLoadMore().hide();
							}
							else
							{
								self.readLoadMore().show();
								$(el).data( 'limitstart', nextlimit );
							}

						})
						.always(function()
						{
							$( '.loading-indicator' ).hide();
						});


					},


					"{replyButton} click" : function( el , event )
					{
						// Stop bubbling up.
						event.preventDefault();

						var content 	= self.options.composerController.editor().val(),
							files 		= new Array;


						if( content.length <= 0 )
						{
							self.replyNotice().html( $.language( 'COM_EASYSOCIAL_CONVERSATION_REPLY_FORM_EMPTY' ) ).addClass( 'alert alert-error' ).removeClass( 'alert-success' );
							return false;
						}

						if( self.options.attachments )
						{
							// Get through each attachments.
							self.attachments().each( function( i , attachment ){
								files.push( $( attachment ).val() );
							});
						}

						var options 	=	{
												"id"		: self.options.id,
												"message"	: content
											};

						if( self.options.attachments )
						{
							options[ 'upload-id' ]	= files;
						}

						if( self.options.location )
						{
							options.address 	= self.options.locationController.locationInput().val();
							options.latitude	= self.options.locationController.locationLatitude().val();
							options.longitude	= self.options.locationController.locationLongitude().val();
						}

						options[ 'tags' ]	= self.composer().controller().editorArea().mentions( 'controller' ).toArray();

						// Disable submit button.
						self.replyButton().attr( 'disabled' , true );

						// Do an ajax call to submit the reply.
						EasySocial.ajax( 'site/controllers/conversations/reply' , options )
						.done(function( html )
						{
							self.replyNotice().html( $.language( 'COM_EASYSOCIAL_CONVERSATION_REPLY_POSTED_SUCCESSFULLY' ) ).addClass( 'alert alert-success' ).removeClass( 'alert-error' );

							// Apply controller on the appended item.
							var item 	= $( html );

							item.implement( EasySocial.Controller.Conversations.Read.Item );

							// Append the data back to the list.
							self.items().append( item );

							// Reset the composer form.
							self.resetForm();
						})
						.always(function()
						{
							// Re-activate button.
							self.replyButton().attr( 'disabled' , false );
						});


						return false;
					},

					"{leaveConversation} click" : function()
					{
						EasySocial.dialog({
							content : EasySocial.ajax( 'site/views/conversations/confirmLeave' , { id : self.options.id } )
						});
					},

					"{addParticipant} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/conversations/addParticipantsForm' , { "id" : self.options.id })
						});
					},

					"{delete} click" : function()
					{
						EasySocial.dialog(
						{
							content : EasySocial.ajax( 'site/views/conversations/confirmDelete' , { "ids" : [ self.options.id ] } ),
							bindings:
							{
								"{deleteButton} click" : function()
								{
									$( '[data-conversation-delete-form]' ).submit();
								}
							}
						});
					},

					/**
					 * Adds a new item into the reading list.
					 */
					addItem: function( obj ){
						// Append the message item into the list.
						self.messageList().append(
							self.view.messageItem({
								item: obj
							})
						);

						// Now we need to empty the message.
						self.textMessage().val( '' ).focus();
					}
				}
		});

		EasySocial.Controller(
			'Conversations.Read.Item',
			{
				defaultOptions :
				{
					id 	: null,

					"{attachmentsWrapper}" : "[data-conversation-attachment-wrapper]",
					"{attachments}"		: "[data-conversation-attachment]"
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						// Get the message id.
						self.options.id 	= self.element.data( 'id' );

						// Implement attachment items.
						self.attachments().implement( EasySocial.Controller.Conversations.Read.Item.Attachment ,
							{
								"{parent}" : self
							});
					},

					removeAttachment : function( el , event )
					{
						// Remove the attachment item
						$( el ).remove();

						// Check to see if there are any more attachments.
						if( self.attachments().length == 0 )
						{
							self.attachmentsWrapper().hide();
						}
					}
				}
			});

		EasySocial.Controller(
			'Conversations.Read.Item.Attachment',
			{
				defaultOptions :
				{
					"{deleteAttachment}" 	: "[data-attachment-delete]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{

					},

					"{deleteAttachment} click" : function( el , event )
					{
						var attachmentId 	= $( el ).data( 'id' );

						EasySocial.dialog(
						{
							content : EasySocial.ajax( 'site/views/conversations/confirmDeleteAttachment', { "id" : attachmentId } ),
							bindings :
							{
								"{deleteButton} click" : function()
								{
									EasySocial.ajax( 'site/controllers/conversations/deleteAttachment',
									{
										id 	: attachmentId
									})
									.done( function()
									{
										// Remove the attachment element.
										self.parent.removeAttachment( self.element );

										EasySocial.dialog(
										{
											content 	: EasySocial.ajax( 'site/views/conversations/attachmentDeleted' , {} )
										});
									})
									.fail( function( message )
									{
										self.setMessage( message );
									})
								}
							}
						});
					}
				}
			})
		module.resolve();
	});
});

EasySocial.module( 'site/dashboard/apps' , function($){

	var module 				= this;

	EasySocial.require()
	.library( 'history' )
	.done(function($){

		EasySocial.Controller(
			'Dashboard.Apps',
			{
				defaultOptions:
				{
					parent		: null,
					pageTitle	: null,
					"{item}"	: "[data-dashboardApps-item]"
				}
			},
			function(self){

				return{

					init : function()
					{
						self.item().implement( EasySocial.Controller.Dashboard.Apps.Item ,
						{
							"{parent}"		: self,
							"{dashboard}"	: self.parent,
							pageTitle 		: self.options.pageTitle
						});
					}
				}
			});

		EasySocial.Controller(
			'Dashboard.Apps.Item',
			{
				defaultOptions:
				{
				}
			}, function(self){

				return{

					init : function()
					{
					},

					"{self} click" : function( el , event )
					{
						// Prevent from bubbling up.
						event.preventDefault();

						// Get the layout meta.
						var layout 	= self.element.data( 'layout' ),
							url 	= self.element.data( layout + '-url' ),
							title 	= self.element.data( 'title' ),
							desc 	= self.element.data( 'description' ),
							appId 	= self.element.data( 'id' );

						// If this is a canvas layout, redirect the user to the canvas view.
						if( layout == 'canvas' )
						{
							window.location 	= url;
							return;
						}

						title 	= $._.isEmpty( self.options.pageTitle ) ? title : self.options.pageTitle;

						// If this is an embedded layout, we need to play around with the push state.
						History.pushState( {state:1} , title , url );

						// Notify the dashboard that it's starting to fetch the contents.
						self.dashboard.content().html("");
						self.dashboard.updatingContents();

						self.element.addClass( 'loading' );

						// Send a request to the dashboard to update the content from the specific app.
						EasySocial.ajax( 'site/controllers/dashboard/getAppContents' ,
						{
							"appId"		: appId
						})
						.done( function( contents )
						{
							self.dashboard.updateHeading( title , desc );

							self.dashboard.updateContents( contents );

						})
						.fail(function( messageObj ){

							return messageObj;

						})
						.always(function(){

							self.element.removeClass( 'loading' );

						});

					}


				}
			});
		module.resolve();
	});

});

EasySocial.module( 'site/dashboard/dashboard' , function($){

	var module = this;

	EasySocial.require()
	.script('site/dashboard/apps', 'site/dashboard/feeds', 'site/dashboard/sidebar', 'site/stream/filter', 'site/dashboard/groups', 'site/dashboard/events')
	.done(function($){

		EasySocial.Controller('Dashboard', {
			defaultOptions:
			{
				currentTitle 	: null,
				pageTitle 		: null,

				"{heading}"			: "[data-dashboard-heading]",
				"{sidebar}"			: "[data-dashboard-sidebar]",
				"{content}"			: "[data-dashboard-real-content]",

				// Feeds.
				"{feeds}"			: "[data-dashboard-feeds]",
				"{groups}"			: "[data-dashboard-groups]",
				"{events}": "[data-dashboard-events]",
				"{groupItems}"		: "[data-dashboard-group-item]",
				"{eventItems}"		: "[data-dashboard-event-item]",
				"{showAllFilters}"	: "[data-app-filters-showall]",
				"{showAllGroups}"	: "[data-groups-filters-showall]",
				"{showAllEvents}"	: "[data-events-filters-showall]",
				"{appFilters}"		: "[data-sidebar-app-filter]",

				// Applications.
				"{apps}"			: "[data-dashboard-apps]",

				// hashtag filter save
				"{saveHashTag}"		: "[data-hashtag-filter-save]"
			}
		}, function(self) {
			return{

				init: function()
				{
					// Implement sidebar controller.
					self.sidebar().implement(EasySocial.Controller.Dashboard.Sidebar, {
						"{parent}"	: self
					});

					// Implement app controller on all app items.
					self.feedsController = self.feeds().addController(EasySocial.Controller.Dashboard.Feeds, {
						"{parent}"	: self
					});

					// Implement app controller on all app items.
					self.apps().implement(EasySocial.Controller.Dashboard.Apps, {
						"{parent}"	: self,
						pageTitle	: self.options.pageTitle
					});

					// Implement groups navigation on dashboard
					self.groups().implement( EasySocial.Controller.Dashboard.Groups, {
						"{parent}"	: self
					});

					// Implement groups navigation on dashboard
					self.events().implement(EasySocial.Controller.Dashboard.Events, {
						"{parent}"	: self
					});
				},

				"{showAllGroups} click": function(el, event) {
					$(el).hide();

					self.groupItems().removeClass('hide');
				},

				"{showAllEvents} click": function(el, event) {
					$(el).hide();

					self.eventItems().removeClass('hide');
				},

				"{showAllFilters} click" : function( el , event )
				{
					$(el).hide();

					self.appFilters().removeClass( 'hide' );
				},

				/**
				 * Responsible to update the heading area in the dashboard.
				 */
				updateHeading: function( title , description )
				{
					self.heading().find( '[data-heading-title]' ).html( title );
					self.heading().find( '[data-heading-desc]' ).html( description );
				},

				/**
				 * Add a loading icon on the content layer.
				 */
				updatingContents: function()
				{
					self.element.addClass("loading");
				},

				/**
				 * Responsible to update the content area in the dashboard.
				 */
				updateContents : function( contents )
				{
					self.element.removeClass("loading");

					// Hide the content first.
					$.buildHTML( contents ).appendTo( self.content() );
				},



				"{saveHashTag} click": function( el )
				{
					var hashtag = el.data('tag');

					EasySocial.dialog({
						content		: EasySocial.ajax( 'site/views/stream/confirmSaveFilter', { "tag": hashtag } ),
						bindings	:
						{
							"{saveButton} click" : function()
							{
								this.inputWarning().hide();

								filterName = this.inputTitle().val();

								if( filterName == '' )
								{
									this.inputWarning().show();
									return;
								}

								EasySocial.ajax( 'site/controllers/stream/addFilter',
								{
									"title"		: filterName,
									"tag"		: hashtag,
								})
								.done(function( html, msg )
								{
									// self.feeds().append( html );

									var item = $.buildHTML( html );
									self.feedsController.addFilterItem( item );

									// show message
									EasySocial.dialog( msg );

									// auto close the dialog
									setTimeout(function() {
										EasySocial.dialog().close();
									}, 2000);

								});
							}
						}
					});
				}


			}
		});

		module.resolve();
	});

});

EasySocial.module('site/dashboard/feeds', function($){

	var module 				= this;

	EasySocial.require()
	.library( 'history' )
	.done(function($){

		EasySocial.Controller(
			'Dashboard.Feeds',
			{
				defaultOptions:
				{
					"{item}"	: "[data-dashboardFeeds-item]",
					"{filter}"	: "[data-dashboardFeeds-Filter-edit]"
				}
			},
			function(self){

				return{

					init : function()
					{
						// Implement each feed links.
						self.item().implement(EasySocial.Controller.Dashboard.Feeds.Item, {
							"{parent}"		: self,
							"{dashboard}"	: self.parent
						});
					},

					addFilterItem: function(feed)
					{
						feed.find('[data-dashboardFeeds-item]').implement(EasySocial.Controller.Dashboard.Feeds.Item, {
							"{parent}"		: self,
							"{dashboard}"	: self.parent
						});

						// feed.appendTo(self.element);
						if ($(self.element).find('.widget-filter-group').length > 0) {
							feed.insertBefore($(self.element).find('.widget-filter-group'));
						} else {
							feed.appendTo(self.element);
						}
					}
				}
			});

		EasySocial.Controller('Dashboard.Feeds.Item', {
			defaultOptions:
			{
			}
		}, function(self) {
			return{

				clicked: false,

				init : function()
				{
				},

				"{self} click" : function()
				{
					//remove no-stream class if any
					$('.es-streams').removeClass( 'no-stream' );

					var type = self.element.data( 'type' ),
						id = self.element.data( 'id' ),
						url = self.element.data( 'url' ),
						title = self.element.data( 'title' ),
						desc = self.element.data( 'description' );

					if (self.clicked) {
						return;
					}

					self.clicked	= true;

					// clear the new feed notification counter.
					var key = '[data-stream-counter-';

					if (type == 'list') {
						key = key + type + '-' + id;
					} else {
						key = key + type;
					}

					key = key + ']';

					$(key).html( '0' );

					// clear new feed counter
					self.element.removeClass('has-notice');

			        var appendTitle = $.joomla.appendTitle;

			        if (appendTitle==="before") {
			            title = $.joomla.sitename + ((title) ? " - " + title : "");
			        }

			        if (appendTitle==="after") {
			            title = ((title) ? title + " - " : "") + $.joomla.sitename;
			        }

					// If this is an embedded layout, we need to play around with the push state.
					History.pushState( {state:1} , title , url );

					// Notify the dashboard that it's starting to fetch the contents.
					self.dashboard.content().html("");
					self.dashboard.updatingContents();

					self.element.addClass('loading');

					EasySocial.ajax( 'site/controllers/dashboard/getStream', {
						"type"	: type,
						"id"	: id,
						"view"  : 'dashboard',
					})
					.done(function(contents, count) {

						self.dashboard.updateHeading(title, desc);

						if (count == 0) {
							$('.es-streams').addClass( 'no-stream' );
						}

						// Trigger change for the stream
						self.trigger('onStreamUpdate', [type]);

						window.streamFilter = type;

						self.dashboard.updateContents(contents);

						// add support to kunena [tex] replacement.
						try { MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]); } catch( err ) {};

					}).fail(function(messageObj) {
						return messageObj;
					}).always(function() {
						self.clicked	= false;
						self.element.removeClass('loading');
					});


				}
			}
		});
		module.resolve();
	});

});

EasySocial.module('site/dashboard/sidebar', function($){

	var module = this;

	EasySocial
	.require()
	.library('history')
	.done(function($) {

		EasySocial.Controller('Dashboard.Sidebar', {
			defaultOptions: {
				"{menuItem}"	: "[data-dashboardSidebar-menu]",
				"{filterBtn}"	: "[data-stream-filter-button]",
				"{editIcon}" 	: "[data-dashboardFeeds-Filter-edit]"
			}
		}, function(self) { return {

			init: function() {
			},
			
			"{menuItem} click": function(menuItem, event) {
				
				// Remove all active class.
				self.menuItem().removeClass('active');

				// Add active class on this item.
				menuItem.addClass('active');
			},

			"{editIcon} click" : function(editIcon, event) {
				event.preventDefault();

				// Update the browser's url
				editIcon.route();
					
				var id = editIcon.data('id');

				// Notify the dashboard that it's starting to fetch the contents.
				self.parent.content().html("");
				self.parent.updatingContents();

				EasySocial.ajax('site/controllers/stream/getFilter', {
					"id": id
				}).done(function(contents) {
					self.parent.updateContents(contents);
				}).fail(function(messageObj) {
					return messageObj;
				});
			},

			"{filterBtn} click" : function(filterButton, event) {
				event.preventDefault();

				// Update the url
				filterButton.route();

				// Notify the dashboard that it's starting to fetch the contents.
				self.parent.content().html("");
				self.parent.updatingContents();

				EasySocial.ajax( 'site/controllers/stream/getFilter', {
					"id": 0
				})
				.done(function(contents) {
					self.parent.updateContents(contents);
				})
				.fail(function(messageObj) {
					return messageObj;
				});
			}
		}});

		module.resolve();
	});

});

EasySocial.module( 'site/stream/filter' , function($){

	var module 				= this;

	EasySocial.require()
	.script( 'site/stream/sidebar' )
	.language(
		'COM_EASYSOCIAL_STREAM_FILTER_WARNING_TITLE_EMPTY',
		'COM_EASYSOCIAL_STREAM_FILTER_WARNING_HASHTAG_EMPTY'
	)
	.done(function($){

		EasySocial.Controller(
			'Stream.Filter',
			{
				defaultOptions:
				{
					"{heading}"			: "[data-filter-heading]",
					"{sidebar}"			: "[data-sidebar-item]",
					"{content}"			: "[data-filter-real-content]"

				}
			},
			function(self){

				return{

					init: function()
					{
						// Implement sidebar controller.
						self.sidebar().implement(EasySocial.Controller.Stream.Filter.Sidebar, {
							"{parent}"	: self
						});

					},

					/**
					 * Responsible to update the heading area in the dashboard.
					 */
					updateHeading: function( title , description )
					{
						self.heading().find( '[data-heading-title]' ).html( title );
						self.heading().find( '[data-heading-desc]' ).html( description );
					},

					/**
					 * Add a loading icon on the content layer.
					 */
					updatingContents: function()
					{
						self.element.addClass("loading");
					},

					/**
					 * Responsible to update the content area in the dashboard.
					 */
					updateContents : function( contents )
					{
						self.element.removeClass("loading");

						// Hide the content first.
						self.content().html( contents );
					}
				}
			});

		EasySocial.Controller(
			'Stream.Filter.Item',
			{
				defaultOptions:
				{
					"{title}"	: "[data-filter-name]",
					"{hashtag}"	: "[data-filter-hashtag]",
					"{saveBtn}"	: "[data-stream-filter-save]",
					"{deleteBtn}"	: "[data-stream-filter-delete]",
					"{form}"	: "[data-filter-inputForm]",

					"{notice}"	: "[filter-form-notice]"
				}
			}, function(self) {

				return{
					init: function()
					{
					},

					"{deleteBtn} click" : function( el )
					{
						var fid = el.data('id');
						var uid = el.data('uid');
						var utype = el.data('utype');

						var controllerPath = 'site/controllers/stream/deleteFilter';

						if( uid )
						{
							var controllerPath = 'site/controllers/' + utype + 's/deleteFilter';
						}

						EasySocial.dialog({
							content		: EasySocial.ajax( 'site/views/stream/confirmFilterDelete' ),
							bindings	:
							{
								"{deleteButton} click" : function()
								{
									EasySocial.ajax( controllerPath,
									{
										"id"		: fid,
										"uid" 		: uid,
										"utype"		: utype
									})
									.done(function( html )
									{
										self.element.fadeOut();

										// close dialog box.
										EasySocial.dialog().close();
									});
								}
							}
						});
					},

					"{saveBtn} click" : function()
					{

						$('div.control-group').removeClass( 'error' );
						self.notice().html();
						self.notice().hide();

						if( self.title().val() == '' )
						{
							self.title().parents('div.control-group').addClass( 'error' );

							self.notice().html( $.language( 'COM_EASYSOCIAL_STREAM_FILTER_WARNING_TITLE_EMPTY' ) );
							self.notice().show();

							return false;
						}

						if( self.hashtag().val() == '' )
						{
							self.hashtag().parents('div.control-group').addClass( 'error' );

							self.notice().html( $.language( 'COM_EASYSOCIAL_STREAM_FILTER_WARNING_HASHTAG_EMPTY' ) );
							self.notice().show();

							return false;
						}

						self.form().submit();
					}


				}

			});

		module.resolve();
	});

});

EasySocial.module('site/stream/sidebar', function($) {

	var module = this;

	EasySocial.require()
	.done(function($){

		EasySocial.Controller('Stream.Filter.Sidebar', {
			defaultOptions: {
			}
		}, function(self) {

			return{

				init: function()
				{
				},
				"{self} click" : function()
				{
					$('[data-sidebar-item]').removeClass('active loading');
					self.element.addClass('active');

					var id = self.element.data('id'),
						url = self.element.data('url'),
						title = self.element.data('title');

					// If this is an embedded layout, we need to play around with the push state.
					History.pushState({state:1} , title , url);

					// Notify the dashboard that it's starting to fetch the contents.
					self.parent.content().html("");
					self.parent.updatingContents();

					self.element.addClass('loading');

					EasySocial.ajax('site/controllers/stream/getFilter', {
						"id": id
					})
					.done(function(contents) {
						self.parent.updateContents(contents);
					})
					.fail(function(messageObj) {
						return messageObj;
					})
					.always(function(){
						self.element.removeClass('loading');
					});
				}
			}
		});

		module.resolve();
	});

});

EasySocial.module( 'site/dashboard/groups' , function($){

	var module 				= this;

	EasySocial.require()
	.library( 'history' )
	.done(function($){

		EasySocial.Controller(
			'Dashboard.Groups',
			{
				defaultOptions:
				{
					"{item}"	: "[data-dashboard-group-item]",
					"{itemLink}": "[data-dashboard-group-item] > a"
				}
			},
			function(self)
			{

				return{

					init : function()
					{
						// console.log( 'here' , self.item() );
					},

					/**
					 * Fires when a feed link is clicked.
					 */
					"{item} click" : function( el , event )
					{
						event.preventDefault();

						$('.es-streams').removeClass( 'no-stream' );

						var type 	= $( el ).data( 'type' ),
							id		= $( el ).data( 'id' ),
							desc 	= $( el ).data( 'description' );

						// clear new feed counter
						self.element.removeClass( 'has-notice' );

						// If this is an embedded layout, we need to play around with the push state.
						$( el ).find( 'a' ).route();

						// Notify the dashboard that it's starting to fetch the contents.
						self.parent.content().html("");
						self.parent.updatingContents();

						self.element.addClass( 'loading' );

						EasySocial.ajax( 'site/controllers/dashboard/getStream' ,
						{
							"type"	: type,
							"id"	: id,
							"view" 	: "dashboard"
						})
						.done(function( contents )
						{
							self.parent.updateContents( contents );
						});
					}
				}
			});
		module.resolve();
	});

});

EasySocial.module('site/dashboard/events', function($){

	var module 				= this;

	EasySocial.require()
	.library('history')
	.done(function($){

		EasySocial.Controller(
			'Dashboard.Events',
			{
				defaultOptions:
				{
					"{item}"	: "[data-dashboard-event-item]",
					"{itemLink}": "[data-dashboard-event-item] > a"
				}
			},
			function(self)
			{

				return{

					init : function()
					{
					},

					/**
					 * Fires when a feed link is clicked.
					 */
					"{item} click" : function(el, event)
					{
						event.preventDefault();

						$('.es-streams').removeClass('no-stream');

						var type 	= $(el).data('type'),
							id		= $(el).data('id'),
							desc 	= $(el).data('description');

						// clear new feed counter
						self.element.removeClass('has-notice');

						// If this is an embedded layout, we need to play around with the push state.
						$( el ).find('a').route();

						// Notify the dashboard that it's starting to fetch the contents.
						self.parent.content().html("");
						self.parent.updatingContents();

						self.element.addClass('loading');

						EasySocial.ajax('site/controllers/dashboard/getStream',
						{
							"type"	: type,
							"id"	: id,
							"view" 	: "dashboard"
						})
						.done(function(contents) {
							self.parent.updateContents(contents);
						});
					}
				}
			});
		module.resolve();
	});

});

EasySocial.module('site/events/browser', function($) {
    var module = this;

    EasySocial
    .require()
    .library('popbox')
    .script('site/events/guestState')
    .language('COM_EASYSOCIAL_EVENTS_DETECTING_LOCATION')
    .view('site/loading/small')
    .done(function() {
        EasySocial.Controller('Events.Browser', {
            defaultOptions: {
                '{filters}': '[data-events-filters] > li',
                '{content}': '[data-events-content]',
                '{list}': '[data-events-list]',

                '{items}': '[data-events-item]',

                '{sort}': '[data-events-sorting] a',
                '{calendar}': '[data-events-calendar]',

                '{pastFilter}': '[data-events-past]',
                '{pastLink}': '[data-events-past-link]',

                '{prevDate}': '[data-events-nav-prevdate]',

                '{nextDate}': '[data-events-nav-nextdate]',

                '{radius}': '[data-events-radius]',

                '{nearbyTitle}': '[data-events-nearby-title]',

                filter: null,
                categoryid: 0,

                delayed: false,

                includePast: false,
                ordering: 'start',

                hasLocation: false,
                userLatitude: '',
                userLongitude: '',

                distance: 10,

                group: null,

                view: {
                    loadingContent: 'site/loading/small'
                }
            }
        }, function(self) {
            return {
                init: function() {
                    self.options.filter = self.element.data('filter');
                    self.options.categoryid = self.element.data('categoryid');

                    // Render the calendar
                    self.renderCalendar();

                    self.initItems();

                    if (self.options.delayed) {
                        self.delayedInit();
                    }
                },

                delayedInit: function() {
                    // It is possible that view is flagging it as "delayed" in order for javascript to make an ajax call to retrieve the data instead

                    // delayed init will have some preset parameter coming from url, hence we don't use the filterbynearby method

                    if (self.options.filter === 'nearby') {
                        var getEvents = function() {
                            EasySocial.ajax('site/controllers/events/getEvents', {
                                filter: self.options.filter,
                                latitude: self.options.userLatitude,
                                longitude: self.options.userLongitude,
                                distance: self.options.distance,
                                ordering: self.options.ordering,
                                includePast: self.options.includePast
                            }).done(function(contents) {
                                self.element.removeClass('loading');

                                self.content().html(contents);

                                self.initItems();
                            });
                        }

                        if (self.options.hasLocation && self.options.userLatitude && self.options.userLongitude) {
                            return getEvents();
                        }

                        // If no location, then we need to resolve a location first

                        // Show the image of "detecting location"

                        EasySocial.require().library('gmaps').done(function() {
                            $.GMaps.geolocate({
                                success: function(position) {
                                    self.options.userLatitude = position.coords.latitude;

                                    self.options.userLongitude = position.coords.longitude;

                                    return getEvents();
                                }
                            });
                        });
                    }
                },

                renderCalendar: function() {
                    EasySocial.ajax('site/views/events/renderCalendar', {})
                        .done(function(html) {
                            self.calendar()
                                .html(html)
                                .addController('EasySocial.Controller.Events.Browser.Calendar', {
                                    '{parent}': self
                                });

                            self.calendar().trigger('calendarLoaded');
                        });
                },

                initItems: function() {
                    self.items().addController('EasySocial.Controller.Events.Browser.Item', {
                        '{parent}': self
                    });
                },

                '{filters} click': function(el, event) {
                    event.preventDefault();

                    self.filters().removeClass('active');

                    el.addClass('active');

                    self.content().html('&nbsp;');

                    // Update the url in the address bar
                    el.find('a').route();

                    self.options.filter = el.data('events-filters-type'),
                    self.options.categoryid = el.data('events-filters-categoryid');

                    // Nearby requires separate processing
                    if (self.options.filter == 'nearby') {
                        return self.filterByNearby();
                    }

                    // Add loading class on container
                    self.element.addClass('loading');

                    EasySocial.ajax('site/controllers/events/getEvents', {
                        filter: self.options.filter,
                        categoryid: self.options.categoryid
                    }).done(function(contents) {

                        // Remove the loading from the container
                        self.element.removeClass('loading');

                        self.content().html(contents);

                        self.initItems();
                    });
                },

                filterByNearby: function() {
                    var getEvents = function() {
                        EasySocial.ajax('site/controllers/events/getEvents', {
                            filter: self.options.filter,
                            latitude: self.options.userLatitude,
                            longitude: self.options.userLongitude
                        }).done(function(contents) {
                            self.element.removeClass('loading');

                            self.content().html(contents);

                            self.initItems();
                        });
                    }

                    if (self.options.hasLocation && self.options.userLatitude && self.options.userLongitude) {
                        self.element.addClass('loading');

                        return getEvents();
                    }

                    // If no location, then we need to resolve a location first

                    // Show a detecting location
                    self.content().html('<div class="es-detecting-location"><i class="fa fa-globe es-muted"></i> ' + $.language('COM_EASYSOCIAL_EVENTS_DETECTING_LOCATION') + ' <i class="icon-loader"></i></div>');

                    // Show the image of "detecting location"

                    EasySocial.require().library('gmaps').done(function() {
                        $.GMaps.geolocate({
                            success: function(position) {
                                self.options.userLatitude = position.coords.latitude;

                                self.options.userLongitude = position.coords.longitude;

                                self.options.hasLocation = true;

                                return getEvents();
                            }
                        });
                    });
                },

                '{sort} click': function(el, event) {
                    event.preventDefault();

                    self.sort().removeClass('active');

                    el.addClass('active');

                    // self.element.addClass('loading');

                    self.list().html(self.view.loadingContent());

                    var ordering = el.data('ordering'),
                        filter = el.data('filter'),
                        categoryid = el.data('categoryid'),
                        includePast = self.pastFilter().is(':checked') ? 1 : 0;

                    self.setPastLink();

                    self.setSortLink();

                    el.route();

                    if (filter === 'nearby') {
                        EasySocial.ajax('site/controllers/events/getEvents', {
                            filter: self.options.filter,
                            latitude: self.options.userLatitude,
                            longitude: self.options.userLongitude,
                            distance: self.options.distance,
                            ordering: ordering,
                            sort: 1,
                            includePast: includePast
                        }).done(function(contents) {
                            self.list().html(contents);

                            self.initItems();
                        });

                        return;
                    }

                    EasySocial.ajax('site/controllers/events/getEvents', {
                        filter: filter,
                        categoryid: categoryid,
                        ordering: ordering,
                        sort: 1,
                        includePast: includePast,
                        group: self.options.group
                    }).done(function(contents) {
                        self.list().html(contents);

                        self.initItems();
                    });
                },

                '{pastFilter} change': function(el) {
                    var activeSort = self.sort('.active'),
                        includePast = el.is(':checked') ? 1 : 0,
                        ordering = activeSort.data('ordering'),
                        filter = activeSort.data('filter'),
                        categoryid = activeSort.data('categoryid');

                    self.list().html(self.view.loadingContent());

                    self.pastLink().route();

                    self.setPastLink();

                    self.setSortLink();

                    if (filter === 'nearby') {
                        EasySocial.ajax('site/controllers/events/getEvents', {
                            filter: self.options.filter,
                            latitude: self.options.userLatitude,
                            longitude: self.options.userLongitude,
                            distance: self.options.distance,
                            ordering: ordering,
                            sort: 1,
                            includePast: includePast
                        }).done(function(contents) {
                            self.list().html(contents);

                            self.initItems();
                        });

                        return;
                    }

                    EasySocial.ajax('site/controllers/events/getEvents', {
                        filter: filter,
                        categoryid: categoryid,
                        ordering: ordering,
                        sort: 1,
                        includePast: includePast,
                        group: self.options.group
                    }).done(function(contents) {
                        self.list().html(contents);

                        self.initItems();
                    });
                },

                '{pastLink} click': function(el, ev) {
                    ev.preventDefault();

                    self.pastFilter().trigger('click');
                },

                setPastLink: function() {
                    var pastLink = self.pastLink(),
                        includePast = self.pastFilter().is(':checked') ? 1 : 0,
                        ordering = self.sort('.active').data('ordering');

                    var link = pastLink.data(ordering + '-' + (includePast ? 'nopast' : 'past'));

                    pastLink.attr('href', link);
                },

                setSortLink: function() {
                    var includePast = self.pastFilter().is(':checked') ? 1 : 0;

                    $.each(self.sort(), function(i, el) {
                        var el = $(el);
                        el.attr('href', self.pastLink().data(el.data('ordering') + '-' + (includePast ? 'past' : 'nopast')));
                    });
                },

                '{prevDate} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.filters().removeClass('active');

                    self.element.addClass('loading');

                    self.content().html('&nbsp;');

                    EasySocial.ajax('site/controllers/events/getEvents', {
                        filter: 'date',
                        date: el.data('events-nav-prevdate')
                    }).done(function(contents, options) {

                        // Remove the loading from the container
                        self.element.removeClass('loading');

                        self.content().html(contents);

                        self.initItems();

                        if (options.isToday) {
                            self.filters().removeClass('active');

                            self.filters('[data-events-filters-type="date"]').addClass('active');
                        }

                        if (options.isTomorrow) {
                            self.filters().removeClass('active');

                            self.filters('[data-events-filters-type="tomorrow"]').addClass('active');
                        }

                        if (options.isCurrentMonth) {
                            self.filters().removeClass('active');

                            self.filters('[data-events-filters-type="month"]').addClass('active');
                        }

                        if (options.isCurrentYear) {
                            self.filters().removeClass('active');

                            self.filters('[data-events-filters-type="year"]').addClass('active');
                        }
                    });
                },

                '{nextDate} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.filters().removeClass('active');

                    self.element.addClass('loading');

                    self.content().html('&nbsp;');

                    EasySocial.ajax('site/controllers/events/getEvents', {
                        filter: 'date',
                        date: el.data('events-nav-nextdate')
                    }).done(function(contents, options) {

                        // Remove the loading from the container
                        self.element.removeClass('loading');

                        self.content().html(contents);

                        self.initItems();

                        if (options.isToday) {
                            self.filters().removeClass('active');

                            self.filters('[data-events-filters-type="date"]').addClass('active');
                        }

                        if (options.isTomorrow) {
                            self.filters().removeClass('active');

                            self.filters('[data-events-filters-type="tomorrow"]').addClass('active');
                        }

                        if (options.isCurrentMonth) {
                            self.filters().removeClass('active');

                            self.filters('[data-events-filters-type="month"]').addClass('active');
                        }

                        if (options.isCurrentYear) {
                            self.filters().removeClass('active');

                            self.filters('[data-events-filters-type="year"]').addClass('active');
                        }
                    });
                },

                '{radius} change': function(el, ev) {
                    var activeSort = self.sort('.active'),
                        includePast = self.pastFilter().is(':checked') ? 1 : 0,
                        ordering = activeSort.data('ordering'),
                        filter = activeSort.data('filter'),
                        categoryid = activeSort.data('categoryid'),
                        distance = el.val();

                    self.options.distance = distance;

                    self.list().html(self.view.loadingContent());

                    // self.pastLink().route();

                    // self.setPastLink();

                    // self.setSortLink();

                    EasySocial.ajax('site/controllers/events/getEvents', {
                        filter: 'nearby',
                        latitude: self.options.userLatitude,
                        longitude: self.options.userLongitude,
                        distance: self.options.distance,
                        ordering: ordering,
                        includePast: includePast,
                        sort: 1
                    }).done(function(contents, options) {
                        self.list().html(contents);

                        self.initItems();

                        History.pushState({state:1}, document.title, options.hrefs[ordering][includePast ? 'past' : 'nopast']);

                        self.pastLink().attr('href', options.hrefs[ordering][includePast ? 'nopast' : 'past']);

                        $.each(self.sort(), function(i, el) {
                            var el = $(el);
                            el.attr('href', options.hrefs[el.data('ordering')][includePast ? 'past' : 'nopast']);

                            self.pastLink().attr('data-' + el.data('ordering') + '-past', options.hrefs[el.data('ordering')]['past']);
                            self.pastLink().attr('data-' + el.data('ordering') + '-nopast', options.hrefs[el.data('ordering')]['nopast']);
                        });

                        self.nearbyTitle().text(options.title);
                    });
                }
            }
        });

        EasySocial.Controller('Events.Browser.Item', {
            defaultOptions: {
                id: null,

                '{action}': '[data-item-action]',

                '{unfeature}': '[data-item-unfeature]',
                '{feature}': '[data-item-feature]',
                '{unpublish}': '[data-item-unpublish]',
                '{delete}': '[data-item-delete]',

                '{guestStateWrap}': '[data-guest-state-wrap]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.options.id = self.element.data('id');

                    self.initGuestStates();
                },

                initGuestStates: function() {
                    self.guestStateWrap().addController('EasySocial.Controller.Events.GuestState');
                },

                '{action} click': function(el) {
                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/itemActionDialog', {
                            id: self.options.id,
                            action: el.data('item-action'),
                            from: 'list'
                        })
                    });
                },

                '{delete} click': function() {
                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/deleteEventDialog', {
                            id: self.options.id
                        })
                    });
                }
            }
        });

        EasySocial.Controller('Events.Browser.Calendar', {
            defaultOptions: {
                '{nav}': '[data-calendar-nav]',

                '{day}': '.day',

                '{month}': '[data-month]',

                view: {
                    loading: 'site/loading/small'
                }
            }
        }, function(self) {
            return {
                init: function() {

                },

                '{self} calendarLoaded': function() {
                    self.day('.has-events').each(function(index, el) {
                        el = $(el);

                        var content = el.find('.event-details').html();

                        el.popbox({
                            content: content,
                            id: 'fd',
                            component: 'es',
                            type: 'events-calendar-filter',
                            position: 'bottom-left',
                            toggle: 'hover'
                        });
                    });

                    var month = self.month('.has-events');

                    if (month.length > 0) {
                        var content = month.find('.event-details').html();
                        month.popbox({
                            content: content,
                            id: 'fd',
                            component: 'es',
                            type: 'events-calendar-filter',
                            position: 'bottom-left',
                            toggle: 'hover'
                        });
                    }
                },

                '{nav} click': function(el, ev) {
                    var date = el.data('calendar-nav');

                    self.element.html(self.view.loading());

                    EasySocial.ajax('site/views/events/renderCalendar', {
                        date: date
                    }).done(function(html) {
                        self.element
                            .html(html)
                            .trigger('calendarLoaded');
                    });
                },

                '{day} click': function(el, ev) {
                    ev.preventDefault();

                    // Update the url in the address bar
                    el.find('a[data-route]:first').route();

                    self.loadEvents(el.data('date'));
                },

                '{day} popboxActivate': function(el, ev, popbox) {
                    popbox.tooltip.find('a[data-route]').on('click', function(event) {
                        event.preventDefault();

                        $(this).route();

                        self.loadEvents($(this).data('date'));
                    });
                },

                '{month} click': function(el, ev) {
                    ev.preventDefault();

                    // Update the url in the address bar
                    el.find('a[data-route]:first').route();

                    self.loadEvents(el.data('month'));
                },

                '{month} popboxActivate': function(el, ev, popbox) {
                    popbox.tooltip.find('a[data-route]').on('click', function(event) {
                        event.preventDefault();

                        $(this).route();

                        self.loadEvents($(this).data('month'));
                    });
                },

                loadEvents: function(date) {
                    self.parent.filters().removeClass('active');

                    // Add loading class on container
                    self.parent.element.addClass('loading');
                    self.parent.content().html('&nbsp;');

                    EasySocial.ajax('site/controllers/events/getEvents', {
                        filter: 'date',
                        date: date
                    }).done(function(contents, options) {

                        // Remove the loading from the container
                        self.parent.element.removeClass('loading');

                        self.parent.content().html(contents);

                        self.parent.initItems();

                        if (options.isToday) {
                            self.parent.filters().removeClass('active');

                            self.parent.filters('[data-events-filters-type="date"]').addClass('active');
                        }

                        if (options.isTomorrow) {
                            self.parent.filters().removeClass('active');

                            self.parent.filters('[data-events-filters-type="tomorrow"]').addClass('active');
                        }

                        if (options.isCurrentMonth) {
                            self.parent.filters().removeClass('active');

                            self.parent.filters('[data-events-filters-type="month"]').addClass('active');
                        }

                        if (options.isCurrentYear) {
                            self.parent.filters().removeClass('active');

                            self.parent.filters('[data-events-filters-type="year"]').addClass('active');
                        }
                    });
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('site/events/guestState', function($) {
    var module = this;

    EasySocial
    .require()
    .language('COM_EASYSOCIAL_EVENTS_GUEST_PENDING')
    .done(function($) {

        EasySocial.Controller('Events.GuestState', {
            defaultOptions: {
                id: null,

                allowMaybe: 1,

                allowNotGoingGuest: 1,

                hidetext: 1,

                refresh: false,

                '{guestAction}': '[data-guest-action]',

                '{guestState}': '[data-guest-state]',

                '{request}': '[data-guest-request]',

                '{withdraw}': '[data-guest-withdraw]',

                '{respond}': '[data-guest-respond]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.options.id = self.element.data('id');

                    self.options.allowMaybe = self.element.data('allowmaybe');
                    self.options.allowNotGoingGuest = self.element.data('allownotgoingguest');
                    self.options.hidetext = self.element.data('hidetext');

                    // Determines if the page requires a refresh
                    // If this is a item page, then the element will have a data-refresh flag
                    // If this is a listing page, then no refresh is required
                    self.options.refresh = self.element.is('[data-refresh]');

                    // self.initPopbox();
                },

                showError: function(msg) {
                    EasySocial.dialog({
                        content: msg
                    });
                },

                stateClasses: {
                    'going': 'btn-es-success',
                    'maybe': 'btn-es-info',
                    'notgoing': 'btn-es-danger'
                },

                '{guestAction} click': function(el) {
                    // Depending on the action

                    var action = el.data('guestAction');

                    if (action === 'state') {
                        var state = el.data('guestState');

                        self.guestAction().removeClass('btn-es-success btn-es-info btn-es-danger');

                        el.addClass(self.stateClasses[state]);

                        if (state === 'notgoing' && !self.options.allowNotGoingGuest) {
                            EasySocial.dialog({
                                content: EasySocial.ajax('site/views/events/notGoingDialog', {
                                    id: self.options.id
                                }),
                                bindings: {
                                    '{closeButton} click': function() {
                                        EasySocial.ajax('site/views/events/refreshGuestState', {
                                            id: self.options.id,
                                            hidetext: self.options.hidetext
                                        }).done(function(html) {
                                            self.element.html(html);

                                            EasySocial.dialog().close();
                                        });
                                    },
                                    '{submitButton} click': function() {
                                        self.response('notgoing')
                                            .done(function() {
                                                if (self.options.refresh) {
                                                    return location.reload();
                                                }

                                                EasySocial.ajax('site/views/events/refreshGuestState', {
                                                    id: self.options.id,
                                                    hidetext: self.options.hidetext
                                                }).done(function(html) {
                                                    self.element.html(html);

                                                    EasySocial.dialog().close();
                                                });
                                            });
                                    }
                                }
                            });
                        } else {
                            self.response(state)
                                .done(function() {
                                    if (self.options.refresh) {
                                        return location.reload();
                                    }
                                })
                                .fail(function(error) {
                                    el.removeClass(self.stateClasses[action]);

                                    self.showError(error.message);
                                });
                        }
                    }

                    if (action === 'request') {
                        EasySocial.dialog({
                            content: EasySocial.ajax('site/views/events/requestDialog', {
                                id: self.options.id
                            }),
                            bindings: {
                                '{submitButton} click': function() {
                                    el
                                        .attr('data-guest-action', 'withdraw')
                                        .data('guestAction', 'withdraw')
                                        .removeAttr('data-guest-request')
                                        .attr('data-guest-withdraw', '')
                                        .text($.language('COM_EASYSOCIAL_EVENTS_GUEST_PENDING'));

                                    self.response(action);

                                    EasySocial.dialog().close();
                                }
                            }
                        });
                    }

                    if (action === 'withdraw') {
                        EasySocial.dialog({
                            content: EasySocial.ajax('site/views/events/withdrawDialog', {
                                id: self.options.id
                            }),
                            bindings: {
                                '{submitButton} click': function() {
                                    self.response('withdraw')
                                        .done(function() {
                                            EasySocial.ajax('site/views/events/refreshGuestState', {
                                                id: self.options.id,
                                                hidetext: self.options.hidetext
                                            }).done(function(html) {
                                                self.element.html(html);

                                                EasySocial.dialog().close();
                                            });
                                        });
                                }
                            }
                        });
                    }

                    if (action === 'attend') {
                        self.response('going').done(function() {
                            EasySocial.ajax('site/views/events/refreshGuestState', {
                                id: self.options.id,
                                hidetext: self.options.hidetext
                            }).done(function(html) {
                                if (self.options.refresh) {
                                    return location.reload();
                                }

                                if (html !== undefined) {
                                    self.element.html(html);

                                    EasySocial.dialog().close();
                                }
                            });
                        });
                    }
                },

                response: function(action) {
                    return EasySocial.ajax('site/controllers/events/guestResponse', {
                        id: self.options.id,
                        state: action
                    });
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('site/events/buttonState', function($) {
    var module = this;

    EasySocial
    .require()
    .language('COM_EASYSOCIAL_EVENTS_GUEST_PENDING')
    .done(function($) {

        EasySocial.Controller('Events.ButtonState', {
            defaultOptions: {
                id: null,

                allowMaybe: 1,

                allowNotGoingGuest: 1,

                hidetext: 1,

                refresh: false,

                isPopbox: 0,

                '{guestAction}': '[data-guest-action]',

                '{guestState}': '[data-guest-state]',

                '{request}': '[data-guest-request]',

                '{withdraw}': '[data-guest-withdraw]',

                '{respond}': '[data-guest-respond]',


                "{rsvpButton}" : "[data-event-rsvp-button]",

            }
        }, function(self) {
            return {
                init: function() {
                    // event id
                    self.options.id = self.element.data('id');

                    self.options.allowMaybe = self.element.data('allowmaybe');
                    self.options.allowNotGoingGuest = self.element.data('allownotgoingguest');
                    self.options.hidetext = self.element.data('hidetext');
                    self.options.isPopbox = self.element.data('ispopbox');
                    // Determines if the page requires a refresh
                    // If this is a item page, then the element will have a data-refresh flag
                    // If this is a listing page, then no refresh is required
                    // self.options.refresh = self.element.is('[data-refresh]');

                    // self.initPopbox();
                },

                showError: function(msg) {
                    EasySocial.dialog({
                        content: msg.message
                    });
                },

                stateClasses: {
                    'going': 'btn-es-success',
                    'maybe': 'btn-es-info',
                    'notgoing': 'btn-es-danger'
                },

                refreshButton: function() {

                   EasySocial.ajax('site/views/events/refreshButtonState', {
                        id: self.options.id,
                        hidetext: self.options.hidetext,
                        isPopbox: self.options.isPopbox
                    }).done(function(html) {
                        self.element.replaceWith(html);
                    });
                },

                "{rsvpButton} popboxActivate": function(el, event, popbox) {
                    // popbox.content  or console.dir(popbox) to see what is inside

                    var selector = 'div#' + popbox.id  + '.popbox-' + popbox.type + ' [data-event-button-container]';
                    $(selector).addController('EasySocial.Controller.Events.ButtonState.Popbox', {
                        "{parent}": self
                    });

                },

                '{guestAction} click': function(el) {
                    self.doAction(el);
                },

                doAction: function(el) {

                    // Depending on the action
                    var action = el.data('guestAction');

                    if (action === 'state') {

                        var state = el.data('guestState');

                        if (state === 'notgoing' && !self.options.allowNotGoingGuest) {

                            EasySocial.dialog({
                                content: EasySocial.ajax('site/views/events/notGoingDialog', {
                                    id: self.options.id
                                }),
                                bindings: {
                                    '{closeButton} click': function() {
                                        self.refreshButton();
                                        EasySocial.dialog().close();
                                    },
                                    '{submitButton} click': function() {
                                        self.response('notgoing')
                                            .done(function() {
                                                self.refreshButton();
                                                EasySocial.dialog().close();
                                            });
                                    }
                                }
                            });
                        } else {

                            self.response(state)
                                .done(function() {
                                    self.refreshButton();
                                })
                                .fail(function(msg) {
                                    el.removeClass(self.stateClasses[action]);
                                    self.showError(msg);
                                });

                        }
                    }

                    if (action === 'request') {
                        EasySocial.dialog({
                            content: EasySocial.ajax('site/views/events/requestDialog', {
                                id: self.options.id
                            }),
                            bindings: {
                                '{submitButton} click': function() {
                                    el
                                        .attr('data-guest-action', 'withdraw')
                                        .data('guestAction', 'withdraw')
                                        .removeAttr('data-guest-request')
                                        .attr('data-guest-withdraw', '')
                                        .text($.language('COM_EASYSOCIAL_EVENTS_GUEST_PENDING'));

                                    self.response(action);

                                    EasySocial.dialog().close();
                                }
                            }
                        });
                    }

                    if (action === 'withdraw') {
                        EasySocial.dialog({
                            content: EasySocial.ajax('site/views/events/withdrawDialog', {
                                id: self.options.id
                            }),
                            bindings: {
                                '{submitButton} click': function() {
                                    self.response('withdraw')
                                        .done(function() {
                                            self.refreshButton();
                                            EasySocial.dialog().close();
                                        });
                                }
                            }
                        });
                    }

                    if (action === 'attend') {
                        self.response('going').done(function() {
                            self.refreshButton();
                            EasySocial.dialog().close();
                        });
                    }
                },

                response: function(action) {
                    return EasySocial.ajax('site/controllers/events/guestResponse', {
                        id: self.options.id,
                        state: action
                    });
                }
            }
        });


        EasySocial.Controller("Events.ButtonState.Popbox",
        {
            defaultOptions: {
                '{guestAction}': '[data-guest-action]'
            }
        }, function(self) {
             return {
                init: function() {
                    console.log('Events.ButtonState.Popbox');
                },

                "{guestAction} click": function(el) {
                    self.parent.doAction(el);
                },

             }
        });


        module.resolve();
    });
});

EasySocial.module('site/events/create', function($) {
    var module = this;

    EasySocial.require().script('validate', 'field').done(function() {
        EasySocial.Controller('Events.Create', {
            defaultOptions: {
                'previousLink': null,

                '{fields}': '[data-create-field]',

                '{previous}': '[data-create-previous]',

                '{next}': '[data-create-submit]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.fields().addController('EasySocial.Controller.Field.Base');
                },

                '{previous} click': function() {
                    window.location = self.options.previousLink;
                },

                '{next} click': function(el) {
                    if (el.enabled()) {
                        el.disabled(true);

                        el.addClass('btn-loading');

                        self.element.validate()
                            .done(function() {
                                el.removeClass('btn-loading');
                                el.enabled(true);

                                self.element.submit();
                            })
                            .fail(function() {
                                el.removeClass('btn-loading');
                                el.enabled(true);

                                EasySocial.dialog({
                                    content: EasySocial.ajax('site/views/profile/showFormError')
                                });
                            });
                    }
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('site/events/createRecurring', function($) {
    var module = this;

    EasySocial.Controller('Events.CreateRecurring', {
        defaultOptions: {
            schedule: [],

            eventId: null,

            '{progress}': '[data-progress-bar]',

            '{form}': '[data-form]'
        }
    }, function(self) {
        return {
            init: function() {
                self.start();
            },

            counter: 0,

            start: function() {
                if (self.options.schedule[self.counter] === undefined) {
                    return self.completed();
                }

                self.create(self.options.schedule[self.counter])
                    .done(function() {
                        self.counter++;

                        var percentage = Math.ceil((self.counter / self.options.schedule.length) * 100);

                        self.progress().css({
                            width: percentage + '%'
                        });

                        self.start();
                    })
                    .fail(function(msg) {
                        console.log(msg);
                    });
            },

            create: function(datetime) {
                return EasySocial.ajax('site/controllers/events/createRecurring', {
                    eventId: self.options.eventId,
                    datetime: datetime
                });
            },

            completed: function() {
                self.progress().parent().removeClass('progress-info').addClass('progress-success');
                self.form().submit();
            }
        }
    })

    module.resolve();
});

EasySocial.module('site/events/edit', function($) {
    var module = this;

    EasySocial.require()
    .script('validate', 'field')
    .done(function() {
        EasySocial.Controller('Events.Edit', {
            defaultOptions: {
                id: null,

                isRecurring: 0,
                hasRecurring: 0,

                '{form}': '[data-form]',

                '{nav}': '[data-step-nav]',
                '{content}': '[data-step-content]',
                '{fields}': '[data-edit-field]',
                '{saveButton}': '[data-edit-save]',

                '{saveApply}': 'input[name="applyRecurring"]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.fields().addController('EasySocial.Controller.Field.Base', {
                        mode: 'edit'
                    });
                },

                errorFields: [],

                '{nav} click': function(el, ev) {
                    var id = $(el).data('for');

                    self.content().hide();

                    self.nav().removeClass('active');

                    el.addClass('active');

                    self.content().filterBy('id', id)
                        .show()
                        .find(self.fields.selector).trigger('show');
                },

                '{nav} error': function(el) {
                    el.addClass('error');
                },

                '{nav} clear': function(el) {
                    if (self.errorFields.length < 1) {
                        el.removeClass('error');
                    }
                },

                '{fields} error': function(el, ev) {
                    self.triggerStepError(el);
                },

                '{fields} clear': function(el, ev) {
                    self.clearStepError(el);
                },

                '{fieldItem} onError': function(el, ev) {
                    self.triggerStepError(el);
                },

                triggerStepError: function(el) {
                    var fieldid = el.data('id'),
                        stepid = el.parents(self.content.selector).data('id');

                    if ($.inArray(fieldid, self.errorFields) < 0) {
                        self.errorFields.push(fieldid);
                    }

                    self.nav().filterBy('for', stepid).trigger('error');
                },

                clearStepError: function(el) {
                    var fieldid = el.data('id'),
                        stepid = el.parents(self.content.selector).data('id');

                    self.errorFields = $.without(self.errorFields, fieldid);

                    self.nav().filterBy('for', stepid).trigger('clear');
                },

                '{saveButton} click': function(el, ev) {
                    ev.preventDefault();

                    el.addClass('btn-loading');

                    self.form().validate()
                        .done(function() {
                            // Check if this buttons has a value for data-edit-save to indicate if recurring should save all
                            if (el.data('editSave') === 'all') {
                                self.saveApply().val(1);
                            }

                            self.form().submit();
                        })
                        .fail(function() {
                            el.removeClass('btn-loading');
                            EasySocial.dialog({
                                content: EasySocial.ajax('site/views/profile/showFormError')
                            });
                        });
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('site/events/item', function($) {
    var module = this;

    EasySocial.template('info/item', '<li data-sidebar-item><a class="ml-20" href="[%= url %]" title="[%= title %]" data-info-item data-info-index="[%= index %]"><i class="fa fa-info-circle mr-5"></i> [%= title %]</a></li>');

    EasySocial
    .require()
    .script('site/friends/suggest', 'site/events/guestState')
    .view('site/loading/small')
    .library('history')
    .done(function($) {
        EasySocial.Controller('Events.Item', {
            defaultOptions: {
                id: null,

                '{filterStreamList}': '[data-filter-stream-list]',

                '{sidebarItem}': '[data-sidebar-item]',

                '{addFilter}': '[data-filter-add]',

                '{editFilter}': '[data-filter-edit]',

                '{filterStream}': '[data-filter-stream]',

                '{filterApp}': '[data-filter-app]',

                '{showAllFilters}': '[data-filter-showall]',

                '{apps}': '[data-app-item]',

                '{content}': '[data-content]',

                '{saveHashtag}': '[data-hashtag-filter-save]',

                '{invite}': '[data-action-invite]',

                '{unpublish}': '[data-action-unpublish]',

                '{delete}': '[data-action-delete]',

                '{guestStateWrap}': '[data-guest-state-wrap]',

                '{info}': '[data-info]',

                '{infoItem}': '[data-info-item]',

                "{menuItem}"    : "[data-dashboardSidebar-menu]",

                view: {
                    infoItem: 'info/item',
                    loading: 'site/loading/small'
                }
            }
        }, function(self) {
            return {
                init: function() {
                    self.initGuestStates();
                },

                initGuestStates: function() {
                    self.guestStateWrap().addController('EasySocial.Controller.Events.GuestState');
                },

                setActive: function(el) {
                    self.sidebarItem().removeClass('active');

                    el.parents(self.sidebarItem.selector).addClass('active');
                },

                setLoading: function(el) {
                    self.content().html('');

                    self.element.addClass('loading');
                },

                updateContents: function(html) {
                    self.element.removeClass('loading');

                    self.content().html(html);
                },

                '{showAllFilters} click': function(el, ev) {
                    el.hide();

                    self.sidebarItem().show();
                },

                '{editFilter} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.setLoading();

                    self.getFilter(el.data('id'));

                    self.setActive(el.parents('[data-sidebar-item]'));
                },

                '{addFilter} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.setActive(el);

                    self.setLoading();

                    self.getFilter(0);
                },

                getFilter: function(id) {
                    EasySocial.ajax('site/controllers/events/getFilter', {
                        filterId: id,
                        eventId: self.options.id
                    }).always(function(contents) {
                        self.updateContents(contents);
                    });
                },

                '{filterApp} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.setActive(el);

                    self.setLoading();

                    self.getStream(el.data('id'), 'apps');
                },

                '{filterStream} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.setActive(el);

                    self.setLoading();

                    self.getStream(el.data('id'), el.data('type'));
                },

                "{menuItem} click" : function( el , event )
                {
                    // Remove all active class.
                    self.menuItem().removeClass( 'active' );

                    // Add active class on this item.
                    $( el ).addClass( 'active' );
                },

                getStream: function(id, type) {
                    EasySocial.ajax('site/controllers/events/getStream', {
                        id: id,
                        type: type,
                        view: "events",
                        eventId: self.options.id
                    }).always(function(contents) {
                        self.updateContents(contents);
                    });
                },

                '{saveHashtag} click': function(el) {
                    var tag = el.data('tag');

                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/stream/confirmSaveFilter', {
                            tag: tag
                        }),
                        bindings: {
                            '{saveButton} click': function() {
                                this.inputWarning().hide();

                                var filterName = this.inputTitle().val();

                                if (filterName == '') {
                                    this.inputWarning().show();
                                    return;
                                }

                                EasySocial.ajax('site/controllers/events/addFilter', {
                                    title: filterName,
                                    tag: tag,
                                    id: self.options.id
                                }).done(function(html, msg) {
                                    var item = $.buildHTML(html);

                                    self.filterStreamList().append(item);

                                    EasySocial.dialog(msg);

                                    setTimeout(function() {
                                        EasySocial.dialog().close();
                                    }, 2000);
                                });
                            }
                        }
                    });
                },

                '{apps} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.setActive(el);

                    self.setLoading();

                    EasySocial.ajax('site/controllers/events/getAppContents', {
                        appId: el.data('app-id'),
                        eventId: self.options.id
                    }).always(function(contents) {
                        self.updateContents(contents);
                    });
                },

                '{info} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.setActive(el);

                    self.setLoading();

                    var loaded = el.data('loaded');

                    if (loaded) {
                        self.infoItem().eq(0).trigger('click');
                        return;
                    }

                    if (el.enabled()) {
                        el.disabled(true);

                        EasySocial.ajax('site/controllers/events/initInfo', {
                            eventId: self.options.id
                        }).done(function(steps) {
                            el.data('loaded', 1);

                            var parent = el.parent('[data-sidebar-item]');

                            // Append all the steps
                            $.each(steps.reverse(), function(index, step) {
                                if (!step.hide) {
                                    parent.after(self.view.infoItem({
                                        url: step.url,
                                        title: step.title,
                                        index: step.index
                                    }));
                                }

                                if (step.html) {
                                    self.updateContents(step.html);
                                    self.content().find('[data-field]').trigger('onShow');
                                }
                            });

                            var item = self.infoItem().eq(0);

                            self.setActive(item);

                            // Have to set the title
                            $(document).prop('title', item.attr('title'));

                            el.enabled(true);
                        }).fail(function(error) {
                            el.enabled(true);
                            self.updateContents(error.message);
                        });
                    }
                },

                '{infoItem} click': function(el, ev) {
                    ev.preventDefault();

                    el.route();

                    self.setActive(el);

                    self.setLoading();

                    var index = el.data('info-index');

                    EasySocial.ajax('site/controllers/events/getInfo', {
                        eventId: self.options.id,
                        index: index
                    }).done(function(contents) {
                        self.updateContents(contents);

                        self.content().find('[data-field]').trigger('onShow');
                    }).fail(function(error) {
                        self.updateContents(error.message);
                    });
                },

                '{invite} click': function(el, ev) {
                    EasySocial.dialog({
                        content: self.view.loading(),
                        width: 400,
                        heigth: 150
                    });

                    EasySocial.ajax('site/views/events/inviteFriendsDialog', {
                        'id' : self.options.id
                    }).done(function(content) {
                        EasySocial.dialog({
                            content: content
                        });
                    });
                },

                '{unpublish} click': function(el, ev) {
                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/unpublishEventDialog', {
                            id: self.options.id
                        })
                    });
                },

                '{delete} click': function(el, ev) {
                    EasySocial.dialog({
                        content: EasySocial.ajax('site/views/events/deleteEventDialog', {
                            id: self.options.id
                        })
                    });
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module('site/events/update', function($) {
    var module = this;

    EasySocial.Controller('Events.Update', {
        defaultOptions: {
            postdata: {},
            updateids: [],
            schedule: [],

            eventId: null,

            '{progress}': '[data-progress-bar]',

            '{form}': '[data-form]'
        }
    }, function(self) {
        return {
            init: function() {
                self.startUpdate();
            },

            updateCounter: 0,
            createCounter: 0,

            updateProgressBar: function() {
                var percentage = Math.ceil(((self.updateCounter + self.createCounter) / (self.options.updateids.length + self.options.schedule.length)) * 100);

                self.progress().css({
                    width: percentage + '%'
                });
            },

            startUpdate: function() {
                if (self.options.updateids[self.updateCounter] === undefined) {
                    return self.startCreate();
                }

                self.update(self.options.updateids[self.updateCounter])
                    .done(function() {
                        self.updateCounter++;

                        self.updateProgressBar();

                        self.startUpdate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            update: function(id) {
                var post = $.extend({}, self.options.postdata, {
                    id: id,
                    applyRecurring: 1
                });

                return EasySocial.ajax('site/controllers/events/update', post);
            },

            startCreate: function() {
                if (self.options.schedule[self.createCounter] === undefined) {
                    return self.completed();
                }

                self.create(self.options.schedule[self.createCounter])
                    .done(function() {
                        self.createCounter++;

                        self.updateProgressBar();

                        self.startCreate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            create: function(datetime) {
                return EasySocial.ajax('site/controllers/events/createRecurring', {
                    eventId: self.options.eventId,
                    datetime: datetime
                });
            },

            completed: function() {
                self.progress().parent().removeClass('progress-info').addClass('progress-success');
                self.form().submit();
            }
        }
    });

    module.resolve();
});

EasySocial.module("site/explorer", function($) {

	var module = this;

	var CLASS_SELECTED = "is-selected",
		STATE_SELECTED = ".is-selected",
		CLASS_CHECKED = "is-checked",
		STATE_CHECKED = ".is-checked",
		STATE_NOT_SELECTED = ":not(.is-selected)",
		CLASS_ACTIVE = "is-active",
		STATE_ACTIVE = ".is-active",
		EVENT_FILE_SELECT = "fileSelect",
		EVENT_FILE_DESELECT = "fileDeselect",
		EVENT_FOLDER_ACTIVATE = "folderActivate",
		EVENT_FOLDER_DEACTIVATE = "folderDeactivate",
		EVENT_FILE_INSERT = "fileInsert",
		EVENT_FOLDER_INSERT = "folderInsert",
		EVENT_FILE_REMOVE = "fileRemove",
		EVENT_FOLDER_REMOVE = "folderRemove",
		EVENT_FILE_USE = "fileUse",
		EVENT_SERVICE_REQUEST = "serviceRequest";

	$.template("explorer/folder", '<div class="fd-explorer-folder" data-id="[%== data.id %]">[%== data.name %]<a href="javascript: void(0);" class="fd-folder-remove-button" data-fd-explorer-delete-folder-button><i class="fa fa-remove"></i></a></div>');

	$.template("explorer/fileGroup", '<div class="fd-explorer-file-group" data-folder="[%== data.id %]" data-plupload-dropsite></div>');

	$.template("explorer/file", '<div class="fd-explorer-file" data-id="[%== data.id %]">[%== data.name %]</div>');

	// TODO: Move this to Foundry
	EasySocial.require()
		.script("site/explorer/uploader")
		.done();

	$.Controller("Explorer",
	{
		pluginName: "explorer",
		hostname: "explorer",

		defaultOptions: {
			view: {
				folder: "explorer/folder",
				fileGroup: "explorer/fileGroup",
				file: "explorer/file"
			},

			layout: {
				fileItemHeight: 52
			},

			uid: null,
			type: null,
			disableValidation: false,
			mockError: false,
			controllerName: null,
			
			"{browser}"    : ".fd-explorer-browser",
			"{viewport}"   : ".fd-explorer-viewport",
			"{folderGroup}": ".fd-explorer-folder-group",
			"{folder}"     : ".fd-explorer-folder",
			"{fileGroup}"  : ".fd-explorer-file-group",
			"{file}"       : ".fd-explorer-file",
			"{button}"     : "[data-fd-explorer-button]",

			"{mockError}"  : "[name=mock_error]",
			"{disableValidation}": "[name=disable_validation]",
			"{fileInput}"  : "[name=file]",
			"{logs}"       : "[data-alertlog]",
			"{togglefunky}": ".togglefunky",
			"{funky}": ".fd-explorer-funky",
			"{serviceState}": ".service-state",


			"{selectAllCheckbox}": "[data-fd-explorer-select-all]",
			"{selectCheckbox}"   : "[data-fd-explorer-select]",

			"{deleteButton}": "[data-fd-explorer-delete-button]",
			"{deleteFolderButton}": "[data-fd-explorer-delete-folder-button]"
		}
	},
	function(self, opts, base) { return {

		init: function() {

			// Set the type and uid
			self.options.type = self.element.data('type');
			self.options.uid  = self.element.data('uid');
			self.options.controllerName = self.element.data('controller-name');

			// Extend with uploader plugin
			// TODO: Move this to Foundry
			$.module("easysocial/site/explorer/uploader")
				.done(function(controller){
					self.addPlugin("uploader", controller);
				});

			// Get folder list
			self.services.getFolders()
				.done(function(data){

					// Generate folder list
					self.insertFolder(data);

					// Activate first folder
					self.folder(":first").click();
				});

			self.viewport().on("scroll", $.debounce(self.viewportScroll, 250));
		},

		baseParams: function() {

			return {
				uid: base.data("uid"),
				type: base.data("type")
			};
		},

		exception: function(ex) {

			var logs = self.logs();

			if (!$.isPlainObject(ex)) {
				ex = {
					message: ex,
					type: "error"
				};
			};

			switch (ex.type) {

				case "error":
					logs.switchClass("alert-error")
						.html(ex.message);
					EasySocial.debug && console.error(ex.message);
					break;

				case "warning":
					logs.switchClass("alert-warning")
						.html(ex.message);
					EasySocial.debug && console.warn(ex.message);
					break;

				case "success":
					logs.switchClass("alert-success")
						.html(ex.message);
					EasySocial.debug && console.log(ex.message);
					break;

				case "info":
				default:
					logs.switchClass("alert-info")
						.html(ex.message);
					EasySocial.debug && console.log(ex.message);
					break;
			}

			return ex;
		},

		library: {
			file: {},
			folder: {}
		},

		data: function(type, id) {

			return self.library[type][id];
		},

		addData: function(type, data) {

			// Normalize arguments
			if ($.isPlainObject(data)) data = [data];

			if (!$.isArray(data)) {
				return self.exception("Unable to add " + type + " to library due to invalid data given.");
			}

			$.each(data, function(i){

				if (!$.isPlainObject(this)) {
					self.exception("Skipping invalid " + type + " data at index " + i + ".");
				}

				// TODO: Server should return proper 0 value.
				if (this.id===null) this.id = 0;

				/*
				var existing = self.library[type][this.id];
				if (existing) {
					self.exception("Replacing existing " + type + " in library for id " + this.id + ".");
				}
				*/

				self.library[type][this.id] = this;
			});
		},

		removeData: function(type, id) {

			delete self.library[type][id];
		},

		// Navigation
		"{folder} click": function(folder) {

			self.activateFolder(folder.data("id"));
		},

		currentFolder: function() {

			return self.folder(STATE_ACTIVE).data("id");
		},

		activateFolder: function(id) {

			var folder = self.folder().filterBy("id", id),
				data = self.data("folder", id);

			if (folder.length < 1) return;

			// Deactivate currently active folder
			self.deactivateFolder(self.folder(STATE_ACTIVE).data("id"));

			// Activate this folder
			folder.addClass(CLASS_ACTIVE);
			self.trigger(EVENT_FOLDER_ACTIVATE, [id, folder, data]);
		},

		deactivateFolder: function(id) {

			var folder = self.folder().filterBy("id", id),
				data = folder.data("folder");

			if (folder.length < 1) return;

			folder.removeClass(CLASS_ACTIVE);
			self.trigger(EVENT_FOLDER_DEACTIVATE, [id, folder, data]);
		},

		selectedFolder: function() {

			return self.currentFolder();
		},

		"{file} click": function(file, event) {

			var multiple = event.metaKey || event.ctrlKey;

			// Deselect existing selection if we're not
			// selecting multiple selection.
			if (!multiple) self.deselectAllFiles();

			// Select or deselect file
			self.toggleFile(file.data("id"));
		},

		toggleFile: function(id) {

			var file = self.file().filterBy("id", id),
				method = file.hasClass(CLASS_SELECTED) ? "deselectFile" : "selectFile";

			if (file.length < 1) return;

			self[method](id);
		},

		selectFile: function(id) {

			var file = self.file().filterBy("id", id),
				data = self.data("file", id);

			if (file.length < 1) return;

			file.addClass(CLASS_SELECTED);
			// file.find(self.selectCheckbox.selector).prop("checked", true);

			self.trigger(EVENT_FILE_SELECT, [id, file, data]);
		},

		deselectFile: function(id) {

			var file = self.file().filterBy("id", id),
				data = file.data("file", id);

			if (file.length < 1) return;

			file.removeClass(CLASS_SELECTED);
			// file.find(self.selectCheckbox.selector).prop("checked", false);

			self.trigger(EVENT_FILE_DESELECT, [id, file, data]);
		},

		selectAllFiles: function() {

			self.file(STATE_NOT_SELECTED).each(function(){
				self.selectFile($(this).data("id"));
			});
		},

		deselectAllFiles: function() {

			self.file(STATE_SELECTED).each(function(){
				self.deselectFile($(this).data("id"));
			});
		},

		selectedFile: function() {

			return self.selectedFiles()[0];
		},

		selectedFiles: function() {

			var files = [],
				selectedFiles;

			// TODO: Need to rethink this.
			// Prefer checked files over selected files
			var selectedFiles = self.file(STATE_CHECKED);

			if (selectedFiles.length < 1) {
				selectedFiles = self.file(STATE_SELECTED);
			}

			selectedFiles
				.each(function(){
					var id = $(this).data("id");
					files.push(id);
				});

			return files;
		},

		insertFolder: function(data) {

			// Normalize arguments.
			if (!$.isArray(data)) data = [data];

			// Validate data.
			var sample = data[0];

			if (!$.isPlainObject(sample)) {
				return self.exception("Invalid folder data given to be inserted into the folder group.");

			}

			// Find folder group.
			var folderGroup = self.folderGroup();

			if (folderGroup.length < 1) {
				return self.exception("Could not locate folder group element.");
			}

			// Generate folders html in a bulk to speeed up DOM insertion.
			var folders = "";
			$.each(data, function(){

				// TODO: Server should return proper 0 value.
				if (this.id===null) this.id = 0;

				folders += self.view.folder(true, {data: this});
			});

			// Insert folders into folder group.
			folders = $.buildHTML(folders).appendTo(folderGroup);

			// Trigger folder insert event.
			self.trigger(EVENT_FOLDER_INSERT, [folders, data]);
		},

		prependFile: function(data) {

			if (!$.isPlainObject(data)) {
				return self.exception("Invalid file data given to be inserted.");
			}

			// Find file group
			var fileGroup = self.fileGroup().filterBy("folder", data.folder);

			if (fileGroup.length < 1) {
				return self.exception("Could not locate file group element for folder id " + data.folder + ".");
			}

			var html = data.html || self.view.file(true, {data: data});

			$.buildHTML(html)
				.data("finalized", true)
				.prependTo(fileGroup);
		},

		insertFile: function(data, id) {

			// Normalize arguments.
			if (!$.isArray(data)) data = [data];

			if (id===undefined) {

				// Validate data.
				var sample = data[0];

				if (!$.isPlainObject(sample)) {
					return self.exception("Invalid file data given to be inserted.");
				}

				id = sample.folder;
			}

			// Find file group
			var fileGroup = self.fileGroup().filterBy("folder", id);

			if (fileGroup.length < 1) {
				return self.exception("Could not locate file group element for folder id " + data.folder + ".");
			}

			var files = [];

			$.each(data, function(){

				var filedata = this;

				self.file().filterBy("id", this.id).each(function(){

					var file = $(this);

					if (file.data("finalized")) return;

					var html = $.buildHTML(filedata.html || self.view.file(true, {data: filedata})).data("finalized", true);

					file.replaceWith(html);

				});
			});

			// Generate files html in bulk to speed up DOM insertion.
			// var files = "";

			// $.each(data, function(){
			// 	files += self.view.file(true, {data: this});
			// });

			// Insert files into file group.
			// files = $.buildHTML(files).appendTo(fileGroup);

			// Trigger file insert event.
			self.trigger(EVENT_FILE_INSERT, [files, data]);
		},

		removeFolder: function(id) {

			// Remove folder.
			var folder = self.folder().filterBy("id", id), failed;

			if (folder.length < 1) {
				failed = self.exception("Could not locate to remove folder element for folder id " + id + ".");
			}

			folder.remove();

			// Remove file group of this folder.
			var fileGroup = self.fileGroup().filterBy("folder", id);

			if (fileGroup.length < 1) {
				failed = self.exception("Could not locate to remove file group element for folder id " + id + ".");
			}

			fileGroup.remove();

			self.trigger(EVENT_FOLDER_REMOVE, [id, failed]);
		},

		removeFile: function(id) {

			// Remove file.
			var file = self.file().filterBy("id", id), failed;

			if (file.length < 1) {
				failed = self.exception("Could not locate to remove file element for file id " + id + ".");
			}

			file.remove();

			self.trigger(EVENT_FILE_REMOVE, [id, failed]);
		},

		// Service
		service: function(hook, params, ajaxOptions) {

			self.serviceState().switchClass("state-busy");

			var task =
				EasySocial.ajax(
						base.data("url"),
						$.extend({
							hook: hook,
							error: opts.mockError
						}, params),
						ajaxOptions
					)
					.always(function(){
						// self.exception({
						// 	type: "info",
						// 	message: "Log message will show here."
						// })
						self.serviceState().switchClass("state-idle");
					})
					.fail(function(ex){
						self.exception(ex);
					});

			// Trigger an event for this service request
			self.trigger(EVENT_SERVICE_REQUEST, [hook, task, params]);

			return task;
		},

		"{button} click": function(button) {

			var hook = button.attr('data-fd-explorer-button'),
				method = self.services[hook];

			// Execute hook
			method && method();
		},

		services: {

			getFolders: function(params) {

				var defaultParams = {
					start: 0,
					limit: 100
				};

				var task =
					self.service("getFolders",
							$.extend(
								self.baseParams(),
								defaultParams,
								params
							)
						)
						.done(function(data){
							self.addData("folder", data);
						});

				return task;
			},

			addFolder: function(params) {

				if (!params) {
					params = {name: prompt($.language("COM_EASYSOCIAL_EXPLORER_ENTER_FOLDER_NAME"))};
				}

				var defaultParams = {
					name: ''
				};

				params = $.extend(self.baseParams() , defaultParams, params);

				if (!params.name && !opts.disableValidation) {
					self.exception({
						message: $.language("COM_EASYSOCIAL_EXPLORER_INVALID_FOLDER_NAME"),
						type: "error"
					});
					return;
				}

				var task =
					self.service("addFolder", params)
						.done(function(data){
							self.addData("folder", data);
							self.insertFolder(data);
						});

				return task;
			},

			removeFolder: function(params) {

				var defaultParams = {
					id: self.selectedFolder()
				};

				if (!opts.disableValidation && self.selectedFolder()===undefined) {
					self.exception("No folder selected");
					return;
				}

				var task =
					self.service("removeFolder", $.extend( self.baseParams() , defaultParams, params))
						.done(function(id){
							self.removeFolder(id);
						});

				return task;
			},

			getFiles: function(params) {

				var defaultParams = {
					start: 0,
					limit: 100
				};

				var task =
					self.service("getFiles", $.extend(self.baseParams() , defaultParams, params))
						.done(function(data){
							self.addData("file", data);
						});

				return task;
			},

			addFile: function(params) {

				// params: {id: id, file: file}
				var defaultParams = {
					id: self.currentFolder(),
					files: self.fileInput()
				};

				if (!opts.disableValidation && !self.fileInput().val()) {
					self.exception("No file chosen yet.");
					return;
				}

				var task =
					self.service("addFile", $.extend( self.baseParams(), defaultParams, params), {type: 'iframe'})
						.done(function(data){
							console.log("Upload returned data:", data);
							self.addData("file", data);
							self.prependFile(data);

							self.exception({
								message: "Added file " + data.name,
								type: "success"
							});
						});

				return task;
			},

			removeFile: function(params) {

				var defaultParams = {
					id: self.selectedFiles()
				};

				var params = $.extend(self.baseParams(), defaultParams, params);

				if (!opts.disableValidation && $.isArray(params.id) && params.length < 1) {
					self.exception("No file selected");
					return;
				}

				var task =
					self.service("removeFile", params)
						.done(function(id){

							if ($.isArray(id)) {
								$.each(id, function(){
									self.removeFile(this);
								});
							} else {
								self.removeFile(id);
							}

							self.selectAllCheckbox().prop("checked", false);
						});

				return task;
			},

			useFile: function() {

				var id = self.selectedFile(),
				 	file = self.file().filterBy("id", id),
					data = self.data("file", id);

				if (file.length < 1) return;

				self.trigger(EVENT_FILE_USE, [id, file, data]);
			},

			previewFile: function() {

				var id = self.selectedFile(),
				 	file = self.file().filterBy("id", id),
					data = self.data("file", id);

				var url = file.data("previewUri");
				if (!url) return;

				window.open(url, "_blank");
			}
		},

		// UI
		"{self} folderActivate": function(explorer, event, id, folder, data) {

			// Find file group.
			var fileGroups = self.fileGroup(),
				fileGroup = fileGroups.filterBy("folder", id);

			// Deactivate other groups
			fileGroups.removeClass(CLASS_ACTIVE);

			// If file group hasn't been created before
			if (fileGroup.length < 1) {

				// TODO: Server should return an empty map.
				if (!data.map) data.map = [];

				var map = '<div class="fd-explorer-file" data-id="' + data.map.join('">&nbsp;</div><div class="fd-explorer-file" data-id="') + '">&nbsp;</div>';

				// Create file group
				fileGroup =
					self.view.fileGroup({data: data})
						.html(map)
						.appendTo(self.viewport());

				// Get files from server
				self.services.getFiles({id: id})
					.done(function(data){

						// and insert file into file group
						self.insertFile(data, id);
					});
			}

			// Activate group
			fileGroup.addClass("is-active");
		},

		// "{viewport} scroll": function(viewport) {

			// TODO: Determine position of list

			// cosole.log("scrolling");
		// }

		viewportScroll: function() {

			var viewport = self.viewport()[0],
				viewportHeight = self.viewport().height(),
				scrollHeight = viewport.scrollHeight,
				scrollTop = viewport.scrollTop,
				top = scrollTop - viewportHeight,
				itemHeight = self.file(":nth(2)").outerHeight(true);

			// console.log(viewport.scrollHeight);

			var index = Math.floor(scrollTop / itemHeight),
				tolerance = 3,
				fileGroup = self.fileGroup(".is-active"),
				id = fileGroup.data("folder");

			// self.browser().addClass("is-loading");

			self.services.getFiles({id: id, start: index - tolerance})
				.done(function(data){
					self.insertFile(data, id);
				})
				.always(function(){
					// self.browser().removeClass("is-loading");
				});
		},

		"{togglefunky} click": function() {
			self.funky().toggle();
		},

		"{disableValidation} change": function(input) {

			opts.disableValidation = !!input.prop("checked");

			self.exception({
				message: "Client-side validation is " + ((!opts.disableValidation) ? "ON!" : "OFF!"),
				type: "info"
			});
		},

		"{mockError} change": function(input) {

			opts.mockError = !!input.prop("checked");
			self.exception({
				message: "Error mocking is " + ((opts.mockError) ? "ON!" : "OFF!"),
				type: "info"
			});
		},

		"{selectAllCheckbox} click": function(checkbox) {

			var checked = checkbox.prop("checked");

			self.fileGroup(STATE_ACTIVE)
				.find(self.selectCheckbox.selector)
				.prop("checked", checked)
				.trigger("change");
		},

		"{selectCheckbox} change": function(checkbox) {

			var file = self.file.of(checkbox),
				id = file.data("id"),
				checked = checkbox.prop("checked");

			file.toggleClass("is-checked", checked);
		},

		"{deleteButton} click": function(deleteButton) {

			var file = self.file.of(deleteButton),
				id   = file.data("id");

			// Request the user for confirmation before deleting
			EasySocial.dialog(
			{
				content : EasySocial.ajax( 'site/views/explorer/confirmDeleteFile' ,  { "id" : id } ),
				bindings:
				{
					"{deleteButton} click" : function()
					{
						EasySocial.dialog().close();
						self.services.removeFile({id: id});
					}
				}
			});

		},

		"{deleteFolderButton} click": function(deleteFolderButton , event ) {

			event.preventDefault();

			var folder = self.folder.of(deleteFolderButton),
				id = folder.data("id");

			// Core folder cannot be deleted
			if (id===0) return;

			// Request the user for confirmation before deleting
			EasySocial.dialog(
			{
				content : EasySocial.ajax( 'site/views/explorer/confirmDeleteFolder' ,  { "id" : id } ),
				bindings:
				{
					"{deleteButton} click" : function()
					{
						EasySocial.dialog().close();
						self.services.removeFolder({id: id});
					}
				}
			});

		}
	}});

	EasySocial.require()
		.language(
			"COM_EASYSOCIAL_EXPLORER_ENTER_FOLDER_NAME",
			"COM_EASYSOCIAL_EXPLORER_INVALID_FOLDER_NAME"
		)
		.done(function(){
			module.resolve();
		});
});

EasySocial.module('site/explorer/uploader', function($) {

var module = this;

$.require()
	.library("plupload")
	.done(function(){

		var Controller =
		$.Controller("Explorer/Uploader",
		{
			defaultOptions: {

				settings: {},

				"{uploadItemGroup}": "[data-fd-explorer-upload-item-group]",
				"{uploadItem}"     : "[data-fd-explorer-upload-item]"
			}
		},
		function(self, opts, base) { return {

			init: function() {

				base.plupload(opts.settings);

				// Set a reference to plupload
				self.plupload = base.plupload("controller").plupload;
			},

			settings: function(key, val) {

				var settings = self.plupload.settings;

				// Setter
				if (val!==undefined) {
					settings[key] = val;
				}

				// Getter
				return (key) ? settings[key] : settings;
			},

			"{self} folderActivate": function(explorer, event, id, folder, data) {


			},

			"{self} BeforeUpload": function(el, event, uploader, file) {

				var url =
					$.uri(EasySocial.ajaxUrl)
						.addQueryParam("controller", self.explorer.options.controllerName)
						.addQueryParam("task", "explorer")
						.addQueryParam("id", self.explorer.currentFolder())
						.addQueryParam("no_html", 1)
						.addQueryParam("format", "json")
						.addQueryParam("hook", "addFile")
						.addQueryParam("tmpl", "component")
						.addQueryParam("uid", base.data("uid"))
						.addQueryParam("type", base.data("type"))
						.addQueryParam(EasySocial.token(), 1)
						.toString();

				self.settings("url", url);
			},

			"{self} FilesAdded": function(el, event, uploader, file) {

				self.plupload.start();
			},

			"{self} UploadFile": function() {

				clearTimeout(self.loadTimer);
				base.addClass("is-loading");
			},

			"{self} FileUploaded": function(el, event, uploader, file, data) {

				self.loadTimer = setTimeout(function(){
					base.removeClass("is-loading");
				}, 1000);

				var explorer = self.explorer;

				// If the response is not a valid object
				if (!$.isPlainObject(data)) {
					self.setMessage("Server did not return proper data after uploading.", "error");
					return;
				}

				explorer.addData("file", data);
				explorer.prependFile(data);
			},

			"{self} FileError": function(el, event, uploader, file, response) {

				base.removeClass("is-loading");

				if ($.isPlainObject(response)) {
					self.setMessage(response.message, "error");
				}
			},

			"{self} Error": function(el, event, uploader, error) {

				base.removeClass("is-loading");

				self.setMessage(error.message, "error");
			}

		}});

		module.resolve(Controller);
	});

});

EasySocial.module('site/explorer/popup', function($) {

var module = this;

EasySocial.require()
.view("site/explorer/popup")
.done(function(){

	$.Controller("Explorer/Popup",
	{
		defaultOptions: {

			view: {
				popup: "easysocial/site/explorer/popup"
			},

			"{popup}"   : "[data-explorer-popup]",
			"{viewport}": "[data-popup-viewport]",
			"{explorer}": "[data-explorer-popup] .fd-explorer",
			"{closeButton}": ".fd-explorer .close-button"
		}
	},
	function(self, opts, base) { return {

		init: function() {

		},

		"{window} resize": $.debounce(function() {

		}, 100),

		show: function() {

			var popup,
				node = self.popup.node;

			// Create node if not exists
			if (!node) {
				popup = self.view.popup();
				node  = self.popup.node = popup[0];
			}

			// Append node if detached
			if (!$.contains(base, node)) {
				popup = $(node).appendTo(base);
			}

			if (!popup.is(":visible")) {
				popup.show().trigger("show");
			}
		},

		hide: function() {

			self.popup()
				.hide()
				.trigger("hide")
				.detach();
		},

		// options: uid, type, url
		open: function(options) {

			self.show();

			var task = $.Deferred();

			var existingExplorer = self.explorer();

			if (existingExplorer.length > 0 &&
				existingExplorer.data("uid")===options.uid &&
				existingExplorer.data("type")===options.type) {
				return task.resolve(existingExplorer.explorer("controller"), self);
			}

			EasySocial.ajax("site/views/explorer/browser", options)
				.done(function(html){

					var browser = $.buildHTML(html);

					self.viewport()
						.empty()
						.append(browser);

					var explorer = browser.filter(".fd-explorer").explorer("controller");

					task.resolve(explorer, self);
				})
				.fail(function(){

					task.reject();
				});

			return task;
		},

		"{self} click": function(el, event) {

			if (event.target===self.popup()[0]) {
				self.hide();
			}
		},

		"{closeButton} click": function() {
			self.hide();
		}

	}});

	var instance = EasySocial.explorer = $("body").addController("Explorer/Popup");

	module.resolve(instance);
});

});

EasySocial.module( 'site/followers/followers' , function($){

	var module 	= this;

	EasySocial.require()
	.view( 'site/loading/small' )
	.script( 'site/conversations/composer' )
	.done(function($){

		EasySocial.Controller(
			'Followers',
			{
				defaultOptions :
				{
					"{content}"	: "[data-followers-content]",
					"{filter}"	: "[data-followers-filter]",
					"{items}"	: "[data-followers-item]",
					"{followingCounter}" : "[data-following-count]",
					'{suggestionCounter}' : "[data-suggest-count]",
					view :
					{
						loader 				: "site/loading/small"
					}
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						self.initItemController();
					},

					initItemController: function()
					{
						self.items().implement( EasySocial.Controller.Followers.Item ,
						{
							"{parent}"	: self
						});
					},

					updateFollowingCounter: function( value )
					{
						var current 	= self.followingCounter().html(),
							updated		= parseInt( current ) + value;

						self.followingCounter().html( updated );
					},

					updateSuggestionCounter: function( value )
					{
						var current 	= self.suggestionCounter().html(),
							updated		= parseInt( current ) + value;

						self.suggestionCounter().html( updated );
					},

					updateContents : function( contents )
					{
						self.content().replaceWith( contents );
					},

					updatePagination : function( pagination )
					{
						$('[data-followers-pagination]').html( pagination );
					},

					"{filter} click" : function(filter, event) {

						var type 	= filter.data( 'followers-filter-type' ),
							title 	= filter.data( 'followers-filter-title' ),
							id 		= filter.data( 'followers-filter-id' ),
							url 	= filter.data( 'followers-filter-url' );

						// Remove active class on all filters
						self.filter().removeClass("active");

						// Add active class to current filter
						filter.addClass("active");

						History.pushState({state:1}, title, url);

						EasySocial.ajax(
							"site/controllers/followers/filter",
							{
								id: id,
								type: type
							})
							.done(function(contents, pagination){

								self.updateContents(contents);
								self.updatePagination(pagination);
								self.initItemController();
							});
					}
				}
			});

			EasySocial.Controller(
				'Followers.Item',
				{
					defaultOptions :
					{
						"{unfollowButton}"	: "[data-followers-item-unfollow]",
						"{followButton}"	: "[data-followers-item-follow]",
						"{composer}"		: "[data-followers-item-compose]"
					}
				},
				function( self )
				{
					return {
						init : function()
						{
							self.options.id 			= self.element.data( 'id' );

							self.initComposer();
						},

						initComposer: function()
						{
							self.composer().implement( EasySocial.Controller.Conversations.Composer.Dialog,
							{
								"recipient"	:
								{
									"id"	: self.options.id
								}
							});
						},

						"{unfollowButton} click" : function()
						{
							EasySocial.dialog(
							{
								content 	: EasySocial.ajax( 'site/views/followers/confirmUnfollow' , { 'id' : self.options.id }),
								bindings 	:
								{
									"{unfollowButton} click" : function()
									{
										EasySocial.ajax( 'site/controllers/followers/unfollow' , { "id" : self.options.id} )
										.done(function()
										{
											// Update the counter
											self.parent.updateFollowingCounter( -1 );

											// Remove this item
											self.element.remove();

											EasySocial.dialog().close();
										});
									}
								}
							});
						},

						"{followButton} click" : function()
						{
							EasySocial.ajax( 'site/controllers/followers/follow' , { "id" : self.options.id} )
							.done(function(content)
							{
								// Update the suggestion counter
								self.parent.updateSuggestionCounter(-1);

								//update following counter
								self.parent.updateFollowingCounter(1);

								// Remove this item
								self.element.html(content);

							})
				            .fail(function(messageObject) {
				                EasySocial.dialog({
				                    content: messageObject.message
				                });
				            });
						}
					}
				});
		module.resolve();
	});
});

EasySocial.module( 'site/friends/friends' , function($){

	var module 	= this;

	EasySocial.require()
	.script(
		'site/friends/list' ,
		'site/friends/item' ,
		'site/friends/suggest',
		'site/conversations/composer'
	)
	.view(
		'site/loading/small' ,
		'site/friends/default.empty' ,
		'site/friends/list.assign'
	)
	.done(function($){

		EasySocial.Controller(
			'Friends.Birthday',
			{
				defaultOptions:
				{
					"{messageButton}"	: "[data-upcoming-birthday-message-button]"
				}
			},
			function( self ){
				return {
					init: function()
					{
						// Get the id of the current user.
						self.options.id 	= self.element.data( 'id' ),
						self.options.name 	= self.element.data( 'name' ),
						self.options.avatar	= self.element.data( 'avatar' );

						self.messageButton().implement( EasySocial.Controller.Conversations.Composer.Dialog,
						{
							"recipient"	:
							{
								"id"	: self.options.id,
								"name"	: self.options.name,
								"avatar": self.options.avatar
							}
						});
					}

				}
			}

		);


		EasySocial.Controller(
			'Friends',
			{
				defaultOptions:
				{
					// Get the default active list if there is any.
					activeList 		: null,

					// Left side friend's list.
					"{friendList}"	: "[data-friends-list]",

					// Content area.
					"{content}"		: "[data-friends-content]",

					// Result
					"{friendItems}"	: "[data-friends-items]",
					"{friendItem}"	: "[data-friends-item]",
					"{emptyList}"	: "[data-friends-emptyItems]",
					"{activeTitle}"	: "[data-friends-activeTitle]",

					// Friends filter
					"{filterItem}"	: "[data-friends-filter]",

					// Friend list actions
					"{friendListActions}"	: "[data-friendList-actions]",

					// Button to add a friend to the list.
					"{addFriendToList}"	: "[data-friends-add]",

					// Counters
					"{friendsCounter}"	: "[data-total-friends]",
					"{pendingCounter}"	: "[data-total-friends-pending]",
					"{suggestionCounter}": "[data-total-friends-suggestion]",
					"{requestCount}"	: "[data-frields-request-sent-count]",

					view :
					{
						loader 				: "site/loading/small",
						emptyFriendItems 	: "site/friends/default.empty",
						addUserForm			: "site/friends/list.assign"
					}

				}
			},
			function( self ){
				return {

					init: function()
					{
						// Implement friend list controller.
						self.friendList().implement( EasySocial.Controller.Friends.List ,
						{
							// parent : self,
							"{parent}" : self
						});

						//Initialize friend item controllers
						self.initFriendItems();
					},

					initFriendItems: function()
					{
						// Apply the friend list actions
						self.friendListActions().implement( EasySocial.Controller.Friends.List.Actions ,
						{
							"{parent}"	: self
						})

						// Implement friend item controller.
						self.friendItem().implement( EasySocial.Controller.Friends.Item ,
						{
							"{parent}"	: self
						});
					},

					updateFriendsCounter: function()
					{
						EasySocial.ajax( 'site/controllers/friends/getCounters' )
						.done(function( totalFriends , totalPending , totalRequests , totalSuggestion )
						{
							self.friendsCounter().html( totalFriends );

							self.pendingCounter().html( totalPending );

							self.requestCount().html( totalRequests );

							self.suggestionCounter().html( totalSuggestion );
						});
					},

					updateListCounters: function()
					{
						EasySocial.ajax( 'site/controllers/friends/getListCounts' ,
						{
						})
						.done( function( lists ){

							$( lists ).each( function( i , list){
								var listController = $( '[data-list-' + list.id + ']').controller();

								listController.updateCounter( list.count );
							});

						});
					},

					insertItem: function( item )
					{
						// Hide any empty notices.
						self.emptyList().hide();

						// Update the counter for the list items.
						self.updateListCounters();

						$( item ).implement( EasySocial.Controller.Friends.Item ,
						{
							"{parent}"	: self
						})
						.prependTo( self.friendItems() );

					},

					removeItem: function( id )
					{
						// Remove item from the list.
						self.friendItem( '[data-friendItem-' + id + ']' ).remove();

						if( self.friendItem().length <= 0 )
						{
							self.emptyList().show();
						}

						// Update the counter for the list items.
						self.updateListCounters();

					},

					updateFriendRequestCount: function( value )
					{
						curCount = parseInt( self.requestCount().text(), 10 );
						if( curCount != NaN )
						{
							curCount = curCount + value;
							self.requestCount().text( curCount );
						}
					},

					updateContent: function( html )
					{
						// Update the content on the friends list.
						self.content().replaceWith(html);

						self.initFriendItems();
					},

					removeActiveFilter: function()
					{
						self.filterItem().removeClass( 'active' );
					},

					"{filterItem} click" : function(filterItem, event )
					{
						var filterType 	= filterItem.data( 'filter' ),
							title 		= filterItem.data( 'title' ),
							userid 		= filterItem.data( 'userid' ),
							url 		= filterItem.data( 'url' );


						// Removes all active state from the friend lists
						if( self.friendList().length > 0)
						{
							self.friendList().controller().removeActiveList();
						}

						// Remove all active state on the filter links.
						self.filterItem().removeClass("active");

						// Add active class to this filter.
						filterItem.addClass( 'active' );

						History.pushState( {state:1} , title , url );

						filterItem.addClass( 'loading' );

						EasySocial.ajax(
							"site/controllers/friends/filter",
							{
								"filter"	: filterType,
								"userid"	: userid

							})
							.done(function(html){

								self.updateContent( html );
							})
							.always(function(){

								// Remove loading on the element.
								filterItem.removeClass("loading");
							});
					}
				}
			}
		);

		module.resolve();
	});
});

EasySocial.module( 'site/friends/list' , function($){

	var module 	= this;

	EasySocial.require()
	.view( 
		'site/loading/small'
	)
	.library( 'history' )
	.script( 'site/friends/suggest' )
	.done(function($){

		EasySocial.Controller(
			'Friends.List',
			{
				defaultOptions:
				{
					parent 		: null,

					"{item}"	: "[data-friends-listItem]",
					"{items}"	: "[data-friends-listItems]",

					"{loadMoreButton}"	: ".loadMoreButton",
					"{loadMore}"		: ".loadMore",

					view :
					{
						loader 		: "site/loading/small",
						items 		: "site/friends/default.lists"
					}
				}
			},
			function( self ){
				return {

					init: function()
					{
						self.item().implement( EasySocial.Controller.Friends.List.Item ,
						{
							"{parent}"	: self
						});
					},

					removeActiveList: function()
					{
						self.item().removeClass( 'active' );
					},

					setDefault : function( id )
					{
						// Remove all items with default class
						self.item().removeClass( 'default' );

						// Add default class on the item
						self.item( '.item-' + id ).addClass( 'default' );
					},

					"{item} click" : function( el )
					{
						var title 	= $(el).data( 'title' ),
							url 	= $(el).data( 'url' );

						History.pushState( {state:1} , title , url );

						// Remove all active class from filters.
						self.parent.removeActiveFilter();

						// Remove all active class from list
						self.item().removeClass( 'active' );

						// Add active class to this element.
						self.item( el ).addClass( 'active' );

						var id 	= $( el ).data( 'id' );

						// Set the active list.
						self.parent.options.activeList	= id;
						
						// Get list of friends.
						EasySocial.ajax( 'site/controllers/friends/getListFriends',
						{
							"id"	: id
						},
						{
							beforeSend: function()
							{
								$( el ).addClass( 'loading' );
							}
						})
						.done(function( html ){

							// Hide loading.
							$( el ).removeClass( 'loading' );

							// Trigger friends list to update with appropriate content.
							self.parent.updateContent( html );

						});
					},

					"{loadMoreButton} click" : function() {
						
						// Get current limit start.
						var limitstart	= self.loadMoreButton().data( 'limitstart' );

						self.loadMore().html( self.view.loader() );

						// Get list of friends.
						EasySocial.ajax(
							"site/controllers/friends/getLists",
							{
								limitstart: limitstart
							})
							.done(function( items ){

								// Hide load more button since nothing to load anymore.
								self.loadMore().hide();

								self.view.items({
									"items"	: items
								}).appendTo( self.items() );
							});
					}
				}
			}
		);

		EasySocial.Controller(
			'Friends.List.Item',
			{
				defaultOptions: 
				{
					id 			: null,

					"{counter}"	: "[data-list-counter]"
				}
			},
			function( self )
			{
				return {

					init: function()
					{
						self.options.id 	= self.element.data( 'id' );
					},

					updateCounter: function( total )
					{
						self.counter().html( total );
					}
				}
			});

		EasySocial.Controller(
			'Friends.List.Actions',
			{
				defaultOptions:
				{
					"{delete}"	: "[data-friendListActions-delete]",
					"{add}"		: "[data-friendListActions-add]",
					"{default}"	: "[data-friendListActions-default]"
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						self.options.id 	= self.element.data( 'id' );
						self.options.title 	= self.element.data( 'title' );
						self.options.userId	= self.element.data( 'userid' );
					},

					"{default} click" : function()
					{
						EasySocial.ajax( 'site/controllers/friends/setDefault' ,
						{
							"id"	: self.options.id
						})
						.done(function()
						{
							// Set the default class on the list item
							self.parent.friendList().controller().setDefault( self.options.id );
						});
					},

					"{add} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/friends/assignList' , { "id" : self.options.id } ),
							bindings 	:
							{
								"{insertButton} click" : function()
								{
									var items = this.suggest().textboxlist("controller").getAddedItems();

									EasySocial.ajax( 'site/controllers/friends/assign' ,
									{
										"uid"		: $.pluck(items, "id"),
										"userId"	: self.options.userId,
										"listId"	: self.options.id
									})
									.done(function( contents ){

										// Hide any notice messages.
										$( '[data-assignFriends-notice]' ).hide();
										

										$( contents ).each(function( i , item ){

											// Pass the item to the parent so it gets inserted into the friends list.
											self.parent.insertItem( item );

											$('[data-friends-items]').removeClass('is-empty');
											
											// Close the dialog
											EasySocial.dialog().close();
										});
									})
									.fail( function( message ){
										$( '[data-assignFriends-notice]' ).addClass( 'alert alert-error' )
											.html( message.message );
									});
								}
							}
						});
					},

					"{delete} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( "site/views/friends/confirmDeleteList" , { "id" : self.options.id } ),
							bindings	:
							{
								"{deleteButton} click" : function()
								{
									$( '[data-friends-list-delete-form]' ).submit();
								}
							}
						});
					}
				}
			}
		);

		module.resolve();
	});
});

EasySocial.module( 'site/friends/item' , function($){

	var module 	= this;

	EasySocial.require()
	.script( 'site/conversations/composer' )
	.language( 'COM_EASYSOCIAL_FRIENDS_REQUEST_SENT_PENDING_APPROVAL', 'COM_EASYSOCIAL_FRIENDS_REQUEST_DIALOG_TITLE', 'COM_EASYSOCIAL_FRIENDS_CANCEL_REQUEST_DIALOG_CANCELLED', 'COM_EASYSOCIAL_FRIENDS_REQUEST_SENT' )
	.done(function($){

		EasySocial.Controller(
			'Friends.Item',
			{
				defaultOptions:
				{
					id 					: null,
					name 				: null,
					friendId 			: null,

					"{removeFromList}"	: "[data-lists-removeFriend]",
					"{unfriend}"		: "[data-friends-unfriend]",
					"{addfriend}"		: "[data-friends-addfriend]",
					"{block}"			: "[data-friends-block]",
					"{message}"			: "[data-friendItem-message]",
					"{reject}"			: "[data-friendItem-reject]",
					"{approve}"			: "[data-friendItem-approve]",

					"{addContainer}" : "[data-friendItem-addbutton]",
					"{addButton}" : "[data-friendItem-add]",

					"{cancelRequest}"	: "[data-friendItem-cancel-request]"
				}
			},
			function( self ){
				return {

					init: function()
					{
						self.options.id 		= self.element.data( 'id' );
						self.options.name 		= self.element.data( 'name' );
						self.options.friendId	= self.element.data( 'friendid' );
						self.options.avatar 	= self.element.data( 'avatar' );

						// Initialize conversation links
						self.initConversation();
					},

					"{addButton} click" : function( el )
					{

						// Implement controller on add friend.
						EasySocial.ajax( 'site/controllers/friends/request' ,
						{
							"id"	: self.options.id
						}).done(function(friendId) {
							// replace the button with done message.
							self.addContainer().html( $.language('COM_EASYSOCIAL_FRIENDS_REQUEST_SENT') );
							self.addContainer().addClass('btn btn-es-success btn-sm mt-20');

						}).fail(function(obj) {


							EasySocial.dialog({
								width: 450,
								height: 180,
								content: obj.message
							});
						});
					},

					initConversation : function()
					{
						// Implement conversation controller on the message link.
						self.message().implement( EasySocial.Controller.Conversations.Composer.Dialog ,
						{
							"recipient"	:
							{
								"name"		: self.options.name,
								"id"		: self.options.id,
								"avatar"	: self.options.avatar
							}
						});

					},

					"{removeFromList} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/friends/confirmRemoveFromList' , { "id" : self.options.id }),
							bindings 	:
							{
								"{removeButton} click" : function()
								{
									EasySocial.ajax( 'site/controllers/friends/removeFromList' ,
									{
										"listId"	: self.parent.options.activeList,
										"userId"	: self.options.id
									})
									.done( function(){

										// Remove the item from the list.
										self.parent.removeItem( self.options.id );

										// Update the counter.

										// Update the dialog to notify the user that the user has been removed from the list.
										EasySocial.dialog(
										{
											"title"		: "User removed from list",
											"content"	: "The user has been removed from the list.",
											"buttons"	:
											[
												{
													"name"			: "Done",
													"classNames"	: "btn btn-es",
													"click"			: function()
													{
														EasySocial.dialog().close();
													}
												}
											]
										})
									})
									.fail( function(message){
										console.log( message );
									});
								}
							}
						});

					},

					"{reject} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/friends/confirmReject' , { "id" : self.options.id } ),
							bindings	:
							{
								// "{rejectButton} click" : function()
								// {
								// 	$( '[data-friends-reject-form]' ).submit();
								// }


								"{rejectButton} click" : function()
								{
									EasySocial.ajax( 'site/controllers/friends/reject' ,
									{
										"id"	: self.options.friendId
									})
									.done(function()
									{
										// Remove itself from the list.
										self.parent.removeItem( self.options.id );

										// Update the counter
										self.parent.updateFriendsCounter();

										EasySocial.dialog(
										{
											content 	: EasySocial.ajax( 'site/views/friends/friendRejected' )
										});
									});
								}



							}
						});
					},

					"{unfriend} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/friends/confirmUnfriend' , { "id" : self.options.id }),
							bindings 	:
							{
								"{unfriendButton} click" : function()
								{
									EasySocial.ajax( 'site/controllers/friends/unfriend' ,
									{
										"id"	: self.options.friendId
									})
									.done(function()
									{
										// Remove itself from the list.
										self.parent.removeItem( self.options.id );

										// Update the counter
										self.parent.updateFriendsCounter();

										EasySocial.dialog(
										{
											content 	: EasySocial.ajax( 'site/views/friends/friendRemoved' , { "id" : self.options.id } )
										});
									});
								}
							}
						});

					},

					"{cancelRequest} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/friends/confirmCancelRequest' , { "id" : self.options.id }),
							bindings 	:
							{
								"{cancelRequestButton} click" : function()
								{
									EasySocial.ajax( 'site/controllers/friends/cancelRequest' ,
									{
										"id"	: self.options.friendId
									})
									.done(function()
									{
										// Remove itself from the list.
										self.parent.removeItem( self.options.id );

										// update count.
										self.parent.updateFriendRequestCount( -1 );

										EasySocial.dialog(
										{
											content 	: EasySocial.ajax( 'site/views/friends/requestCancelled' , { "id" : self.options.id } )
										});
									});
								}
							}
						});

					},

					"{approve} click" : function( el )
					{
						EasySocial.ajax( 'site/controllers/friends/approve',
						{
							"id" : self.options.friendId
						})
						.done(function()
						{
							// Update the counter
							self.parent.updateFriendsCounter();

							// Remove this item from the pending list.
							self.element.remove();
						});
					},

					"{addfriend} click" : function( el )
					{

						// Implement controller on add friend.
						EasySocial.ajax( 'site/controllers/friends/request' ,
						{
							"id"	: self.options.id
						})
						.done( function( friendId )
						{
							// update count
							self.parent.updateFriendRequestCount( 1 );

							EasySocial.dialog({
								title: $.language('COM_EASYSOCIAL_FRIENDS_REQUEST_DIALOG_TITLE'),
								content: $.language('COM_EASYSOCIAL_FRIENDS_REQUEST_SENT_PENDING_APPROVAL', self.options.name )
							});

							// Remove itself from the list.
							self.parent.removeItem( self.options.id );
						})
						.fail(function( message )
						{
							EasySocial.dialog(
							{
								content 	: EasySocial.ajax( 'site/views/friends/exceeded' )
							});
						});
					},

					"{block} click" : function()
					{
						console.log( 'block' );
					}
				}
			}
		);

		module.resolve();
	});
});

EasySocial.module('site/groups/groups', function($)
{
	var module	= this;

	EasySocial.require()
	.view('site/loading/small')
	.script('validate', 'field')
	.done(function($) {
		EasySocial.Controller(
			'Groups.Browser', {
				
				defaultOptions: {
					"{filters}": "[data-es-groups-filters] > li",
					"{sort}": "[data-groups-sort]",
					"{categories}": "[data-es-groups-categories] >li",
					"{content}": "[data-es-groups-content]",
					"{items}": "[data-groups-item]",
					"{featured}": "[data-groups-featured-item]",
					"{listContents}": "[data-es-groups-list]",

					view: {
						loader: "site/loading/small"
					}
				}
			}, function(self) {
				return {

					init: function() {
						// Implement user item controller
						self.initGroupController();
					},

					initGroupController : function() {

						// Implement the filters
						self.filters().implement(EasySocial.Controller.Groups.Filter,{
							"{parent}" : self
						});

						// Implement the sorting
						self.sort().implement(EasySocial.Controller.Groups.Sort,{
							"{parent}" : self
						});

						// Implement category filters
						self.categories().implement(EasySocial.Controller.Groups.Filter.Category, {
							"{parent}": self
						});

						self.featured().implement(EasySocial.Controller.Groups.Browser.Item, {
							"{parent}": self
						});

						self.items().implement(EasySocial.Controller.Groups.Browser.Item, {
							"{parent}": self
						});
					},

					// Allows child items to set an active filter
					setActive: function(element) {
						// Remove all category filters
						self.categories().removeClass('active');

						// Remove all active items
						self.filters().removeClass('active');

						// Add active on the element
						$(element).addClass('active');

						// Add loading class
						self.content().html('&nbsp;');
						self.element.addClass('loading');
					},

					setListContent: function(contents) {

						self.listContents().html(contents);

						self.items().implement(EasySocial.Controller.Groups.Browser.Item, {
							"{parent}": self
						});
					},

					setContent: function(contents, replaceWrapper) {

						// When content is ready, we should remove the loading state.
						self.element.removeClass('loading');

						//Update the content
						if (replaceWrapper) {
							self.content().html(contents);	
						} else {
							self.listContents().html(contents);
						}
						
						self.items().implement(EasySocial.Controller.Groups.Browser.Item, {
							"{parent}": self
						});
					}
				}
			}
		);


		EasySocial.Controller('Groups.Browser.Item', {
				defaultOptions: {
					"{joinGroup}": "[data-groups-item-join]",
					"{leaveGroup}": "[data-groups-leave]",
					"{respond}": "[data-groups-item-respond]",
					"{setFeatured}": "[data-groups-item-set-featured]",
					"{removeFeatured}": "[data-groups-item-remove-featured]",
					"{deleteGroup}": "[data-groups-item-delete]",
					"{unpublishGroup}": "[data-groups-item-unpublish]",
					"{footer}": "[data-groups-item-footer]"
				}
			}, function(self, options, base) {

				return {
					
					init : function() {
						options.id = self.element.data('id');
						options.type = self.element.data('type');
					},

					"{deleteGroup} click" : function(el, event) {
						EasySocial.dialog({
							content 	: EasySocial.ajax('site/views/groups/confirmDelete', { "id" : self.options.id })
						});
					},

					"{unpublishGroup} click" : function(el, event) {
						EasySocial.dialog({
							content: EasySocial.ajax('site/views/groups/confirmUnpublishGroup', { "id" : self.options.id })
						});
					},

					"{setFeatured} click" : function(el, event) {
						EasySocial.dialog({
							content	: EasySocial.ajax('site/views/groups/setFeatured', {"id" : self.options.id})
						});
					},

					"{removeFeatured} click" : function(el, event) {
						EasySocial.dialog({
							content : EasySocial.ajax('site/views/groups/removeFeatured', { "id" : self.options.id })
						})
					},

					"{respond} click" : function(el, event) {
						EasySocial.dialog({
							content: EasySocial.ajax('site/views/groups/confirmRespondInvitation', { "id" : self.options.id }),
							bindings: {
								"{rejectButton} click" : function() {

									// Add loading
									base.switchClass('is-loading');

									EasySocial.ajax('site/controllers/groups/respondInvitation', {
										"id": options.id,
										"action": "reject"
									}).done(function() {

										// Show join button
										base.switchClass('is-guest');

										EasySocial.dialog().close();
									});
								},

								"{acceptButton} click" : function() {

									// Add loading
									base.switchClass('is-loading');

									EasySocial.ajax('site/controllers/groups/respondInvitation', {
										"id": options.id,
										"action": "accept"
									}).done(function() {

										// Show leave button
										base.switchClass('is-member');

										EasySocial.dialog().close();
									});
								}
							}
						});
					},

					"{leaveGroup} click": function(leaveButton, event) {

						EasySocial.dialog({
							content: EasySocial.ajax('site/views/groups/confirmLeaveGroup', {"id": options.id}),
							bindings: {
								"{leaveButton} click" : function() {

									// Add loading
									base.switchClass('is-loading');

									// Perform an ajax call to really leave the group
									EasySocial.ajax('site/controllers/groups/leaveGroup', {
										"id": options.id
									}).done(function() {
										// Show the join group again
										base.switchClass('is-guest');

										// Hide the dialog
										EasySocial.dialog().close();
									});
								}
							}
						});
					},

					"{joinGroup} click" : function(joinButton, event) {

						// If this is an open group, hide the join button since the user is already a member of the group
						if (options.type == 'open') {

							// Add loading
							base.switchClass('is-loading');

							// Join the group and hide the footer
							EasySocial.ajax('site/controllers/groups/joingroup', {
								"id": options.id
							}).done(function() {
								base.switchClass('is-member');
							});

							return;
						}

						// If this is a private group, display the standard popup.
						EasySocial.dialog({
							content: EasySocial.ajax('site/controllers/groups/joinGroup', { "id" : options.id})
						});
					}
				}
			}
		);

		EasySocial.Controller(
			'Groups.Edit', {
				defaultOptions: {
					id: null,

					"{stepContent}": "[data-group-edit-fields-content]",
					"{stepItem}": "[data-group-edit-fields-step]",

					// Forms.
					"{profileForm}": "[data-group-fields-form]",

					// Content for profile editing
					"{profileContent}": "[data-group-edit-fields]",

					"{fieldItem}": "[data-group-edit-fields-item]",

					// Submit buttons
					"{save}"			: "[data-group-fields-save]"
				}
			}, function(self) {
				return {

					init: function()
					{
						self.fieldItem().addController('EasySocial.Controller.Field.Base', {
							mode: 'edit'
						});
					},

					errorFields: [],

					// Support field throwing error internally
					'{fieldItem} error': function(el, ev)
					{
						self.triggerStepError(el);
					},

					// Support for field resolving error internally
					'{fieldItem} clear': function(el, ev)
					{
						self.clearStepError(el);
					},

					// Support validate.js throwing error externally
					'{fieldItem} onError': function(el, ev)
					{
						self.triggerStepError(el);
					},

					triggerStepError: function(el)
					{
						var fieldid = el.data('id'),
							stepid = el.parents(self.stepContent.selector).data('id');

						if($.inArray(fieldid, self.errorFields) < 0)
						{
							self.errorFields.push(fieldid);
						}

						self.stepItem().filterBy('for', stepid).trigger('error');
					},

					clearStepError: function(el)
					{
						var fieldid = el.data('id'),
							stepid = el.parents(self.stepContent.selector).data('id');

						self.errorFields = $.without(self.errorFields, fieldid);

						self.stepItem().filterBy('for', stepid).trigger('clear');
					},

					"{stepItem} click" : function(el, event)
					{
						var id 	= $(el).data('for');

						// Profile form should be hidden
						self.profileContent().show();

						// Hide all profile steps.
						self.stepContent().hide();

						// Remove active class on step item
						self.stepItem().removeClass('active');

						// Add active class on the selected item.
						el.addClass('active');

						// Get the step content element
						var stepContent = self.stepContent('.step-' + id);

						// Show active profile step.
						stepContent.show();

						// Trigger onShow on the field item in the content
						stepContent.find(self.fieldItem.selector).trigger('show');
					},

					"{stepItem} error": function(el)
					{
						el.addClass('error');
					},

					"{stepItem} clear": function(el)
					{
						if(self.errorFields.length < 1)
						{
							el.removeClass('error');
						}
					},

					"{save} click" : function(el, event)
					{
						// Run some error checks here.
						event.preventDefault();

						el.addClass('btn-loading');

						self.profileForm()
							.validate()
							.fail(function()
							{
								el.removeClass('btn-loading');
								EasySocial.dialog(
								{
									content 	: EasySocial.ajax('site/views/profile/showFormError')
								});
							})
							.done(function()
							{
								self.profileForm().submit();
							});

						return false;
					}
				}
			}
		);

		EasySocial.Controller('Groups.Filter', {
				defaultOptions: {
				}
			}, function(self) {
				return {
					init : function() {
					},

					"{self} click" : function(el, event) {

						// Prevent default.
						event.preventDefault();

						// Add active class to itself.
						self.parent.setActive(el);

						// Update the URL on the browser
						$(el).find('a').route();

						EasySocial.ajax('site/controllers/groups/getGroups', {
							filter: self.element.data('es-groups-filters-type')
						})
						.done(function(contents) {
							self.parent.setContent(contents, true);

							// Re-apply controller
							self.parent.initGroupController();
						});
					}
				}
			}
		);

		EasySocial.Controller('Groups.Sort', {
				defaultOptions: {
				}
			}, function(self) {
				return {

					init : function() {
					},

					"{self} click" : function(sortButton, event) {

						event.preventDefault();

						// Get the sort type
						var type = sortButton.data('type');
						var filter = sortButton.data('filter');
						var category = sortButton.data('categoryid');

						// Create an anchor link and route it?
						$('<a>').attr({
							"title": document.title,
							"href": sortButton.attr('href')
						}).route();

						// Add the active state on the current element.
						self.parent.sort().removeClass('active');
						sortButton.addClass('active');

						// Add the loader on the list content
						self.parent.listContents().html(self.parent.view.loader());


						// Render the ajax to load the contents.
						EasySocial.ajax('site/controllers/groups/getGroups', {
							ordering: type,
							filter: filter,
							categoryId: category
						})
						.done(function(contents) {

							// Update the contents
							self.parent.setContent(contents, false);

							// Re-apply controller
							self.parent.initGroupController();
						});
					}
				}
			}
		);

		EasySocial.Controller('Groups.Filter.Category', {
				defaultOptions: {
					id 	: null
				}
			}, function(self) {
				
				return {
					init : function() {
						self.options.id = self.element.data('es-groups-category-id');
					},

					"{self} click" : function(el, event) {
						// Prevent default.
						event.preventDefault();

						// Set active item
						self.parent.setActive(el);

						// Update the url
						$(el).find('a').route();

						// Perform ajax calls to update the content
						EasySocial.ajax('site/controllers/groups/getGroups', {
							categoryId 	: self.options.id
						})
						.done(function(contents) {
							self.parent.setContent(contents, true);

							// Re-apply controller
							self.parent.initGroupController();
						});
					}
				}
			}
		);

		EasySocial.Controller('Groups.Create', {
			defaultOptions: {
				'previousLink': null,

				'{fieldItem}': '[data-groups-create-fields-item]',

				'{previousButton}': '[data-groups-create-previous]',

				'{nextButton}': '[data-groups-create-submit]'
			}
		}, function(self) {
			return {
				init: function() {
					self.fieldItem().addController('EasySocial.Controller.Field.Base');
				},

				'{previousButton} click': function() {
					window.location = self.options.previousLink;
				},

				'{nextButton} click': function(el) {
					if (el.enabled()) {
						el.disabled(true);

						el.addClass('btn-loading');

						self.element.validate()
							.done(function() {
								el.removeClass('btn-loading');
								el.enabled(true);

								self.element.submit();
							})
							.fail(function() {
								el.removeClass('btn-loading');
								el.enabled(true);

								EasySocial.dialog({
									content 	: EasySocial.ajax('site/views/profile/showFormError')
								});
							});
					}
				}
			}
		});

		module.resolve();
	});
});


EasySocial.module( 'site/groups/item' , function($)
{
	var module	= this;

	EasySocial.template('info/item', '<li data-es-group-filter><a class="ml-20" href="[%= url %]" title="[%= title %]" data-info-item data-info-index="[%= index %]"><i class="fa fa-info-circle mr-5"></i> [%= title %]</a></li>');

	EasySocial.require()
	.script('site/friends/suggest')
	.library('history')
	.done(function($) {
		EasySocial.Controller('Groups.Item', {
			defaultOptions: {

				"{content}": "[data-es-group-item-content]",
				"{apps}": "[data-es-group-item-app]",
				"{filters}": "[data-es-group-filter]",
				"{filterStream}" : "[data-es-group-stream]",
				"{appFilter}"	: "[data-es-group-app-filter]",
				"{appFilterShowAll}" : "[data-app-filters-showall]",
				"{filterBtn}"	 : "[data-stream-filter-button]",
				"{filterEditBtn}": "[data-dashboardFeeds-Filter-edit]",

				"{filterModeration}": "[data-filter-moderation]",

				// hashtag filter save
				"{saveHashTag}"		: "[data-hashtag-filter-save]",

				"{filterUL}": "[data-es-group-ul]",

				"{joinGroup}": "[data-es-group-join]",
				"{leaveGroup}": "[data-es-group-leave]",
				"{invite}": "[data-es-group-invite]",
				"{respond}": "[data-es-group-respond]",
				"{withdraw}": "[data-es-group-withdraw]",

				'{info}': '[data-info]',
				'{infoItem}': '[data-info-item]',

				view: {
					infoItem: 'info/item'
				}
			}
		}, function(self, options, base) {
				return {
					init : function(){

						options.type = base.data('type');
						options.id = base.data('id');


						// Implement app controller
						self.apps().implement(EasySocial.Controller.Groups.Item.App, {
							"{parent}": self,
							"groupId": options.id
						});
					},

					setActive: function(el) {
						// Remove all active filters
						self.filters().removeClass('active');

						// Add active filter of the element
						el.parent().addClass('active');
					},

					setLoading: function(el) {
						// Empty the contents
						self.content().html('');

						// Add loading class
						self.element.addClass('loading');
					},

					updateContents: function(html) {
						// Once the content is updated, remove the loading class
						self.element.removeClass('loading');

						self.content().html(html);
					},

					"{appFilterShowAll} click" : function(el,event) {
						// Hide itself
						el.hide();

						self.filters().removeClass('hide');
					},

					"{filterEditBtn} click" : function(el, event) {
						event.preventDefault();

						// Update the url
						el.route();

						// Notify the dashboard that it's starting to fetch the contents.
						self.setLoading();

						self.setActive(el);

						EasySocial.ajax( 'site/controllers/groups/getFilter' ,
						{
							"id"			: el.data( 'id' ),
							"clusterId" 	: self.options.id
						})
						.done(function( contents )
						{
							// self.dashboard.updateHeading( title , desc );

							self.updateContents( contents );
						})
						.fail( function( messageObj ){

							return messageObj;
						})
						.always(function(){

						});

					},

					"{filterBtn} click" : function(el, event) {

						// Prevent bubbling up
						event.preventDefault();

						// Update the url
						el.route();

						self.setActive(el);

						// Notify the dashboard that it's starting to fetch the contents.
						self.setLoading();

						EasySocial.ajax( 'site/controllers/groups/getFilter' , {
							"id": 0,
							"clusterId": self.options.id
						}).done(function(contents) {
							self.updateContents(contents);
						}).fail(function(messageObj) {
							return messageObj;
						}).always(function(){
						});

					},

					"{appFilter} click" : function(el, event) {
						event.preventDefault();

						// Get the url and the title
						var url 	= el.data('url'),
							title 	= el.data('title');

						// Set the browser's url
						History.pushState( {state:1} , title , url);

						// Set active class
						self.setActive( el );

						// Set the loading screen
						self.setLoading();

						// Set active menu
						self.setActive(el);

						// Get the id of the app
						var id 	= el.data('id');

						// Perform an ajax to get the group's stream data
						EasySocial.ajax( 'site/controllers/groups/getStream',
						{
							"id" 	: self.options.id,
							"app"	: id,
							"view" 	: "groups"
						})
						.done(function( contents )
						{
							self.updateContents( contents );
						});
					},

					"{filterModeration} click": function(filterModeration, event) {
						event.preventDefault();

						// Update the browser's url
						filterModeration.route();

						// Set the active class to the current filter
						self.setActive(filterModeration);

						// Perform an ajax to get the group's stream data
						EasySocial.ajax('site/controllers/groups/getStream', {
							"id": options.id,
							"view": 'groups',
							"moderation": 1
						}).done(function(contents) {
							self.updateContents(contents);
						});
					},

					"{filterStream} click" : function(el, event) {
						event.preventDefault();

						// Set active class
						self.setActive( el );

						// Set the browser's url
						el.route();

						// Notify the dashboard that it's starting to fetch the contents.
						self.setLoading();

						var currentSidebarMenu = $("[data-dashboardSidebar-menu].active");
						var fid = currentSidebarMenu.data( 'fid' );

						// Perform an ajax to get the group's stream data
						EasySocial.ajax( 'site/controllers/groups/getStream', {
							"id": self.options.id,
							"filterId": fid,
							"view": 'groups',
							"layout": 'item'
						}).done(function(contents) {
							self.updateContents(contents);
						});
					},

					"{saveHashTag} click": function( el )
					{
						var hashtag = el.data('tag');
						var id 		= el.data('id');

						EasySocial.dialog({
							content		: EasySocial.ajax( 'site/views/stream/confirmSaveFilter', { "tag": hashtag } ),
							bindings	:
							{
								"{saveButton} click" : function()
								{
									this.inputWarning().hide();

									filterName = this.inputTitle().val();

									if( filterName == '' )
									{
										this.inputWarning().show();
										return;
									}

									EasySocial.ajax( 'site/controllers/groups/addFilter',
									{
										"title"		: filterName,
										"tag"		: hashtag,
										"id"		: id,
									})
									.done(function( html, msg )
									{
										// self.feeds().append( html );

										var item = $.buildHTML( html );

										self.filterUL().append( item );

										// show message
										EasySocial.dialog( msg );

										// auto close the dialog
										setTimeout(function() {
											EasySocial.dialog().close();
										}, 2000);

									});
								}
							}
						});
					},

					"{withdraw} click" : function( el , event )
					{
						EasySocial.dialog(
						{
							content	: EasySocial.ajax( 'site/views/groups/confirmWithdraw' , { "id" : self.options.id } )
						});
					},

					"{invite} click": function(el, event) {
						
						EasySocial.dialog({
							content: EasySocial.ajax('site/views/groups/inviteFriends', { "id" : self.options.id }),
							position: {
								my: "center top",
								at: "center top",
								of: window
							}
						});
					},

					"{respond} click" : function( el , event )
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/groups/confirmRespondInvitation' , { "id" : self.options.id } ),
							bindings: {
								"{rejectButton} click" : function() {
									this.responseValue().val('reject');

									this.form().submit();
								},

								"{acceptButton} click" : function() {
									this.responseValue().val('accept');

									this.form().submit();
								}
							}
						})
					},

					"{joinGroup} click" : function(el, event) {

						// // If this is an open group, hide the join button since the user is already a member of the group
						// if (options.type == 'open') {

						// 	// Add loading
						// 	base.switchClass('is-loading');

						// 	// Join the group and hide the footer
						// 	EasySocial.ajax('site/controllers/groups/joingroup', {
						// 		"id": options.id
						// 	}).done(function() {
						// 		base.switchClass('is-member');
						// 	});

						// 	return;
						// }

						// // If this is a private group, display the standard popup.
						// EasySocial.dialog({
						// 	content: EasySocial.ajax('site/controllers/groups/joinGroup', { "id" : options.id})
						// });

						EasySocial.dialog({
							content: EasySocial.ajax('site/controllers/groups/joinGroup' , { "id" : self.options.id})
						});
					},

					"{leaveGroup} click" : function( el , event )
					{
						EasySocial.dialog({
							content: EasySocial.ajax( 'site/views/groups/confirmLeaveGroup' , { "id" : self.options.id } ),
							bindings: {
								"{leaveButton} click" : function() {
									this.leaveForm().submit();
								}
							}
						})
					},

					'{info} click': function(el, ev) {
						ev.preventDefault();

						el.route();

						self.setActive(el);

						self.setLoading();

						var loaded = el.data('loaded');

						if (loaded) {
							self.infoItem().eq(0).trigger('click');
							return;
						}

						if (el.enabled()) {
							el.disabled(true);

							EasySocial.ajax('site/controllers/groups/initInfo', {
								groupId: self.options.id
							}).done(function(steps) {
								el.data('loaded', 1);

								var parent = el.parent('[data-es-group-filter]');

								// Append all the steps
								$.each(steps.reverse(), function(index, step) {
									if (!step.hide) {
										parent.after(self.view.infoItem({
											url: step.url,
											title: step.title,
											index: step.index
										}));
									}

									if (step.html) {
										self.updateContents(step.html);
										self.content().find('[data-field]').trigger('onShow');
									}
								});

								var item = self.infoItem().eq(0);

								self.setActive(item);

								// Have to set the title
								$(document).prop('title', item.attr('title'));

								el.enabled(true);
							}).fail(function(error) {
								el.enabled(true);
								self.updateContents(error.message);
							});
						}
					},

					'{infoItem} click': function(el, ev) {
						ev.preventDefault();

						el.route();

						self.setActive(el);

						self.setLoading();

						var index = el.data('info-index');

						EasySocial.ajax('site/controllers/groups/getInfo', {
							groupId: self.options.id,
							index: index
						}).done(function(contents) {
							self.updateContents(contents);

							self.content().find('[data-field]').trigger('onShow');
						}).fail(function(error) {
							self.updateContents(error.message);
						});
					}
				}
			}
		);

		EasySocial.Controller(
			'Groups.Item.App',
			{
				defaultOptions:
				{

				}
			},
			function( self )
			{
				return {
					init : function()
					{
						self.options.id 	= self.element.data( 'app-id' );
					},

					"{self} click" : function( el , event )
					{
						// Prevent event from bubbling up
						event.preventDefault();

						// Update the url in the browser
						el.route();

						// Set active element
						self.parent.setActive( el );

						// Set loading class
						self.parent.setLoading();

						// Make an ajax call to get the app contents
						EasySocial.ajax( 'site/controllers/groups/getAppContents' ,
						{
							"appId"		: self.options.id,
							"groupId"	: self.options.groupId
						})
						.done( function( contents )
						{
							self.parent.updateContents( contents );
						})
						.fail(function( messageObj )
						{
							return messageObj;
						});
					}
				}
			}
		);

		EasySocial.Controller('Groups.Item.Members', {
			defaultOptions: {
				"{items}" 	: "[data-group-members-item]",
				"{filters}"	: "[data-group-members-filter]",
				"{content}"	: "[data-group-members-content]"
			}
		}, function(self) {
			return {

				init : function() {
					self.options.id = self.element.data('id');
					self.items().implement(EasySocial.Controller.Groups.Item.Members.Record);
				},

				"{filters} click" : function(el, event) {
					// Remove active
					self.filters().removeClass( 'active' );

					// Set current to active
					el.addClass( 'active' );

					// Get the filter
					var filter 	= el.data( 'filter' );

					// Set the loading class
					self.content().html( '&nbsp;' );
					self.content().addClass( 'is-loading' );

					EasySocial.ajax( 'apps/group/members/controllers/groups/filterMembers' ,
					{
						"id"		: self.options.id,
						"filter" 	: filter
					})
					.done(function( contents )
					{
						// Remove is-loading
						self.content().removeClass( 'is-loading' );

						self.content().html( contents );

						// Re-implement the members record
						self.items().implement(EasySocial.Controller.Groups.Item.Members.Record);
					});
				}
			}
		});

		EasySocial.Controller('Groups.Item.Members.Record', {
			defaultOptions: {
				"{makeAdmin}" : "[data-members-make-admin]",
				"{revokeAdmin}": "[data-members-revoke-admin]",
				"{approve}": "[data-members-approve]",
				"{reject}": "[data-members-reject]",
				"{removeMember}": "[data-members-remove]",
				"{cancelInvitation}": "[data-members-cancel-invitation]"
			}
		}, function(self) { return {
			
			init : function() {
				self.options.id = self.element.data('id');
				self.options.groupId = self.element.data('groupid');
				self.options.redirect = self.element.data('redirect');
			},

			// Approve a member
			"{approve} click" : function(el) {

				EasySocial.dialog({
					"content": EasySocial.ajax('site/views/groups/confirmApprove', { "id" : self.options.groupId , "userId" : self.options.id, "return": self.options.redirect })
				});
			},

			"{reject} click" : function()
			{
				EasySocial.dialog(
				{
					content 	: EasySocial.ajax( 'site/views/groups/confirmReject' , { "id" : self.options.groupId , "userId" : self.options.id } )
				});
			},

			"{cancelInvitation} click" : function()
			{
				EasySocial.dialog(
				{
					content 	: EasySocial.ajax( 'site/views/groups/confirmCancelInvitation' , { "id" : self.options.groupId , "userId" : self.options.id } )
				});
			},

			"{revokeAdmin} click" : function()
			{
				EasySocial.dialog(
				{
					content 	: EasySocial.ajax( 'site/views/groups/confirmRevokeAdmin' , { "id" : self.options.groupId , "userId" : self.options.id } ),
					bindings:
					{
						"{revokeButton} click" : function()
						{
							EasySocial.ajax( 'site/controllers/groups/revokeAdmin' ,
							{
								"id"		: self.options.groupId,
								"userId"	: self.options.id
							})
							.done(function()
							{
								// Close the dialog once done.
								EasySocial.dialog().close();

								self.element.removeClass( 'is-admin' ).addClass( 'is-member' );
							});

						}
					}
				});
			},

			"{removeMember} click" : function()
			{
				EasySocial.dialog(
				{
					content 	: EasySocial.ajax( 'site/views/groups/confirmRemoveMember' , { "id" : self.options.groupId , "userId" : self.options.id } )
				});
			},

			"{makeAdmin} click" : function()
			{
				EasySocial.dialog(
				{
					content	: EasySocial.ajax( 'site/views/groups/confirmMakeAdmin' , { "id" : self.options.id }),
					bindings:
					{
						"{makeAdminButton} click" : function()
						{
							EasySocial.ajax( 'site/controllers/groups/makeAdmin' ,
							{
								"id"		: self.options.groupId,
								"userId"	: self.options.id
							})
							.done(function()
							{
								// Close the dialog once done.
								EasySocial.dialog().close();

								self.element.removeClass( 'is-member' ).addClass( 'is-admin' );
							});

						}
					}
				});
			}
		}});

		EasySocial.Controller(
			'Groups.Item.Discussions',
			{
				defaultOptions:
				{
					"{filter}" 	: "[data-group-discussions-filter]",
					"{contents}": "[data-group-discussion-contents]"
				}
			},
			function(self)
			{
				return {
					init: function()
					{
						self.options.id 	= self.element.data( 'id' );
					},

					setContent: function( html )
					{
						// Remove loading class since we already have the content.
						self.contents().removeClass( 'is-loading' );

						self.contents().html( html );
					},

					setActiveFilter: function( el )
					{
						// Remove active class.
						self.filter().removeClass( 'active' );

						// Add active class to the current element
						el.addClass( 'active' );
					},

					"{filter} click" : function( el , event )
					{
						var filter = el.data( 'filter' );

						// Add loader for the contents area
						self.contents().html( '&nbsp;' ).addClass( 'is-loading' );

						// Set active filter
						self.setActiveFilter( el );

						// Run the ajax call now
						EasySocial.ajax( 'apps/group/discussions/controllers/discussion/getDiscussions' ,
						{
							"id"		: self.options.id,
							"filter" 	: filter
						})
						.done(function( contents , empty )
						{
							if( empty )
							{
								self.contents().addClass( 'is-empty' );
							}
							else
							{
								self.contents().removeClass( 'is-empty' );
							}
							// Set the contents
							self.setContent( contents );
						});
					}
				}
			}
		);
		EasySocial.Controller(
			'Groups.Item.Discussion',
			{
				defaultOptions:
				{
					"{form}"		: "[data-reply-form]",
					"{list}"		: "[data-reply-list]",
					"{replies}"		: "[data-reply-item]",
					"{repliesWrap}"	: "[data-replies-wrapper]",

					"{replyCounter}": "[data-reply-count]",

					"{lock}"		: "[data-discussion-lock]",
					"{unlock}"		: "[data-discussion-unlock]",
					"{delete}"		: "[data-discussion-delete]"
				}
			},
			function( self )
			{
				return {
					init: function()
					{
						self.options.id 		= self.element.data( 'id' );
						self.options.groupId	= self.element.data( 'groupid' );

						self.implementReply( self.replies() );

						self.form().implement( EasySocial.Controller.Groups.Item.Discussion.Form ,
						{
							"{parent}"	: self
						});
					},

					implementReply: function()
					{
						self.replies().implement( EasySocial.Controller.Groups.Item.Discussion.Reply ,
						{
							"{parent}"	: self
						});
					},

					insertReply: function( html )
					{
						// Since we know that we need to append the reply item, we need to remove is-unanswered
						self.element.removeClass( 'is-unanswered' );

						// Since an item is added, we want to remove the empty class.
						self.repliesWrap().removeClass( 'is-empty' );

						// Append the new item
						self.list().append( html );

						// Implement the controller again
						self.implementReply();
					},

					updateReplyCounter: function( total )
					{
						if( total == 0 )
						{
							self.repliesWrap().addClass( 'is-empty' );
						}
						self.replyCounter().html( total );
					},

					setResolved: function()
					{
						self.element.addClass( 'is-resolved' );
					},

					"{unlock} click" : function( el , event )
					{
						EasySocial.ajax( 'apps/group/discussions/controllers/discussion/unlock' ,
						{
							"id" : self.options.id
						})
						.done(function()
						{
							// Add lock element
							self.element.removeClass( 'is-locked' );
						});
					},

					"{delete} click" : function( el , event )
					{
						EasySocial.dialog(
						{
							content : EasySocial.ajax( 'apps/group/discussions/controllers/discussion/confirmDelete' , { "id" : self.options.id , "groupId" : self.options.groupId })
						});
					},

					"{lock} click" : function( el , event )
					{
						EasySocial.dialog(
						{
							content : EasySocial.ajax( 'apps/group/discussions/controllers/discussion/confirmLock' ),
							bindings:
							{
								"{lockButton} click" : function()
								{
									EasySocial.ajax( 'apps/group/discussions/controllers/discussion/lock' ,
									{
										"id" : self.options.id
									})
									.done(function()
									{
										// Hide the dialog
										EasySocial.dialog().close();

										// Add lock element
										self.element.addClass( 'is-locked' );
									});
								}
							}
						});
					}
				}
			}
		);

		EasySocial.Controller(
			'Groups.Item.Discussion.Reply',
			{
				defaultOptions:
				{
					"{acceptAnswer}"	: "[data-reply-accept-answer]",
					"{delete}"			: "[data-reply-delete]",
					"{edit}"			: "[data-reply-edit]",
					"{cancelEdit}"		: "[data-reply-edit-cancel]",
					"{update}"			: "[data-reply-edit-update]",
					"{textarea}"		: "[data-reply-content]",
					"{content}"			: "[data-reply-display-content]",
					"{alertDiv}" 		: "div.alert-error"
				}
			},
			function( self )
			{
				return {
					init: function()
					{
						self.options.id 	= self.element.data( 'id' );
					},
					"{acceptAnswer} click" : function()
					{
						EasySocial.ajax( 'apps/group/discussions/controllers/reply/accept' ,
						{
							"id" : self.options.id
						})
						.done(function()
						{
							self.parent.setResolved();
						});
					},

					cancelEditing : function()
					{
						self.element.removeClass( 'is-editing' );
					},

					"{cancelEdit} click" : function()
					{
						self.cancelEditing();
					},

					"{edit} click" : function()
					{
						self.element.addClass( 'is-editing' );
					},

					"{update} click" : function()
					{
						var content 	= self.textarea().val();

						// console.log( self.element);

						// If content is empty, throw some errors
						if( content == '' )
						{
							self.element.addClass( 'is-empty' );
							self.alertDiv().show();
							return false;
						}

						EasySocial.ajax( 'apps/group/discussions/controllers/reply/update' ,
						{
							"id"		: self.options.id,
							"content"	: content
						})
						.done(function( content )
						{
							// Update the content
							self.content().html( content );

							self.element.removeClass( 'is-empty' );
							self.alertDiv().hide();


							// Hide the textarea
							self.cancelEditing();
						});
					},

					"{delete} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'apps/group/discussions/controllers/reply/confirmDelete' , { "id"	: self.options.id } ),
							bindings	:
							{
								"{deleteButton} click" : function()
								{
									EasySocial.ajax( 'apps/group/discussions/controllers/reply/delete',
									{
										"id"	: self.options.id
									})
									.done(function( discussion )
									{
										// Update the counter
										self.parent.updateReplyCounter( discussion.total_replies );

										// Hide the dialog
										EasySocial.dialog().close();

										// Remove the element
										self.element.remove();
									});
								}
							}
						});
					}
				}
			}
		);

		EasySocial.Controller(
			'Groups.Item.Discussion.Form',
			{
				defaultOptions:
				{
					"{textarea}"	: "[data-reply-content]",
					"{submitReply}" : "[data-reply-submit]"
				}
			},
			function( self )
			{
				return {
					init: function()
					{
					},
					"{submitReply} click" : function( el , event )
					{
						var content 	= self.textarea().val();

						// If content is empty, throw some errors
						if( content == '' )
						{
							self.element.addClass( 'is-empty' );
							return false;
						}

						EasySocial.ajax( 'apps/group/discussions/controllers/reply/submit' ,
						{
							"id"		: self.parent.options.id,
							"groupId"	: self.parent.options.groupId,
							"content"	: content
						})
						.done(function( html )
						{
							// Inser the new node back.
							self.parent.insertReply( html );

							// Update the textarea
							self.textarea().val( '' );
						});

					}
				}
			}
		);

		EasySocial.Controller('Groups.Item.News', {
				defaultOptions: {
					"{delete}" 			: "[data-news-delete]",
					"{likes}"			: "[data-likes-action]",
					"{counter}"			: "[data-news-counter]",
					"{likeContent}" 	: "[data-likes-content]",
				}
			}, function(self) {
				return {

					init : function()
					{
						self.options.id 	= self.element.data( 'id' );
						self.options.groupId = self.element.data( 'group-id' );
					},

					//need to make the data-stream-counter visible
					"{likes} onLiked": function(el, event, data) {
						self.counter().removeClass('hide');
					},

					"{likes} onUnliked": function(el, event, data) {
						var hideCounter 	= self.likeContent().hasClass( 'hide' );

						if( hideCounter )
						{
							self.counter().addClass( 'hide' );
						}
					},
					"{delete} click" : function( el , event )
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'apps/group/news/controllers/news/confirmDelete' , { "id" : self.options.id , "groupId" : self.options.groupId })
						});
					}
				}
			}
		);

		module.resolve();
	});
});



EasySocial.module( "site/notifications/list", function($){

	var module = this;


	EasySocial.require()
	.done( function($)
	{
		EasySocial.Controller( 'NotificationsList',
		{
			defaultOptions:
			{
				"{item}"		: "[data-notifications-list-item]",
				"{list}" 		: "[data-notifications-list]",
				"{allread}" 	: "[data-notification-all-read]",
				"{allclear}" 	: "[data-notification-all-clear]",

				"{notiLoadMoreBtn}" : "[data-notification-loadmore-btn]"
			}
		},
		function( self )
		{
			return {
				init : function()
				{
					self.item().implement( EasySocial.Controller.NotificationsList.Item ,
						{
							"{parent}"	: self
						});
				},

				"{allread} click" : function()
				{
					EasySocial.ajax( 'site/controllers/notifications/setAllState' ,
					{
						"state"	: "read"
					})
					.done(function()
					{
						self.item().removeClass( 'is-read is-hidden is-unread' ).addClass( 'is-read' );
					});
				},

				"{allclear} click" : function()
				{
					// show dialog to get confimation from user.
					var dialog =
						EasySocial.dialog({
							content: EasySocial.ajax(
								"site/views/notifications/clearAllConfirm"
							),
							bindings: {
								"{clearButton} click": function() {

									EasySocial.ajax( 'site/controllers/notifications/setAllState' ,
									{
										"state"	: "clear"
									})
									.done(function()
									{
										self.item().removeClass( 'is-read is-hidden is-unread is-read' ).addClass( 'is-remove' );
										EasySocial.dialog().close();
									});

								}
							}
						});
				},

				"{notiLoadMoreBtn} click" : function( el, event )
				{
					var startlimit 	= $(el).data( 'startlimit' );
					if( startlimit < 0 )
					{
						return;
					}

					EasySocial.ajax( 'site/controllers/notifications/loadmore' ,
					{
						"startlimit" : startlimit
					})
					.done(function( contents, nextlimit )
					{
						// update next limit
						$(el).data( 'startlimit', nextlimit );

						if( contents.length > 0 )
						{
							$.buildHTML(contents)
							 	.insertBefore( self.notiLoadMoreBtn() );
							 	// .addController("NotificationsList.Item");

							 //add controller
							 self.item().implement( EasySocial.Controller.NotificationsList.Item );
						}

						if( nextlimit < 0)
						{
							// no more item. let hide the loadmore button.
							self.notiLoadMoreBtn().hide();
						}

					})
					.fail( function( messageObj ){
						return messageObj;
					})
					.always(function(){

						// self.loading = false;
					});


				}



			}
		});

		EasySocial.Controller( 'NotificationsList.Item' ,
		{
			defaultOptions :
			{
				"{unread}"	: "[data-notifications-list-item-unread]",
				"{read}"	: "[data-notifications-list-item-read]",
				"{delete}"	: "[data-notifications-list-item-delete]"
			}
		},
		function(self)
		{
			return {
				init : function()
				{
					self.options.id 	= self.element.data( 'id' );

				},

				"{unread} click" : function()
				{
					EasySocial.ajax( 'site/controllers/notifications/setState' ,
					{
						"id"	: self.options.id,
						"state"	: "unread"
					})
					.done(function()
					{
						self.element.removeClass( 'is-read is-hidden is-unread' ).addClass( 'is-unread	' );
					});
				},

				"{read} click" : function()
				{
					EasySocial.ajax( 'site/controllers/notifications/setState' ,
					{
						"id"	: self.options.id,
						"state"	: "read"
					})
					.done(function()
					{
						self.element.removeClass( 'is-read is-hidden is-unread' ).addClass( 'is-read' );
					});
				},

				"{delete} click" : function()
				{


					var dialog =
						EasySocial.dialog({
							content: EasySocial.ajax(
								"site/views/notifications/clearConfirm"
							),
							bindings: {
								"{clearButton} click": function() {

									EasySocial.ajax( 'site/controllers/notifications/setState' ,
									{
										"id"	: self.options.id,
										"state"	: "clear"
									})
									.done(function()
									{
										self.element.removeClass( 'is-read is-hidden is-unread is-read' ).addClass( 'is-remove' );
										EasySocial.dialog().close();
									})
									.fail(function( msg )
									{
										EasySocial.dialog({
											content: msg.message
										});
									});
								}
							}
						});



					// EasySocial.ajax( 'site/controllers/notifications/setState' ,
					// {
					// 	"id"	: self.options.id,
					// 	"state"	: "hidden"
					// })
					// .done(function()
					// {
					// 	self.element.removeClass( 'is-read is-hidden is-unread' ).addClass( 'is-hidden' );
					// });


				}
			}
		});

		module.resolve();
	});

});

EasySocial.module( 'site/points/history' , function(){

	var module	= this;

	EasySocial.require()
	.done(function($)
	{
		EasySocial.Controller(
			'Points.History',
			{
				defaultOptions :
				{
					"{loadMore}"	: "[data-points-history-pagination]",
					"{timeline}"	: "[data-points-history-timeline]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{
					},

					"{loadMore} click" : function( el , event )
					{
						var current 	= $( el ).data( 'current' );

						EasySocial.ajax( 'site/views/points/getHistory' , 
						{
							"limitstart"	: current,
							"id"			: self.options.id
						}).done(function( contents , nextLimit , done )
						{
							self.timeline().append( contents );

							$( el ).data( 'current' , nextLimit );

							if( done )
							{
								$( el ).hide();
								// $( el ).attr( 'disabled' , 'disabled' );
							}
						});
					}
				}
			});

		module.resolve();
	});
});

EasySocial.module('site/polls/polls', function($){

	var module = this;

    var lang = EasySocial.options.momentLang;

	EasySocial.require()
    .library('datetimepicker', 'moment/' + lang)
	.view('site/loading/small')
	.done(function($) {

		EasySocial.Controller('Polls',
		{
			defaultOptions: {
				// Check every 30 seconds by default.
				interval	: 30,

				// Properties
				checknew	: null,
				source      : null,
				sourceId    : null,
				autoload	: true,

				// Elements
				"{itemList}": "[data-polls-list]",
				"{copiedItem}": "[data-polls-item-copied]",

                // inputs
                "{pollTitle}" : "[data-polls-title]",
                "{pollItemList}" : "[data-polls-item]",
                "{pollItem}" : "[data-polls-item-text]",
                "{pollMultiple}" : "[data-polls-multiple]",
                "{pollExpiry}": "[data-polls-expirydate]",
                "{itemTobeRemoved}": "[data-polls-tobe-removed]",
                "{pollSourceId}": "[data-polls-sourceid]",


                //hidden inputs
                "{pollId}": "[data-polls-id]",
                "{pollUid}": "[data-polls-uid]",
                "{pollElement}": "[data-polls-element]",

				// buttons
				"{addItem}": "[data-polls-add]",
				"{deleteItem}": "[data-polls-item-delete]",

				view: {
					loadingContent: "site/loading/small"
				}
			}
		}, function(self) {
			return {

				init : function()
				{
					// Implement stream item controller.
					// self.item().addController(EasySocial.Controller.Stream.Item, {
					// 	"{parent}": self
					// });


                    self.pollExpiry().addController('EasySocial.Controller.Polls.Datetime', {
                        '{parent}': self
                    });
				},

				"{deleteItem} click": function(ele, event) {
					//lets check if this is the last item or not.
					// if yes, do not delete.
					// var len = $("[data-polls-item]").length;
                    var len = self.pollItemList().length;

					if (len <= 1) {
						return;
					}

					// remove this item from the list.
					var item = $(ele).closest("[data-polls-item]");

                    var hasId = item.attr('data-id');

                    if (typeof hasId !== typeof undefined && hasId !== false) {
                        var itemId = item.data('id');

                        if (itemId != undefined || itemId != '') {
                            if (self.itemTobeRemoved) {
                                var temp = self.itemTobeRemoved().val();
                                temp = (temp == '') ? itemId : temp + ',' + itemId;
                                self.itemTobeRemoved().val(temp);
                            }
                        }
                    }

                    item.remove();

				},

				"{addItem} click": function(ele, event) {
					// lets copy the copied version and append into item list.
					var copied = self.copiedItem().clone();

					//remove data attribute.
					copied
						.removeAttr("data-polls-item-copied")
						.attr("data-polls-item", "")
						.show();

					//travel inside the input textbox and change the name.
					copied.find("input[name='copied']")
                        .attr("name", "items[]")
                        .attr("data-polls-item-text","");

					self.itemList().append(copied);
				},

                "toData" : function(){

                    var arritems = [];

                    var data = {
                        id: self.pollId().val(),
                        uid: self.pollUid().val(),
                        element: self.pollElement().val(),
                        title: self.pollTitle().val(),
                        items: arritems,
                        multiple: self.pollMultiple().is( ':checked' ) ? 1 : 0,
                        toberemove: '',
                        sourceid: self.pollSourceId().val()
                    };

                    self.pollExpiry().trigger('datetimeExport', [data]);

                    if (self.pollItem().length > 0) {
                        $.each(self.pollItem(), function(idx, item) {
                            var text = $(item);

                            // remove this item from the list.
                            var curItem = $(item).closest("[data-polls-item]");
                            var hasId = curItem.attr('data-id');
                            var itemId = '0';

                            if (typeof hasId !== typeof undefined && hasId !== false) {
                                itemId = curItem.data('id');
                            }

                            if (text.val() != '') {
                                finalItem = {"id": itemId, "text": text.val()};
                                arritems.push(finalItem);
                            }
                        });

                        if (self.itemTobeRemoved) {
                            var tobedelete = self.itemTobeRemoved().val();
                            data.toberemove = tobedelete;
                        }

                        data.items = arritems;
                    }

                    return data;
                },

                "validateForm" : function(){
                    var data = self.toData();

                    if ($.isEmpty(data.title)
                        || data.items.length == 0) {
                        return false;
                    }

                    if (data.items.length <= 0) {
                        return false;
                    }

                    return true;
                }

			}
		});


        EasySocial.Controller('Polls.Vote',
        {
            defaultOptions: {

                isMultiple: false,

                // Elements
                "{itemList}": "[data-polls-list]",
                "{resultList}": "[data-polls-results-list]",
                "{voteItem}" : "[data-vote-item]",
                "{voteOption}" : "[data-vote-item-option]",
                "{voteNotice}" : "[data-polls-notice]",
                "{resultBtnContainer}": "[data-polls-result-button-div]",

                "{editBtn}": "[data-polls-edit-button]",
                "{viewVoterBtn}" : "[data-poll-count-button]",

                view: {
                    loadingContent: "site/loading/small"
                }
            }
        }, function(self,opts,base) {
            return {

                init : function()
                {
                    // poll id
                    opts.id = base.data("id");

                    // console.log(self.options.isMultiple);
                    // console.log(opts.id);
                },

                "updateProgressBar" : function() {

                    var items = self.voteItem();
                    var total = 0;

                    $.each(items, function(idx, item) {
                        var itemCnt = $(item).data('count');
                        total = total + itemCnt;
                    });


                    $.each(items, function(idx, item) {

                        var itemCnt = $(item).data('count');
                        var id = $(item).data('id');
                        var percentage = (itemCnt / total) * 100;

                        var elemData = '[data-poll-bar-' + id + '] .progress-bar';
                        var elemLabel = '[data-poll-count-label-' + id + ']';

                        $(elemData).css('width', percentage + '%');
                        $(elemLabel).text(itemCnt);
                        self.viewVoterBtn().removeClass('hide');

                    });

                },

                "showResults" : function() {
                    self.resultList().removeClass('hide');
                    self.resultBtnContainer().addClass('hide');
                },

                "toData" : function(){

                    var arritems = [];

                    var data = {
                        title: self.pollTitle().val(),
                        items: arritems,
                        multiple: self.pollMultiple().is( ':checked' ) ? 1 : 0,
                        sourceid: self.pollSourceId().val()
                    };

                    self.pollExpiry().trigger('datetimeExport', [data]);

                    if (self.pollItem().length > 0) {
                        $.each(self.pollItem(), function(idx, item) {
                            var text = $(item);

                            if (text.val() != '') {
                                arritems.push(text.val());
                            }
                        });

                        data.items = arritems;
                    }

                    return data;
                },

                "{voteOption} change": function(ele, event){

                    var item = $(ele);

                    var isChecked = item.is(':checked') ? true : false;
                    var itemId = item.data('id');

                    if (isChecked) {
                        self.updateVote(itemId, 'vote', ele);
                    } else {
                        self.updateVote(itemId, 'unvote', ele);
                    }

                    if (isChecked && !self.options.isMultiple) {
                        // now we need to uncheck the other 'checked' item.
                        $.each(self.voteOption(), function(idx, item){
                            var opt = $(item);

                            if (opt.data('id') != itemId && opt.is(':checked')) {
                                selectItem = opt.data('id');
                                opt.prop('checked', false);

                                self.updateVote(selectItem, 'unvote', opt);
                            }
                        });
                    }

                    return;
                },

                "{viewVoterBtn} click": function(ele, event) {
                    var voteItem = $(ele).closest('[data-vote-item]');
                    var itemId = $(voteItem).data('id');


                    EasySocial.ajax('site/views/polls/voters', {
                        id: self.options.id,
                        itemid: itemId
                    })
                    .done(function(content) {

                        if ($.trim(content) == "") {
                            return;
                        }

                        var elemData = '[data-poll-voters-' + itemId + ']';

                        $(elemData)
                            .html(content)
                            .removeClass('hide');

                    })
                    .fail(function() {

                    });

                },

                "updateVote" : function(itemId, act, ele) {

                    EasySocial.ajax("site/controllers/polls/vote", {
                        id : self.options.id,
                        itemId : itemId,
                        act : act
                    })
                    .done(function(msg, items){

                        var divParent = $(ele).closest('[data-vote-item]');
                        var count = $(divParent).data('count');

                        if (act == 'vote') {
                            count = count + 1;
                        } else if (act == 'unvote') {
                            count = count - 1;
                        }

                        // lets update the count
                        $(divParent).data('count', count);

                        // console.log($(divParent).data('count'));

                        // update progress bar
                        self.updateProgressBar();


                        // show view button
                        // self.viewBtn().removeClass('hide');

                        // self.voteNotice()
                        //     .removeClass('hide')
                        //     .addClass('alert-success')
                        //     .text(msg)
                        //     .delay(5000)
                        //     .fadeOut();

                    })
                    .fail(function(msgObj){

                        self.voteNotice()
                            .removeClass('hide')
                            .text(msgObj.message);

                    });


                },


                "{editBtn} click": function(ele, event) {

                },

                "{resultBtn} click": function(ele, event) {
                    self.showResults();
                },

                "{voteBtn} click": function(ele, event) {

                    var selectItems = [];

                    $.each(self.voteOption(), function(idx, item){
                        var opt = $(item);

                        if (opt.is(':checked')) {
                            selectItems.push(opt.data('id'));
                        }
                    });

                    if (selectItems.length == 0) {
                        // nothing selected. abort action.
                        return;
                    }

                    // hide the vote button
                    self.voteBtn().hide();

                    //show result
                    self.showResults();

                    EasySocial.ajax("site/controllers/polls/vote", {
                        id     : self.options.id,
                        items   : selectItems
                    })
                    .done(function(msg, items){

                        // update progress bar
                        self.updateProgressBar(items);

                        // show view button
                        self.viewBtn().removeClass('hide');

                        self.voteNotice()
                            .removeClass('hide')
                            .addClass('alert-success')
                            .text(msg)
                            .delay(5000)
                            .fadeOut();

                    })
                    .fail(function(msgObj){

                        self.voteNotice()
                            .removeClass('hide')
                            .text(msgObj.message);

                    });
                }

            }
        });

        EasySocial.Controller('Polls.Datetime', {
            defaultOptions: {
                '{picker}': '[data-picker]',
                '{toggle}': '[data-picker-toggle]',
                '{datetime}': '[data-datetime]'
            }
        }, function(self) {
            return {
                init: function() {

                    var minDate = new $.moment();
                    var yearto = new Date().getFullYear() + 10;
                    var dateFormat = 'DD-MM-YYYY hh:mm A';

                    // Minus 1 on the date to allow today
                    minDate.date(minDate.date() - 1);

                    self.picker()._datetimepicker({
                        component: "es",
                        useCurrent: false,
                        format: dateFormat,
                        minDate: minDate,
                        maxDate: new $.moment({y: yearto}),
                        icons: {
                            time: 'glyphicon glyphicon-time',
                            date: 'glyphicon glyphicon-calendar',
                            up: 'glyphicon glyphicon-chevron-up',
                            down: 'glyphicon glyphicon-chevron-down'
                        },
                        sideBySide: false,
                        pickTime: 1,
                        minuteStepping: 1,
                        language: lang
                    });

                    var curActiveDateTime = self.element.data('value');
                    if (curActiveDateTime != '') {
                        var dateObj = $.moment(curActiveDateTime);
                        self.datetimepicker('setDate', dateObj);
                    }
                },

                datetimepicker: function(name, value) {
                    return self.picker().data('DateTimePicker')[name](value);
                },

                '{toggle} click': function() {
                    self.picker().focus();
                },

                '{picker} dp.change': function(el, ev) {
                    self.setDateValue(ev.date.toDate());

                    //self.parent.element.trigger('event' + $.String.capitalize(self.options.type), [ev.date]);
                },

                setDateValue: function(date) {
                    // Convert the date object into sql format and set it into the input
                    self.datetime().val(date.getFullYear() + '-' +
                                        ('00' + (date.getMonth()+1)).slice(-2) + '-' +
                                        ('00' + date.getDate()).slice(-2) + ' ' +
                                        ('00' + date.getHours()).slice(-2) + ':' +
                                        ('00' + date.getMinutes()).slice(-2) + ':' +
                                        ('00' + date.getSeconds()).slice(-2));
                },

                '{self} datetimeExport': function(el, ev, data) {
                    data['expirydate'] = self.datetime().val();
                }
            }
        })

		module.resolve();

	});
});

EasySocial.module( 'site/profile/about', function($){
	var module = this;

	EasySocial.require().script('field').library('history').done(function($) {
		EasySocial.Controller('Profile.About', {
			defaultOptions: {
				'{stepItem}'	: '[data-profile-about-step-item]',
				'{stepContent}'	: '[data-profile-about-step-content]',

				'{fieldItem}'	: '[data-field]'
			}
		}, function(self) {
			return {
				init: function() {
					self.fieldItem().addController('EasySocial.Controller.Field.Base', {
						mode: 'display'
					});
				},

				'{stepItem} click': function(el, ev) {
					ev.preventDefault();

					el.find('a').route();

					var target = el.data('for');

					self.stepItem().removeClass('active');

					el.addClass('active');

					self.stepContent().filterBy('id', target).trigger('activateTab');
				},

				'{stepContent} activateTab': function(el, ev) {
					self.stepContent().removeClass('active');

					el.addClass('active');

					el.find(self.fieldItem.selector).trigger('onShow');
				}
			}
		});

		module.resolve();
	});
});

EasySocial.module( 'site/profile/admintool' , function($){

	var module 				= this;

	EasySocial.require()
	.done(function($){

		EasySocial.Controller('Profile.Admin', {
				defaultOptions: {
					"{deleteUser}": "[data-admintool-delete]",
					"{banUser}": "[data-admintool-ban]",
					"{unban}": "[data-admintool-unban]"
				}
			}, function(self) { return {

					init: function() {
					},

					"{unban} click": function(el) {
						var uid = el.data('id');

						EasySocial.dialog({
							content: EasySocial.ajax('site/views/profile/confirmUnban', {id: uid}),
							bindings: {
								"{unbanButton} click": function() {
									
									EasySocial.ajax('site/controllers/profile/unbanUser', {
										"id": uid
									}).done(function(html) {
										EasySocial.dialog({
											content: html
										});
									});

								},
								
								"{closeButton} click": function() {
									EasySocial.dialog().close();
								}
							}
						});
					},

					"{deleteUser} click" : function(el) {

						var uid = el.data('id');

						EasySocial.dialog({
							content: EasySocial.ajax( 'site/views/profile/confirmDeleteUser', {id: uid}),
							bindings: {
								"{deleteButton} click": function() {
									EasySocial.ajax('site/controllers/profile/deleteUser', {
										"id": uid
									})
									.done(function(html) {
										EasySocial.dialog({
											content: html
										});
									});
								},
								"{closeButton} click": function() {
									EasySocial.dialog().close();
								}
							}
						});
					},

					"{banUser} click" : function(el) {
						var uid = el.data('id');

						EasySocial.dialog({
							content: EasySocial.ajax( 'site/views/profile/confirmBanUser', {id: uid}),
							bindings: {
								
								"{banButton} click": function() {
									var period = $('[data-ban-period]').val();

									EasySocial.ajax( 'site/controllers/profile/banUser' ,
									{
										"id"	: uid,
										"period": period
									})
									.done( function(html)
									{
										EasySocial.dialog({
											content: html
										});

									});
								},
								"{closeButton} click": function() {
									EasySocial.dialog().close();
								}
							}
						});
					}
				}
		});

		module.resolve();
	});

});

EasySocial.module( 'site/profile/edit' , function($){

	var module 				= this;

	EasySocial.require()
	.script( 'validate', 'field', 'oauth/facebook' )
	.done(function($){

		EasySocial.Controller(
			'Profile.Edit',
			{
				defaultOptions:
				{
					userid				: null,

					"{stepContent}"		: "[data-profile-edit-fields-content]",
					"{stepItem}"		: "[data-profile-edit-fields-step]",

					// Forms.
					"{profileForm}"		: "[data-profile-fields-form]",

					// Content for profile editing
					"{profileContent}"	: "[data-profile-edit-fields]",

					"{fieldItem}"		: "[data-profile-edit-fields-item]",

					// Submit buttons
					"{save}"			: "[data-profile-fields-save]",
					"{saveClose}"		: "[data-profile-fields-save-close]",

					// Delete Profile
					"{deleteProfile}"	: "[data-profile-edit-delete]",

					'{taskInput}'		: 'input[name="task"]'
				}
			},
			function( self )
			{
				return {

					init: function()
					{
						self.fieldItem().addController('EasySocial.Controller.Field.Base', {
							userid: self.options.userid,
							mode: 'edit'
						});
					},

					errorFields: [],

					// Support field throwing error internally
					'{fieldItem} error': function(el, ev) {
						self.triggerStepError(el);
					},

					// Support for field resolving error internally
					'{fieldItem} clear': function(el, ev) {
						self.clearStepError(el);
					},

					// Support validate.js throwing error externally
					'{fieldItem} onError': function(el, ev) {
						self.triggerStepError(el);
					},

					triggerStepError: function(el) {
						var fieldid = el.data('id'),
							stepid = el.parents(self.stepContent.selector).data('id');

						if($.inArray(fieldid, self.errorFields) < 0 ) {
							self.errorFields.push(fieldid);
						}

						self.stepItem().filterBy('for', stepid).trigger('error');
					},

					clearStepError: function(el) {
						var fieldid = el.data('id'),
							stepid = el.parents(self.stepContent.selector).data('id');

						self.errorFields = $.without(self.errorFields, fieldid);

						self.stepItem().filterBy('for', stepid).trigger('clear');
					},

					"{stepItem} click" : function( el , event )
					{
						var id 	= $(el).data('for');

						// Profile form should be hidden
						self.profileContent().show();

						// Remove active class on step item
						self.stepItem().removeClass('active');

						// Add active class on the selected item.
						el.addClass('active');

						// Remove active class on step content
						self.stepContent().removeClass('active');

						// Get the step content element
						var stepContent = self.stepContent().filterBy('id', id);


						// Add active class on the selected content
						stepContent.addClass('active');

						// Trigger onShow on the field item in the content
						stepContent.find(self.fieldItem.selector).trigger('show');
					},

					"{stepItem} error": function(el) {
						el.addClass('error');
					},

					"{stepItem} clear": function(el) {
						if(self.errorFields.length < 1) {
							el.removeClass('error');
						}
					},

					"{save} click" : function( el , event )
					{
						// Run some error checks here.
						event.preventDefault();

						$( el ).addClass( 'btn-loading' );

						self.profileForm()
							.validate()
							.fail( function()
							{
								$( el ).removeClass( 'btn-loading' );
								EasySocial.dialog(
								{
									content 	: EasySocial.ajax( 'site/views/profile/showFormError' )
								});
							})
							.done( function()
							{
								self.taskInput().val('save');
								self.profileForm().submit();
							});

						return false;
					},

					"{saveClose} click": function(el, event)
					{
						// Run some error checks here.
						event.preventDefault();

						$(el).addClass('btn-loading');

						self.profileForm()
							.validate()
							.fail(function()
							{
								$(el).removeClass('btn-loading');
								EasySocial.dialog(
								{
									content: EasySocial.ajax('site/views/profile/showFormError')
								});
							})
							.done(function()
							{
								self.taskInput().val('saveclose');
								self.profileForm().submit();
							});

						return false;
					},

					"{deleteProfile} click" : function()
					{
						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/profile/confirmDelete' )
						});
					}
				}
		});

		module.resolve();
	});

});

EasySocial.module('site/profile/feeds', function($){

	var module 				= this;

	EasySocial.require()
	.library('history')
	.done(function($){

		EasySocial.Controller(
			'Profile.Feeds',
			{
				defaultOptions:
				{
					"{menuItem}"	: "[data-profileSidebar-menu]",
					"{item}"	: "[data-profileFeeds-item]",
					"{filter}"	: "[data-profileFeeds-Filter-edit]"
				}
			},
			function(self){

				return{

					init : function()
					{
						// Implement each feed links.
						self.item().implement(EasySocial.Controller.Profile.Feeds.Item, {
							"{parent}"	: self,
							"{profile}"	: self.parent
						});
					},

					"{menuItem} click" : function( el , event )
					{
						// Remove all active class.
						self.menuItem().removeClass( 'active' );

						// Add active class on this item.
						$( el ).addClass( 'active' );
					},

					addFilterItem: function(feed)
					{
						feed.find('[data-profileFeeds-item]').implement(EasySocial.Controller.Profile.Feeds.Item, {
							"{parent}"	: self,
							"{profile}"	: self.parent
						});

						feed.appendTo(self.element);
					}
				}
			});

		EasySocial.Controller('Profile.Feeds.Item', {
			defaultOptions:
			{
			}
		}, function(self) {
			return{

				clicked: false,

				init : function()
				{
				},

				"{self} click" : function()
				{
					//remove no-stream class if any
					$('.es-streams').removeClass( 'no-stream' );

					var type = self.element.data( 'type' ),
						filterId = self.element.data( 'filterid' ),
						userId = self.element.data( 'user' ),
						url = self.element.data( 'url' ),
						title = self.element.data( 'title' ),
						desc = self.element.data( 'description' );

					if (self.clicked) {
						return;
					}

					self.clicked = true;

					// clear the new feed notification counter.
					var key = '[data-stream-counter-';

					if (type == 'list') {
						key = key + type + '-' + id;
					} else {
						key = key + type;
					}

					key = key + ']';

					$(key).html( '0' );

					// clear new feed counter
					self.element.removeClass('has-notice');


			        var appendTitle = $.joomla.appendTitle;

			        if (appendTitle==="before") {
			            title = $.joomla.sitename + ((title) ? " - " + title : "");
			        }

			        if (appendTitle==="after") {
			            title = ((title) ? title + " - " : "") + $.joomla.sitename;
			        }

					// If this is an embedded layout, we need to play around with the push state.
					History.pushState( {state:1} , title , url );

					// Notify the profile that it's starting to fetch the contents.
					self.profile.contents().html("");
					self.profile.updatingContents();

					self.element.addClass('loading');

					EasySocial.ajax( 'site/controllers/profile/getStream', {
						"type"	: type,
						"filterId"	: filterId,
						"id"	: userId,
						"view"  : 'profile',
					})
					.done(function(contents, count) {

						if (count == 0) {
							$('.es-streams').addClass( 'no-stream' );
						}

						// Trigger change for the stream
						self.trigger('onStreamUpdate', [type]);

						window.streamFilter = type;

						self.profile.updateContent(contents);

						// add support to kunena [tex] replacement.
						try { MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]); } catch( err ) {};

					}).fail(function(messageObj) {
						return messageObj;
					}).always(function() {
						self.clicked	= false;
						self.element.removeClass('loading');
					});


				}
			}
		});
		module.resolve();
	});

});


EasySocial.module( 'site/profile/friends' , function($){

	var module 				= this;

	EasySocial.require()
	.view( 'site/loading/small')
	.language(
		'COM_EASYSOCIAL_FRIENDS_DIALOG_CANCEL_REQUEST',
		'COM_EASYSOCIAL_CANCEL_BUTTON',
		'COM_EASYSOCIAL_YES_CANCEL_MY_REQUEST_BUTTON'
	)
	.done(function($){

		EasySocial.Controller(
			'Profile.Friends.Request',
			{
				defaultOptions:
				{
					id 		: null,
					callback		: null,

					// Elements
					"{addButton}"		: "[data-profileFriends-add]",
					"{manageButton}"	: "[data-profileFriends-manage]",
					"{pendingButton}"	: "[data-profileFriends-pending]",
					"{respondButton}"	: "[data-profileFriends-respond]",
					"{cancelRequest}"	: "[data-profileFriends-cancelRequest]",

					"{unfriend}"		: "[data-profile-friends-unfriend]",
					"{approve}"			: "[data-friends-response-approve]",
					"{reject}"			: "[data-friends-response-reject]",

					// The current add friend / cancel friend btuton.
					"{button}"			: "[data-profileFriends-button]",

					// Dropdown
					"{dropdown}"		: "[data-profileFriends-dropdown]",

					view :
					{
						loader 			: "site/loading/small",
					}
				}
			},
			function(self)
			{
				return{

					init: function()
					{
						// Set the friend id.
						self.options.id 		= self.element.data( 'friend' );

						// Set the target id
						self.options.target 	= self.element.data( 'id' );

						// Set the callback url
						self.options.callback 	= self.element.data( 'callback' );
					},

					showDropDown : function()
					{
						self.element.addClass( 'open' );
					},

					hideDropDown : function()
					{
						self.element.removeClass( 'open' );
					},

					"{addButton} click" : function( el ) {

						var button = self.button();

						button.addClass("loading");

						EasySocial.ajax("site/controllers/friends/request", {
								id: self.options.target
							})
							.done(function(friendId, button) {

								// Remove any previous dropdown
								self.dropdown().remove();

								// After the request is complete, set the correct friend id.
								self.options.id = friendId;

								// Replace the button
								self.button().replaceWith(button);
							}).fail(function(obj){

								EasySocial.dialog({
									content: obj.message
								});

								button.removeClass("loading");
							});
					},

					"{cancelRequest} click" : function(el , event) {
						// If user can click on the cancel request, they should have a valid friend id by now.
						var friendId 	= self.options.id;

						// Hide any dropdown that's open
						self.hideDropDown();

						// Show confirmation dialog
						EasySocial.dialog({
							content: EasySocial.ajax( 'site/views/friends/confirmCancel' ),
							bindings:
							{
								"{confirmButton} click": function()
								{
									EasySocial.ajax( 'site/controllers/friends/cancelRequest' ,
									{
										"id"	: self.options.id
									})
									.done( function( button )
									{
										// Remove any previous dropdowns.
										self.dropdown().remove();

										// Update the button
										self.button().replaceWith( button );

										// Hide the dialog once the request has been cancelled.
										EasySocial.dialog().close();
									});
								}
							}
						});

					},

					"{unfriend} click" : function( el , event )
					{
						var userId 	= $( el ).data( 'id' );
						// Implement controller on add friend.
						EasySocial.dialog(
						{
							content		: EasySocial.ajax( 'site/views/friends/confirmUnfriend' , { "id"	: userId } ),
							bindings 	:
							{
								"{unfriendButton} click" : function()
								{
									EasySocial.ajax( 'site/controllers/friends/unfriend' ,
									{
										"id"	: self.options.id
									})
									.done(function( button )
									{
										// Remove any previous dropdowns.
										self.dropdown().remove();

										// Update the button
										self.button().replaceWith( button );

										// Close the dialog
										EasySocial.dialog().close();
									});
								}
							}
						});
					},

					"{approve} click" : function( el , event )
					{
						var friendId 	= self.options.id;

						// Hide dropdown
						self.hideDropDown();

						EasySocial.ajax( 'site/controllers/friends/approve' ,
						{
							"id"	: friendId
						})
						.done( function( button )
						{
							// Replace the button.
							self.button().replaceWith( button );
						});
					},

					"{reject} click" : function( el , event )
					{
						var friendId 	= self.options.id;

						// Hide dropdown
						self.hideDropDown();

						EasySocial.dialog(
						{
							content 	: EasySocial.ajax( 'site/views/friends/confirmReject' ),
							bindings :
							{
								"{rejectButton} click" : function()
								{
									EasySocial.ajax( 'site/controllers/friends/reject' ,
									{
										"id"	: friendId
									})
									.done( function( button )
									{
										// Update the button.
										self.button().replaceWith( button );

										EasySocial.dialog(
										{
											content 	: EasySocial.ajax( 'site/views/friends/friendRejected' ),
										});

									});


								}
							}
						});
					},

					"{dropdown} click" : function( el , event )
					{
						// Disallow clicking of events to trigger parent items.
						event.stopPropagation();
					},

					"{approveRequest} click" : function()
					{
						// Update the task
						self.respondForm().find( 'input[name=task]' ).val( 'approve' );

						// Update the friend id
						self.respondForm().find( 'input[name=id]' ).val( self.options.friendId );

						// Update the return url.
						self.respondForm().find( 'input[name=return]' ).val( self.options.callback );

						// Submit the form.
						self.respondForm().submit();
					}
				}
		});


		module.resolve();
	});

})

EasySocial.module( 'site/profile/header' , function($){

	var module 				= this;

	EasySocial.require()
	.script(
		'site/profile/friends' ,
		'site/profile/subscriptions' ,
		'site/conversations/composer'
	).done(function($) {

		EasySocial.Controller(
			'Profile.Header', {
				defaultOptions: {
					// Properties
					id: null,

					// Elements
					"{friendRequest}"	: "[data-profile-friends]",
					"{subscribe}"		: "[data-profile-followers]",
					"{conversation}"	: "[data-profile-conversation]"
				}
			}, function(self) {
				return {

					init: function() {

						// Get the id of the current user.
						self.options.id = self.element.data('id');
						self.options.name = self.element.data('name');
						self.options.avatar = self.element.data('avatar');

						// Implement friends controller on the friend request button.
						self.friendRequest().implement(EasySocial.Controller.Profile.Friends.Request, {
							"{parent}": self
						});

						// Implement subscription controller on the subscribe button.
						self.subscribe().implement(EasySocial.Controller.Profile.Subscriptions, {
							"{parent}"	: self
						});

						self.conversation().implement(EasySocial.Controller.Conversations.Composer.Dialog, {
							"recipient"	: {
								"id": self.options.id,
								"name"	: self.options.name,
								"avatar": self.options.avatar
							}
						});
					}
				}
			}
		);


		module.resolve();
	});


});

EasySocial.module( 'site/profile/subscriptions' , function($){

	var module 				= this;

	EasySocial.Controller(
		'Profile.Subscriptions',
		{
			defaultOptions:
			{
				// Properties
				id			: null,

				"{follow}"	: "[data-subscription-follow]",
				"{unfollow}": "[data-subscription-unfollow]",
				"{message}"	: "[data-subscription-message]",
				"{button}"	: "[data-subscription-button]"
			}
		},
		function(self)
		{
			return{

				init: function()
				{
					self.options.id 	= self.element.data( 'id' );
				},

				toggleDropDown : function()
				{
					self.element.toggleClass( 'open' );
				},

				"{unfollow} click" : function()
				{
					// Toggle dropdown.
					self.toggleDropDown();

					// Let's do an ajax call to follow the user.
					EasySocial.ajax( 'site/controllers/profile/unfollow' ,
					{
						"id"	: self.options.id,
						"type"	: 'user'
					})
					.done(function(button)
					{
						self.button().replaceWith( button );
					})
				},

				"{follow} click" : function()
				{
					// Toggle dropdown.
					self.toggleDropDown();

					// Let's do an ajax call to follow the user.
					EasySocial.ajax( 'site/controllers/profile/follow' ,
					{
						"id"	: self.options.id,
						"type"	: 'user'
					})
					.done(function( button )
					{
						self.button().replaceWith( button );
					});
				}
			}
		});

		module.resolve();

});

EasySocial.module( 'site/profile/miniheader' , function($){

	var module = this;

	EasySocial.require()
	.library(
		'scrollTo'
	)
	.done(function($){

		EasySocial.Controller(
			'Profile.MiniHeader',
			{
				defaultOptions: {

					"{viewport}": "[data-appscroll-viewport]",
					"{content}": "[data-appscroll-content]",
					"{apps}": "[data-appscroll-content] li",
					"{buttons}": "[data-appscroll-buttons]",
					"{nextButton}": "[data-appscroll-next-button]",
					"{prevButton}": "[data-appscroll-prev-button]"
				}
			},
			function(self){ return {

				init: function() {

					self.setLayout();

					// When page is refreshed, scroll value might be retained.
					self.viewport().scrollTo(0);
				},

				"{window} resize": $.debounce(function(){

					self.setLayout();

				}, 300),

				setLayout: function() {

					var viewport = self.viewport(),
						width = 5;

					if ($(".es-main").hasClass("w480")) {

						self.content().css({
							width: "auto"
						});

						self.enabled = false;

						return;
					}

					self.apps().each(function(){ width += $(this).outerWidth(true) });

					if (width > viewport.width()) {

						self.content()
							.css({
								width: width,
								float: "none"
							});

						self.buttons()
							.css("opacity", 1);

						self.enabled = true;
					}
				},

				enabled: false,

				"{nextButton} click": function() {

					if (!self.enabled) return;

					var viewport = self.viewport(),
						width = viewport.width() - 80; // 80 offset

					viewport.scrollTo('+=' + width + 'px', 800, {axis: 'x', easing: 'easeInOutCubic'});
				},

				"{prevButton} click": function() {

					if (!self.enabled) return;

					var viewport = self.viewport(),
						width = viewport.width() - 80; // 80 offset

					viewport.scrollTo('-=' + width + 'px', 800, {axis: 'x', easing: 'easeInOutCubic'});
				}

			}});


		module.resolve();
	});


});

EasySocial.module('site/profile/notifications', function($) {

	var module = this;

	EasySocial.require()
		.script('site/profile/header')
		.done(function() {
			EasySocial.Controller('Profile.Notifications', {
				defaultOptions: {
					// App item
					"{sidebarItem}"	: "[data-notification-item]",
					"{contentItem}"	: "[data-notification-content]",

					//input form
					"{notificationForm}" : "[data-notifications-form]"
				},
			}, function(self) {
				return {

					init : function() {
					},

					"{sidebarItem} click": function(el, event) {
						self.sidebarItem().removeClass('active');

						el.addClass('active');

						self.contentItem().hide();

						var element = el.data('alert-element');

						self.contentItem('[data-alert-element="' + element + '"]').show();
					}
				}
			});

			module.resolve();
		});
});

EasySocial.module( 'site/profile/privacy' , function($){

	var module 	= this;

	EasySocial.require()
	.script( 'site/profile/header' )
	.library( 'history', 'textboxlist' )
	.view( 'site/loading/small' )
	.done(function($){

		EasySocial.Controller(
			'Profile.Privacy',
			{
				defaultOptions:
				{
					// App item
					"{sidebarItem}"	: "[data-profile-privacy-item]",
					"{contentItem}"	: "[data-privacy-content]",

					"{privacyItem}" : "[data-privacy-item]",

					//input form
					"{privacyForm}" : "[data-profile-privacy-form]",

					"{formActions}": "[data-form-actions]",

					view :
					{
						loading : "site/loading/small"
					}
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						// Implement profile header.
						self.sidebarItem().implement( EasySocial.Controller.Profile.Privacy.Sidebar ,
						{
							"{parent}"	: self
						});

						self.privacyItem().implement( EasySocial.Controller.Profile.Privacy.Item ,
						{
							"{parent}"	: self
						});
					},

					updateContent : function(group)
					{
						// Hide the contents first
						self.contentItem().hide();

						// Only display the appropriate group
						$('.privacy-content-' + group).show();

						if (group == 'blocked') {
							self.formActions().hide();
						} else {
							self.formActions().show();
						}
					}
				}
			}
		);

		EasySocial.Controller(
			'Profile.Privacy.Sidebar',
			{
				defaultOptions :
				{
					"{sidebarItem}"		: "[data-profile-privacy-item]",
				}
			},
			function( self )
			{
				return {
					init : function()
					{

					},

					"{self} click" : function( el )
					{
						// Prevent from bubbling up.
						// event.preventDefault();

						$('[data-profile-privacy-item]').removeClass( 'active' );
						$( el ).addClass( 'active' );

						var group = self.element.data( 'group' );
						self.parent.updateContent( group );
					}
				}
			});


		EasySocial.Controller(
			'Profile.Privacy.Item',
			{
				defaultOptions :
				{
					"{selection}"		: "[data-privacy-select]",
					"{hiddenCustom}" 	: "[data-hidden-custom]",
					"{customForm}" 		: "[data-privacy-custom-form]",

					"{customTextInput}" : "[data-textfield]",
					"{customItems}"		: "input[]",
					"{customHideBtn}"	: "[data-privacy-custom-hide-button]",
					"{customInputItem}"	: "[data-textboxlist-item]",
					"{customEditBtn}"   : "[data-privacy-custom-edit-button]"
				}
			},
			function( self )
			{
				return {
					init : function()
					{

						self.customTextInput().textboxlist(
							{
								component: 'es',
								unique: true,
								plugin: {
									autocomplete: {
										exclusive: true,
										minLength: 2,
										cache: false,
										query: function( keyword ) {

											var users = self.getTaggedUsers();

											var ajax = EasySocial.ajax("site/views/privacy/getfriends", {
												q: keyword,
												exclude: users
											});
											return ajax;
										}
									}
								}
							}
						);

						self.textboxlistLib = self.customTextInput().textboxlist("controller");
					},

					getTaggedUsers: function()
					{
						var users = [];
						var items = self.customInputItem();

						if( items.length > 0 )
						{
							$.each( items, function( idx, element ) {
								users.push( $( element ).data('id') );
							});
						}

						return users;
					},

					// event listener for adding new name
					"{customTextInput} addItem": function(el, event, data) {

						// lets get the exiting ids string
						var ids    = self.hiddenCustom().val();
						var values = '';

						if( ids == '')
						{
							values = data.id;
						}
						else
						{
							var idsArr = ids.split(',');
							idsArr.push( data.id );

							values = idsArr.join(',');
						}

						//now update the customhidden value.
						self.hiddenCustom().val( values );
					},

					// event listener for removing name
					"{customTextInput} removeItem": function(el, event, data ) {
						// lets get the exiting ids string
						var ids    = self.hiddenCustom().val();
						var values = '';
						var newIds = [];

						var idsArr = ids.split(',');

						for( var i = 0; i < idsArr.length; i++ )
						{
							if( idsArr[i] != data.id )
							{
								newIds.push( idsArr[i] );
							}
						}

						if( newIds.length <= 0 )
						{
							values = '';
						}
						else
						{
							values = newIds.join(',');
						}

						//now update the customhidden value.
						self.hiddenCustom().val( values );
					},

					"{customEditBtn} click" : function( el )
					{
						self.customForm().toggle();
					},

					"{selection} change" : function( el )
					{
						var selected = el.val();

						if( selected == 'custom' )
						{
							self.customForm().show();
							self.customEditBtn().show();
						}
						else
						{
							self.customForm().hide();
							self.customEditBtn().hide();
						}

						return;
					},

					"{customHideBtn} click" : function()
					{
						self.customForm().hide();

						self.customEditBtn().show();

						self.textboxlistLib.autocomplete.hide();

						return;
					}
				}
			});


		module.resolve();
	});

});

EasySocial.module( 'site/profile/profile' , function($){

	var module 	= this;

	EasySocial.template('info/item', '<li data-profile-apps-item data-layout="custom"><a class="ml-20" href="[%= url %]" title="[%= title %]" data-info-item data-info-index="[%= index %]"><i class="fa fa-info-circle mr-5"></i> [%= title %]</a></li>');

	EasySocial.require()
	.script('site/profile/header', 'site/profile/feeds')
	.library('history')
	.done(function($) {

		EasySocial.Controller('Profile', {
				defaultOptions: {

					// The current user being viewed
					id : null,

					// Elements
					"{header}": "[data-profile-header]",

					// App item
					"{feeds}"	: "[data-profile-feeds]",
					"{app}"		: "[data-profile-apps-item]",
					"{action}"	: "[data-profile-apps-menu]",
					"{showAllFilters}"	: "[data-app-filters-showall]",
					"{appFilters}"		: "[data-sidebar-app-filter]",

					// Contents
					"{contents}"	: "[data-profile-real-content]",

					// Sidebar
					"{sidebar}"      : "[data-sidebar]",
					"{sidebarToggle}": "[data-sidebar-toggle]",

					'{info}': '[data-info]',
					'{infoItem}': '[data-info-item]',

					view: {
						infoItem: 'info/item'
					}
				}
			},
			function(self) { return {

					init : function() {

						// Get the user's id.
						self.options.id = self.element.data('id');

						// Implement profile header.
						self.header().implement(EasySocial.Controller.Profile.Header, {
							"{parent}"	: self
						});

						// Implement app controller on all app items.
						self.feedsController = self.feeds().addController(EasySocial.Controller.Profile.Feeds, {
							"{parent}"	: self
						});

						// Set layout on document ready
						$(function(){
							self.setLayout();
						});

						// Set layout on responsive event
						$(".es-responsive").on("responsive", function(){
							self.setLayout();
						});
					},

					setLayout: function() {

						var sidebar = self.sidebar(),
							sidebarToggle = self.sidebarToggle();

						if (sidebarToggle.is(":visible")) {

							var container =
								$('<div class="es-container responsive">')
									.append(sidebar)
									.insertAfter(sidebarToggle);
						} else {
							$(".es-profile .es-container:not(.responsive)").prepend(sidebar);
							$(".es-profile .es-container.responsive").remove();
						}
					},

					"{sidebarToggle} sidebarToggle": function(sidebarToggle) {

						self.setLayout();
					},

					"{app} click" : function(el, event) {
						// Remove active class.
						self.app().removeClass( 'active' );

						// Add active class to this current item.
						$( el ).addClass( 'active' );

						// Prevent from bubbling up
						event.preventDefault();

						var data = el.data();

						if(data.layout === 'canvas')
						{
							window.location = data[data.layout + 'Url'];
							return;
						}

						// Since 1.3
						// Added support for custom items
						if (data.layout === 'custom') {
							return;
						}

				        var title = data.title;

				        if (data.namespace == 'site/controllers/profile/getStream') {

					        var appendTitle = $.joomla.appendTitle;

					        if (appendTitle==="before") {
					            title = $.joomla.sitename + ((title) ? " - " + title : "");
					        }

					        if (appendTitle==="after") {
					            title = ((title) ? title + " - " : "") + $.joomla.sitename;
					        }
				        }

						History.pushState({state: 1}, title, data[data.layout + 'Url'] );

						if(self.sidebarToggle().is(':visible'))
						{
							$.scrollTo(self.contents());
						}

						EasySocial.ajax(data.namespace, {
							id: data.id,
							view: 'profile',
							appId: data.appId
						}, {
							beforeSend: function() {
								self.loading();
							}
						}).done(function(contents) {
							self.updateContent(contents);
						}).fail(function(messageObj) {
							return messageObj;
						});
					},


					"{showAllFilters} click" : function( el , event ) {
						$(el).hide();

						self.appFilters().removeClass( 'hide' );
					},

					updateContent : function(content) {
						self.element.removeClass("loading");

						self.contents().html( content );
					},

					/**
					 * Add a loading icon on the content layer.
					 */
					updatingContents: function()
					{
						self.element.addClass("loading");
					},

					loading: function() {

						self.contents().html("");
						self.element.addClass("loading");
					},

					'{info} click': function(el, ev) {
						ev.preventDefault();

						el.route();

						self.loading();

						var loaded = el.data('loaded');

						if (loaded) {
							self.infoItem().eq(0).trigger('click');

							return;
						}

						EasySocial.ajax('site/controllers/profile/initInfo', {
							id: self.options.id
						}).done(function(steps) {
							el.data('loaded', 1);

							var parent = el.parent('[data-profile-apps-item]');

							// Append all the steps
							$.each(steps.reverse(), function(index, step) {
								if (!step.hide) {
									parent.after(self.view.infoItem({
										url: step.url,
										title: step.title,
										index: step.index
									}));
								}

								if (step.html) {
									self.updateContent(step.html);
									self.contents().find('[data-field]').trigger('onShow');
								}
							});

							var item = self.infoItem().eq(0).parent('[data-profile-apps-item]');

							self.app().removeClass('active');

							item.addClass('active');

							// Have to set the title
							// $(document).prop('title', self.infoItem().eq(0).attr('title'));
						});
					},

					'{infoItem} click': function(el, ev) {
						ev.preventDefault();

						el.route();

						self.loading();

						var index = el.data('info-index');

						EasySocial.ajax('site/controllers/profile/getInfo', {
							id: self.options.id,
							index: index
						}).done(function(contents) {
							self.updateContent(contents);

							self.contents().find('[data-field]').trigger('onShow');

							self.app().removeClass('active');

							el.parent('[data-profile-apps-item]').addClass('active');

						}).fail(function(error) {
							self.updateContent(error.message);
						});
					}
				}
			}
		);

		module.resolve();
	});

});

EasySocial.module( 'site/registrations/registrations' , function($){

	var module 				= this;

	EasySocial.require()
	.script( 'validate', 'field' )
	.view( 'site/registration/dialog.error' )
	.language( 'COM_EASYSOCIAL_CLOSE_BUTTON' , 'COM_EASYSOCIAL_REGISTRATION_ERROR_DIALOG_TITLE' )
	.done(function($){

		EasySocial.Controller(
			'Registrations.Form',
			{
				defaultOptions:
				{
					// passed in by caller
					previousLink	 : null,

					"{submit}"		: "[data-registration-submit]",
					"{field}"		: "[data-registration-fields-item ]",
					"{previous}"	: "[data-registration-previous]",

					view :
					{
						formError 	: "site/registration/dialog.error"
					}
				}
			},
			function(self)
			{

				return{

					init: function()
					{
						self.field().addController('EasySocial.Controller.Field.Base', {
							mode: 'register'
						});
					},

					"{previous} click" : function( el , event )
					{
						event.preventDefault();


						window.location.href	= self.options.previousLink;

						return false;
					},

					"{submit} click" : function( el , event )
					{
						event.preventDefault();

						// Apply loading class on button
						$( el ).addClass( 'btn-loading' );

						$( self.element ).validate()
						.fail( function()
						{
							// Remove loading class
							$( el ).removeClass( 'btn-loading' );

							EasySocial.dialog(
							{
								"title"		: $.language( 'COM_EASYSOCIAL_REGISTRATION_ERROR_DIALOG_TITLE' ),
								"content"	: self.view.formError(true),
								"width"		: 400,
								"height"	: 150,
								"buttons"	:
								[
									{
										"name"	: $.language( 'COM_EASYSOCIAL_CLOSE_BUTTON' ),
										"classNames"	: "btn btn-es-primary",
										"click"	: function()
										{
											EasySocial.dialog().close();
										}
									}
								]

							});
						})
						.done( function()
						{
							self.element.submit();
						});

						return false;
					}
				}
			});

		module.resolve();
	});

});

EasySocial.module( 'site/search/advanced.criteria' , function(){
	var module	= this;

	EasySocial.require()
	.view( 'site/loading/small' )
	.script( 'site/search/map' )
	.language( 'COM_EASYSOCIAL_ADVANCED_SEARCH_ADDRESS_DISTANCE_NOTICE' )
	.done( function($){

		EasySocial.Controller(
		'Search.Advanced.Criteria',
		{
			defaultOptions:
			{

				"{addButton}" 		: "[data-criteria-add-button]",
				"{removeButton}" 	: "[data-criteria-remove-button]",

				"{itemConditionDiv}" : "[data-itemConditionDiv]",
				"{itemCriteria}" 	: "[data-itemCriteria]",
				"{itemDataKey}" 	: "[data-itemDataKey]",
				"{itemOperator}" 	: "[data-itemOperator]",
				"{itemCondition}" 	: "[data-itemCondition]",

				"{dateStart}" 		: "[data-start]",
				"{dateEnd}" 		: "[data-end]",
				"{dataCondition}" 	: "[data-condition]",

                '{frmDistance}' : '[data-distance]',
                '{frmAddress}' : '[data-address]',
                '{frmLatitude}' : '[data-latitude]',
                '{frmLongitude}' : '[data-longitude]',

				//used for notice message if there is any
				"{dataNotice}" : "[data-criteria-notice]",

				"{locationLabel}" : "[data-location-label]",
				"{textField}" : "[data-location-textfield]",

				// loading gif
				view :
				{
					loadingContent 	: "site/loading/small"
				}
			}
		},
		function( self ){
			return {

				init : function()
				{
					self.element.addController(EasySocial.Controller.Search.Map);

					if (self.frmAddress().val() != undefined && self.frmAddress().val() != '') {
                    	self.textField().val(self.frmAddress().val());
                    	self.locationLabel().removeClass('hide');
					}
				},

				"{itemOperator} change" : function()
				{
					criteria 	= self.itemCriteria().find( 'select' );
					datakey		= self.itemDataKey().find( 'select' );
					operator 	= self.itemOperator().find( 'select' );

					var data 	= criteria.val().split( '|' );

					var key 	= data[0];
					var type 	= data[1];

					var opValue     = operator.val();
					var datakey		= datakey.val();

					if( opValue == 'blank' || opValue == 'notblank' )
					{
						self.itemCondition().hide();
					}
					else
					{
						if( opValue == 'between' )
						{
							self.getConditions( type, opValue, datakey );
						}
						else
						{
							if( type == 'datetime' || type == 'birthday' )
							{
								if( self.dateStart().length > 0 )
								{
									self.getConditions( type, opValue, datakey );
								}
							}
						}

						if( self.itemCondition().is( ":hidden" ) )
						{
							self.itemCondition().show();
						}

					}

				},

				getConditions : function( type, opValue, datakey )
				{
						// lets call ajax to get the value.
						EasySocial.ajax(
							"site/controllers/search/getConditions",
							{
								"element"	: type,
								"operator" 	: opValue,
								"datakey" 	: datakey
							})
							.done(function( conditions ) {

								self.itemCondition().show();

								// adding new condtions
								self.itemCondition().remove();
								var contents = $.buildHTML( conditions );
								contents.insertAfter( self.itemOperator() );

							})
							.fail( function( messageObj ){
								return messageObj;
							})
							.always(function(){

							});
				},

				"{frmDistance} change" : function() {

                    var distance = self.frmDistance().val();
                    var address = self.frmAddress().val();
                    var lat = self.frmLatitude().val();
                    var lng = self.frmLongitude().val();

                    var computedVal = distance + '|' + lat + '|' + lng + '|' + address;
                    self.dataCondition().val(computedVal);
				},

				"{dateStart} change" : function( el )
				{
					start 	= self.dateStart().val();
					end 	= self.dateEnd().val();


					var data = start;

					if( end.length > 0 )
					{
						data = data + '|' + end;
					}

					// update value
					self.dataCondition().val( data );
				},

				"{dateEnd} change" : function()
				{
					start 	= self.dateStart().val();
					end 	= self.dateEnd().val();

					var data = start;
					data = data + '|' + end;

					// update value
					self.dataCondition().val( data );
				},

				"{itemCriteria} change" : function()
				{
					select = self.itemCriteria().find( 'select' );

					if( select.val() != '' )
					{
						var data = select.val().split( '|' );

						var key 	= data[0];
						var type 	= data[1];

						//lets hide the notice message.
						self.dataNotice().addClass('hide');

						// lets get the correct operators and condition.

						EasySocial.ajax(
							"site/controllers/search/getDataKeys",
							{
								"key"		: key,
								"element"	: type
							})
							.done(function( datakeys, operators, conditions ) {

								self.itemDataKey().remove();
								self.itemOperator().remove();
								self.itemCondition().remove();

								// adding new operators
								// self.itemOperator().remove();
								var contents = $.buildHTML( operators );
								contents.insertAfter( self.itemConditionDiv() );

								// adding new operators
								if (datakeys != '') {
									var contents = $.buildHTML( datakeys );
									contents.insertAfter( self.itemConditionDiv() );
								}

								// adding new condtions
								// self.itemCondition().remove();
								var contents = $.buildHTML( conditions );
								contents.insertAfter( self.itemOperator() );

							})
							.fail( function( messageObj ){
								return messageObj;
							})
							.always(function(){

							});
					}

					// console.log( select.val() );
				},

				"{itemDataKey} change" : function()
				{
					select = self.itemCriteria().find( 'select' );

					if( select.val() != '' )
					{
						var data = select.val().split( '|' );

						var key 	= data[0];
						var type 	= data[1];

						//attempt to get the selected datakey
						var datakeys = self.itemDataKey().find( 'select' );
						var datakey = datakeys.val();

						// lets get the correct operators and condition.
						EasySocial.ajax(
							"site/controllers/search/getOperators",
							{
								"key"		: key,
								"element"	: type,
								"datakey" 	: datakey
							})
							.done(function( operators, conditions ) {

								// adding new operators
								self.itemOperator().remove();
								var contents = $.buildHTML( operators );
								contents.insertAfter( self.itemDataKey() );

								// adding new condtions
								self.itemCondition().remove();
								var contents = $.buildHTML( conditions );
								contents.insertAfter( self.itemOperator() );

								if (datakey == 'distance') {
									self.locationLabel().removeClass('hide');
								} else {
									self.locationLabel().addClass('hide');
								}

							})
							.fail( function( messageObj ){
								return messageObj;
							})
							.always(function(){

							});


					}

					// console.log( select.val() );
				},




				"{removeButton} click" : function()
				{
					// If this is the last search item, do not allow removing
					self.element.remove();
				}




			} //return
		});

		module.resolve();

	});

});

EasySocial.module( 'site/search/map' , function($){
	var module	= this;

    // Create search template first
    $.template('easysocial/maps.suggestion', '<div class="es-location-suggestion" data-location-suggestion><span class="formatted_address">[%= location.formatted_address %]</span></div>');

	EasySocial.require()
	.library('gmaps')
	.done( function(){

        // Constants
        var KEYCODE = {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            ENTER: 13,
            ESCAPE: 27,
            LEFT: 37,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        };

		EasySocial.Controller(
		'Search.Map',
		{
			defaultOptions:
			{
                "{icon}" : "[data-loaction-icon]",
                "{locationLabel}" : "[data-location-label]",
                '{textField}'       : '[data-location-textfield]',

                "{detectButton}" : "[data-location-detect]",
                "{suggestions}"  : "[data-location-suggestions]",
                "{suggestion}"      : "[data-location-suggestion]",
                "{autocomplete}" : "[data-location-autocomplete]",

                // form elements
                "{dataCondition}" : "[data-condition]",
                "{frmDistance}" : "[data-distance]",
                "{frmAddress}" : "[data-address]",
                "{frmLatitude}" : "[data-latitude]",
                "{frmLongitude}" : "[data-longitude]",

                view: {
                    suggestion: 'maps.suggestion'
                }
			}
		},
		function( self ){
			return {

				init : function()
				{

				},

                locations: {},

                lastQueryAddress: null,

                results: [],

                result: null,

                "{detectButton} click": function() {

                    self.icon()
                            .removeClass('fa fa-flash')
                            .addClass('btn-loading');

                    clearTimeout(self.detectTimer);

                    // self.detectTimer = setTimeout(function() {
                    //     self.base().removeClass("is-busy");
                    // }, 8000);

                    $.GMaps.geolocate({
                        success: function(position) {
                            $.GMaps.geocode({
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                                callback: function(locations, status) {
                                    if (status=="OK") {
                                        self.suggest(locations);
                                    }
                                }
                            });
                        },
                        error: function(error) {
                            var message = "";

                            switch (error.code) {

                                case 1:
                                    message = $.language("COM_EASYSOCIAL_LOCATION_PERMISSION_ERROR");
                                    break;

                                case 2:
                                    message = $.language("COM_EASYSOCIAL_LOCATION_TIMEOUT_ERROR");
                                    break;

                                case 3:
                                default:
                                    message = $.language("COM_EASYSOCIAL_LOCATION_UNAVAILABLE_ERROR");
                                    break;
                            }

                            EasySocial.dialog({
                                content: message
                            });
                        },
                        always: function() {
                            clearTimeout(self.detectTimer);

                            self.icon()
                                    .removeClass('btn-loading')
                                    .addClass('fa fa-flash');
                        }
                    });
                },

                lookup: $.debounce(function(address) {

                    // self.base().addClass("is-busy");

                    $.GMaps.geocode({
                        address: address,
                        callback: function(locations, status) {

                            // self.base().removeClass("is-busy");

                            if (status=="OK") {

                                // Store a copy of the results
                                self.locations[address] = locations;

                                // Suggestion locations
                                self.suggest(locations);

                                self.lastQueryAddress = address;
                            }
                        }
                    });

                }, 250),


                "{textField} keypress": function(textField, event) {

                    switch (event.keyCode)
                    {
                        case KEYCODE.UP:

                            var prevSuggestion = $(
                                self.suggestion(".active").prev(self.suggestion.selector)[0] ||
                                self.suggestion(":last")[0]
                            );

                            // Remove all active class
                            self.suggestion().removeClass("active");

                            prevSuggestion
                                .addClass("active")
                                .trigger("activate");

                            self.suggestions()
                                .scrollTo(prevSuggestion, {
                                    offset: prevSuggestion.height() * -1
                                });

                            event.preventDefault();

                            break;

                        case KEYCODE.DOWN:

                            var nextSuggestion = $(
                                self.suggestion(".active").next(self.suggestion.selector)[0] ||
                                self.suggestion(":first")[0]
                            );

                            // Remove all active class
                            self.suggestion().removeClass("active");

                            nextSuggestion
                                .addClass("active")
                                .trigger("activate");

                            self.suggestions()
                                .scrollTo(nextSuggestion, {
                                    offset: nextSuggestion.height() * -1
                                });

                            event.preventDefault();

                            break;

                        case KEYCODE.ENTER:

                            var activeSuggestion = self.suggestion(".active"),
                                location = activeSuggestion.data("location");
                                self.set(location);

                            self.hideSuggestions();

                            event.preventDefault();
                            break;

                        case KEYCODE.ESCAPE:
                            self.hideSuggestions();
                            event.preventDefault();
                            break;
                    }

                },

                "{textField} keyup": function(textField, event) {

                    switch (event.keyCode) {

                        case KEYCODE.UP:
                        case KEYCODE.DOWN:
                        case KEYCODE.LEFT:
                        case KEYCODE.RIGHT:
                        case KEYCODE.ENTER:
                        case KEYCODE.ESCAPE:
                            // Don't repopulate if these keys were pressed.
                            break;

                        default:
                            var address = $.trim(textField.val());

                            if (address==="") {
                                // self.base().removeClass("has-location");
                                self.hideSuggestions();
                            }

                            // if (address==self.lastQueryAddress) return;

                            var locations = self.locations[address];

                            // If this location has been searched before
                            if (locations) {

                                // And set our last queried address to this address
                                // so that it won't repopulate the suggestion again.
                                self.lastQueryAddress = address;

                                // Just use cached results
                                self.suggest(locations);

                            // Else ask google to find it out for us
                            } else {

                                self.lookup(address);
                            }
                            break;
                    }
                },

                set: function(location) {

                    var lat = location.geometry.location.lat(),
                        lng = location.geometry.location.lng(),
                        address = location.formatted_address,
                        distance = self.frmDistance().val();

                    self.frmAddress().val(address);
                    self.frmLatitude().val(lat);
                    self.frmLongitude().val(lng);

                    var computedVal = distance + '|' + lat + '|' + lng + '|' + address;
                    self.dataCondition().val(computedVal);

                    self.textField().val(address);
                    // self.locationLabel().removeClass('hide');

                    self.hideSuggestions();

                },

                "{suggestion} click": function(suggestion, event) {
                    var location = suggestion.data("location");
                    self.set(location);
                },

                suggest: function(locations) {

                    self.hideSuggestions();

                    var suggestions = self.suggestions();

                    if (locations.length < 0) return;

                    self.results = locations;

                    $.each(locations, function(i, location){
                        // Create suggestion and append to list
                        self.view.suggestion({
                                location: location
                            })
                            .data("location", location)
                            .appendTo(suggestions);
                    });

                    // self.autocomplete().addClass('active');
                    self.showSuggestions();
                },

                showSuggestions: function() {

                    self.focusSuggestion = true;

                    // self.element.find(".es-story-footer")
                    //     .addClass("swap-zindex");

                    setTimeout(function(){

                        self.autocomplete().addClass("active");

                        var doc = $(document),
                            hideOnClick = "click.es.advancedsearch.location";

                        doc
                            .off(hideOnClick)
                            .on(hideOnClick, function(event){

                                // Collect list of bubbled elements
                                var targets = $(event.target).parents().andSelf();

                                if (targets.filter(self.element).length > 0) return;

                                doc.off(hideOnClick);

                                self.hideSuggestions();
                            });

                    }, 500);
                },

                hideSuggestions: function() {

                    // Clear location suggestions
                    self.suggestions().empty();

                    self.focusSuggestion = false;

                    self.autocomplete().removeClass("active");

                    $(document).off("click.es.advancedsearch.location");

                }


			} //return
		});

		module.resolve();

	});

});

EasySocial.module( 'site/search/advanced' , function(){
	var module	= this;

	EasySocial.require()
	.script( 'site/search/advanced.criteria' )
	.view( 'site/loading/small')
	.language( 'COM_EASYSOCIAL_STREAM_LOAD_PREVIOUS_STREAM_ITEMS' )
	.done( function($){

		EasySocial.Controller(
		'Search.Advanced',
		{
			defaultOptions:
			{
				// Elements
				"{sidebar}"       	: "[data-advsearch-sidebar]",
				"{sidebarItem}"		: "[data-sidebar-item]",

				"{item}"			: "[data-adv-search-item]",
				"{list}" 			: "[data-advsearch-list]",

				"{searchForm}" 		: "[data-adv-search-form]",
				"{savefilterBtn}" 	: "[data-advsearch-savefilter]",

				"{deletefilterBtn}" : "[data-advsearch-deletefilter]",

				"{content}" 		: "[data-advsearch-content]",

				"{addCriteria}"		: "[data-adv-search-add-criteria]",

				"{criteriaTemplate}"	: "[data-adv-search-criteria-template]",

				"{resultlist}" 		: "[data-advsearch-result-list]",

				// loading gif
				view :
				{
					loadingContent 	: "site/loading/small"
				}
			}
		},
		function( self ){
			return {

				init : function()
				{
					// Implement sidebar item controller.
					self.sidebarController = self.sidebar().addController( EasySocial.Controller.Search.Advanced.Sidebar,
												{
													"{parent}" : self
												});

					// implement search criteria item controller.
					self.item()
						.addController( EasySocial.Controller.Search.Advanced.Criteria,
							{
								"{parent}" : self
							});

				},

				/**
				 * Add a loading icon on the content layer.
				 */
				updatingContents: function()
				{
					self.element.addClass("loading");
				},

				/**
				 * Responsible to update the content area in the dashboard.
				 */
				updateContents : function( contents )
				{
					self.element.removeClass("loading");

					// Hide the content first.
					self.content().html( contents );
				},


				"{deletefilterBtn} click": function( el ) {

					var id = $(el).data( "id" );

					EasySocial.dialog({
						content		: EasySocial.ajax( 'site/views/search/confirmFilterDelete', { "fid": id } ),
						bindings	:
						{
							"{deleteButton} click" : function()
							{
								EasySocial.ajax( 'site/controllers/search/deleteFilter',
								{
									"fid"		: id
								})
								.done(function()
								{
									// delete the sidebar item
									$('[data-search-filter-' + id + ']').remove();

									//set active to default filter.
									$('[data-search-filter-0]').addClass( 'active' );

									//reset content
									self.content().html("");
									self.updatingContents();

									EasySocial.ajax( 'site/controllers/search/getFilterResults' ,
									{
										"fid"	: '0',
									})
									.done(function( contents )
									{
										var contents = $.buildHTML(contents);

										contents
											.addController( "EasySocial.Controller.Search.Advanced.Criteria",
												{
													"{parent}" : self
												});

										self.updateContents( contents );

									})
									.fail( function( messageObj )
									{
										return messageObj;
									})


									EasySocial.dialog().close();
								});
							}
						}
					});

				},


				"{savefilterBtn} click" : function()
				{
					var data 		= self.searchForm().serializeJSON();

					EasySocial.dialog({
						content		: EasySocial.ajax( 'site/views/search/confirmSaveFilter' ),
						bindings	:
						{
							"{saveButton} click" : function()
							{
								this.inputWarning().hide();

								filterName = this.inputTitle().val();
								filterSitewide = this.inputSitewide().is(':checked') ? 1 : 0;

								if( filterName == '' )
								{
									this.inputWarning().show();
									return;
								}

								EasySocial.ajax( 'site/controllers/search/addFilter',
								{
									"title"		: filterName,
									"sitewide"	: filterSitewide,
									"data"		: data,
								})
								.done(function( html, msg )
								{
									var item = $.buildHTML( html );
									self.sidebarController.addFilterItem( item );

									// show message
									EasySocial.dialog( msg );

									// auto close the dialog
									setTimeout(function() {
										EasySocial.dialog().close();
									}, 2000);

								});
							}
						}
					});
				},

				"{addCriteria} click" : function( el , event )
				{
					// Duplicate the template
					var tmpl	= self.criteriaTemplate().clone();

					// Remove any unecessary attributes for the template
					$( tmpl )
						.removeClass( 'hide' )
						.removeAttr( 'data-adv-search-criteria-template' )
						.addController(
							EasySocial.Controller.Search.Advanced.Criteria ,
							{
								"{parent}" : self
							}
						);

					// Append the template to the list now.
					self.list().append( tmpl );
				}
			}
		});

		EasySocial.Controller(
		'Search.Advanced.Sidebar',
		{
			defaultOptions:
			{
				"{item}" : "[data-sidebar-item]",

				// loading gif
				view :
				{
					loadingContent 	: "site/loading/small"
				}
			}
		},
		function( self ){
			return {

				init : function()
				{
					// Implement each feed links.
					self.item().implement( EasySocial.Controller.Search.Advanced.Sidebar.Item ,
					{
						"{parent}"		: self,
						"{root}"		: self.parent
					});
				},


				"addFilterItem" : function( item )
				{

					//item.find('[data-sidebar-item]').implement( EasySocial.Controller.Search.Advanced.Sidebar.Item ,
					item.implement( EasySocial.Controller.Search.Advanced.Sidebar.Item ,
					{
						"{parent}"		: self,
						"{root}"		: self.parent
					});

					item.appendTo( $('[data-advsearch-sidebar-ul]') );

				},


			} //return
		});

		EasySocial.Controller(
		'Search.Advanced.Sidebar.Item',
		{
			defaultOptions:
			{
				"{filterDeleteBtn}" : "[data-search-filter-delete]",
				"{filterItem}" 		: "[data-search-filter-item]",

				"{item}"			: "[data-adv-search-item]",


				// loading gif
				view :
				{
					loadingContent 	: "site/loading/small"
				}
			}
		},
		function( self ){
			return {

				init : function()
				{

				},

				"{filterItem} click" : function( el , event )
				{
					// Prevent event bubbling
					event.preventDefault();

					$( '[data-sidebar-item]' ).removeClass( 'active loading' );
					self.element.addClass( 'active');

					var id		= self.element.data( 'id' ),
						url 	= self.element.data( 'url' ),
						title 	= self.element.data( 'title' );

					// Update browser's URL
					$( el ).route();

					// Notify the dashboard that it's starting to fetch the contents.
					self.root.content().html("");
					self.root.updatingContents();

					self.element.addClass( 'loading' );

					EasySocial.ajax( 'site/controllers/search/getFilterResults' ,
					{
						"fid"	: id,
					})
					.done(function( contents )
					{
						var contents = $.buildHTML(contents);

						contents
							.find( self.item.selector )
							.addController( "EasySocial.Controller.Search.Advanced.Criteria",
								{
									"{parent}" : self.root
								});

						self.root.updateContents( contents );

					})
					.fail( function( messageObj )
					{
						return messageObj;
					})
					.always(function()
					{
						self.element.removeClass( 'loading' );
					});


				}


			} //return
		});

		module.resolve();

	});

});

EasySocial.module( 'site/search/advanced.list.group' , function($){

	var module	= this;

	EasySocial.require()
	.view( 'site/loading/small', 'site/search/loadbutton' )
	.script('site/groups/groups')
	.language( 'COM_EASYSOCIAL_SEARCH_LOAD_MORE_ITEMS' )
	.done(function($){


		EasySocial.Controller(
			'Search.Advanced.List.Group',
			{
				defaultOptions:
				{
					// Elements
					"{item}" : "[data-search-item]",
					"{pagination}" : "[data-search-pagination]",
					"{loadmorebutton}" : "[data-search-loadmore-button]",

					"{searchForm}" : "[data-adv-search-form]",

					// loading gif
					view :
					{
						loadingContent 	: "site/loading/small",
						loadmoreContent : "site/search/loadbutton"
					}

				}
			},
			function( self ){
				return {

					init : function()
					{
						self.item().implement(EasySocial.Controller.Groups.Browser.Item);

						self.on("scroll.advsearch", window, $._.debounce(function(){

							if (self.loading) return;

							if (self.pagination().visible()) {

								self.loadMore();
							}

						}, 250));
					},

					"{loadmorebutton} click": function(){
						self.loadMore();
					},


					loadMore: function() {

						var next_limit 	= self.pagination().data('last-limit');
						var data 		= self.searchForm().serializeJSON();

						// console.log( next_limit );
						// console.log( data );


						if( next_limit == '-1')
						{
							self.loadmorebutton().hide();
							return;
						}

						self.loading = true;

						EasySocial.ajax( 'site/controllers/search/loadmore' ,
						{
							"data" : data,
							"nextlimit" : next_limit
						},
						{
							beforeSend: function()
							{
								self.pagination().html( self.view.loadingContent() );
							}
						})
						.done(function( contents, next_limit )
						{
							// update next last-update
							self.pagination().data('last-limit', next_limit );

							// append stream into list.
							self.pagination().before( contents );

							//re-implement controller on new items
							self.item().implement(EasySocial.Controller.Groups.Browser.Item);

							if ( next_limit == '-1') {
								self.pagination().html('');
							} else {
								//append the anchor link.
								self.pagination().html( self.view.loadmoreContent() );

							}


						})
						.fail( function( messageObj ){

							return messageObj;
						})
						.always(function(){

							self.loading = false;

						});
					}




				}
			});

		module.resolve();
	});

});

EasySocial.module( 'site/search/advanced.list' , function($){

	var module	= this;

	EasySocial.require()
	.view( 'site/loading/small', 'site/search/loadbutton' )
	.script('site/search/item')
	.language( 'COM_EASYSOCIAL_SEARCH_LOAD_MORE_ITEMS' )
	.done(function($){


		EasySocial.Controller(
			'Search.Advanced.List',
			{
				defaultOptions:
				{
					// Elements
					"{item}"			: "[data-search-item]",
					"{pagination}"  	: "[data-search-pagination]",
					"{loadmorebutton}" 	: "[data-search-loadmore-button]",

					"{searchForm}" 		: "[data-adv-search-form]",

					// loading gif
					view :
					{
						loadingContent 	: "site/loading/small",
						loadmoreContent : "site/search/loadbutton"
					}

				}
			},
			function( self ){
				return {

					init : function()
					{
						self.item().implement( EasySocial.Controller.Search.Item );

						self.on("scroll.advsearch", window, $._.debounce(function(){

							if (self.loading) return;

							if (self.pagination().visible()) {

								self.loadMore();
							}

						}, 250));
					},

					"{loadmorebutton} click": function(){
						self.loadMore();
					},


					loadMore: function() {

						var next_limit 	= self.pagination().data('last-limit');
						var data 		= self.searchForm().serializeJSON();

						// console.log( next_limit );
						// console.log( data );


						if( next_limit == '-1')
						{
							self.loadmorebutton().hide();
							return;
						}

						self.loading = true;

						EasySocial.ajax( 'site/controllers/search/loadmore' ,
						{
							"data" : data,
							"nextlimit" : next_limit
						},
						{
							beforeSend: function()
							{
								self.pagination().html( self.view.loadingContent() );
							}
						})
						.done(function( contents, next_limit )
						{
							// update next last-update
							self.pagination().data('last-limit', next_limit );

							// append stream into list.
							self.pagination().before( contents );

							//re-implement controller on new items
							self.item().implement( EasySocial.Controller.Search.Item );

							if ( next_limit == '-1') {
								self.pagination().html('');
							} else {
								//append the anchor link.
								self.pagination().html( self.view.loadmoreContent() );

							}


						})
						.fail( function( messageObj ){

							return messageObj;
						})
						.always(function(){

							self.loading = false;

						});
					}




				}
			});

		module.resolve();
	});

});

EasySocial.module( 'site/search/item' , function($){

	var module	= this;

	EasySocial.require()
	.view(
		'site/loading/small'
	)
	.language(
		'COM_EASYSOCIAL_FRIENDS_REQUEST_SENT_NOTICE'
	)
	.done(function($){

		EasySocial.Controller(
			'Search.Item',
			{
				defaultOptions:
				{
					// Elements
					"{toggle}"		: "[data-activity-toggle]",
					"{deleteBtn}"	: "[data-activity-delete]",

					"{addFriendButton}" : "[data-search-friend-button]",
					"{pendingFriendButton}" : "[data-search-friend-pending-button]",
					// Dropdown
					"{dropdown}"		: "[data-profileFriends-dropdown]",

					view :
					{
						loader 			: "site/loading/small"
					}
				}
			},
			function( self ){
				return {

					init : function()
					{
						// Implement sidebar controller.
						friendid 		: null
					},

					"{pendingFriendButton} click" : function( el )
					{
						self.dropdown().html(
							$.language( 'COM_EASYSOCIAL_FRIENDS_REQUEST_SENT_NOTICE' )
						);
					},

					/**
					 * Triggered when the add friend button is clicked
					 */
					"{addFriendButton} click" : function( el )
					{
						var id = self.element.data('friend-uid');

						$( el ).addClass( 'btn-loading' );

						// Implement controller on add friend.
						EasySocial.ajax( 'site/controllers/friends/request' ,
						{
							"viewCallback"	: "usersRequest",
							"id"	: id
						})
						.done( function( button )
						{
							// After the request is complete, set the correct friend id.
							// self.options.friendid 	= friendId;

							$( el ).replaceWith( button );

							self.dropdown().remove();

							// Remove the loading state from the button
							$( el ).removeClass( 'btn-loading' );

						})
						.fail(function( message )
						{
							EasySocial.dialog(
							{
								content 	: EasySocial.ajax( 'site/views/friends/exceeded' )
							});
							
							self.dropdown().html( message );
						});

					}

				}
			});

		module.resolve();
	});

});

EasySocial.module( 'site/search/dating' , function($){
	var module	= this;

	EasySocial.require()
	.script( 'site/search/map' )
	.done( function(){

		EasySocial.Controller(
		'Search.Dating',
		{
			defaultOptions:
			{
				"{itemCriteria}" 	: "[data-itemCriteria]",
				"{itemDataKey}" 	: "[data-itemDataKey]",
				"{itemOperator}" 	: "[data-itemOperator]",
				"{itemCondition}" 	: "[data-itemCondition]",

				"{dateStart}" 		: "[data-start]",
				"{dateEnd}" 		: "[data-end]",
				"{dataCondition}" 	: "[data-condition]",

				"{dataGender}" : "[data-gender-radio]",

                '{frmDistance}' : '[data-distance]',
                '{frmAddress}' : '[data-address]',
                '{frmLatitude}' : '[data-latitude]',
                '{frmLongitude}' : '[data-longitude]',

				"{locationLabel}" : "[data-location-label]",
				"{textField}" : "[data-location-textfield]"
			}
		},
		function( self ){
			return {

				init : function()
				{
					self.element.addController(EasySocial.Controller.Search.Map);

					if (self.frmAddress().val() != '') {
                    	self.textField().val(self.frmAddress().val());
					}
				},

				"{frmDistance} change" : function() {
                    var distance = self.frmDistance().val();
                    var address = self.frmAddress().val();
                    var lat = self.frmLatitude().val();
                    var lng = self.frmLongitude().val();

                    var computedVal = distance + '|' + lat + '|' + lng + '|' + address;
                    self.dataCondition().val(computedVal);
				},

				"{dataGender} click" : function(el) {
					self.dataCondition().val( el.val() );
				},

				"{dateStart} change" : function() {
					start 	= self.dateStart().val();
					end 	= self.dateEnd().val();

					var data = start;

					if( end.length > 0 )
					{
						data = data + '|' + end;
					}

					// update value
					self.dataCondition().val( data );
				},

				"{dateEnd} change" : function() {
					start 	= self.dateStart().val();
					end 	= self.dateEnd().val();

					var data = end;

					if( start.length > 0 )
					{
						data = start + '|' + data;
					}

					// update value
					self.dataCondition().val( data );
				}


			} //return
		});

		module.resolve();

	});

});

EasySocial.module( 'site/search/list' , function($){

	var module	= this;

	EasySocial.require()
	.view( 'site/loading/small', 'site/search/loadbutton' )
	.script('site/search/item')
	.language( 'COM_EASYSOCIAL_SEARCH_LOAD_MORE_ITEMS' )
	.done(function($){


		// TODO: Move this away from here
		// $.fn.visible = function(partial){

		// 	var $t	= $(this),
		// 		$w	= $(window),
		// 	viewTop	= $w.scrollTop(),
		// 	viewBottom	= viewTop + $w.height(),
		// 	_top		= $t.offset().top,
		// 	_bottom		= _top + $t.height(),
		// 	compareTop	= partial === true ? _bottom : _top,
		// 	compareBottom	= partial === true ? _top : _bottom;

		// 	return ((compareBottom <= viewBottom) && (compareTop >= viewTop));
	 //    };


		EasySocial.Controller(
			'Search.List',
			{
				defaultOptions:
				{
					// Elements
					"{item}"	: "[data-search-item]",


					"{pagination}"  : "[data-search-pagination]",
					"{loadmorebutton}" : "[data-search-loadmore-button]",

					// loading gif
					view :
					{
						loadingContent 	: "site/loading/small",
						loadmoreContent : "site/search/loadbutton"
					}

				}
			},
			function( self ){
				return {

					init : function()
					{
						self.item().implement( EasySocial.Controller.Search.Item );

						self.on("scroll.search", window, $._.debounce(function(){

							if (self.loading) return;

							if (self.pagination().visible()) {

								self.loadMore();
							}

						}, 250));
					},

					"{loadmorebutton} click": function(){
						self.loadMore();
					},


					loadMore: function() {

						var query 		= $("[data-search-query]").val();
						var type 		= $("[data-sidebar-menu].active").data( 'type' );
						var next_limit 	= self.pagination().data('last-limit');
						var last_type 	= self.pagination().data('last-type');

						var filters = [];
						$("[data-search-filtertypes]:checked").each( function(idx, ele) {
							filters.push($(ele).val());
						});

						if( next_limit == '-1')
						{
							self.loadmorebutton().hide();
							return;
						}

						self.loading = true;

						EasySocial.ajax( 'site/controllers/search/getItems' ,
						{
							"next_limit" : next_limit,
							"last_type" : last_type,
							"type" : type,
							"q" : query,
							"loadmore" : '1',
							'filtertypes' : filters
						},
						{
							beforeSend: function()
							{
								self.pagination().html( self.view.loadingContent() );
							}
						})
						.done(function( contents, next_type, next_limit )
						{
							// update next last-update and last-type
							self.pagination().data('last-limit', next_limit );
							self.pagination().data('last-type', next_type );


							// append stream into list.
							self.pagination().before( contents );

							//re-implement controller on new items
							self.item().implement( EasySocial.Controller.Search.Item );

							if ( next_limit == '-1') {
								self.pagination().html('');
							} else {
								//append the anchor link.
								self.pagination().html( self.view.loadmoreContent() );
							}


						})
						.fail( function( messageObj ){

							return messageObj;
						})
						.always(function(){

							self.loading = false;
							//self.pagination().html('');
						});
					}




				}
			});

		module.resolve();
	});

});

EasySocial.module( 'site/search/search' , function($){

	var module	= this;

	EasySocial.require()
	.library( 'history' )
	.script( 'site/search/sidebar', 'site/profile/friends' )
	.view( 'site/loading/small' )
	.done(function($){

		EasySocial.Controller(
		'Search',
		{
			defaultOptions:
			{
				// Properties
				items		: null,

				// Elements
				"{container}"	: "[data-search]",

				"{contentTitle}": "[data-search-content-title]",
				"{content}"		: "[data-search-content]",
				"{sidebar}"		: "[data-search-sidebar]",


				"{sidebarItem}"	: "[data-sidebar-item]",


				view :
				{
					loadingContent 	: "site/loading/small"
				}
			}
		},
		function( self ){
			return {

				init : function()
				{
					// Implement sidebar controller.
					self.sidebar().implement( EasySocial.Controller.Search.Sidebar ,
					{
						"{parent}"	: self
					});

					self.sidebarItem().implement( EasySocial.Controller.Search.Sidebar.Item ,
					{
						"{parent}"	: self
					});
				},


				/**
				 * Add a loading icon on the content layer.
				 */
				updatingContents: function()
				{
					self.content().html( self.view.loadingContent() );
				},

				updateContent: function( content )
				{
					self.content().html( content );
				}

			}
		});

		module.resolve();
	});

});

EasySocial.module( 'site/search/sidebar' , function($){

	var module	= this;

	EasySocial.require()
	.done(function($){

		EasySocial.Controller(
			'Search.Sidebar',
			{
				defaultOptions:
				{
					"{menuItem}"	: "[data-sidebar-menu]"
				}
			},
			function( self ){
				return {

					init: function()
					{
					},

					"{menuItem} click" : function( el , event )
					{
						// Remove all active class.
						self.menuItem().removeClass( 'active' );

						// Add active class on this item.
						$( el ).addClass( 'active' );
					}
				}
			});


		EasySocial.Controller(
			'Search.Sidebar.Item',
			{
				defaultOptions:
				{
				}
			},
			function( self ){
				return {

					init: function()
					{
					},

					"{self} click" : function( el , event )
					{

						var type 	= self.element.data( 'type' ),
							url 	= self.element.data( 'url' );

						var query = $("[data-search-query]").val();
						var filters = [];

						// clear all filters
						$("[data-search-filtertypes]").each( function(idx, ele) {
							$(ele).prop('checked', false);
						});

						if (type != "") {
							filters.push(type);

							$("[data-search-filtertypes]").each( function(idx, ele) {
								if ($(ele).val() == type) {
									$(ele).prop('checked', true);
								}
							});
						}

						// If this is an embedded layout, we need to play around with the push state.
						History.pushState( {state:1} , '' , url );

						self.parent.updatingContents();

						// console.log( query );
						//return;

						//ajax call here.
						EasySocial.ajax( 'site/controllers/search/getItems',
						{
							"type"		: type,
							"q" 		: query,
							"filtertypes" : filters
						})
						.done(function( html )
						{
							self.parent.updateContent( html );
						})
						.fail(function( message ){
							console.log( message );
						});

						self.parent.updateContent();
					}
				}
			});

		module.resolve();
	});

});

EasySocial.module("site/search/toolbar", function($){

	var module	= this;

	EasySocial.Controller("Search.Toolbar",
	{
		defaultOptions: {
			showadvancedlink : true,
			"{textfield}": "[data-nav-search-input]"
		}
	},
	function(self, opts, base) { return {

		init : function() {
			self.options.showadvancedlink = self.element.data('showadvancedlink') == 0 ? 0 : 1 ;

			self.element.siblings('[data-nav-search-filter]').addController(EasySocial.Controller.Search.Toolbar.Filter, {
				"{parent}": self
			});

		},

		cache: {},

		showPopBox: false,

		rePopBox: null,

		search: $.debounce(function(keyword) {

			if (self.loading) {
				return;
			}

			if (!keyword || !(keyword=$.trim(keyword)) || keyword.length <= 2) {
				return;
			}

			var textfield = self.textfield();

			var cacheIndex = keyword;

			// Cheap fix
			textfield.popbox("widget").hide();
			textfield.popbox("widget").destroy();

			var filters = [];
			$("[data-search-filtertypes]:checked").each( function(idx, ele) {

				filterValue = $(ele).val();
				filters.push(filterValue);

				// valueInteger = parseInt(filterValue);
				// cacheIndex += valueInteger.toString();
			});

			var task =
				// Take from cache if keyword has been searched before
				// self.cache[cacheIndex] ||
				// Else make and ajax call
				EasySocial.ajax("site/controllers/search/getItems", {
					"q": keyword,
					"mini": "1",
					"showadvancedlink": self.options.showadvancedlink,
					"filtertypes" : filters
				})
				.done(function(){
					// Cache this search result
					// self.cache[cacheIndex] = task;
				});

			task
				.fail(function(message) {
					console.log(message);
				})
				.always(function(){
					self.loading = false;
				});

			self.hide();

			base.popbox({
				content: task,
				id: "fd",
				component: "es",
				type: "search",
				toggle: "click",
				cache: false,
				offset: 0
			});

			var popbox = base.popbox("widget");

			popbox.show();
			popbox.keyword = keyword;

		}, 250),


		reSearch: function(keyword) {

			if (self.loading) {
				return;
			}

			if (!keyword || !(keyword=$.trim(keyword)) || keyword.length <= 2) {
				return;
			}

			var textfield = self.textfield();

			var cacheIndex = keyword;

			// Cheap fix
			self.textfield().popbox("widget").hide();
			self.textfield().popbox("widget").destroy();

			var filters = [];
			$("[data-search-filtertypes]:checked").each( function(idx, ele) {

				filterValue = $(ele).val();
				filters.push(filterValue);

				// valueInteger = parseInt(filterValue);
				// cacheIndex += valueInteger.toString();
			});

			var task =
				// Else make and ajax call
				EasySocial.ajax("site/controllers/search/getItems", {
					"q": keyword,
					"mini": "1",
					"showadvancedlink": self.options.showadvancedlink,
					"filtertypes" : filters
				})
				.done(function(){
				});

			task
				.fail(function(message) {
					console.log(message);
				})
				.always(function(){
					self.loading = false;
					self.showPopBox = true;
				});

			self.hide();

			base.popbox({
				content: task,
				id: "fd",
				component: "es",
				type: "search",
				toggle: "click",
				cache: false,
				offset: 0
			});

		},

		hide: function() {
			var popbox = base.popbox("widget");

			if (popbox) {
				popbox.hide();
			}
		},

		show: function() {
			var popbox = base.popbox("widget");
			popbox.show();
		},

		"{textfield} keydown": function() {
			self.hide();
		},

		"{textfield} keyup": function(textfield, event) {

			// 27 == escape
			if (event.which===27) {
				return;
			}

			var keyword = textfield.val();
			self.search(keyword);
		},

		"{self} popboxLoading": function(el, event, popbox) {

			popbox.loader.width(base.width());

			popbox.loader
				.position(popbox.position);

			base.addClass("is-active");
		},

		"{self} popboxActivate": function(el, event, popbox) {

			popbox.tooltip.width(base.width());

			popbox.tooltip
				.position(popbox.position);

			base.addClass("is-active");
		},

		"{self} popboxDeactivate": function(el, event, popbox) {

			base.removeClass("is-active");
		}

	}});



	EasySocial.Controller("Search.Toolbar.Filter",
	{
		defaultOptions: {
			"{filterButton}": "[data-filter-button]",

			"{filterDropdown}" : ".dropdown-menu",
			"{filterDropdownInput}" : ".dropdown-menu input",
			"{filterDropdownLabel}" : ".dropdown-menu label",

			"{filterBox}" : "[data-search-filtertypes]",
			"{selectAllBtn}" : "[data-filter-selectall]",
			"{deselectAllBtn}" : "[data-filter-deselectall]"

		}
	},
	function(self, opts, base) { return {
		init : function() {
			// console.log('toolbar.filter.init');
		},

		"{self} blur": function(ele, event) {

			console.log('test');

            if (self.parent.showPopBox) {
                self.parent.show();
            }
		},

		"{selectAllBtn} click": function(ele, ev) {
			// disable click event
			ev.stopPropagation();

			self.filterBox().prop("checked", true);
		},

		"{deselectAllBtn} click": function(ele, ev) {
			// disable click event
			ev.stopPropagation();

			self.filterBox().prop("checked", false);
		},

		// "{filterBox} click": function(ele, ev) {
		// 	ev.stopPropagation();

		// 	if ($(ele).is(":checked")) {
		// 		$(ele).prop("checked", false);
		// 	} else {
		// 		$(ele).prop("checked", true);
		// 	}
		// },

        "{filterButton} click": function(ele, event) {

            // When filter button is clicked, we should hide the popbox
            if (self.element.hasClass('open')) {
                // we are doing a close action here.
                // if (self.parent.showPopBox) {
                //     self.parent.show();
                // }
                // self.parent.hide();

            	var keyword = self.parent.textfield().val();
                self.parent.search(keyword);
            } else {
                self.parent.hide();
            }
        },

        "{filterDropdownInput} click": function (el, ev) {
            ev.stopPropagation();

            // var keyword = self.parent.textfield().val();

            // console.log(keyword, self.parent.textfield());

            // self.parent.reSearch(keyword);
        },

        "{filterDropdownLabel} click": function (el, ev) {
            ev.stopPropagation();
        }

	}});

	module.resolve();

});

EasySocial.module('site/stream/item', function() {

	var module	= this;

	EasySocial.require()
	.library("mentions", "placeholder", "dialog")
	.view(
		"site/friends/suggest.item",
		"site/friends/suggest.hint.search",
		"site/friends/suggest.hint.empty",
		"site/hashtags/suggest.item",
		"site/hashtags/suggest.hint.search",
		"site/hashtags/suggest.hint.empty"
	)
	.done(function($){

		EasySocial.Controller('Stream.Item', {
			defaultOptions: {
				view: {
					suggestItem: "site/friends/suggest.item",
					tagSuggestItem: "site/hashtags/suggest.item"
				},

				// Properties
				id: "",
				context: "",

				// Elements
				"{deleteFeed}"	: "[data-stream-delete]",
				"{editStream}"	: "[data-stream-edit]",
				"{updateStream}"	: "[data-stream-edit-update]",
				"{cancelEditStream}" : "[data-stream-edit-cancel]",

				"{editPoll}"	: "[data-stream-polls-edit]",
				"{cancelEditPoll}"	: "[data-stream-polls-edit-cancel]",
				"{updatePoll}"	: "[data-stream-polls-edit-update]",


				"{publishItem}": "[data-stream-publish]",
				"{addBookmark}": "[data-stream-bookmark-add]",
				"{removeBookmark}": "[data-stream-bookmark-remove]",

				"{addSticky}": "[data-stream-sticky-add]",
				"{removeSticky}": "[data-stream-sticky-remove]",

				"{hideLink}"	: "[data-stream-hide]",
				"{unHideLink}"	: "[data-stream-show]",

				"{hideAppLink}"	: "[data-stream-hide-app]",
				"{unHideAppLink}"	: "[data-stream-show-app]",

				"{hideActorLink}" 	: "[data-stream-hide-actor]",
				"{unHideActorLink}" : "[data-stream-show-actor]",

				"{hideNotice}"	: "[data-stream-hide-notice]",

				"{actions}"		: "[data-streamItem-actions]",
				"{contents}"	: "[data-streamItem-contents]",


				"{streamContent}"	: "[data-stream-content]",
				"{streamEditor}"	: "[data-stream-editor]",

				"{streamData}"		: "[data-stream-item]",

				"{likes}"			: "[data-likes-action]",
				"{counterBar}"		: "[data-stream-counter]",
				"{likeContent}" 	: "[data-likes-content]",
				"{repostContent}" 	: "[data-repost-content]",

				"{share}"			: "[data-repost-action]",

				// Translations
				"{translateLink}": "[data-stream-translate]",
				"{translateLoader}": "[data-stream-translate-loader]",

				// for stream comment
				"{streamCommentLink}" 	: "[data-stream-action-comments]",
				"{streamCommentBlock}" 	: "[data-comments]"
			}
		}, function(self, opts, base) {

			return {

				init: function() {
					// Set the stream's unique id.
					opts.id = base.data('id');
					opts.context = base.data('context');
					opts.ishidden = base.data('ishidden');
					opts.actor = base.data('actor');
				},

				plugins: {},

				"{translateLink} click": function(translateLink, event) {

					// Get the stream content
					var contents = self.streamContent().html();

					// Add a loading indicator on the translation link
					self.element.addClass('is-translating');

					EasySocial.ajax('site/controllers/stream/translate', {
						"contents": contents
					})
					.done(function(translated) {						
						self.streamContent().html(translated);
					})
					.always(function() {
						self.element.removeClass('is-translating');
						self.element.addClass('is-translated');
					});
				},

				"{addBookmark} click": function(el, event) {
					// Add the bookmark class
					self.element.addClass('is-bookmarked');

					EasySocial.ajax('site/controllers/stream/bookmark', {
						"id" : self.options.id
					})
					.done(function() {
						// Do nothing once the item is already bookmarked
					})
					.fail(function(message) {
						// If this is failed, we need to display the message object
						self.element.removeClass('is-bookmarked');

						self.setMessage(message);
					});
				},

				"{removeBookmark} click": function(el, event) {
					var filterType = window.streamFilter || false;

					// Remove the bookmarked class
					if (filterType != 'bookmarks') {
						self.element.removeClass('is-bookmarked');
					}

					EasySocial.ajax('site/controllers/stream/removeBookmark', {
						"id": self.options.id
					}).done(function(html) {
						if (filterType == 'bookmarks') {
							self.element.html(html);
						}
					});
				},


				"{addSticky} click": function(el, event) {
					EasySocial.ajax('site/controllers/stream/addSticky', {
						"id" : self.options.id
					})
					.done(function() {
						// add sticky icon
						self.element.addClass('is-sticky');
					})
					.fail(function(obj) {

						// If this is failed, we need to display the message object
						EasySocial.dialog({
							content: obj.message
						});

					});
				},

				"{removeSticky} click": function(el, event) {
					var filterType = window.streamFilter || false;

					if (filterType != 'sticky') {
						// Remove the bookmarked class
						self.element.removeClass('is-sticky');
					}

					EasySocial.ajax('site/controllers/stream/removeSticky', {
						"id": self.options.id
					})
					.done(function(html){

						if (filterType == 'sticky') {
							self.element.html(html);
						}
					});
				},

				"{publishItem} click": function(el, event) {
					var id = opts.id;

					EasySocial.ajax('site/controllers/stream/publish', {
						"id": id
					}).done(function() {
						// When the stream is published, we want to hide the item
						base.switchClass('is-published');
					});
				},

				"{likes} onLiked": function(el, event, data) {

					//need to make the data-stream-counter visible
					self.counterBar().removeClass('hide');

				},

				"{likes} onUnliked": function(el, event, data) {

					var isLikeHide 		= self.likeContent().hasClass('hide');
					var isRepostHide 	= self.repostContent().hasClass('hide');

					if( isLikeHide && isRepostHide )
					{
						self.counterBar().addClass( 'hide' );
					}
				},

				"{share} create": function(el, event, itemHTML) {

					//need to make the data-stream-counter visible
					self.counterBar().removeClass( 'hide' );

				},


				"{streamCommentLink} click" : function()
				{
					// self.streamCommentBlock().toggle();
					self.streamCommentBlock().trigger('show');
				},

				/**
				 * Executes when a stream action is clicked.
				 */
				"{actions} click" : function( el , event )
				{
					// Remove active class on all action links
					self.actions().removeClass( 'active' );

					// Add active class on itself.
					$( el ).addClass( 'active' );
				},

				/**
				 * Delete a stream item
				 */
				 "{deleteFeed} click" : function() {
					var uid = self.options.id;

					EasySocial.dialog({
						content: EasySocial.ajax('site/views/stream/confirmDelete'),
						bindings: {

							"{deleteButton} click" : function() {
								EasySocial.ajax( 'site/controllers/stream/delete',
								{
									"id"		: uid,
								})
								.done(function( html )
								{

									EasySocial.dialog({
										content: html
									});

									self.element.fadeOut();

									// Close dialog box after 2 seconds
									setTimeout(function() {
										EasySocial.dialog().close();
									}, 2000);
								})
								.fail(function( message ){

									EasySocial.dialog({
										content: message
									});


								});

							}
						}
					});

				 },

				"{editPoll} click" : function()
				{
					var uid = self.options.id,
						element = 'stream';

					EasySocial.ajax('site/views/polls/edit',
					{
						"uid": uid,
						"element": element,
						"source": 'stream'
					})
					.done(function(html)
					{
						// Add editing state
						self.element.addClass('is-editing');

						self.streamContent().hide();

						self.streamEditor().html(html);

					});
				},

				"{cancelEditPoll} click" : function()
				{
					self.element.removeClass('is-editing');

					// Remove the contents
					self.streamEditor().html('');

					// Show the contents
					self.streamContent().show();
				},

				"{updatePoll} click": function()
				{
					var pollController = self.element.find('[data-polls-edit]').controller('EasySocial.Controller.Polls');

					var valid = pollController.validateForm();

                    if (! valid) {
                        return task.reject('Error validating polls inputs. Please make sure all the required fields are filled in.');
                    }

					var data = pollController.toData();

					EasySocial.ajax('site/controllers/polls/update', data)
					.done(function(html, id)
					{
						self.streamContent().html(html);

						self.cancelEditPoll().click();
					});
				},


				"{cancelEditStream} click" : function()
				{
					self.element.removeClass('is-editing');

					// Remove the contents
					self.streamEditor().html('');

					// Show the contents
					self.streamContent().show();
				},

				"{editStream} click" : function()
				{
					var id = self.options.id;

					EasySocial.ajax('site/views/stream/edit',
					{
						"id"	: id
					})
					.done(function(html)
					{
						// Add editing state
						self.element.addClass('is-editing');

						self.streamContent().hide();

						self.streamEditor().html(html);

						var textbox = self.streamEditor().find('[data-story-textbox]');
						var mentions = textbox.controller("mentions");

						if (mentions) {
							mentions.cloneLayout();
							return;
						}

						textbox
							.mentions({
								triggers: {
								    "@": {
										type: "entity",
										wrap: false,
										stop: "",
										allowSpace: true,
										finalize: true,
										query: {
											loadingHint: true,
											searchHint: $.View("easysocial/site/friends/suggest.hint.search"),
											emptyHint: $.View("easysocial/site/friends/suggest.hint.empty"),
											data: function(keyword) {

												var task = $.Deferred();

												EasySocial.ajax("site/controllers/friends/suggest", {search: keyword})
													.done(function(items){

														if (!$.isArray(items)) task.reject();

														var items = $.map(items, function(item){
															item.title = item.screenName;
															item.type = "user";
															item.menuHtml = self.view.suggestItem(true, {
																item: item,
																name: "uid[]"
															});
															return item;
														});

														task.resolve(items);
													})
													.fail(task.reject);

												return task;
											},
											use: function(item) {
												return item.type + ":" + item.id;
											}
									    }
									},
									"#": {
									    type: "hashtag",
									    wrap: true,
									    stop: " #",
									    allowSpace: false,
										query: {
											loadingHint: true,
											searchHint: $.View("easysocial/site/hashtags/suggest.hint.search"),
											emptyHint: $.View("easysocial/site/hashtags/suggest.hint.empty"),
											data: function(keyword) {

												var task = $.Deferred();

												EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
													.done(function(items){

														if (!$.isArray(items)) task.reject();

														var items = $.map(items, function(item){
															item.title = "#" + item.title;
															item.type = "hashtag";
															item.menuHtml = self.view.tagSuggestItem(true, {
																item: item,
																name: "uid[]"
															});
															return item;
														});

														task.resolve(items);
													})
													.fail(task.reject);

												return task;
											}
									    }
									}
								},
								plugin: {
									autocomplete: {
										id: "fd",
										component: "es",
										modifier: "es-story-mentions-autocomplete",
										sticky: true,
										shadow: true,
										position: {
											my: 'left top',
											at: 'left bottom',
											of: self.streamEditor().find('.es-story-text'),
											collision: 'none'
										}
									}
								}
							});
					});
				},

				"{updateStream} click" : function()
				{
					var textbox	 	= self.streamEditor().find('[data-story-textbox]'),
						textField	= self.streamEditor().find('[data-story-textfield]'),
						mentions 	= textbox.mentions("controller").toArray(),
						hashtags 	= self.element.data("storyHashtags"),
						hashtags 	= (hashtags) ? hashtags.split(",") : [],
						nohashtags	= false,
						data 		= {};

					if (hashtags.length > 0) {
						var tags =
							$.map(mentions, function(mention)
							{
								if (mention.type==="hashtag" && $.inArray(mention.value, hashtags) > -1)
								{
									return mention;
								}
							});

						nohashtags = tags.length < 1;
					}

					data.mentions = $.map(mentions, function(mention){
						if (mention.type==="hashtag" && $.isPlainObject(mention.value)) {
							mention.value = mention.value.title.slice(1);
						}
						return JSON.stringify(mention);
					});

					data.content 	= textField.val();
					data.id 		= self.options.id;

					EasySocial.ajax('site/controllers/story/update', data)
					.done(function(html, id)
					{
						self.streamContent().html(html);

						self.cancelEditStream().click();
					});

				},

				/**
				 * Hide's a stream item.
				 */
				"{hideLink} click" : function()
				{
					// Add hide class
					self.streamData().addClass( 'es-feed-loading' );

					EasySocial.ajax( 'site/controllers/stream/hide',
					{
						"id"		: self.options.id
					})
					.done(function( html )
					{
						self.streamData().removeClass( 'es-feed-loading' );

						self.streamData().hide();
						self.element.append( html );
					})
					.fail(function( message ){

					});
				},

				"{hideActorLink} click": function()
				{
					EasySocial.ajax( 'site/controllers/stream/hideactor',
					{
						"actor"		: self.options.actor
					})
					.done(function( html )
					{
						// hide itself.
						self.streamData().hide();

						// hide all feeds that belong to this actor.
						$( '.stream-actor-' + self.options.actor ).addClass('hide-stream');

						self.element.append( html );

					})
					.fail(function( message ){
						console.log( message );
					});
				},

				/**
				 * unHide's a stream item.
				 */
				"{unHideActorLink} click" : function()
				{

					EasySocial.ajax( 'site/controllers/stream/unhideactor',
					{
						"actor"		: self.options.actor
					})
					.done(function()
					{
						self.hideNotice().remove();

						//show itself.
						self.streamData().show();

						// show all the items with same context
						$( '.stream-actor-' + self.options.actor ).removeClass('hide-stream');

					})
					.fail(function( message ){
						console.log( message );
					});
				},

				/**
				 * Hide's a stream item.
				 */
				"{hideAppLink} click" : function()
				{
					// self.actions().trigger( "onHideStream" , self.options.id );
					EasySocial.ajax( 'site/controllers/stream/hideapp',
					{
						"context"		: self.options.context
					})
					.done(function( html )
					{
						// self.streamData().hide();
						// self.element.append( self.view.hiddenItem() );

						// hide itself.
						self.streamData().hide();

						// hide all feeds that belong to this context.
						$( '.stream-context-' + self.options.context ).addClass('hide-stream');

						self.element.append( html );

					})
					.fail(function( message ){
						console.log( message );
					});
				},

				/**
				 * unHide's a stream item.
				 */
				"{unHideLink} click" : function()
				{

					EasySocial.ajax( 'site/controllers/stream/unhide',
					{
						"id"		: self.options.id
					})
					.done(function()
					{
						self.hideNotice().remove();
						self.streamData().show();

					})
					.fail(function( message ){
						console.log( message );
					});
				},

				/**
				 * unHide's a stream item.
				 */
				"{unHideAppLink} click" : function()
				{

					EasySocial.ajax( 'site/controllers/stream/unhideapp',
					{
						"context"		: self.options.context
					})
					.done(function()
					{
						self.hideNotice().remove();

						//show itself.
						self.streamData().show();

						// show all the items with same context
						$( '.stream-context-' + self.options.context ).removeClass('hide-stream');

					})
					.fail(function( message ){
						console.log( message );
					});
				}

			}
		});

		module.resolve();
	});
});

EasySocial.module('site/stream/stream', function(){

	var module = this;

	EasySocial.require()
	.script('site/stream/item')
	.view('site/loading/small', 'site/stream/loadbutton')
	.language('COM_EASYSOCIAL_STREAM_LOAD_PREVIOUS_STREAM_ITEMS')
	.done(function($) {

		EasySocial.Controller('Stream', {

			defaultOptions: {
				// Check every 30 seconds by default.
				interval	: 30,

				// Properties
				checknew	: null,
				source      : null,
				sourceId    : null,
				autoload	: true,

				// Elements
				"{story}": "[data-story]",
				"{share}": "[data-repost-action]",
				"{list}": "[data-stream-list]",
				"{newNotiBar}": "[data-stream-notification-bar]",
				"{newNotiButton}": "[data-stream-notification-button]",

				"{item}": "[data-streamItem]",
				"{pagination}": "[data-stream-pagination]",
				"{paginationGuest}": "[data-stream-pagination-guest]",
				"{paginationCluster}": "[data-stream-pagination-cluster]",

				view: {
					loadingContent: "site/loading/small",
					loadmoreContent: "site/stream/loadbutton"
				}
			}
		}, function(self) {
			return {

				init : function()
				{
					// Implement stream item controller.
					self.item().addController(EasySocial.Controller.Stream.Item, {
						"{parent}": self
					});

					// Do not run updates checking when viewing single stream page.
					if (self.options.source != 'stream' && self.options.source != 'unity') {

						// Run the checking on new updates
						if( self.options.checknew == true ) {
							self.startMonitoring();
						}
					}

					if (self.options.autoload == true) {

						self.on("scroll.stream", window, $._.debounce(function(){

							if (self.loading) {
								return;
							}

							if (self.options.source == 'unity') {
								if (self.paginationGuest().visible()) {
									self.loadMoreGuest();
								}
							} else {
								iscluster = (self.options.source == 'dashboard' || self.options.source == 'profile') ? false : true;
								var pagination = (iscluster === true) ? self.paginationCluster() : self.pagination();

								if (pagination.visible()) {
									self.loadMore(iscluster);
								}
							}

						}, 250));

					}

					self.setLayout();
				},

				setLayout: function() {
					// Does nothing for now
				},

				"{window} resize": $.debounce(function() {

					self.setLayout();

				}, 500),

				"{story} create": function(el, event, itemHTML, ids ) {

					if (ids != '') {
						self.updateExcludeIds(ids);
					}

					// update the current date so that the next new stream notification will not include this item.
					self.updateCurrentDate();

					$.buildHTML(itemHTML)
						.prependTo(self.list())
						.addController("EasySocial.Controller.Stream.Item");

					self.list().children( "li.empty" ).remove();
				},

				"{share} create": function(el, event, itemHTML) {

					$.buildHTML(itemHTML)
						.prependTo(self.list())
						.addController("EasySocial.Controller.Stream.Item");

					self.list().children( "li.empty" ).remove();

					// update the current date so that the next new stream notification will not include this item.
					self.updateCurrentDate();
				},

				updateCurrentDate: function()
				{

					EasySocial.ajax( 'site/controllers/stream/getCurrentDate' ,
					{
					})
					.done(function( currentdate )
					{
						// console.log( currentdate );

						// update next start date
						self.element.data('currentdate', currentdate );

					})
					.fail( function( messageObj ){

					});

				},

				updateExcludeIds: function( id )
				{
					ids = self.element.data('excludeids' );
					newIds = '';

					if( ids != '' && ids != undefined )
					{
						newIds = ids + ',' + id;
					}
					else
					{
						newIds = id;
					}

					self.element.data('excludeids', newIds );
				},

				clearExcludeIds: function()
				{
					self.element.data('excludeids', '' );
				},

				/**
				 * Start running checks.
				 */
				startMonitoring: function()
				{
					if (self._destroyed) return self.stopMonitoring();

					var interval 	= self.options.interval * 1000;

					// Debug
					if( EasySocial.debug )
					{
						// console.info( 'Start monitoring new stream requests at interval of ' + self.options.interval + ' seconds.' );
					}

					self.options.state	= setTimeout( self.check , interval );
					// self.check();
				},

				/**
				 * Stop running any checks.
				 */
				stopMonitoring: function()
				{
					clearTimeout( self.options.state );
				},

				"{self} destroyed": function() {

					self.stopMonitoring();
				},

				/**
				 * Check for new updates
				 */
				check: function(){

					// Stop monitoring so that there wont be double calls at once.
					self.stopMonitoring();

					var interval 	= self.options.interval * 1000;

					var type 		= $("[data-dashboardSidebar-menu].active").data( 'type' );
					var id 			= $("[data-dashboardSidebar-menu].active").data( 'id' );
					var currentdate = self.element.data('currentdate');

					// console.log( currentdate );

					var excludeIds  = self.element.data('excludeids');

					// console.log( excludeIds );

					var pageNottiContent = $.trim( self.newNotiBar().html() );

					// debug code. do not remove!
					// console.log( 'currentdate: ' + currentdate, excludeIds );


					if( type == undefined && id == undefined )
					{
						if( self.options.source == 'profile' )
						{
							type = 'me';
							id 	 = self.options.sourceId;
						}
					}

					// console.log( type );
					// console.log( id );
					// console.log( excludeIds );


					EasySocial.ajax( 'site/controllers/stream/checkUpdates' ,
					{
						"type"		  : type,
						"id"		  : id,
						"currentdate" : currentdate,
						"exclude" 	  : excludeIds,
						"source"	  : self.options.source,
						"view"	  	  : self.options.source
					})
					.done( function( data, contents, nextupdate )
					{
						if (self._destroyed) {
							return self.stopMonitoring();
						}

						// update current date
						self.element.data('currentdate', nextupdate );

						if( data.length > 0 )
						{

							for( var i = 0 ; i < data.length; i++ )
							{
								item = data[ i ];

								if( item.cnt > 0 )
								{
									var key = '[data-stream-counter-' + item.type + ']';

									curCount = $( key ).text();
									newCount = ( curCount == '' ) ? item.cnt : parseInt( curCount, 10 ) + parseInt( item.cnt, 10 );

									$( key ).html( newCount );
									$( key ).parents('li').addClass('has-notice');
								}
							}

							contents 	= $.trim( contents );
							curContents = $.trim( self.newNotiBar().text() );

							// display the 'new feed bar' when there is new counter and this new feed bar is not display before.
							if( contents.length > 0 && curContents.length == 0 )
							{
								// append notification into list.
								self.newNotiBar().html( contents );
							}

						}

						// Continue monitoring.
						self.startMonitoring();
					});

				},

				"{newNotiButton} click" : function(el, event) {

					var type 		= $(el).data( 'type' );
					var id 			= $(el).data( 'uid' );
					var currentdate = $(el).data( 'since' );

					EasySocial.ajax( 'site/controllers/stream/getUpdates' ,
					{
						"type"		  : type,
						"id"		  : id,
						"currentdate" : currentdate,
						"source"	  : self.options.source,
						"view"	  	  : self.options.source
					})
					.done( function( contents, nextupdate, streamIds )
					{
						// clear the stream counter on the currect active filter bar.
						var key = '[data-stream-counter-';

						if( type == 'list' )
						{
							key = key + type + '-' + id;
						}
						else
						{
							key = key + type;
						}

						key = key + ']';

						$( key ).parents('li').removeClass('has-notice');

						// clear the counter value
						$( key ).html( '0' );

						// lets remove the stream items from the page if there is any
						$.each(streamIds, function(idx, uid) {
							self.item().where('id',uid).remove();
						});

						var itemCount = streamIds.length;

						// we need to update the pagination next limit start
						var pagination = '';

						if (self.paginationGuest().length > 0) {
							pagination = self.paginationGuest();
						} else {
							pagination = self.pagination();
						}

						var	startlimit = pagination.data("nextlimit");
						startlimit = startlimit + itemCount;

						pagination.data({
							nextlimit: startlimit
						});

						//clear the new feeds notification.
						self.newNotiBar().html('');

						// append stream into list.
						$.buildHTML(contents)
						 	.prependTo( self.list() )
						 	.addController("EasySocial.Controller.Stream.Item");

						 // lets clear the exclude ids
						 self.clearExcludeIds();

						 // update the next update date
						 self.element.data('currentdate', nextupdate );

					});

				},


				"{paginationGuest} click" : function() {

					self.loadMoreGuest();
				},

				loadMoreGuest: function() {


					var pagination = self.paginationGuest(),
						startlimit = pagination.data("nextlimit");

					var view = self.options.source;

					if (!startlimit) return;


					self.loading = true;

					pagination.html( self.view.loadingContent({content: ""}) );

					EasySocial.ajax(
						"site/controllers/stream/loadmoreGuest",
						{
							startlimit: startlimit,
							view: view
						})
						.done(function(contents, nextlimit ) {

							// Update start & end date
							pagination.data({
								nextlimit: nextlimit
							});

							var contents = $.buildHTML(contents);

								contents
									.insertBefore(pagination)
									.filter(self.item.selector)
									.addController("EasySocial.Controller.Stream.Item");

							// add support to kunena [tex] replacement.
							try { MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]); } catch( err ) {};

							//if (self.options.autoload || nextlimit=="") {
							if ( nextlimit=="" ) {
								pagination.html('');
							} else {
								//append the anchor link.
								// link = '<a class="btn btn-es-primary btn-stream-updates" href="javascript:void(0);"><i class="fa fa-repeat"></i> ' + $.language('COM_EASYSOCIAL_STREAM_LOAD_PREVIOUS_STREAM_ITEMS') + '</a>';
								// pagination.html( link );
								pagination.html( self.view.loadmoreContent() );

							}
						})
						.fail( function( messageObj ){

							return messageObj;
						})
						.always(function(){

							self.loading = false;
						});
				},

				"{paginationCluster} click" : function() {
					self.loadMore(true);
				},

				"{pagination} click" : function() {
					self.loadMore();
				},

				loadMore: function( iscluster ) {

					var currentSidebarMenu = $("[data-dashboardSidebar-menu].active"),
						type = currentSidebarMenu.data('type'),
						id   = currentSidebarMenu.data('id');
						tag  = currentSidebarMenu.data('tag');
						fid  = currentSidebarMenu.data('fid'); // this is the support group hashtag filtering.

					var pagination = (iscluster === true) ? self.paginationCluster() : self.pagination(),
						startlimit = pagination.data("nextlimit"),
						context		= pagination.data('context');

					var view = self.options.source;

					if (!startlimit) return;

					// if (profileid != undefined && !profileid) {
					// 	type = 'profile';
					// 	id 	 = profileid;
					// }

					// console.log(type, id);

					if (type == undefined && id == undefined) {
						if (self.options.source == 'profile') {
							type = 'me';
							id 	 = self.options.sourceId;
						}
					}

					self.loading = true;

					pagination.html( self.view.loadingContent({content: ""}) );

					EasySocial.ajax(
						"site/controllers/stream/loadmore",
						{
							"id"		: id,
							"type"		: type,
							"startlimit": startlimit,
							"view"		: view,
							"tag"		: tag,
							"filterId"	: fid,
							"context"	: context,
							"iscluster" : iscluster
						})
						.done(function(contents, nextlimit) {

							// Update start & end date
							pagination.data({
								nextlimit: nextlimit
							});

							var contents = $.buildHTML(contents);

								contents
									.insertBefore(pagination)
									.filter(self.item.selector)
									.addController("EasySocial.Controller.Stream.Item");

							self.setLayout();

							// add support to kunena [tex] replacement.
							try { MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]); } catch( err ) {};

							if ( nextlimit=="" ) {
								pagination.html('');
							} else {
								//append the anchor link.
								// link = '<a class="btn btn-es-primary btn-stream-updates" href="javascript:void(0);"><i class="fa fa-repeat"></i> ' + $.language('COM_EASYSOCIAL_STREAM_LOAD_PREVIOUS_STREAM_ITEMS') + '</a>';
								// pagination.html( link );
								pagination.html( self.view.loadmoreContent() );
							}
						})
						.fail( function( messageObj ){

							return messageObj;
						})
						.always(function(){

							self.loading = false;
						});
				}
			}
		});

		module.resolve();
	});
});

EasySocial.module( 'site/subscriptions/follow' , function(){

	var module	= this;

	EasySocial.require()
	.language(
		'COM_EASYSOCIAL_SUBSCRIPTION_INFO')
	.done(function($){

		EasySocial.Controller(
		'Follow',
		{
			defaultOptions:
			{

			}
		},
		function( self )
		{
			return {

				init: function()
				{
				},

				"{self} click" : function()
				{
					EasySocial.ajax( 'site/controllers/subscriptions/toggle' ,
					{
						"uid"	: self.element.data('id'),
						"type"	: self.element.data('type'),
						"notify": "1"
					})
					.done(function( content , label )
					{
						// update the label
						self.element.text( label );

						EasySocial.dialog({
							title: $.language('COM_EASYSOCIAL_SUBSCRIPTION_INFO'),
							content: content
						});

					})
					.fail( function( message ){
						self.setMessage( message, 'error' );
					});

				}
			}
		});

		module.resolve();
	});
});

EasySocial.module('site/system/broadcast', function($){

	var module 				= this;

	EasySocial.require()
	.library('gritter')
	.done(function($){

		EasySocial.Controller(
			'System.Broadcast',
			{
				defaultOptions: {
					interval: 30,
					sticky: false,
					period: 8
				}
			},
			function(self){
				return {

					init: function()
					{
						self.startMonitoring();
					},
					
					startMonitoring: function()
					{
						var interval = self.options.interval * 1000;

						self.options.state	= setTimeout(self.check, interval);
					},

					stopMonitoring: function()
					{
						clearTimeout(self.options.state);
					},

					check: function()
					{
						// Stop monitoring so that there wont be double calls at once.
						self.stopMonitoring();

						var interval = self.options.interval * 1000;

						// Needs to run in a loop since we need to keep checking for new notification items.
						setTimeout(function(){

							EasySocial.ajax('site/controllers/notifications/getBroadcasts')
							.done(function(items){

								if (items) {

									$(items).each(function(i, item) {

										$.gritter.add({
											title: item.title,
											text: item.content,
											image: item.authorAvatar,
											sticky: self.options.sticky,
											time: self.options.period * 1000,
											class_name: 'es-broadcast'
										});

									});
								}

								// Continue monitoring.
								self.startMonitoring();
							});

						}, interval);

					},
				}
			});

		module.resolve();
	});

});

EasySocial.module( 'site/toolbar/conversations' , function($){

	var module = this;

	EasySocial.require()
	.library('tinyscrollbar')
	.done(function($){

		EasySocial.Controller(
			'Notifications.Conversations',
			{
				defaultOptions:
				{
					// Check every 10 seconds by default.
					interval : 30,

					// Elements within this container.
					"{counter}" : "[data-notificationConversation-counter]"
				}
			},
			function(self){ return{

				init: function()
				{
					// Start the automatic checking of new notifications.
					self.startMonitoring();
				},

				/**
				 * Start running checks.
				 */
				startMonitoring: function()
				{
					var interval 	= self.options.interval * 1000;

					// Debug
					if( EasySocial.debug )
					{
						// console.info( 'Start monitoring conversation notifications at interval of ' + self.options.interval + ' seconds.' );
					}

					self.options.state	= setTimeout( self.check , interval );
				},

				/**
				 * Stop running any checks.
				 */
				stopMonitoring: function()
				{
					// Debug
					if( EasySocial.debug )
					{
						// console.info( 'Stop monitoring conversation notifications.' );
					}

					clearTimeout( self.options.state );
				},

				/**
				 * Check for new updates
				 */
				check: function()
				{

					// Stop monitoring so that there wont be double calls at once.
					self.stopMonitoring();

					var interval 	= self.options.interval * 1000;

					// Needs to run in a loop since we need to keep checking for new notification items.
					setTimeout( function(){

						EasySocial.ajax( 'site/controllers/notifications/getConversationCounter')
						.done( function( total ){

							if( total > 0 )
							{
								// Add new notice on the toolbar
								self.element.addClass( 'has-notice' );

								// Update the counter's count.
								self.counter().html( total );
							}
							else
							{
								self.element.removeClass( 'has-notice' );
							}

							// Continue monitoring.
							self.startMonitoring();
						});

					}, interval );

				}
			}}
		);

		module.resolve();
	});

});

EasySocial.module( 'site/toolbar/friends' , function($){

	var module 				= this;

	EasySocial.require()
	.library( 'tinyscrollbar' )
	.language( 'COM_EASYSOCIAL_FRIENDS_REQUEST_REJECTED' )
	.done(function($){

		EasySocial.Controller(
			'Notifications.Friends',
			{
				defaultOptions:
				{

					// Check every 10 seconds by default.
					interval: 3,

					// The return url when the friend approval is approved.
					returnURL 	: "",

					// Elements within this container.
					"{counter}"		: "[data-notificationFriends-counter]",
					"{loadRequestsButton}" : ".loadRequestsButton"
				}
			},
			function(self){ return{

				init: function()
				{
					// Start the automatic checking of new notifications.
					self.startMonitoring();
				},

				/**
				 * Start running checks.
				 */
				startMonitoring: function()
				{
					var interval 	= self.options.interval * 1000;

					// Debug
					if( EasySocial.debug )
					{
						// console.info( 'Start monitoring friend requests at interval of ' + self.options.interval + ' seconds.' );
					}

					self.options.state	= setTimeout( self.check , interval );
				},

				/**
				 * Stop running any checks.
				 */
				stopMonitoring: function()
				{
					// Debug
					if( EasySocial.debug )
					{
						// console.info( 'Stop monitoring friend requests.' );
					}

					clearTimeout( self.options.state );
				},

				/**
				 * Check for new updates
				 */
				check: function(){

					// Stop monitoring so that there wont be double calls at once.
					self.stopMonitoring();

					var interval 	= self.options.interval * 1000;

					// Needs to run in a loop since we need to keep checking for new notification items.
					setTimeout( function(){

						EasySocial.ajax('site/controllers/notifications/friendsCounter')
						.done( function( total )
						{

							if( total > 0 )
							{
								// Update element
								self.element.addClass( 'has-notice' );

								// Update the counter's count.
								self.counter().html( total );
							}
							else
							{
								self.element.removeClass( 'has-notice' );
							}

							// Continue monitoring.
							self.startMonitoring();
						});

					}, interval );
				}
			}}
		);

		EasySocial.Controller(
			'Notifications.Friends.Item',
			{
				defaultOptions:
				{
					"{actionsWrapper}" 	: "[data-friend-item-actions]",
					"{acceptFriend}"	: "[data-friend-item-accept]",
					"{rejectFriend}"	: "[data-friend-item-reject]",
					"{actions}"			: "[data-friend-item-action]",
					"{title}"			: "[data-friend-item-title]",
					"{mutual}" 			: "[data-friend-item-mutual]",

					// Views
					view	:
					{
						loader 		: 'site/loading/small'
					},
				}
			},
			function( self ){
				return {

					init: function()
					{

					},

					"{acceptFriend} click" : function( el , event )
					{
						// Stop other events from being triggered.
						event.stopPropagation();

						var toolbar	= $('[data-notifications-friends]').controller(),
							counter	= false;

						self.actionsWrapper().addClass( 'friend-adding' );

						// Send an ajax request to approve the friend.
						EasySocial.ajax( 'site/controllers/friends/approve' ,
						{
							viewCallback	: "notificationsApprove",
							id				: $( el ).data( 'id' )
						})
						.done(function( title , mutualFriendsContent )
						{
							// Update the current state
							self.actionsWrapper().removeClass( 'friend-adding' ).addClass( 'added-friends' );

							self.title().html( title );

							self.mutual().html( mutualFriendsContent );


							if (toolbar) {
								var counter 	= toolbar.counter().html(),
									counter 	= parseInt(counter),
									counter 	= counter - 1
									counter		= counter.toString();

								toolbar.counter().html(counter);

								if (counter == 0) {
									toolbar.element.removeClass('has-notice');
								}
							}
						})
						.fail( function( message )
						{
							// Append error message.
							self.element.html( message.message );
						});

					},


					"{rejectFriend} click" : function( el , event )
					{
						event.stopPropagation();

						EasySocial.ajax( 'site/controllers/friends/reject' ,
						{
							"id"	: $( el ).data( 'id' )
						})
						.done( function( button )
						{
							self.actionsWrapper().html( $.language( 'COM_EASYSOCIAL_FRIENDS_REQUEST_REJECTED' ) );
						})
						.fail( function( message )
						{
							// Append error message.
							self.element.html( message.message );
						});

					}
				}
			}
		);

		module.resolve();
	});

});

EasySocial.module( 'site/toolbar/login' , function($){

	var module 				= this;

	EasySocial.require()
	.library( 'popbox' )
	.done(function($){

		EasySocial.Controller(
			'Toolbar.Login',
			{
				defaultOptions:
				{
					"{dropdown}"		: "[data-toolbar-login-dropdown]"
				}
			},
			function(self){ return{

				init: function()
				{


				},

				"{self} popboxActivate" : function( el , event , popbox )
				{
					$( popbox.tooltip ).find( 'label' ).on( 'click' , function( event )
					{

						event.preventDefault();
						// Prevent propagation
						event.stopPropagation();

						// lets manually do the element focusing
						var labelForId = $(this).attr('for');
						var inputElement = $('[data-popbox-content] #' + labelForId);

						if (inputElement.is(':checkbox')) {
							inputElement.click();
						} else {
							inputElement.focus();
						}

					});
					// $( popbox.tooltip ).implement( EasySocial.Controller.Toolbar.Login.User );
				}
			}}
		);

		module.resolve();
	});

});

EasySocial.module('site/toolbar/notifications' , function($){

	var module 				= this;

	EasySocial.require()
	.script( 
		'site/toolbar/friends', 
		'site/toolbar/story',
		'site/toolbar/system',
		'site/toolbar/profile',
		'site/toolbar/login',
		'site/toolbar/conversations'
	)
	.done(function($){

		EasySocial.Controller('Notifications', {
			defaultOptions: {
				friendsInterval: 30,
				systemInterval: 30,
				conversationsInterval: 30,

				"{friendNotifications}": "[data-notifications-friends]",
				"{conversationNotifications}": "[data-notifications-conversations]",
				"{systemNotifications}": "[data-notifications-system]",
				"{profileItem}": "[data-toolbar-profile]",
				"{storyForm}": "[data-toolbar-story]",
				"{login}": "[data-toolbar-login]",
				"{item}": "[data-toolbar-item]"
			}
		}, function(self, opts){ return { 

			init: function() {

				// Implement toolbar login controller
				self.login().addController(EasySocial.Controller.Toolbar.Login);

				// Initialize profile controller for toolbar.
				if (!opts.guest) {

					self.profileItem().addController(EasySocial.Controller.Toolbar.Profile, {
						interval: self.options.systemInterval
					});

					// Initialize system notifications controller.
					self.systemNotifications().addController(EasySocial.Controller.Notifications.System, {
						interval: opts.systemInterval
					});

					// Initialize friends controller.
					self.friendNotifications().addController( EasySocial.Controller.Notifications.Friends, {
						interval: self.options.friendsInterval
					});

					// Initialize conversations controller.
					self.conversationNotifications().addController(EasySocial.Controller.Notifications.Conversations, {
						interval: self.options.conversationsInterval
					});
					
					// Initialize story form controller.
					self.storyForm().addController(EasySocial.Controller.Notifications.Story);
				}

				// Initialize responsive layout for the notification bar.
				self.setLayout();

				// Monitor clicks on the body. So that all dropdowns should be hidden whenever clicks are made on the body.
				$('body').on('click.out-of-dropdown', function() {
					self.item().removeClass('open');
				});
			},

			"{window} resize": $.debounce(function(){
				self.setLayout();
			}, 250),

			setLayout: function() {

				var elem = self.element,
					toolbarWidth = elem.outerWidth(true) - 80,
					allItemWidth = 0;

					// Calculate how much width toolbar items are taking
					self.item().each(function(){
						allItemWidth += $(this).outerWidth(true);
					});

				var exceeded = (allItemWidth > toolbarWidth);

				elem.toggleClass("narrow", exceeded).toggleClass("wide", !exceeded);
			}
		}});

		module.resolve();
	});

});

EasySocial.module( 'site/toolbar/story' , function($){

	var module 				= this;

	EasySocial.require()
	.done(function($){

		EasySocial.Controller(
			'Notifications.Story',
			{
				defaultOptions:
				{
					"{loadFormButton}"	: ".loadFormButton",
					"{dropdown}"		: ".dropdown-menu"
				}
			},
			function(self){ return{ 

				init: function()
				{
				},

				"{dropdown} click" : function( el , event )
				{
					// event.stopPropagation();
				},

				"{self} hideDropdown" : function()
				{
					// self.element.removeClass( 'open' );
				},

				"{dropdown} click" : function( el , event )
				{
					// Disallow clicking of events to trigger parent items.
					event.stopPropagation();
				}
			}}
		);

		module.resolve();
	});

});

EasySocial.module( 'site/toolbar/system' , function($){

	var module = this;

	EasySocial.require()
	.view('site/notifications/system.empty')
	.library('tinyscrollbar')
	.done(function($) {

		EasySocial.Controller('Notifications.System', {
			
			defaultOptions: {
				pageTitle: null,
				interval: 30,

				// Elements within this container.
				"{counter}": "[data-notificationSystem-counter]"
			}
		}, function(self, opts){ return{

			init: function() {
				// Initialize the default page title
				opts.pageTitle = $(document).attr('title');

				// Start the automatic checking of new notifications.
				self.startMonitoring();
			},

			startMonitoring: function() {
				var interval = self.options.interval * 1000;

				self.options.state = setTimeout(self.check, interval);
			},

			stopMonitoring: function() {
				clearTimeout(self.options.state);
			},

			check: function(){

				// Stop monitoring so that there wont be double calls at once.
				self.stopMonitoring();

				var interval = self.options.interval * 1000;

				// Needs to run in a loop since we need to keep checking for new notification items.
				setTimeout( function(){

					EasySocial.ajax('site/controllers/notifications/getSystemCounter')
					.done(function( total ){

						if (total > 0) {
							// When there is new notification items, we want to update the page title.
							$(document).attr('title', self.options.pageTitle + ' (' + total + ')');

							// Update toolbar item element
							self.element.addClass( 'has-notice' );

							// Update the counter's count.
							self.counter().html( total );
						} else {

							self.element.removeClass( 'has-notice' );

							// When the new notification button is clicked, we want to reset to the original title.
							$(document).attr('title', self.options.pageTitle);
						}

						// Continue monitoring.
						self.startMonitoring();
					});

				}, interval );

			},

			'{window} easysocial.clearSystemNotification': function() {
				self.element.removeClass('has-notice');
				self.counter().html(0);
			}

		}});

		EasySocial.Controller('Notifications.System.Popbox', {
			defaultOptions: {
				"{readall}"	: "[data-notificationsystem-readall]",
				"{items}"	: "[data-notificationsystem-items]",

				view: {
					empty	: "site/notifications/system.empty"
				}
			}
		}, function(self) {
			return {
				init: function() {

				},

				"{readall} click": function() {

					// Bad way of implementing this
					$('[data-notificationSystem-counter]').parents('li').removeClass('has-notice');
					$('[data-notificationSystem-counter]').html(0);

					EasySocial.ajax( 'site/controllers/notifications/setAllState' ,
					{
						"state"	: "read"
					})
					.done(function()
					{
						self.items().html('');

						self.items().append(self.view.empty());

						self.items().addClass('is-empty');

						$(window).trigger('easysocial.clearSystemNotification');
					});
				}
			}
		})

		module.resolve();
	});

});

EasySocial.module('site/toolbar/profile', function($) {

	var module = this;

	EasySocial.require()
	.library('popbox')
	.done(function($){

		EasySocial.Controller('Toolbar.Profile', {
				defaultOptions: {
					"{dropdown}": "[data-toolbar-profile-dropdown]"
				}
			}, function(self){ return{

				init: function() {

				},

				"{self} popboxActivate" : function(el, event, popbox) {
					$(popbox.tooltip)
						.implement(EasySocial.Controller.Toolbar.Profile.Logout);
				}
			}}
		);

		EasySocial.Controller('Toolbar.Profile.Logout',{
				defaultOptions: {
					// Elements within this container.
					"{logoutForm}": "[data-toolbar-logout-form]",
					"{logoutButton}": "[data-toolbar-logout-button]"
				}
			}, function(self) { return{
					
					logout: function() {
						self.logoutForm().submit();
					},

					"{logoutButton} click" : function() {
						console.log('debug');

						self.logout();
					}
				}
			});

		module.resolve();
	});

});

EasySocial.module("site/users/popbox", function($) {

	var module = this;

	EasySocial.require()
		.library("popbox")
		.done(function(){

			EasySocial.module("users/popbox", function($) {

				this.resolve(function(popbox){

					var ids = popbox.button.data("ids"),
						position = popbox.button.attr("data-popbox-position") || "top-left";

					return {
						content: EasySocial.ajax("site/views/users/popbox", {ids: ids}),
						id: "fd",
						component: "es",
						type: "users",
						position: position
					}
				})
			});

		});

	module.resolve();

});

EasySocial.module( 'site/users/users' , function($){

	var module 				= this;

	EasySocial.require()
	.library( 'history' )
	.view(
		'site/loading/small',
		'site/users/button.following'
	)
	.done(function($){

		EasySocial.Controller(
			'Users',
			{
				defaultOptions :
				{
					"{content}"		: "[data-users-content]",
					"{listing}"		: "[data-users-listing]",
					"{sort}"		: "[data-users-sort]",
					"{filter}"		: "[data-users-filter]",
					"{items}"		: "[data-users-item]",
					"{pagination}" 	: "[data-users-pagination]",
					"{profile}": "[data-users-filter-profile]",
					"{search}": "[data-users-filter-search]",

					view :
					{
						loading 			: 'site/loading/small'
					}
				}
			},
			function( self )
			{
				return {

					init : function()
					{
						// Implement user item controller
						self.initUserController();
					},

					initUserController : function()
					{
						self.items().implement( EasySocial.Controller.Users.Item ,
						{
							"{parent}"	: self
						});
					},

					removeActiveFilter: function()
					{
						self.filter().each(function(){
							$(this).parent().removeClass('active');
						});

						self.profile().each(function(){
							$(this).parent().removeClass('active');
						})

						self.search().each(function(){
							$(this).parent().removeClass('active');
						})
					},

					"{profile} click": function(el, event)
					{
						event.preventDefault();

						var id = $(el).data('id');

						self.removeActiveFilter();

						// add active class
						$(el).parent().addClass('active');

						// Route the current url
						$(el).route();

						// Update contents with loading
						self.listing().html(self.view.loading());

						EasySocial.ajax('site/controllers/users/getUsersByProfile',
						{
							"id": id
						})
						.done(function(output){

							self.content().html(output);

							// Re-apply controller
							self.initUserController();
						});
					},

					"{search} click": function(el, event)
					{
						event.preventDefault();

						var id = $(el).data('id');

						self.removeActiveFilter();

						// add active class
						$(el).parent().addClass('active');

						// Route the current url
						$(el).route();

						// Update contents with loading
						self.listing().html(self.view.loading());

						EasySocial.ajax('site/controllers/users/getUsersByFilter',
						{
							"id": id
						})
						.done(function(output){

							self.content().html(output);

							// Re-apply controller
							self.initUserController();
						});
					},

					"{filter} click" : function( el , event )
					{
						event.preventDefault();

						// Remove any active states for filters and sort items
						self.sort().removeClass( 'active' );

						self.removeActiveFilter();

						// Add active class to the current filter item.
						$( el ).parent().addClass( 'active' );

						// Get the sort type.
						var filter 	= $( el ).data( 'filter' );

						self.options.filter 	= filter;
						$( el ).route();

						// Add loading state to the content.
						self.listing().html( self.view.loading() );

						// Set the first sort item as the active item
						self.sort( ':first' ).addClass( 'active' );

						// Perform the ajax call to retrieve the new users listing
						EasySocial.ajax( 'site/controllers/users/getUsers',
						{
							"filter" 			: filter,
							"showpagination"	: 1
						})
						.done(function( output )
						{
							self.content().html( output );

							// Re-apply controller
							self.initUserController();
						});
					},

					"{sort} click" : function( el , event )
					{
						event.preventDefault();

						// Get the sort type
						var type 	= $( el ).data( 'type' );

						$( '<a>' ).attr( { title : document.title , href : $(el).attr( 'href' ) }).route();

						// Add the active state on the current element.
						self.sort().removeClass( 'active' );

						$( el ).addClass( 'active' );

						// Add loading state to the content.
						self.listing().html( self.view.loading() );

						// Remove pagination
						self.pagination().remove();

						EasySocial.ajax( 'site/controllers/users/getUsers' ,
						{
							"sort"				: type,
							"filter"			: self.options.filter,
							"isSort" 			: true,
							"showpagination" 	: 1
						})
						.done(function(contents)
						{
							// Update the contents on the page.
							self.listing().html( contents );

							// Re-apply controller
							self.initUserController();
						});

					}
				}
			});

		EasySocial.Controller('Users.Item', {
			
			defaultOptions: {
				id: null,
				"{followUser}": "[data-es-followers-follow]",
				"{addFriend}": "[data-users-add-friend]",
				"{friendsButton}": "[data-users-friends-button]",
				"{compose}": "[data-users-friends-compose]",
				"{unfriend}": "[data-users-friends-unfriend]",

				view: {
					followingButton: 'site/users/button.following'
				}
			}
		}, function(self) {

			return {

				init: function() {
					self.options.id = self.element.data('id');
				},

				"{followUser} following": function(el, event) {
					// Hide the previous popbox
					$(el).popbox('hide');

					// Replace the button
					$(el).replaceWith( self.view.followingButton() );
				},

				"{addFriend} click": function(addButton, event) {
					
					// Add a loading state to the button
					$(addButton).addClass( 'btn-loading' );

					// Append loading state on the button
					EasySocial.ajax( 'site/controllers/friends/request' , {
						"viewCallback": "usersRequest",
						"id": self.options.id
					})
					.done(function(pendingButton) {
						// Replace the button
						$(addButton).replaceWith(pendingButton);

						// Remove the loading state from the button
						$(addButton).removeClass('btn-loading');
					})
					.fail(function(obj) {
						EasySocial.dialog({
							content: obj.message
						});

						$(addButton).removeClass('btn-loading');
					})
				}

			}
		});

		module.resolve();
	});


});

EasySocial.module("story", function($){

var module = this;

// This speeds up story initialization during development mode.
// Do not add this to the manifest file.
EasySocial.require()
	.language(
		"COM_EASYSOCIAL_LOCATION_PERMISSION_ERROR",
		"COM_EASYSOCIAL_STREAM_META_JOINER"
	)
	.view(
		"apps/user/links/story/attachment.item",
		"site/location/story.suggestion",
		"site/albums/upload.item",
		"site/friends/suggest.item",
		"site/friends/suggest.hint.search",
		"site/friends/suggest.hint.empty",
		"site/hashtags/suggest.item",
		"site/hashtags/suggest.hint.search",
		"site/hashtags/suggest.hint.empty"
	)
	.done();

// Non-essential dependencies
EasySocial.require()
	.script(
		"story/locations",
		"story/friends",
		"story/mood"
	);

EasySocial.require()
	.library("mentions", "placeholder")
	.script('site/stream/item')
	.language(
		"COM_EASYSOCIAL_STORY_SUBMIT_ERROR",
		"COM_EASYSOCIAL_STORY_CONTENT_EMPTY",
		"COM_EASYSOCIAL_STORY_NOT_ON_STREAM_FILTER"
	).done(function(){

		EasySocial.Controller("Story", {
			
			defaultOptions: {
				view: {
					suggestItem: "site/friends/suggest.item",
					tagSuggestItem: "site/hashtags/suggest.item"
				},

				plugin: {
					text: {
						id: "text",
						name: "text",
						selector: "[data-story-plugin-name=photos]",
						type: "panel"
					}
				},

				sourceView: null,

				attachment: {
					limit: 1,
					lifo: true
				},

				enterToSubmit: false,

				"{header}"		: "[data-story-header]",
				"{body}"  		: "[data-story-body]",
				"{footer}"		: "[data-story-footer]",

				"{form}"        : "[data-story-form]",
				"{textbox}"     : "[data-story-textbox]",
				"{textField}"   : "[data-story-textField]",
				"{target}"      : "[data-story-target]",

				"{cluster}"      : "[data-story-cluster]",
				"{clusterType}"  : "[data-story-clustertype]",

				"{submitButton}": "[data-story-submit]",
				"{resetButton}" : "[data-story-reset]",
				"{privacyButton}": "[data-story-privacy]",

				"{panelContents}": "[data-story-panel-contents]",
				"{panelContent}": "[data-story-panel-content]",
				"{panelButton}": "[data-story-panel-button]",
				// "{defaultPanel}"	: "[data-story-panel-button-default]",

				//stream listing
				"{streamContainer}": "[data-streams]",
				"{streamItem}"     : "[data-streamItem]",

				"{friends}": "[data-story-friends]",
				"{location}": "[data-story-location]",
				"{mood}": "[data-story-mood]",

				// Mentions
				"{mentionsOverlay}": "[data-mentions-overlay]",

				// Meta
				"{meta}"        : "[data-story-meta]",
				"{metaContents}": "[data-story-meta-contents]",
				"{metaContent}" : "[data-story-meta-content]",
				"{metaButtons}" : "[data-story-meta-buttons]",
				"{metaButton}"  : "[data-story-meta-button]"
			},

			hostname: "story"
		}, function(self, opts, base) { return {

			init: function() {

				// Find out what's my story id
				self.id = base.data("story");

				// Create plugin repository
				$.each(self.options.plugin, function(pluginName, pluginOptions) {

					var plugin = self.plugins[pluginName] = pluginOptions;

					// Pre-count the number of available attachment type
					if (plugin.type=="attachment") self.attachments.max++;

					// Add selector property
					plugin.selector = self.getPluginSelector(pluginName);
				});

				self.setMentionsLayout();

				if (self.friends().length > 0) {
					EasySocial.module("story/friends")
						.done(function(){
							self.addPlugin("friends");
						});
				}

				if (self.location().length > 0) {
					EasySocial.module("story/locations")
						.done(function(){
							self.addPlugin("locations");
						});
				}

				if (self.mood().length > 0) {

					EasySocial.module("story/mood")
						.done(function(){
							self.addPlugin("mood");
						});
				}

				// Remember placeholder value (used by meta)
				self.placeholder = self.textField().attr("placeholder");

				// Duckpunch setMessage
				self._setMessage = self.setMessage;

				self.setMessage = function() {

					// Do not set any messages when story is collapsed or is resizing.
					if (base.hasClass("is-collapsed") || base.hasClass("is-resizing")) {
						return;
					}

					// Remove any previous message group first to avoid stacking error messages.
					this.element
						.find('[data-message-group]')
						.remove();

					self._setMessage.apply(this, arguments);
				};

				// Show placeholder shim for ie9
				if (navigator.userAgent.match(/MSIE 9.0/i)) {
					base.addClass("is-ie");
				}

				self.checkResetButton();

				// Resolve story instance
				$.module("story-" + self.id).resolve(self);
			},

			checkResetButton: function() {

				var textField = self.textField(),
					defaultText = textField.attr("data-default");

				if (defaultText) {
					self.resetButton()
						.toggle(textField.val()!==defaultText);
				}
			},

			"{textField} keyup": $.debounce(function(textField){

				self.checkResetButton();

			}, 250, {leading: true}),

			"{self} click": function(element, event) {

				if ($(event.target).parents().andSelf().filter(self.resetButton()[0]).length > 0) return;
				self.expand();
			},

			"{textField} touchstart": function() {
				self.expand();
			},

			"{textField} keydown": function(textField, event) {
				self.expand();
			},

			"{textField} click": function() {
				self.expand();
			},

			"{textField} mousedown": function(textField, event) {
				self.expand();
			},

			"{textField} keypress": function(textField, event) {

				if (
					// If pressing enter submits form
					opts.enterToSubmit &&
					// And enter key was pressed
					event.keyCode==13 &&
					// Without any meta keys involved
					!(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey)
				) {
					self.save();
					event.preventDefault();
				}
			},

			expand: $.debounce(function() {

				if (base.hasClass("is-expanded") || base.hasClass("is-resizing")) {
					return;
				}

				var transitionEnd   = $.support && $.support.transition && $.support.transition.end,
					transitionEvent = (transitionEnd || "transitionend") + ".es.story",
					finalize = $.debounce(function(){

						base.off(transitionEvent)
							.addClass("is-expanded")
							.removeClass("is-resizing")

						// Executes only once
						self.setMentionsLayout();
						self.submitButton().removeAttr("data-disabled");
						self.textField().focus();
					}, 1);

				if (transitionEnd) {
					base.on(transitionEvent, finalize);
				} else {
					setTimeout(finalize, 600);
				}

				// The CSS transition in this class expands the textarea
				base.removeClass("is-collapsed")
					.addClass("is-resizing");
			}, 1),

			collapse: function() {

				if (base.hasClass("is-collapsed") || base.hasClass("is-resizing")) {
					return;
				}

				base.addClass("is-resizing")
					.removeClass("is-expanded");

				setTimeout(function(){
					base.addClass("is-collapsed")
						.removeClass("is-resizing");
				}, 1);
			},

			reset: function(collapse) {

				self.clear();

				// If there are default values in the textarea, don't collapse
				if (self.textField().val()!=="") {
					return;
				}

				if (collapse) {
					self.collapse();
				}
			},

			setMentionsLayout: function() {

				var textbox = self.textbox(),
					mentions = textbox.controller("mentions");

				if (mentions) {
					mentions.cloneLayout();
					return;
				}

				var body = self.body();

				textbox
					.mentions({
						triggers: {
						    "@": {
								type: "entity",
								wrap: false,
								stop: "",
								allowSpace: true,
								finalize: true,
								query: {
									loadingHint: true,
									searchHint: $.View("easysocial/site/friends/suggest.hint.search"),
									emptyHint: $.View("easysocial/site/friends/suggest.hint.empty"),
									data: function(keyword) {

										var task = $.Deferred();

										EasySocial.ajax("site/controllers/friends/suggest", {search: keyword})
											.done(function(items){

												if (!$.isArray(items)) {
													task.reject();
													return;
												}

												var items = $.map(items, function(item){
													item.title = item.screenName;
													item.type = "user";
													item.menuHtml = self.view.suggestItem(true, {
														item: item,
														name: "uid[]"
													});
													return item;
												});

												task.resolve(items);
											})
											.fail(task.reject);

										return task;
									},
									use: function(item) {
										return item.type + ":" + item.id;
									}
							    }
							},
							"#": {
							    type: "hashtag",
							    wrap: true,
							    stop: " #",
							    allowSpace: false,
								query: {
									loadingHint: true,
									searchHint: $.View("easysocial/site/hashtags/suggest.hint.search"),
									emptyHint: $.View("easysocial/site/hashtags/suggest.hint.empty"),
									data: function(keyword) {

										var task = $.Deferred();

										EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
											.done(function(items){

												if (!$.isArray(items)) { 
													task.reject(); 
													return; 
												}

												var items = $.map(items, function(item){
													item.title = "#" + item.title;
													item.type = "hashtag";
													item.menuHtml = self.view.tagSuggestItem(true, {
														item: item,
														name: "uid[]"
													});
													return item;
												});

												task.resolve(items);
											})
											.fail(task.reject);

										return task;
									}
							    }
							}
						},
						plugin: {
							autocomplete: {
								id: "fd",
								component: "es",
								modifier: "es-story-mentions-autocomplete",
								sticky: true,
								shadow: true,
								position: {
									my: 'left top',
									at: 'left bottom',
									of: textbox.parent(),
									collision: 'none'
								},
								size: {
									width: function() {
										return body.width();
									}
								}
							}
						}
					});
			},

			//
			// PLUGINS
			//
			plugins: {},

			getPluginName: function(element) {
				return $(element).data("story-plugin-name");
			},

			getPluginSelector: function(pluginName) {
				return "[data-story-plugin-name=" + pluginName + "]";
			},

			hasPlugin: function(pluginName, pluginType) {

				var plugin = self.plugins[pluginName];

				if (!plugin) return false;

				// Also check for pluginType
				if (pluginType) return (plugin.type===pluginType);

				return true;
			},

			buildPluginSelectors: function(selectorNames, plugin, pluginControllerType) {

				var selectors = {};

				$.each(selectorNames, function(i, selectorName) {

					var selector = self[selectorName].selector + plugin.selector;

					if (pluginControllerType=="function") {
						selectors[selectorName] = function() {
							return self.find(selector);
						};
					} else {
						selectors["{"+selectorName+"}"] = selector;
					}
				});

				return selectors;
			},

			"{self} addPlugin": function(element, event, pluginName, pluginController, pluginOptions, pluginControllerType) {

				// Prevent unregistered plugin from extending onto story
				if (!self.hasPlugin(pluginName))
				{
					return;
				}

				var plugin = self.plugins[pluginName],
					extendedOptions = {};

				// See plugin type and build the necessary options for them
				switch (plugin.type)
				{
					case "panel":
						var panelSelectors = [
							"panelButton",
							"panelContent"
						];
						extendedOptions = self.buildPluginSelectors(panelSelectors, plugin, pluginControllerType);
						break;
				}

				$.extend(pluginOptions, extendedOptions);
			},

			"{self} registerPlugin": function(element, event, pluginName, pluginInstance) {

				// Prevent unregistered plugin from extending onto story
				if (!self.hasPlugin(pluginName)) return;

				var plugin = self.plugins[pluginName];

				plugin.instance = pluginInstance;
			},

			//
			// PANELS
			//

			panels: {},

			currentPanel: "text",

			getPanel: function(pluginName) {

				// If plugin is not a panel, stop.
				if (!self.hasPlugin(pluginName, 'panel')) return;

				var plugin = self.plugins[pluginName];

				// Return existing panel entry if it has been created,
				return self.panels[plugin.name] ||

						// or create panel entry and return it.
						(self.panels[plugin.name] = {
							plugin: plugin,
							button: self.panelButton(plugin.selector),
							content: self.panelContent(plugin.selector)
						});
			},

			activatePanel: function(pluginName) {

				// Get panel
				var panel = self.getPanel(pluginName);

				// If panel does not exist, stop.
				if (!panel) return;

				// Deactivate current panel
				self.deactivatePanel(self.currentPanel);

				// Set plugin as current panel
				self.currentPanel = pluginName;

				var panelContents = self.panelContents();

				// Activate panel container
				panelContents.addClass("active");

				// Activate panel
				panel.button.addClass("active");
				panel.content
					.appendTo(panelContents)
					.addClass("active");

                base.addClass("plugin-" + pluginName);

				// Invoke plugin's activate method if exists
				self.invokePlugin(pluginName, "activatePanel", [panel]);

				// Trigger panel activate event
				self.trigger("activatePanel", [pluginName]);

				// Refocus story form
				self.textField().focus();
			},

			deactivatePanel: function(pluginName) {

				// Get panel
				var panel = self.getPanel(pluginName);

				// If panel does not exist, stop.
				if (!panel) return;

				// Deactivate panel
				panel.button.removeClass("active");
				panel.content.removeClass("active");

                base.removeClass("plugin-" + pluginName);

				// Deactivate panel container
				self.panelContents().removeClass("active");

				// Invoke plugin's deactivate method if exists
				self.invokePlugin(pluginName, "deactivatePanel", [panel]);

				// Trigger panel deactivate event
				self.trigger("deactivatePanel", [pluginName]);
			},

			addPanelCaption: function(pluginName, panelCaption) {

				// Get panel
				var panel = self.getPanel(pluginName);

				// If panel does not exist, stop.
				if (!panel) return;

				panel.button
					.addClass("has-data")
					.find(".with-data").html(panelCaption);
			},

			removePanelCaption: function(pluginName) {

				// Get panel
				var panel = self.getPanel(pluginName);

				// If panel does not exist, stop.
				if (!panel) return;

				panel.button
					.removeClass("has-data")
					.find(".with-data").empty();
			},

			// Triggered when the panel buttons beneath the story footer is clicked
			"{panelButton} click": function(panelButton, event) {

				var pluginName = self.getPluginName(panelButton);

				self.activatePanel(pluginName);
			},

			//
			// SAVING
			//
			saving: false,

			save: function() {

				if (self.saving) {
					return;
				}

				self.saving = true;

				// Create save object
				var save = $.Deferred();
				
				save.data = {};
				save.tasks = [];

				save.addData = function(plugin, props) {

					var pluginName = plugin.options.name,
						pluginType = plugin.options.type;

					if (pluginName !== self.currentPanel) {
						return;
					}


					save.data.attachment = self.currentPanel;

					if ($.isPlainObject(props))
					{
						$.each(props, function(key, val)
						{
							save.data[pluginName + "_" + key] = val;
						});
					}
					else
					{
						save.data[pluginName] = props;
					}
				};

				save.addTask = function(name) {
					var task = $.Deferred();
					task.name = name;
					task.save = save;
					save.tasks.push(task);
					return task;
				};

				save.process = function() {
					if (save.state()==="pending") {
						$.when.apply($, save.tasks)
							.done(function() {

								// If content & attachment is empty, reject.
								if (!$.trim(save.data.content) && !save.data.attachment) {
									save.reject($.language("COM_EASYSOCIAL_STORY_CONTENT_EMPTY"), "warning");
									return;
								}

								save.resolve();
							})
							.fail(save.reject);
					}

					return save;
				};

				// Set the current panel so that the plugins know whether they should intercept
				save.currentPanel = self.currentPanel;

				// Trigger the save event
				self.trigger("save", [save]);

				self.element.addClass("saving");

				save.process()
					.done(function(){
						var mentions = self.textbox().mentions("controller").toArray(),
							hashtags = self.element.data("storyHashtags"),
							hashtags = (hashtags) ? hashtags.split(",") : [],
							nohashtags = false;

						if (hashtags.length > 0) {
							var tags =
								$.map(mentions, function(mention)
								{
									if (mention.type==="hashtag" && $.inArray(mention.value, hashtags) > -1)
									{
										return mention;
									}
								});

							nohashtags = tags.length < 1;
						}

						self.trigger("beforeSubmit", [save]);


						// then the ajax call to save story.
						EasySocial.ajax("site/controllers/story/create", save.data)
							.done(function(html, id) {

								if (nohashtags) {
									html = self.setMessage($.language("COM_EASYSOCIAL_STORY_NOT_ON_STREAM_FILTER"));
								}
								
								self.trigger("create", [html, id]);
								self.clear();
								self.reset();
							})
							.fail(function(message){
								self.trigger("fail", arguments);
								if (!message) return;
								self.setMessage(message.message, message.type);
							})
							.always(function(){

								self.trigger("afterSubmit", [save]);

								self.element.removeClass("saving");
								self.saving = false;
							});
					})
					.fail(function(message, messageType){

						if (!message) {
							message = $.language("COM_EASYSOCIAL_STORY_SUBMIT_ERROR");
							messageType = "error";
						}

						self.setMessage(message, messageType);
						self.element.removeClass("saving");
						self.saving = false;
					});
			},

			clear: function() {

				// Clear textfield
				self.textField().val("");

				// Clear status messages
				self.clearMessage();

				// Reactivate text panel
				self.activatePanel("text");

				// Deactivate meta
				self.deactivateMeta(self.currentMeta);

				// Trigger clear event
				self.trigger("clear");

				// Reset mentions
				var mentions = self.textbox().mentions("controller");
				mentions.reset();

				self.checkResetButton();

				setTimeout(function(){
					mentions.cloneLayout();
				}, 500);

				// Focus textfield
				self.textField().focus();
			},

			"{self} save": function(element, event, save) {

				var content = self.textField().val(),
					data = save.data;

				data.view 	 = self.options.sourceView;
				data.content = content;
				data.target  = self.target().val();
				data.cluster = self.cluster().val();
				data.clusterType = self.clusterType().val();
				data.privacy = self.find("[data-privacy-hidden]").val();
				data.privacyCustom = self.find("[data-privacy-custom-hidden]").val();

				var mentions = self.textbox().mentions("controller").toArray();

				data.mentions = $.map(mentions, function(mention){
					if (mention.type==="hashtag" && $.isPlainObject(mention.value)) {
						mention.value = mention.value.title.slice(1);
					}
					return JSON.stringify(mention);
				});
			},

			"{submitButton} click": function(submitButton, event) {
				self.save();
			},

			"{resetButton} click": function() {
				self.reset(true);
			},

			//
			// Privacy
			//
			"{privacyButton} click": function(el) {
				setTimeout(function(){
					var isActive = el.find("[data-es-privacy-container]").hasClass("active");
					// self.footer().toggleClass("allow-overflow", isActive);
				}, 1);
			},

			//
			// Meta
			//
			metas: {
				friends: "",
				location: "",
				mood: ""
			},

			currentMeta: null,

			getMeta: function(metaName) {

				var meta = {
					name: metaName,
					button: self.metaButton().filterBy("storyMetaButton", metaName),
					content: self.metaContent().filterBy("storyMetaContent", metaName)
				};

				if (meta.button.length < 1 || meta.content.length < 1) return null;

				return meta;
			},

			activateMeta: function(metaName) {

				var meta = self.getMeta(metaName);

				if (!meta) return;

				// Deactivate current meta
				self.deactivateMeta(self.currentMeta);

				meta.button.addClass("active");

				// Always push meta content to the beginning
				meta.content
					.appendTo(self.metaContents())
					.addClass("active");

				self.currentMeta = metaName;

				self.trigger("activateMeta", [meta]);

				base.addClass("has-meta");
			},

			deactivateMeta: function(metaName) {

				var meta = self.getMeta(metaName);

				if (!meta) return;

				meta.button.removeClass("active");

				meta.content.removeClass("active");

				self.currentMeta = null;

				self.trigger("deactivateMeta", [meta]);

				base.removeClass("has-meta");
			},

			toggleMeta: function(metaName) {

				if (self.currentMeta == metaName) {
					self.deactivateMeta(metaName);
				} else {
					self.activateMeta(metaName);
				}
			},

			getMetaText: function() {

				var metas = self.metas,
					parts = [],
					joiner = $.language("COM_EASYSOCIAL_STREAM_META_JOINER");

				$.each(["friends", "location", "mood"], function(i, type){
					var meta = metas[type];
					if (meta) parts.push(meta);
				});

				return parts.join(joiner);
			},

			setMeta: function(metaName, content) {

				self.metas[metaName] = content;
				self.updateMeta();
			},

			updateMeta: $.debounce(function() {

				// This is debounced so we only have to update
				// the html once after multiple setMeta calls.
				var metaText = self.getMetaText(),
					meta = self.meta(),
					textField = self.textField();

				// Highlight meta button icon if meta has content
				$.each(self.metas, function(key, val){
					var meta = self.getMeta(key);
					meta && meta.button.toggleClass("has-content", !!val);
				});

				// If there is no meta string, don't show anything.
				if (!metaText) {
					meta.remove();
					textField.attr("placeholder", self.placeholder);
					return;
				}

				// Create meta element if it does not exist;
				var mentionsOverlay = self.mentionsOverlay();
				if (meta.length < 1) {
					meta = $('<u class="es-story-meta" data-story-meta data-ignore></u>').appendTo(mentionsOverlay);
				}

				// Add rtl mark if necessary
				var rtlMark =  mentionsOverlay.css("direction")=="rtl" ? "&#8207;" : "";

				// Update meta string
				meta.html(rtlMark + " &mdash; " + metaText);

				// Don't show placeholder text if we have meta text
				textField.attr("placeholder", "");

				self.setMentionsLayout();

			}, 1),

			refreshMeta: function() {

				// Trigger refresh meta so plugins
				// can update the meta the database
				self.trigger("refreshMeta");

				self.updateMeta();
			},

			"{textbox} triggerClear": function() {

				self.refreshMeta();
			},

			"{meta} click": function(meta, event) {

				// Do not focus textfield if a link was clicked
				if ($(event.target).is("a")) return;

				self.textField().focus();
			},

			"{metaButton} click": function(metaButton) {

				var metaName = metaButton.attr("data-story-meta-button");
				self.toggleMeta(metaName);
			}
		}});

		module.resolve();
	});

});

EasySocial.module("story/blog", function($){

    var module = this;

    EasySocial.require()
        .done(function(){

            EasySocial.Controller("Story.Blog",
                {
                    defaultOptions: {
                        "{title}" : "[data-blog-title]",
                        "{content}" : "[data-blog-content]",
                        "{category}": "[data-story-blog-category]"
                    }
                },
                function(self)
                {
                    return {

                    init: function()
                    {
                    },

                    "{story} save": function(element, event, save)
                    {
                        // Determines which profile we should broadcast to
                        var categoryId = self.category().val(),
                            title = self.title().val(),
                            content = self.content().val();


                        var data = {"categoryId" : categoryId, "title" : title, "content" : content};

                        save.addData(self, data);
                    }
                }}
            );

            // Resolve module
            module.resolve();

        });
});

EasySocial.module("story/broadcast", function($){

	var module = this;

	EasySocial.require()
		.done(function(){

			EasySocial.Controller("Story.Broadcast",
				{
					defaultOptions: {
						"{profile}" : "[data-broadcast-profile]",
						"{title}" : "[data-broadcast-title]",
						"{link}" : "[data-broadcast-link]",
						"{message}": "[data-broadcast-message]",
						"{type}": "[data-broadcast-type]"
					}
				},
				function(self)
				{
					return {

					init: function()
					{
					},

					"{story} save": function(element, event, save)
					{
						// Determines which profile we should broadcast to
						var profileId = self.profile().val(),
							title = self.title().val(),
							link = self.link().val(),
							type = self.type().val();

						var data = {"broadcast": "1", "profileId" : profileId, "title" : title, "link" : link, "type" : type};

						save.addData(self, data);
					},

					"{story} beforeSubmit": function(element, event, save)
					{
						if (save.currentPanel != 'broadcast') {
							return;
						}

						save.data.content = self.message().val();
					}
				}}
			);

			// Resolve module
			module.resolve();

		});
});

EasySocial.module('story/event', function($) {
    var module = this;

    var lang = EasySocial.options.momentLang;

    EasySocial.require()
    .library('datetimepicker', 'moment/' + lang)
    .view('site/loading/small')
    .language('COM_EASYSOCIAL_STORY_EVENT_INSUFFICIENT_DATA', 'COM_EASYSOCIAL_STORY_EVENT_INVALID_START_END_DATETIME')
    .done(function() {
        EasySocial.Controller('Story.Event', {
            defaultOptions: {
                '{base}': '[data-story-event-base]',

                '{category}': '[data-story-event-category]',
                '{form}': '[data-story-event-form]',

                '{timezone}': '[data-event-timezone]',

                '{datetimeForm}': '[data-event-datetime-form]',

                '{datetime}': '[data-event-datetime]',

                '{title}': '[data-event-title]',
                '{description}': '[data-event-description]',

                view: {
                    loading: 'site/loading/small'
                }
            }
        }, function(self) {
            return {
                init: function() {
                },

                '{category} change': function(el, ev) {
                    if(el.val()) {
                        self.form()
                            .show()
                            .html(self.view.loading());

                        self.loadStoryForm(el.val()).done(function(html) {
                            self.form().html(html);

                            var data = self.datetimeForm().htmlData();

                            var yearto;

                            if (!$.isEmpty(data.yearto)) {
                                yearto = parseInt(data.yearto) + 1;
                            } else {
                                yearto = new Date().getFullYear() + 100
                            }

                            $.extend(self.options, {
                                yearfrom: data.yearfrom || 1930,
                                yearto: yearto,
                                allowTime: data.allowtime,
                                allowTimezone: data.allowtimezone,
                                dateFormat: data.dateformat,
                                disallowPast: data.disallowpast,
                                minuteStepping: parseInt(data.minutestepping)
                            });

                            self.datetime().addController('EasySocial.Controller.Story.Events.Datetime', {
                                '{parent}': self
                            });
                        });
                    } else {
                        self.form()
                            .hide()
                            .html('');
                    }
                },

                loadStoryForm: $.memoize(function(id) {
                    return EasySocial.ajax('apps/user/events/controllers/events/loadStoryForm', {
                        id: id
                    });
                }),

                '{story} save': function(element, event, save) {

                    if (save.currentPanel != 'event') {
                        return;
                    }

                    var data = {
                        title: self.title().val(),
                        description: self.description().val(),
                        category: self.category().val()
                    };

                    if (self.options.allowTimezone) {
                        data.timezone = self.timezone().val()
                    }

                    self.datetime().trigger('datetimeExport', [data]);

                    self.options.name = 'event';

                    var task = save.addTask('validateEventForm');

                    self.save(task, data);
                },

                save: function(task, data) {
                    if ($.isEmpty(data.title)
                        || $.isEmpty(data.category)
                        || $.isEmpty(data.start)) {

                        return task.reject($.language('COM_EASYSOCIAL_STORY_EVENT_INSUFFICIENT_DATA'));
                    }

                    if (!$.isEmpty(data.start) && !$.isEmpty(data.end) && data.end < data.start) {
                        return task.reject($.language('COM_EASYSOCIAL_STORY_EVENT_INVALID_START_END_DATETIME'));
                    }

                    task.save.addData(self, data);

                    task.resolve();
                }
            }
        });

        EasySocial.Controller('Story.Events.Datetime', {
            defaultOptions: {
                type: null,

                '{picker}': '[data-picker]',
                '{toggle}': '[data-picker-toggle]',
                '{datetime}': '[data-datetime]'
            }
        }, function(self) {
            return {
                init: function() {
                    self.options.type = self.element.data('event-datetime');

                    var minDate = new $.moment();

                    if (self.parent.options.disallowPast) {
                        // Minus 1 on the date to allow today
                        minDate.date(minDate.date() - 1);
                    } else {
                        minDate.year(self.parent.options.yearfrom);
                    }

                    self.picker()._datetimepicker({
                        component: "es",
                        useCurrent: false,
                        format: self.parent.options.dateFormat,
                        minDate: minDate,
                        maxDate: new $.moment({y: self.parent.options.yearto}),
                        icons: {
                            time: 'glyphicon glyphicon-time',
                            date: 'glyphicon glyphicon-calendar',
                            up: 'glyphicon glyphicon-chevron-up',
                            down: 'glyphicon glyphicon-chevron-down'
                        },
                        sideBySide: false,
                        pickTime: self.parent.options.allowTime == 1,
                        minuteStepping: self.parent.options.minuteStepping,
                        language: lang
                    });

                    var dateObj = $.moment();

                    dateObj.minute(0);
                    dateObj.second(0);

                    // If this is end, manually add 1 hour
                    if (self.options.type == 'end') {
                        dateObj.hour(dateObj.hour() + 1);
                    }

                    self.datetimepicker('setDate', dateObj);
                },

                datetimepicker: function(name, value) {
                    return self.picker().data('DateTimePicker')[name](value);
                },

                '{toggle} click': function() {
                    self.picker().focus();
                },

                '{picker} dp.change': function(el, ev) {
                    self.setDateValue(ev.date.toDate());

                    self.parent.element.trigger('event' + $.String.capitalize(self.options.type), [ev.date]);
                },

                setDateValue: function(date) {
                    // Convert the date object into sql format and set it into the input
                    self.datetime().val(date.getFullYear() + '-' +
                                        ('00' + (date.getMonth()+1)).slice(-2) + '-' +
                                        ('00' + date.getDate()).slice(-2) + ' ' +
                                        ('00' + date.getHours()).slice(-2) + ':' +
                                        ('00' + date.getMinutes()).slice(-2) + ':' +
                                        ('00' + date.getSeconds()).slice(-2));
                },

                '{parent} eventStart': function(el, ev, date) {
                    if (self.options.type === 'start') {
                        return;
                    }

                    // self.datetimepicker('setMinDate', date ? date : new $.moment({y: self.parent.options.yearfrom}));
                },

                '{parent} eventEnd': function(el, ev, date) {
                    if (self.options.type === 'end') {
                        return;
                    }

                    // self.datetimepicker('setMaxDate', date ? date : new $.moment({y: self.parent.options.yearto}));
                },

                '{self} datetimeExport': function(el, ev, data) {
                    data[self.options.type] = self.datetime().val();
                }
            }
        })

        module.resolve();
    });
});

EasySocial.module("story/files", function($){

	var module = this;

	EasySocial.require()
		.library('plupload')
		.view('apps/user/files/story/attachment.item', 'apps/user/files/story/progress')
		.done(function(){

			EasySocial.Controller("Story.Files",
				{
					defaultOptions: {

						"{canvas}": "[data-files-canvas]",
						"{dropsite}": "[data-files-dropsite]",
						"{upload}": "[data-files-upload]",

						"{uploadGroup}": "[data-files-items]",
						"{fileItem}": "[data-files-item]",
						"{removeItem}": "[data-files-item-remove]",
						"{uploadItem}": "[data-files-upload-item]",


						settings: {
							url: null,
							max_file_size: null,
							filters: []
						},

						view: {
							attachment: "apps/user/files/story/attachment.item",
							progress: "apps/user/files/story/progress"
						}
					}
				},
				function(self) { return {

					items: {},

					init: function() {

						// Initialize plupload's settings
						var options = $.extend({
													"{uploadButton}": self.upload.selector,
													"{uploadDropsite}": self.dropsite.selector
												}, {"settings": self.options.settings});


						// Implement plupload controller on the canvas
						self.uploader = self.canvas().addController('plupload', options);

	                    // Plupload
	                    self.plupload = self.uploader.plupload;

	                    // Add the uploader
	                    self.addPlugin("uploader", self.uploader);

	                    // Indicate uploader supports drag & drop
	                    if (!$.IE && self.plupload.runtime=="html5") {
	                        self.canvas().addClass("can-drop-file");
	                    }

	                    // Indicate uploader is ready
	                    self.canvas().addClass("can-upload");

	                    self.setLayout();
					},

					hasItems: function() {
						var hasItem = self.fileItem().length > 0,
							hasUploadItem = self.uploadItem().length > 0;

						return hasItem || hasUploadItem;
					},

					setLayout: function() {

						// Show upload hint when content is empty
						self.canvas()
							.toggleClass("has-items", self.hasItems());
					},

					removeFile: function(id) {

						// Remove photo item
						self.fileItem()
							.where('id', id)
							.remove();

						self.setLayout();
					},

					clearFiles: function(){

						self.fileItem().remove();
						self.uploadItem().remove();

						self.setLayout();
					},

	                removeFileItem: function(id) {

	                    var item = self.getItem(id);
	                    
	                    if (!item) {
	                    	return;
	                    }


	                    // Remove item
	                    self.plupload.removeFile(item.file());
	                    item.element.remove();
	                    delete self.items[id];

	                    self.setLayout();
	                },

	                getItem: function(file) {

	                    var id;

	                    // By id
	                    if ($.isString(file)) {
	                    	id = file;
	                    }

	                    // By file object
	                    if (file && file.id) {
	                    	id = file.id;
	                    }

	                    return self.items[id];
	                },

	                createItem: function(file) {

						// Get the view item
	                    var item = self.view.progress({file: file});

	                    // Add to item group
	                    self.uploadGroup().append(item);

	                    // Keep a copy of the item in our registry
	                    self.items[file.id] = item;

	                    self.setLayout();

	                    self.trigger("QueueCreated", [item]);

	                    return item;
	                },

					"{uploader} FilesAdded": function(el, event, uploader, files) {

	                    // Wrap the entire body in a try...catch scope to prevent
	                    // browser from trying to redirect and load the file if anything goes wrong here.
	                    try {

	                        // Reverse upload ordering as we are prepending.
	                        files.reverse();

	                        $.each(files, function(i, file) {

	                            // The item may have been created before, e.g.
	                            // when plupload error event gets triggered first.
	                            if (self.getItem(file)) return;

	                            self.createItem(file);
	                        });

	                    } catch (e) {
	                        console.error(e);
	                    };

	                    self.setLayout();

						// Begin the upload process
						self.uploader.plupload.start();
					},

					"{uploader} FileUploaded": function(el, event, uploader, file, response) {

						var progress = self.getItem(file),
							attachmentItem = self.view.attachment({"file" : file, "id" : response.id});

						// Insert the preview after the progress
						attachmentItem
							.data('file-id', response.id)
							.addClass('new-item')
							.insertAfter(progress);

						// Remove the progress
						progress.remove();

						self.setLayout();

						// Remove the new-item class since we want it to be displayed on the screen once it is added
						setTimeout(function(){
							attachmentItem.removeClass("new-item");
						}, 1);
					},

	                "{uploader} UploadProgress": function(el, event, uploader, file) {

	                    var item = self.getItem(file);

	                    if (!item) {
	                    	return;
	                    }

		            	var noFilesize = (file.size===undefined || file.size=="N/A");
		            	file.percentage = file.percent + "%";
		                file.filesize   = (noFilesize) ? "" : $.plupload.formatSize(file.size);
		                file.remaining  = (noFilesize) ? "" : $.plupload.formatSize(file.size - (file.loaded || 0));

	                    var percentage = file.percentage;

						// Never use 100% because users might think
						// the photo is completely uploaded when it might
						// still be working.
						if (percentage=="100%") {
							percentage = "99%";
						}

						if (percentage=="0%") {
							percentage = "1%";
						}

						item.find('.upload-progress-bar')
							.width(percentage);

						// Set the percentage
						item.find('.upload-percentage')
							.html(percentage);
	                },


					"{uploader} FileError": function(el, event, uploader, file, response) {

						self.story.setMessage(response.message, "error");

						var uploadingFile = self.uploadingFile;

						if (uploadingFile) {
							uploadingFile.reject();

							delete self.uploadingFile;
						}

						self.setLayout();
					},

					"{uploader} Error": function(el, event, uploader, error) {

						self.story.setMessage(error.message, "error");

						var uploadingFile = self.uploadingFile;

						if (uploadingFile) {
							uploadingFile.reject();

							delete self.uploadingFile;
						}

						// Temporary workaround. Delegated event don't work
						// because the element has been removed.
						self.removeItem()
							.click(function(){
								setTimeout(function(){
									self.setLayout();
								}, 1);
							});

						self.setLayout();
					},

					"{removeItem} click": function(el) {

						var id = el.parent(self.fileItem.selector).data('id');

						// Remove item
						self.removeFile(id);
					},

					//
					// Saving
					//
					"{story} save": function(element, event, save) {

						if (!self.hasItems()) {
							return;
						}

						self.uploadingFile = save.addTask('uploadingFile');
						self.save();
					},

					save: function() {

						var uploadingFile = self.uploadingFile;

						if (!uploadingFile) {
							return;
						}

						var items = self.fileItem();

						if (items.length) {

							var files = []
								save = uploadingFile.save;

							items.each(function(){
								files.push($(this).data('id'));
							});

							save.addData(self, files);

							uploadingFile.resolve();

							delete self.uploadingFile;
						}
					},

					"{story} clear": function() {

						self.clearFiles();
					}
				}}
			);

			// Resolve module
			module.resolve();

		});
});

EasySocial.module("story/friends", function($){

var module = this;

EasySocial.require()
.library("textboxlist")
.language(
	"COM_EASYSOCIAL_STREAM_STORY_WITH",
	"COM_EASYSOCIAL_STREAM_STORY_WITH_JOINER",
	"COM_EASYSOCIAL_STREAM_STORY_WITH_LAST_JOINER",
	"COM_EASYSOCIAL_AND"
)
.done(function(){

	EasySocial.Controller("Story.Friends",
	{
		defaultOptions: {
			"{friendList}": ".es-story-friends-textbox",
			"{textField}": ".es-story-friends-textbox [data-textboxlist-textfield]"
		}
	},
	function(self){ return {

		init: function() {

			self.textField().placeholder();

			// Friend tagging
			self.friendList()
				.textboxlist({
					component: 'es',
					plugin: {
						autocomplete: {
							exclusive : true,
							cache     : false,
							query     : self.search,
							filterItem: self.createMenuItem,

							component: "es",
							modifier: "es-story-friends-autocomplete",
							sticky: true,
							shadow: true
						}
					}
				});
		},

		search: function(keyword) {

			var users = self.getTaggedUsers();

			return EasySocial.ajax(
					   "site/controllers/friends/suggest",
					   {
					   	   "search": keyword,
					   	   "exclude": users
					   });
		},

		getTaggedUsers: function() {

			var users = [];
			var items = $( "[data-textboxlist-item]" );
			if( items.length > 0 )
			{
				$.each( items, function( idx, element ) {
					users.push( $( element ).data('id') );
				});
			}

			return users;
		},

		//
		// Tagging
		//
		createMenuItem: function(item, keyword) {

			item.title = item.screenName;

			var avatar = $(new Image())
				.addClass("textboxlist-menu-avatar")
				.attr({
					src: item.avatar
				}).toHTML();

			item.html     = avatar + ' ' + item.title;
			item.menuHtml = avatar + ' ' + item.title;

			return item;
		},

		//
		// Mentions
		//
		mention: function(mode, query, callback) {

			self.search(query)
				.done(function(users){

					var friends = [];

					$.each(users, function(i, user)
					{
						friends.push(
						{
							id: user.id,
							name: user.screenName,
							avatar: user.avatar,
							type: 'contact'
						});
					});

					callback(friends);
				});
		},

		//
		// Meta
		//
		updateMeta: function() {

			var friendList = self.friendList().controller("textboxlist"),
				friends = friendList.getAddedItems();

			if (friends.length < 1) {
				self.story.setMeta("friends", "");
				return;
			}

			var last = friends.length - 1,
				caption = $.language("COM_EASYSOCIAL_STREAM_STORY_WITH") + " ";

			$.each(friends, function(i, friend){

				// TODO: Get user permalink
				caption += '<a href="' + friend.permalink + '" target="_blank">' + friend.screenName + "</a>";

				// TODO: This is not the right way to join language
				if (i!=last) {
					var joiner = $.language("COM_EASYSOCIAL_STREAM_STORY_WITH_JOINER");

					if (i==last-1) {
						joiner = $.language("COM_EASYSOCIAL_STREAM_STORY_WITH_LAST_JOINER");
					}

					caption += joiner;
				}
			});

			self.story.setMeta("friends", caption);
		},

		"{friendList} addItem": function() {
			self.updateMeta();
		},

		"{friendList} removeItem": function() {
			self.updateMeta();
		},

		"{story} activateMeta": function(el, event, meta) {

			if (meta.name==="friends") {
				setTimeout(function(){
					self.textField().focus();
				}, 1);
			}
		},

		"{story} save": function(el, event, save) {

			var friendList = self.friendList().controller("textboxlist");

			var tags = friendList.getAddedItems().map(function(friend){
				return friend.id;
			});

			save.data['friends_tags'] = tags;
		},

		"{story} clear": function() {

			var friendList = self.friendList().controller("textboxlist");
			friendList.clearItems();
		}

	}});

	// Resolve module
	module.resolve();

});

});

EasySocial.module("story/links", function($){

	var module = this;

	EasySocial
	.require()
	.view("site/links/story/attachment.item")
	.done(function(){

		EasySocial.Controller("Story.Links", {
			defaultOptions: {

				view: {
					linkItem: "site/links/story/attachment.item"
				},

				// urlParser: /(^|\s)((https?:\/\/)?[\w-]+(\.[\w-]+)+\.?(:\d+)?(\/\S*)?)/gi,
				// /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi,
				urlParser: /(^|\s)(https?:\/\/)?(([a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.([a-z]{2,7}))|(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))(:[0-9]{1,5})?(\/.*)?/gi,

				validateUrl: false,

				// Attachment item
				"{linkForm}"        : "[data-story-link-form]",
				"{linkInput}"       : "[data-story-link-input]",

				"{linkContent}"     : "[data-story-link-content]",
				"{linkItem}"        : "[data-story-link-item]",
				"{linkTitle}"       : "[data-story-link-title]",
				"{linkDescription}" : "[data-story-link-description]",
				"{linkImages}"      : "[data-story-link-images]",
				"{linkImage}"       : "[data-story-link-image]",
				"{imageWrapper}": "[data-story-link-image-wrapper]",

				"{linkVideo}"		: "[data-story-link-video]",
				"{titleTextfield}"      : "[data-story-link-title-textfield]",
				"{descriptionTextfield}": "[data-story-link-description-textfield]",

				"{panelButton}"		: "[data-story-link-panel-button]",
				"{attachButton}"    : "[data-story-link-attach-button]",
				"{removeButton}"    : "[data-story-link-remove-button]",
				"{removeThumbnail}"	: "[data-story-link-remove-image]"
			}
		}, function(self, opts, base) {
			
			return {
			
			init: function() {
				self.linkInput().placeholder();
			},

			activateAttachment: function() {

				if (self.doNotFocus) {
					return;
				}

				setTimeout(function(){
					self.linkInput().focus();
					self.doNotFocus = false;
				}, 500);
			},

			//
			// Link manipulation
			//
			links: {},

			currentLink: null,

			crawling: false,

			extractUrls: function(str) {

				var urlParser = self.options.urlParser;
				var urls = str.match(urlParser);

				// Discard non http/https protocols
				if ($.isArray(urls)) {
					return $.map(urls, function(url, i){
						return $.trim(url);
					});
				} else {
					return [];
				}
			},

			fixUrl: function(url) {

				// If there's no protocol, use "http".
				var url = $.uri(url);

				if (!/http|https/.test(url.protocol())) {
					url.setProtocol("http");
				}

				return url.toString();
			},

			getLink: function(urls) {

				// If a block of string was given,
				// extract urls from it.
				if ($.isString(urls)) {
					urls = self.extractUrls(urls);
				}

				// If there are no urls, stop.
				if (urls.length < 0) return;

				// Get only the first url
				var url = urls[0];

				// If this is a new url,
				// create a new link object for it.
				link = self.links[url] || self.createLink(url);

				// When the link is resolved,
				// add link to the attachment item.
				return link;
			},

			createLink: function(url) {

				// Create a new link object
				var link = self.links[url] = $.Deferred();

				// Add url property
				link.url = url;

				self.crawling = true;

				// Get link info from crawler
				EasySocial.ajax('site/controllers/crawler/fetch', {
					urls: [url]
				}).done(function(links) {

					// Get the info about the link
					var info = links[url];

					if (!info) {
						link.reject();
					}

					// Add link info
					// Properties: charset, description, images, keywords, opengraph, title
					link.info = info;

					// Prefer opengraph over general meta
					var og = info.opengraph || {},
						oembed = info.oembed || {};

					// Merge the open graph data and images
					var image = [];

					if (oembed.thumbnail) {
						image.push(oembed.thumbnail);
					}

					if (og.image) {
						image.push(og.image);
					}

					if (info.images) {
						$.merge(image, info.images);
					}

					link.data = {
									title: oembed.title || og.title || info.title,
									desc: oembed.description || og.desc  || info.description,
									url:  url,
									images: image,
									video: (og.video) ? og.video : info.videos
								};

					// Create link item
					link.item = self.view.linkItem(link.data)
									.data("link", link);

					link.item
						.addController("EasySocial.Controller.Story.Links.Item");

					link.resolve(link);
				})
				.fail(function(){
					link.reject();
				})
				.always(function() {
					self.crawling = false;
				});

				return link;
			},

			addLink: function(link) {

				// Add link item to attachment item
				self.linkContent()
					.empty()
					.append(link.item);

				self.linkForm()
					.hide();

				self.currentLink = link;
			},

			removeLink: function() {

				self.linkItem()
					.detach();

				self.linkForm()
					.show();

				self.currentLink = null;
			},

			//
			// Link form
			//
			"{attachButton} click": function() {

				var linkInput = self.linkInput();
				var linkForm  = self.linkForm();
				var url = $.trim(self.linkInput().val());

				// If there's no url, stop.
				if (url==="") {
					return;
				}

				// Fix the url
				url = self.fixUrl(url);

				// Set fixed link back to input box
				self.linkInput().val(url);

				// Set link form as busy
				linkForm.addClass("busy");

				// Get link
				self.getLink(url)
					.done(function(link){
						self.addLink(link);
					})
					.always(function(){
						linkForm.removeClass("busy");
					});
			},

			"{removeButton} click": function(button) {

				self.currentLink.disabled = true;

				self.removeLink();
			},

			"{story.textField} input": $._.debounce(function(textField, event) {

				// Don't look for links if we've already added one
				if (self.currentLink || self.crawling) {
					return;
				}

				// Retrieve the last typed url
				var content = textField.val();
				var urls = self.extractUrls(content);
				var url = urls[urls.length - 1];

				if (!url) {
					return;
				}

				// Check if link has been crawled before
				var url = self.fixUrl(url);
				var link = self.links[url];

				if (link && link.disabled) {
					return;
				}

				if (self.options.validateUrl) {
					var failed = false;

					EasySocial.ajax('site/controllers/crawler/validate', {
						"url": url
					}).done(function() {

						console.log('valid');
						// Set the url as the value
						self.linkInput().val(url);

						// Do not focus when attachment is activated
						self.doNotFocus = true;

						// Trigger links attachment
						self.panelButton().click();

						// Add link
						self.attachButton().click();
					});

					return;
				}

				// Set the url as the value
				self.linkInput().val(url);

				// Do not focus when attachment is activated
				self.doNotFocus = true;

				// Trigger links attachment
				self.panelButton().click();

				// Add link
				self.attachButton().click();

			}, 950),

			//
			// Saving
			//
			"{story} save": function(element, event, save) {
				
				if (!self.currentLink) {
					return;
				}

				var data = {
							title: self.titleTextfield().val(),
							description: self.descriptionTextfield().val(),
							url: self.currentLink.url,
							video: self.linkVideo().val()
						};

				if (!self.removeThumbnail().is(":checked")) {

					data.image = self.imageWrapper('.active')
									.find('img')
									.attr('src');
				}

				save.addData(self, data);
			},

			"{story} clear": function() {

				self.linkInput().val("");

				self.removeLink();
			}
		}});

		EasySocial.Controller('Story.Links.Item', {
			defaultOptions: {

				"{previousImage}"	: "[data-story-link-image-prev]",
				"{nextImage}"		: "[data-story-link-image-next]",
				
				"{image}"			: "[data-story-link-image]",
				"{imageWrapper}": "[data-story-link-image-wrapper]",

				"{imagesWrapper}"	: "[data-story-link-images]",
				"{imageIndex}"		: "[data-story-link-image-index]",
				"{removeThumbnail}"	: "[data-story-link-remove-image]",

				"{imageDimensions}": "[data-story-link-image-dimensions]",
				"{imageWidth}": "[data-image-width]",
				"{imageHeight}": "[data-image-height]",

				"{title}": "[data-story-link-title]",
				"{description}": "[data-story-link-description]",
				"{titleTextfield}"      : "[data-story-link-title-textfield]",
				"{descriptionTextfield}": "[data-story-link-description-textfield]"
			}
		}, function(self, opts, base) { 

			return {

			init: function() {

				// Init dimensions
				self.initDimensions();
			},

			initDimensions: function() {

				// When the images are loaded, set the width and height accordingly.
				self.image()
					.on('load', function() {
						var width = this.naturalWidth;
						var height = this.naturalHeight;

						var wrapper = $(this).parent();

						// Set the width and height on the width and height
						wrapper.find(self.imageWidth.selector)
							.html(width);

						wrapper.find(self.imageHeight.selector)
							.html(height);
					});
			},

			"{removeThumbnail} click" : function() {
				var isChecked = self.removeThumbnail().is(':checked');

				if (isChecked) {
					self.imagesWrapper().hide();
				} else {
					self.imagesWrapper().show();
				}

				self.element.toggleClass("has-images", !isChecked);
			},

			"{previousImage} click" : function() {
				var currentImage = self.imageWrapper('.active');
				var prevImage = currentImage.prev();
				var index = parseInt(self.imageIndex().html());
				var nextIndex = index - 1;

				if (prevImage.length > 0) {
					currentImage.removeClass('active');
					prevImage.addClass('active');

					self.imageIndex().html(nextIndex);
				}
			},

			"{nextImage} click" : function() {
				var currentImage = self.imageWrapper('.active');
				var nextImage = currentImage.next();

				var index = parseInt(self.imageIndex().html());
				var nextIndex = index + 1;

				if (nextImage.length > 0) {
					currentImage.removeClass('active');
					nextImage.addClass('active');

					self.imageIndex().html(nextIndex);
				}
			},

			"{title} click": function() {

				var editingTitle = self.element.hasClass("editing-title");

				self.element.toggleClass("editing-title", !editingTitle);

				if (!editingTitle) {
					self.editTitle();
				}
			},

			editTitleEvent: "click.es.story.editLinkTitle",

			editTitle: function() {

				self.element.addClass("editing-title");

				setTimeout(function(){

					self.titleTextfield()
						.val(self.title().text())
						.focus()[0].select();

					$(document).on(self.editTitleEvent, function(event) {
						if (event.target!==self.titleTextfield()[0]) {
							self.saveTitle("save");
						}
					});
				}, 1);
			},

			saveTitle: function(operation) {

				if (!operation) {
					operation = save;
				}

				var value = self.titleTextfield().val();

				if (operation == 'save') {
					if (value === '') {
						value = self.title().data('default');
					}

					self.title().html(value);
				}

				self.element.removeClass("editing-title");

				$(document).off(self.editTitleEvent);
			},

			"{titleTextfield} keyup": function(el, event) {

				// Escape
				if (event.keyCode==27) {
					self.saveTitle("revert");
				}
			},

			"{description} click": function() {

				var editingDescription = self.element.hasClass("editing-description");

				self.element.toggleClass("editing-description", !editingDescription);

				if (!editingDescription) {
					self.editDescription();
				}
			},

			editDescriptionEvent: "click.es.story.editLinkDescription",

			editDescription: function() {

				self.element.addClass("editing-description");

				setTimeout(function(){

					var descriptionClone = self.description().clone(),
						noDescription = descriptionClone.hasClass("no-description");

					descriptionClone.wrapInner(self.descriptionTextfield());

					if (noDescription) {
						self.descriptionTextfield().val("");
					}

					// self.descriptionTextfield()
					// 	.expandingTextarea();

					self.descriptionTextfield()
						.focus()[0].select();

					$(document).on(self.editDescriptionEvent, function(event) {

						if (event.target!==self.descriptionTextfield()[0]) {
							self.saveDescription("save");
						}
					});
				}, 1);
			},

			saveDescription: function(operation) {
				if (!operation) operation = save;

				var value = self.descriptionTextfield().val().replace(/\n/g, "<br//>");

				switch (operation) {

					case "save":

						var noValue = (value==="");

						self.description()
							.toggleClass("no-description", noValue);

						if (noValue) {
							value = self.descriptionTextfield().attr("placeholder");
						}

						self.description()
							.html(value);
						break;

					case "revert":
						break;
				}

				self.element.find(".textareaClone").remove();

				self.element.removeClass("editing-description");

				$(document).off(self.editDescriptionEvent);
			},

			"{descriptionTextfield} keyup": function(el, event) {
				// Escape
				if (event.keyCode==27) {
					self.saveDescription("revert");
				}
			}
		}
		});

		// Resolve module
		module.resolve();

	});
});

EasySocial.module("story/locations", function($){

	var module = this;

	EasySocial.require()
	.library(
		"gmaps",
		"scrollTo",
		"image"
	)
	.view("site/location/story.suggestion")
	.language(
		"COM_EASYSOCIAL_LOCATION_PERMISSION_ERROR",
		"COM_EASYSOCIAL_LOCATION_TIMEOUT_ERROR",
		"COM_EASYSOCIAL_LOCATION_UNAVAILABLE_ERROR",
		"COM_EASYSOCIAL_STREAM_AT"
	)
	.done(function() {

		// Constants
		var KEYCODE = {
			BACKSPACE: 8,
			COMMA: 188,
			DELETE: 46,
			DOWN: 40,
			ENTER: 13,
			ESCAPE: 27,
			LEFT: 37,
			RIGHT: 39,
			SPACE: 32,
			TAB: 9,
			UP: 38
		};

		EasySocial.Controller("Story.Locations",
		{
			defaultOptions: {

				view: {
					suggestion: "site/location/story.suggestion"
				},

				map: {
					lat: 0,
					lng: 0
				},

				"{base}": "[data-story-location]",
				"{form}": "[data-story-location-form]",

				"{textField}"   	: "[data-story-location-textField]",
				"{detectButton}"	: "[data-story-location-detect-button]",

				"{autocomplete}"	: "[data-story-location-autocomplete]",
				"{suggestions}"		: "[data-story-location-suggestions]",
				"{suggestion}"		: "[data-story-location-suggestion]",

				"{textbox}"			: "[data-story-location-textbox]",
				"{removeButton}"	: "[data-story-location-remove-button]",

				"{map}"     : "[data-story-location-map]",
				"{mapImage}": "[data-story-location-map-image]",

				"{meta}": "[data-story-meta-location]",
			}
		},
		function(self, opts) { return {

			init: function() {

				// Only show auto-detect button if the browser supports geolocation
				if (navigator.geolocation) {
					self.base().addClass("is-detectable");
					// self.detectButton().show();
				}

				// Add placeholder support for IE9
				self.textField().placeholder();

				// Allow textfield input only when controller is implemented
				self.textField().removeAttr("disabled");
			},

			"{window} resize": $.debounce(function() {

				var currentLocation = self.currentLocation;

				if (!currentLocation) return;

				var mapImage = self.mapImage();

				if (mapImage.data("width") !== mapImage.width()) {

					var coords = currentLocation.geometry.location,
						lat = coords.lat(),
						lng = coords.lng();

					self.navigate(lat, lng);
				}

			}, 250),

			navigate: function(lat, lng) {

				var mapImage = self.mapImage(),
					width    = mapImage.width(),
					height   = mapImage.height(),
					url =
						$.GMaps.staticMapURL({
							size: [width, height],
							lat: lat,
							lng: lng,
							sensor: true,
							scale: 2,
							markers: [
								{lat: lat, lng: lng}
							]
						});

				$.Image.get(url)
					.done(function() {
						mapImage.css({
							"backgroundImage": $.cssUrl(url),
							"backgroundSize": "cover",
							"backgroundPosition": "center center"
						});

						self.base().addClass("has-location");
					});
			},

			// Memoized locations
			locations: {},

			lastQueryAddress: null,

			"{textField} keypress": function(textField, event) {

				switch (event.keyCode)
				{
					case KEYCODE.UP:

						var prevSuggestion = $(
							self.suggestion(".active").prev(self.suggestion.selector)[0] ||
							self.suggestion(":last")[0]
						);

						// Remove all active class
						self.suggestion().removeClass("active");

						prevSuggestion
							.addClass("active")
							.trigger("activate");

						self.suggestions()
							.scrollTo(prevSuggestion, {
								offset: prevSuggestion.height() * -1
							});

						event.preventDefault();

						break;

					case KEYCODE.DOWN:

						var nextSuggestion = $(
							self.suggestion(".active").next(self.suggestion.selector)[0] ||
							self.suggestion(":first")[0]
						);

						// Remove all active class
						self.suggestion().removeClass("active");

						nextSuggestion
							.addClass("active")
							.trigger("activate");

						self.suggestions()
							.scrollTo(nextSuggestion, {
								offset: nextSuggestion.height() * -1
							});

						event.preventDefault();

						break;

					case KEYCODE.ENTER:

						var activeSuggestion = self.suggestion(".active"),
							location = activeSuggestion.data("location");
							self.set(location);

						self.hideSuggestions();
						break;

					case KEYCODE.ESCAPE:
						self.hideSuggestions();
						break;
				}

			},

			"{textField} keyup": function(textField, event) {

				switch (event.keyCode) {

					case KEYCODE.UP:
					case KEYCODE.DOWN:
					case KEYCODE.LEFT:
					case KEYCODE.RIGHT:
					case KEYCODE.ENTER:
					case KEYCODE.ESCAPE:
						// Don't repopulate if these keys were pressed.
						break;

					default:
						var address = $.trim(textField.val());

						if (address==="") {
							self.base().removeClass("has-location");
							self.hideSuggestions();
						}

						// if (address==self.lastQueryAddress) return;

						var locations = self.locations[address];

						// If this location has been searched before
						if (locations) {

							// And set our last queried address to this address
							// so that it won't repopulate the suggestion again.
							self.lastQueryAddress = address;

							// Just use cached results
							self.suggest(locations);

						// Else ask google to find it out for us
						} else {

							self.lookup(address);
						}
						break;
				}
			},

			lookup: $.debounce(function(address) {

				self.base().addClass("is-busy");

				EasySocial.ajax('site/controllers/location/getLocations', {
					query: address
				}).done(function(locations) {
					self.base().removeClass("is-busy");

					// Store a copy of the results
					self.locations[address] = locations;

					// Suggestion locations
					self.suggest(locations);

					self.lastQueryAddress = address;
				}).fail(function(msg) {
					console.log(msg);
				});
			}, 250),

			suggest: function(locations) {

				var suggestions = self.suggestions();

				// Clear location suggestions
				suggestions
					.empty();

				if (locations.length < 0) return;

				$.each(locations, function(i, location) {

					// Create suggestion and append to list
					self.view.suggestion({
							location: location
						})
						.data("location", location)
						.appendTo(suggestions);
				});

				self.showSuggestions();
			},

			showSuggestions: function() {

				self.focusSuggestion = true;

				self.element.find(".es-story-footer")
					.addClass("swap-zindex");

				self.story.clearMessage();

				setTimeout(function(){

					self.autocomplete().addClass("active");

					var doc = $(document),
						hideOnClick = "click.es.story.location";

					doc
						.off(hideOnClick)
						.on(hideOnClick, function(event){

							// Collect list of bubbled elements
							var targets = $(event.target).parents().andSelf();

							if (targets.filter(self.element).length > 0) return;

							doc.off(hideOnClick);

							self.hideSuggestions();
						});

				}, 500);
			},

			hideSuggestions: function() {

				self.focusSuggestion = false;

				self.autocomplete().removeClass("active");

				$(document).off("click.es.story.location");

				setTimeout(function(){

					if (self.focusSuggestion) return;

					self.element.find(".es-story-footer")
						.removeClass("swap-zindex");

				}, 500);
			},

			"{suggestion} activate": function(suggestion, event) {

				var location = suggestion.data("location");

				self.navigate(
					location.latitude,
					location.longitude
				);
			},

			"{suggestion} mouseover": function(suggestion) {

				// Remove all active class
				self.suggestion().removeClass("active");

				suggestion
					.addClass("active")
					.trigger("activate");
			},

			"{suggestion} click": function(suggestion, event) {

				var location = suggestion.data("location");

				self.set(location);

				self.hideSuggestions();
			},

			set: function(location) {

				self.currentLocation = location;

				var process = $.Deferred();

				if ($.isEmpty(location.fulladdress)) {
					self.getAddress(location.latitude, location.longitude)
						.done(function(address) {
							location.fulladdress = location.name + ', ' + address;

							process.resolve(location);
						});
				} else {
					process.resolve(location);
				}

				process.done(function(location) {
					self.navigate(location.latitude, location.longitude);

					self.textField().val(location.fulladdress);

					self.lastQueryAddress = location.address;

					var link =
							$('<a href="javascript: void(0);" data-story-meta-location>')
								.html(location.fulladdress)
								.toHTML(),

						caption = $.language("COM_EASYSOCIAL_STREAM_AT") + " " + link;

					self.story.setMeta("location", caption);

					self.base().addClass("has-location");
				});
			},

			unset: function() {

				self.currentLocation = null;

				self.textField().val('');

				self.story.removePanelCaption("locations");

				self.mapImage().attr("src", "");

				self.story.setMeta("location", "");

				self.base().removeClass("has-location");
			},

			activatePanel: function() {

				setTimeout(function(){
					self.textField().focus();
				}, 500);
			},

			deactivatePanel: function() {

				var location = self.currentLocation;

				if (location) {
					self.set(location);
				}
			},

			detectTimer: null,

			"{detectButton} click": function() {

				var story = self.story,
					textbox = self.textbox();

				self.base().addClass("is-busy");

				clearTimeout(self.detectTimer);

				self.detectTimer = setTimeout(function(){
					story.clearMessage();
					story.setMessage($.language("COM_EASYSOCIAL_LOCATION_PERMISSION_ERROR"));
					self.base().removeClass("is-busy");
				}, 8000);



				$.GMaps.geolocate({
					success: function(position) {

						// story.clearMessage();

						EasySocial.ajax('site/controllers/location/getLocations', {
							latitude: position.coords.latitude,
							longitude: position.coords.longitude
						}).done(function(locations) {
							self.suggest(locations);
							self.textField().focus();
						}).fail(function(msg) {
							console.log(msg);
						});
					},
					error: function(error) {

						story.clearMessage();

						var message = "";

						switch (error.code) {

							case 1:
								message = $.language("COM_EASYSOCIAL_LOCATION_PERMISSION_ERROR");
								break;

							case 2:
								message = $.language("COM_EASYSOCIAL_LOCATION_TIMEOUT_ERROR");
								break;

							case 3:
							default:
								message = $.language("COM_EASYSOCIAL_LOCATION_UNAVAILABLE_ERROR");
								break;
						}

						story.setMessage(message);
					},
					always: function() {
						clearTimeout(self.detectTimer);
						self.base().removeClass("is-busy");
					}
				});
			},

			"{removeButton} click": function() {
				self.unset();
				self.hideSuggestions();
			},

			"{meta} click": function() {
				self.story.activateMeta("location");
			},

			"{story} activateMeta": function(el, event, meta) {

				if (meta.name==="location") {
					setTimeout(function(){
						self.textField().focus();
					}, 1);
				}
			},

			"{story} save": function(event, element, save) {

				var currentLocation = self.currentLocation;

				if (!currentLocation) return;

				var task = save.addTask('saveLocation');

				if ($.isEmpty(currentLocation.fulladdress)) {
					self.getAddress(currentLocation.latitude, currentLocation.longitude).done(function(address) {
						currentLocation.fulladdress = currentLocation.name + ', ' + address;

						self.save(task, currentLocation);
					});
				} else {
					self.save(task, currentLocation);
				}
			},

			getAddress: $.memoize(function(latitude, longitude) {
				var process = $.Deferred(),
					geocoder = new google.maps.Geocoder(),
					latlng = new google.maps.LatLng(latitude, longitude);

				geocoder.geocode({
					'latLng': latlng
				},
				function(results, status) {
					if (status == google.maps.GeocoderStatus.OK) {
						process.resolve(results[0].formatted_address);
					}
				});

				return process;
			}, function(lat, lng) {
				return lat + ',' + lng;
			}),

			save: function(task, location) {
				task.save.data['locations_short_address'] = location.name;
				task.save.data['locations_lat'] = location.latitude;
				task.save.data['locations_lng'] = location.longitude;
				task.save.data['locations_formatted_address'] = location.fulladdress;
				task.save.data['locations_data'] = JSON.stringify(location);

				task.resolve();
			},

			"{story} clear": function() {

				self.unset();
				self.hideSuggestions();
			}
		}});

		// Resolve module
		module.resolve();

	});

});

EasySocial.module("story/mood", function($) {

var module = this;

EasySocial.require()
	.language(
		"COM_EASYSOCIAL_MOOD_FEELING_CUSTOM"
	)
	.done(function() {

		// Constants
		var KEYCODE = {
			BACKSPACE: 8,
			COMMA: 188,
			DELETE: 46,
			DOWN: 40,
			ENTER: 13,
			ESCAPE: 27,
			LEFT: 37,
			RIGHT: 39,
			SPACE: 32,
			TAB: 9,
			UP: 38
		};

		EasySocial.Controller("Story.Mood", {

			defaultOptions: {

				"{base}": "[data-story-mood]",

				"{presets}": "[data-story-mood-presets]",
				"{preset}": "[data-story-mood-preset]",

				"{verb}": "[data-story-mood-verb]",
				"{verbType}": "[data-story-mood-verb-type]",
				"{textField}": "[data-story-mood-textfield]",

				"{removeButton}": "[data-story-mood-remove-button]"
			}
		},
		function(self, opts) { return {

			init: function() {

				self.reset();

				// Add placeholder support for IE9
				self.textField().placeholder();
			},

			setLayout: function() {

				var base = self.base(),
					textField = self.textField();

				base.toggleClass("is-empty", textField.val()==="");
			},

			currentMood: {},

			resetMood: function() {

				self.currentMood = {
					icon: '',
					verb: '',
					subject: '',
					text: '',
					custom: false
				};

				self.preset().removeClass("is-disabled");

				self.story.setMeta("mood", "");
			},

			setMood: function(type, content) {

				var currentMood = self.currentMood;

				if ($.isPlainObject(type)) {
					$.extend(currentMood, type);
				} else {
					currentMood[type] = content;
				}

				// This toggles the preset selection
				self.base().toggleClass("using-preset", !currentMood.custom);

				self.updateMeta();

				self.setLayout();
			},

			getVerb: function() {
				return self.verbType(".active").data("storyMoodVerbType") || "feeling";
			},

			reset: function() {

				self.selecting = true;

				self.resetMood();

				self.preset()
					.removeClass("is-disabled");

				self.textField()
					.val("")
					.focus();

				self.setLayout();

				self.base()
					.removeClass("using-preset hide-preset");

				self.selecting = false;
			},

			updateMeta: function() {

				var currentMood = self.currentMood,
					icon = currentMood.icon ? '<i class="es-emoticon ' + currentMood.icon + '"></i> ' : '';

				self.verbType()
					.removeClass("active")
					.filterBy("storyMoodVerbType", currentMood.verb)
					.addClass("active");

				self.story.setMeta("mood", icon + currentMood.text);
			},

			"{preset} click": function(preset) {

				// Create mood object
				var mood = {
					icon       : preset.data("storyMoodIcon"),
					verb       : preset.data("storyMoodVerb"),
					subject    : preset.data("storyMoodSubject"),
					text       : preset.data("storyMoodText"),
					subjectText: preset.data("storyMoodSubjectText"),
					custom     : false,
				};

				self.selecting = true;

				// Update textfield and refocus
				self.textField()
					.val(mood.subjectText)
					.focus();

				// Update meta
				self.setMood(mood);

				self.selecting = false;
			},

			"{textField} keydown": function(textField, event) {

				self.update();
			},

			"{textField} keyup": function(textField, event) {

				self.update();
			},

			"{textField} input": function(textField, event) {

				// If user is selecting from preset,
				// don't do anything.
				if (self.selecting) return;

				// Get text
				var text = textField.val();

				if (!text) {
					self.reset();
					return;
				}

				// If user modifies a preset, set mood to custom.
				// This *might* cause the preset selection to show if there are matching keywords.
				var currentMood = self.currentMood,
					presetModified = !currentMood.custom && (text !== currentMood.subjectText);

					if (presetModified) {
						self.setMood("custom", true);
					}

				// Highlight preset candidates
				var candidates =
					self.preset()
						.filter(function(){
							var preset = $(this),
								isDisabled = preset.data("storyMoodSubjectText").indexOf(text) !== 0;
							preset.toggleClass("is-disabled", isDisabled);
							return !isDisabled;
						});

				// Hide preset seleection if there is no candidate
				self.base().toggleClass("hide-preset", candidates.length < 1);

				// Create mood object
				var verb = self.getVerb(),
					mood = {
						verb   : verb,
						subject: '',
						custom : true,
						text   : $.language("COM_EASYSOCIAL_MOOD_" + verb.toUpperCase() + "_CUSTOM", text),
					};

				// Set custom mood
				self.setMood(mood);
			},

			"{removeButton} click": function() {

				self.reset();
			},

			"{story} activateMeta": function(el, event, meta) {

				if (meta.name==="mood") {
					setTimeout(function(){
						self.textField().focus();
					}, 1);
				}
			},

			"{story} save": function(event, element, save) {

				var currentMood = self.currentMood;

				if (!currentMood.verb) return;

				save.data.mood_icon    = currentMood.icon;
				save.data.mood_verb    = currentMood.verb;
				save.data.mood_subject = currentMood.subject;
				save.data.mood_custom  = currentMood.custom;
				save.data.mood_text    = currentMood.text;
			},

			"{story} clear": function() {
				self.reset();
			}
		}});

		// Resolve module
		module.resolve();

	});

});
EasySocial.module("story/photos", function($){

	var module = this;

	EasySocial.require()
		.script("albums/uploader")
		.done(function() {

			EasySocial.Controller("Story.Photos", {
					defaultOptions: {

						"{albumView}"     : "[data-album-view]",
						"{albumContent}"  : "[data-album-content]",
						"{uploadButton}"  : "[data-album-upload-button]",

						"{photoItemGroup}": "[data-photo-item-group]",
						"{photoItem}"     : "[data-photo-item]",
						"{photoImage}"    : "[data-photo-image]",
						"{photoRemoveButton}": "[data-photo-remove-button]",
						"{uploadItem}"    : "[data-photo-upload-item]",

						"{uploadRemoveButton}": ".upload-remove-button",
					}
				},
				function(self) { return {

					init: function() {

						// I have access to:
						// self.story
						// self.attachmentButton()
						// self.attachmentItem()
						// self.attachmentContent()
						// self.attachmentToolbar()
						// self.attachmentDragHandle()
						// self.attachmentRemoveButton()

						self.uploader =
							self.albumView()
								.addController(
									EasySocial.Controller.Albums.Uploader,
									$.extend({
										"{uploadButton}"   : self.uploadButton.selector,
										"{uploadItemGroup}": self.photoItemGroup.selector,
										"{uploadDropsite}" : self.albumContent.selector
									},
									{settings: self.options.uploader})
								);

						// Difference from album viewer
						self.photoItemGroup()
							.css("opacity", 1);

						self.addPlugin("uploader", self.uploader);

						self.setLayout();
					},

					hasItems: function() {

						var hasPhotoItem  = self.photoItem().length > 0,
							hasUploadItem = self.uploadItem().length > 0;

						return hasPhotoItem || hasUploadItem;
					},

					setLayout: function() {

						// Show upload hint when content is empty
						self.albumView()
							.toggleClass("has-photos", self.hasItems());
					},

					activateAttachment: function() {

						// self.initialize();

						// if (self.attachedPhotos.length < 1) {
						// 	self.showPhotosForm();
						// }
					},

					removePhoto: function(id) {

						// Remove photo item
						self.photoItem()
							.filterBy('photoId', id)
							.remove();

						self.setLayout();
					},

					clearPhoto: function(){

						self.photoItem().remove();
						self.uploadItem().remove();

						self.setLayout();
					},

					"{uploader} FilesAdded": function() {
						self.setLayout();
						self.uploader.start();
					},

					"{uploader} FileUploaded": function(el, event, uploader, file, response) {

						var uploadItem = self.uploader.getItem(file),
							photoItem = $($.parseHTML($.trim(response.html)));

							photoData = response.data;

							// Initialize photo item
							photoItem
								.data("photo", photoData)
								.addClass("new-item")
								.insertAfter(uploadItem.element);

							self.uploader.removeItem(file.id);

							self.setLayout();

							setTimeout(function(){
								photoItem.removeClass("new-item");
							}, 1);

							self.save();
					},

					"{uploader} FileError": function(el, event, uploader, file, response) {

						self.story.setMessage(response.message, "error");

						var uploadingPhoto = self.uploadingPhoto;

						if (uploadingPhoto) {
							uploadingPhoto.reject();
							delete self.uploadingPhoto;
						}

						self.uploader.removeItem(file.id);

						self.setLayout();
					},

					"{uploader} Error": function(el, event, uploader, error) {

						self.story.setMessage(error.message, "error");

						var uploadingPhoto = self.uploadingPhoto;

						if (uploadingPhoto) {
							uploadingPhoto.reject();
							delete self.uploadingPhoto;
						}

						// Temporary workaround. Delegated event don't work
						// because the element has been removed.
						self.uploadRemoveButton()
							.click(function(){
								setTimeout(function(){
									self.setLayout();
								}, 1);
							});

						self.setLayout();
					},

					"{photoRemoveButton} click": function(photoRemoveButton) {

						var photoId =
							photoRemoveButton
								.parent(self.photoItem.selector)
								.data("photoId");

						self.removePhoto(photoId);
					},

					//
					// Saving
					//

					"{story} save": function(element, event, save) {

						if (!self.hasItems()) {
							return;
						}

						self.uploadingPhoto = save.addTask("uploadingPhoto");
						self.save();
					},

					save: function() {

						var uploadingPhoto = self.uploadingPhoto;

						if (!uploadingPhoto) return;

						var uploadItems = self.uploadItem();

						if (uploadItems.length < 1) {

							var photos = [],
								save = uploadingPhoto.save;

							self.photoItem().each(function(){
								photos.push($(this).data("photoId"));
							});

							save.addData(self, photos);

							uploadingPhoto.resolve();

							delete self.uploadingPhoto;
						}
					},

					"{story} clear": function() {

						self.clearPhoto();
					}
				}}
			);

			// Resolve module
			module.resolve();

		});
});

EasySocial.module('story/polls', function($) {
    var module = this;

    EasySocial.require()
    .library('datetimepicker')
    .view('site/loading/small')
    .language('COM_EASYSOCIAL_STORY_EVENT_INSUFFICIENT_DATA', 'COM_EASYSOCIAL_STORY_EVENT_INVALID_START_END_DATETIME')
    .done(function() {
        EasySocial.Controller('Story.Polls', {
            defaultOptions: {
                '{base}': '[data-story-event-base]',

                '{category}': '[data-story-event-category]',
                '{form}': '[data-story-event-form]',

                '{timezone}': '[data-event-timezone]',

                '{datetimeForm}': '[data-event-datetime-form]',

                '{datetime}': '[data-event-datetime]',

                '{title}': '[data-event-title]',
                '{description}': '[data-event-description]',

                view: {
                    loading: 'site/loading/small'
                }
            }
        }, function(self) {
            return {
                init: function() {

                },

                '{story} save': function(element, event, save) {

                    if (save.currentPanel != 'polls') {
                        return;
                    }

                    var pollController = element.find('[data-polls]').controller('EasySocial.Controller.Polls');

                    self.options.name = 'polls';

                    var task = save.addTask('validatePollsForm');
                    self.save(task, pollController);
                },

                save: function(task, pollController) {

                    var valid = pollController.validateForm();

                    if (! valid) {
                        return task.reject('Error validating polls inputs. Please make sure all the required fields are filled in.');
                    }

                    var data = pollController.toData();
                    task.save.addData(self, data);

                    task.resolve();
                }
            }
        });

        module.resolve();
    });
});

EasySocial.module("story/quickpost", function($){

	var module = this;

	EasySocial.Controller("Story.Quickpost", {
		defaultOptions: {
			"{submitButton}": "[data-quickpost-submit]",
			"{content}": "[data-quickpost-content]",
			"{message}": "[data-quickpost-message]",
			"{privacyButton}": "[data-story-privacy]",
			"{footer}": "[data-story-footer]"
		}
	}, function(self) { return {

		init: function() {
		},

		"{submitButton} click": function(el) {
			id = el.data('quickpost-userid');
            content = self.content().val();
            
            EasySocial.ajax('site/controllers/story/createFromModule', {
                'target': id,
                'privacy': 'public',
                'content': content
            }).done(function(successfull, message, html, id) {

            	// If not successfull we should just display the message as html codes
            	if (!successfull) {
            		self.message()
            			.html(message)
            			.addClass('alert fade in alert-warning');
            		return;
            	}

            	self.message().html(message)
            		.addClass('alert fade in alert-success');

            	// Clear the textfield.
            	self.content().val('');
            	
                self.trigger("create", [html, id]);

            }).fail(function(result) {
                self.message().html(result.message);
                self.message().addClass('alert fade in alert-warning');                
            });
		},

		"{privacyButton} click": function(el) {
			
			setTimeout(function(){
				var isActive = el.find("[data-es-privacy-container]").hasClass("active");
				self.footer().toggleClass("allow-overflow", isActive);
			}, 1);
		}
	}});

	// Resolve module
	module.resolve();
});

EasySocial.module( 'story/tasks', function($)
{
	var module 	= this;

	EasySocial.require()
	.view( 'apps/group/tasks/story/attachment.item' )
	.done(function()
	{
		EasySocial.Controller( 'Story.Tasks',
		{
			defaultOptions:
			{
				view:
				{
					taskItem: "apps/group/tasks/story/attachment.item"
				},

				'{form}'	: '[data-story-tasks-form]',
				'{input}'	: '[data-story-tasks-input]',
				'{list}'	: '[data-story-tasks-list]',
				'{milestone}'	: '[data-story-tasks-milestone]'
			}
		},
		function( self )
		{
			return {
				init: function()
				{
					self.implementForm();
				},

				implementForm: function()
				{
					self.form().implement( EasySocial.Controller.Story.Tasks.Form , { '{parent}' : self });
				},

				createInputRow: function( currentElement )
				{
					var item  = self.view.taskItem();

					$( item )
						.implement( EasySocial.Controller.Story.Tasks.Form , { '{parent}' : self })
						.appendTo( self.list() );


					// After appending, set the focus to the new item's input
					$( item ).find( 'input' ).focus();
				},

				"{story} save": function(element, event, save)
				{
					var values 	= new Array();

					$.each( self.input() , function( i , item )
					{
						if( $( item ).val() != '' )
						{
							values.push( $(item).val() );	
						}
					});

					var data = {
									items 		: values,
									milestone 	: self.milestone().val()
								};

					save.addData( self , data );
				},

				"{story} clear": function()
				{
					// self.linkInput().val("");

					// self.removeLink();
				}
			}
		});

		EasySocial.Controller( 'Story.Tasks.Form',
		{
			defaultOptions:
			{
				'{input}'	: '[data-story-tasks-input]',
				'{remove}'	: '[data-story-tasks-remove]'
			}
		},
		function( self )
		{
			return {
				init: function()
				{
				},

				'{input} keyup' : function( el , event )
				{
					// Enter key
					if(event.keyCode == 13)
					{
						self.parent.createInputRow( self.element );
					}
				},

				'{remove} click' : function( el , event )
				{
					self.element.remove();
				}
			}
		});

		module.resolve();
	});
});
EasySocial.module("story/videos", function($){

	var module = this;

	EasySocial.require()
	.library('image', 'plupload')
	.language(
		"COM_EASYSOCIAL_VIDEOS_STORY_SELECT_CATEGORY",
		"COM_EASYSOCIAL_VIDEOS_STORY_ENTER_VIDEO",
		"COM_EASYSOCIAL_VIDEOS_STORY_PROCESSING_VIDEO",
		"COM_EASYSOCIAL_VIDEOS_STORY_CLICK_INSERT_VIDEO",
		"COM_EASYSOCIAL_VIDEOS_STORY_NO_VIDEO_DETECTED"
	)
	.done(function($){

	EasySocial.Controller("Story.Videos", {
		defaultOptions: {

			// This is the main wrapper for the form
			"{form}": "[data-video-form]",

			// Video links
			"{insertVideo}": "[data-insert-video]",
			"{videoLink}": "[data-video-link]",
			"{videoCategory}": "[data-video-category]",

			// Video uploads
			"{uploaderForm}": "[data-video-uploader]",
			"{uploaderButton}": "[data-video-uploader-button]",
			"{uploaderDropsite}": "[data-video-uploader-dropsite]",
			"{uploaderProgressBar}": "[data-video-uploader-progress-bar]",
			"{uploaderProgressText}": "[data-video-uploader-progress-text]",

			// Video preview
			"{removeButton}": "[data-remove-video]",
			"{previewImageWrapper}": "[data-video-preview-image]",
			"{previewTitle}": "[data-video-preview-title]",
			"{title}": "[data-video-title]",
			"{previewDescription}": "[data-video-preview-description]",
			"{description}": "[data-video-description]"
		}
	}, function(self, opts, base) { return {

			init: function() {


				// If video uploader form doesn't exist, perhaps the admin already disabled this
				if (self.uploaderForm().length == 0) {
					return;
				}

				// Implement plupload
				self.uploader = self.uploaderForm().addController("plupload", $.extend({
						"{uploadButton}": self.uploaderButton.selector,
						"{uploadDropsite}": self.uploaderDropsite.selector
					}, opts.uploader)
				);

				self.plupload = self.uploader.plupload;
			},

			isProcessed: function() {
				self.form().switchClass('is-processed');

				self.processing = false;
			},

			isUploading: function() {
				self.form().switchClass('is-uploading');
			},

			isProcessing: function() {
				self.form().switchClass('is-processing');

				self.processing = true;
			},

			isInitial: function() {
				self.form().switchClass('is-waiting');
			},

			currentCategory: null,
			processing: false,
			video: null,
			videoType: null,

			updatePreview: function(type, data, imageUrl) {

				self.video = {
					"type": type,
					"title": data.title,
					"description": data.description,
					"link": data.link,
					"id": data.id ? data.id : '',
					"isEncoding": false
				};

				// Update the title
				if (data.title) {
					self.previewTitle().html(data.title);
				}

				// Update the description
				if (data.description) {
					self.previewDescription().html(data.description);
				}

				// Load the image
				$.Image.get(imageUrl).done(function(image){
					image.appendTo(self.previewImageWrapper());
				});

			},

			resetProgress: function() {

				// Reset the progress bar
				self.uploaderProgressBar().css('width', '0%');
				self.uploaderProgressText().html('0%');
			},

			clearForm: function(resetVideo) {

				if (resetVideo) {
					self.video = null;
				}

				// Set to initial position
				self.isInitial();

				// Reset all the form values
				self.videoLink().val('');

				self.previewImageWrapper().html('');

				self.previewTitle().html('');
				self.title().val('');

				self.previewDescription().html('');
				self.description().val('');
			},

			editTitleEvent: "click.es.story.video.editLinkTitle",
			editDescriptionEvent: "click.es.story.video.editLinkDescription",

			editTitle: function() {

				// Apply the class to the form wrapper
				self.form().addClass('editing-title');

				setTimeout(function(){

					self.title()
						.val(self.previewTitle().text())
						.focus()[0]
						.select();

					$(document).on(self.editTitleEvent, function(event) {
						if (event.target !== self.title()[0]) {
							self.saveTitle("save");
						}
					});

				}, 1);
			},

			saveTitle: function(operation) {

				if (!operation) {
					operation = 'save';
				}

				var value = self.title().val();

				if (operation == 'save') {
					self.previewTitle().html(value);
				}

				// Remove the editing title class
				self.form().removeClass('editing-title');

				self.video.title = value;

				$(document).off(self.editTitleEvent);
			},

			checkVideoStatus: function(videoId) {
				EasySocial.ajax('site/controllers/videos/status', {
					"id": videoId,
					"uid": opts.video.uid,
					"type": opts.video.type,
					"createStream": 0
				}).done(function(permalink, progress, data, thumbnail) {

					if (progress === 'done') {

						self.processing = false;

						// Set the progress bar to 100%
						self.uploaderProgressBar().css('width', '100%');
						self.uploaderProgressText().html('100%');

						// Update the state
						self.isProcessed();

						// Update the preview
						self.updatePreview('upload', data, thumbnail);

						// Reset the progress bar
						self.resetProgress();

						return;
					}

					// Set the progress bar width
					var progress = progress + '%';
					self.uploaderProgressBar().css('width', progress);
					self.uploaderProgressText().html(progress);

					// This should run in a loop
					self.checkVideoStatus(videoId);
				});
			},

			editDescription: function() {

				self.form().addClass('editing-description');

				setTimeout(function(){

					var descriptionClone = self.previewDescription().clone();
					var noDescription = descriptionClone.hasClass("no-description");

					descriptionClone.wrapInner(self.description());

					if (noDescription) {
						self.description().val("");
					}

					self.description()
						.val(self.previewDescription().text())
						.focus()[0].select();

					$(document).on(self.editDescriptionEvent, function(event) {

						if (event.target!==self.description()[0]) {
							self.saveDescription("save");
						}
					});
				}, 1);
			},

			saveDescription: function(operation) {

				if (!operation) {
					operation = 'save';
				}

				var value = self.description().val().replace(/\n/g, "<br//>");

				switch (operation) {

					case "save":

						var noValue = (value==="");

						self.previewDescription()
							.toggleClass("no-description", noValue);

						if (noValue) {
							value = self.description().attr("placeholder");
						}

						self.previewDescription()
							.html(value);

						self.video.description = value;
						break;

					case "revert":
						break;
				}

				self.form().find(".textareaClone").remove();

				self.form().removeClass("editing-description");

				$(document).off(self.editDescriptionEvent);
			},

			"{uploaderForm} FilesAdded": function() {

				// Set the state to uploading
				self.isUploading();

				// Start the upload
				self.plupload.start();
			},

			"{uploaderForm} FileUploaded": function(uploaderForm, event, uploader, file, response) {

				// Server thrown an error
				if (response.error) {

					// Set the message
					self.clearMessage();
					self.setMessage(response.error);

					// Display the video upload form again
					self.clearForm(true);

					return false;
				}

				// If the server isn't encoding on the fly, we should display some message
				if (!response.isEncoding) {

					self.processing = false;

					// Set the progress bar to 100%
					self.uploaderProgressBar().css('width', '100%');
					self.uploaderProgressText().html('100%');

					// Update the state
					self.isProcessed();

					// Update the preview
					self.updatePreview('upload', response.data, response.thumbnail);

					self.video.isEncoding = true;

					// Reset the progress bar
					self.resetProgress();

					return;
				}

				self.processing = true;

				// Update the progress since the video needs to be converted.
				self.checkVideoStatus(response.data.id);
			},

			"{uploaderForm} Error": function(el, event, uploader, error) {

				// Get the error message
				var message = opts.errors[error.code];

				self.story.setMessage(message, "error");
			},

			"{previewTitle} click": function() {

				var editing = self.form().hasClass('editing-title');

				self.form().toggleClass('editing-title', !editing);

				if (!editing) {
					self.editTitle();
				}
			},

			"{previewDescription} click": function() {
				var editing = self.form().hasClass('editing-description');

				self.form().toggleClass('editing-description', !editing);

				if (!editing) {
					self.editDescription();
				}
			},

			"{videoCategory} change": function(videoCategory) {
				self.currentCategory = videoCategory.val();
			},

			"{insertVideo} click": function() {

				var url = self.videoLink().val();

				if (!url || self.processing) {
					return;
				}

				// Hide the form
				self.isProcessing();

				EasySocial.ajax('ajax:/apps/user/videos/controllers/process/process', {
					"type": "link",
					"link": url
				}).done(function(data, image, embed) {
					self.isProcessed();

					data.link = url;

					self.updatePreview('link', data, image);
				});
			},

			"{removeButton} click": function(removeButton) {
				self.clearForm(true);
			},

			//
			// Saving
			//

			"{story} save": function(element, event, save) {

                if (save.currentPanel != 'videos') {
                    return;
                }

				var url = self.videoLink().val();
				if (url && !self.video) {
					save.reject($.language('COM_EASYSOCIAL_VIDEOS_STORY_CLICK_INSERT_VIDEO'));
					return;
				}

				if (!url && !self.video) {
					save.reject($.language('COM_EASYSOCIAL_VIDEOS_STORY_NO_VIDEO_DETECTED'));
					return;
				}

				// Add the task for uploading video
				self.uploadingVideo = save.addTask("uploadingVideo");

				self.save(save);
			},

			"{story} afterSubmit": function() {

				var uploadingVideo = self.uploadingVideo;

				if (!uploadingVideo) {
					return;
				}

				// Reset the form upon submission
				self.clearForm(true);

				delete self.uploadingVideo;

				if (self.video && self.video.isEncoding) {

					EasySocial.dialog({
						content: EasySocial.ajax('site/views/videos/showEncodingMessage')
					});

					delete self.video;
					return;
				}

				delete self.video;
			},

			save: function(save) {

				var uploadingVideo = self.uploadingVideo;

				if (!uploadingVideo) {
					return;
				}

				if (self.processing) {
					save.reject($.language('COM_EASYSOCIAL_VIDEOS_STORY_PROCESSING_VIDEO'));
					return;
				}

				// Attach the category to the video data
				self.video.category = self.videoCategory().val();

				if (!self.video.category || self.video.category == 0) {
					save.reject($.language('COM_EASYSOCIAL_VIDEOS_STORY_SELECT_CATEGORY'));
					return;
				}

				save.addData(self, self.video);

				uploadingVideo.resolve();

				self.videoType = self.video.type;
			},

			"{story} clear": function() {
				self.clearForm(false);
			}
	}});

	// Resolve module
	module.resolve();

	});
});

EasySocial.module( 'stream' , function(){

	var module	= this;


	EasySocial.require()
	.library( 'dialog' )
	.script( 'comment' )
	.view( 'site/likes/item' )
	.language(
		'COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_UNSUBSCRIBE',
		'COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_SUBSCRIBE',
		'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_OK',
		'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_SUBMIT',
		'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_CANCEL',
		'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_UNSUBSCRIBE',
		'COM_EASYSOCIAL_SUBSCRIPTION_ARE_YOU_SURE_UNSUBSCRIBE',
		'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_SUBSCRIBE',
		'COM_EASYSOCIAL_STREAM_DIALOG_FEED',
		'COM_EASYSOCIAL_STREAM_BUTTON_CLOSE'
	)
	.done(function($){

		EasySocial.Controller(
			'Stream.Item',
			{
				defaultOptions: {
					id : '',

					'{streamItem}' : '.streamItem',
					'{streamData}' : '.streamData',

					'{streamResponds}' : '.stream-responds',

					'{likeItem}' : '.likeItem',
					'{likeItemList}' : '.likeItemList',

					'{commentLink}' : '.commentLink',
					'{commentFrame}' : '.commentFrame',
					'{commentInput}' : '.commentInput',

					'{followItem}' : '.followItem',
					'{unfollowItem}' : '.unfollowItem',

					'{hideItem}' : '.hideItem',
					'{unhideItem}' : '.unhideItem'
				}
			},
			function( self ){ return {

				init: function(){
					self.commentFrame().implement('EasySocial.Controller.Comments', {						
						uid: self.element.data('id'),
						pagination: new CommentPagination({
							total: self.commentFrame().data('total')
						}),
						commentlist: new Comment.List()
					});
				},

				"{likeItem} click" : function(){
					EasySocial.ajax( 'site:/controllers/likes/toggle' ,
						{
							'id' 		: self.element.data('id'),
							'type'		: 'stream'
						} ,
						{
							success: function( obj ){

								var content = '';

								if( obj.likeCount > 0 )
								{
									content = self.view.likeitem({
									 	likeCount : obj.likeCount
									});

									// temp solution bcos ejs cannot process html code.
									content.find(".likeText").html(obj.message);
								}

								// update the like text
								self.likeItemList().html(content);

								// update the label
								self.likeItem().text( obj.label );

							},
							fail: function(){

							}
						});

				},

				"{unfollowItem} click" : function(){

					var subId = self.element.data('sid');

					if( subId )
					{
						// perform unsubscription.
						$.dialog({
							title: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_UNSUBSCRIBE' ),
							content: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_ARE_YOU_SURE_UNSUBSCRIBE' ),
							buttons:
							[
								{
									name: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_UNSUBSCRIBE' ),
									click: function(){

										EasySocial.ajax( 'site:/controllers/subscriptions/remove' ,
											{
												'id' 				: subId
											} ,
											{
												success: function( obj ){
													$.dialog({
														title: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_UNSUBSCRIBE' ),
														content: obj.message,
														buttons: [
															{
																name: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_OK' ),
																click: function(){
																	self.unfollowItem().removeClass( 'unfollowItem' );
																	$.dialog().close();
																}
															}

														]
													});
												},
												fail: function(){

												}
											});

									}

								},
								{
									name: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_CANCEL' ),
									click: function(){
										$.dialog().close();
									}
								}
							]
						});

					}

				},

				"{followItem} click" : function(){

					// perform subscription.
					EasySocial.ajax( 'site:/controllers/subscriptions/form' ,
						{
							'contentId' 		: self.element.data('id'),
							'contentType'		: 'stream'
						} ,
						{
							success: function( obj ){

								if( obj.message != '' )
								{
									$.dialog({
										title: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_SUBSCRIBE' ),
										content: obj.message,
										buttons: [
											{
												name: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_CANCEL' ),
												click: function(){
													$.dialog().close();
												}
											}
										]
									});

									return;
								}

								$.dialog({

									title: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_SUBSCRIBE' ),
									content: obj.htmlform,
									buttons: [
										{
											name : $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_SUBMIT' ),
											click : function(){

												var fullname 	= $('#esfullname').val() ;
												var email 		= $('#email').val();

												EasySocial.ajax( 'site:/controllers/subscriptions/add' ,
													{
														'contentId' 		: self.element.data('id'),
														'contentType'		: 'stream',
														'esfullname'		: fullname,
														'email'				: email
													} ,
													{
														success: function( obj ){
															$.dialog({
																title: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_DIALOG_SUBSCRIBE' ),
																content: obj.message,
																buttons: [
																	{
																		name: $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_OK' ),
																		click: function(){
																			self.followItem().removeClass( 'followItem' );
																			$.dialog().close();
																		}
																	}

																]
															});
														},
														fail: function(){

														}
													});

											}
										},
										{
											name : $.language( 'COM_EASYSOCIAL_SUBSCRIPTION_BUTTON_CANCEL' ),
											click : function(){
												$.dialog().close();
											}
										}
									]
								});
							},
							fail: function(){

							}
						});

				},

				"{hideItem} click" : function(){
					EasySocial.ajax( 'site:/controllers/stream/hide' ,
						{
							'id' 		: self.element.data('id')
						} ,
						{
							success: function( obj )
							{
								var content = '<div>' + obj.message + '</div>';

								self.streamData().hide();
								self.element.append(content);
							},
							fail: function( obj )
							{
								$.dialog({
									title: $.language( 'COM_EASYSOCIAL_STREAM_DIALOG_FEED' ),
									content: obj.message,
									buttons: [
										{
											name: $.language( 'COM_EASYSOCIAL_STREAM_BUTTON_CLOSE' ),
											click: function(){
												$.dialog().close();
											}
										}
									]
								});
							}
						});

				},


				"{unhideItem} click" : function(){
					EasySocial.ajax( 'site:/controllers/stream/unhide' ,
						{
							'id' 		: self.element.data('id')
						} ,
						{
							success: function( obj )
							{
								self.streamData().show();
								self.element.children().last().remove();

							},
							fail: function( obj )
							{
								$.dialog({
									title: $.language( 'COM_EASYSOCIAL_STREAM_DIALOG_FEED' ),
									content: obj.message,
									buttons: [
										{
											name: $.language( 'COM_EASYSOCIAL_STREAM_BUTTON_CLOSE' ),
											click: function(){
												$.dialog().close();
											}
										}
									]
								});
							}
						});
				},

				"{commentLink} click" : function(){
					self.commentInput().focus();

				}

			} }
		);


		module.resolve();
	});
});

EasySocial.module( 'tab' , function($) {

var module = this;

EasySocial.Controller(
	'Tab',
	{
		// A list of selectors we define
		// and expect template makers to follow.
		defaultOptions:
		{
			view			:{

			},
			"{tabs}"		: '',
			'{tabsContent}'	: '',
			'{defaultActive}': ''
		}
	},
	function(self){

		return {

			init: function()
			{
				// @task: If defaultActive exists, we make this element with the active class.
				self.defaultActive().click();

			},

			'{tabs} click' : function( element ){

				// If the element has class of inactive, we shouldn't do anything here.
				if( $( element ).hasClass( 'inactive' ) )
				{
					return false;
				}

				// Remove active tab.
				self.tabs( '.active' ).removeClass( 'active' );

				// @task: Add active class to itself.
				$( element ).addClass( 'active' );

				// @task: Hide all contents
				self.tabsContent().hide();

				// @task: Find the current element's id.
				var activeContent		= '.tab-' + $( element ).attr( 'id' );

				// @task: Show active content
				self.tabsContent( activeContent ).show();
			}

		}
	}
);

module.resolve();

});

EasySocial.module( 'toggle' , function($) {

var module = this;

EasySocial.Controller(
	'Toggle',
	{
		// A list of selectors we define
		// and expect template makers to follow.
		defaultOptions:
		{
			view			:{

			},
			'{selector}'	: ""
		}
	},
	function(self){

		return {

			init: function()
			{
			},

			'{selector} click' : function( element ){
				$( element ).next().toggle();
				$( element ).toggleClass('this-closed');
			}

		}
	}
);

module.resolve();

});

EasySocial.module( 'uploader/item' , function($){

	var module 	= this;

	EasySocial.require()
	.view( 'site/uploader/preview' )
	.done( function($){

		EasySocial.Controller(
			'Uploader.Item',
			{
				defaults:
				{
					"{uploadItem}" : ".uploadItem",
					"{uploadItemPreview}" : ".uploadItem.preview a.itemLink",

					// Actions
					"{itemLink}"		: '.itemLink',
					"{itemDelete}"		: '.itemDelete',

					view: {

						preview : 'site/uploader/preview'

					}
				}
			},
			function( self ){ return {

				init: function(){

				},

				"{itemDelete} click": function( el ){

					var id 		= $( el ).data( 'id' );

					EasySocial.ajax( 'site:/controllers/uploader/delete' , {
						'id'	: id
					}, function(){

						// Remove the item from the list
						$( el ).parents( 'li.uploadItem' ).remove();
					})
				},

				"{uploadItemPreview} click" : function( el ){

					var uri 	= $( el ).data( 'uri' ),
						title 	= $( el ).data( 'title' );

					$.dialog({
						title: title,
						content: $.Image.get(uri)
					});





					// $.dialog({
					// 	'title'		: title,
					// 	'content'	: content,
					// 	afterShow	: function(){

					// 		$.dialog().update();

					// 	}
					// });
				}

			} }
		);
	});

	module.resolve();
});

EasySocial.module('videos/form', function($) {

	var module = this;

	EasySocial.require()
	.script('site/friends/suggest')
	.library('mentions')
	.done(function($) {

	EasySocial.Controller('Videos.Form', {
		defaultOptions: {
			"{videoSource}": "[data-video-source]",

			// Forms for video source
			"{forms}": "[data-form-source]",
			"{linkForm}": "[data-form-link]",
			"{uploadForm}": "[data-form-upload]",

			// Mentions
			"{mentions}": "[data-mentions]"
		}
	}, function(self, opts, base) { return {

		init: function() {
			self.initMentions();
		},

		initMentions: function() {

			self.mentions()
				.addController("EasySocial.Controller.Friends.Suggest", {
					"showNonFriend": false,
					"includeSelf": true,
					"name": "tags[]",
					"exclusion": opts.tagsExclusion
				});
		},

		"{videoSource} change": function(videoSource, event) {

			var source = $(videoSource).val();
			var form = self[source + "Form"]();

			// Hide all source forms
			self.forms().addClass('hide');

			// Remove hidden class for the active form
			form.removeClass('hide');
		}

	}});

	module.resolve();


	});

});

EasySocial.module('videos/item', function($) {

	var module = this;

	EasySocial.require()
	.done(function($) {

	EasySocial.Controller('Videos.Item', {
		defaultOptions: {

			tagAdding	: null,

			"{tagPeople}": "[data-video-tag]",
			"{tagsWrapper}": "[data-video-tag-wrapper]",
			"{deleteButton}": "[data-video-delete]",

			"{removeTag}": "[data-remove-tag]",
			"{tagItem}": "[data-tags-item]",

			"{featureButton}": "[data-video-feature]",
			"{unfeatureButton}": "[data-video-unfeature]"
		}
	}, function(self, opts, base) { return {

		init: function() {
			opts.id = self.element.data('id');
		},

		"{unfeatureButton} click": function(unfeatureButton, event) {
			EasySocial.dialog({
				content: EasySocial.ajax("site/views/videos/confirmUnfeature", {
					"id": opts.id,
					"callbackUrl": opts.callbackUrl
				})
			})
		},

		"{featureButton} click": function(featureButton, event) {

			EasySocial.dialog({
				content: EasySocial.ajax("site/views/videos/confirmFeature", {
					"id": opts.id,
					"callbackUrl": opts.callbackUrl
				})
			});
		},

		"{deleteButton} click": function(deleteButton, event) {
			EasySocial.dialog({
				content: EasySocial.ajax("site/views/videos/confirmDelete", {
					"id": opts.id
				}),
				bindings: {

				}
			})
		},

		"{removeTag} click": function(removeTag, event) {

			var parent = removeTag.parents(self.tagItem.selector);
			var id = parent.data('id');

			parent.remove();

			// If the length is only 1, we know that it's empty
			if (self.tagsWrapper().children().length == 1) {
				self.tagsWrapper().addClass('is-empty');
			}

			EasySocial.ajax('site/controllers/videos/removeTag', {
				"id": id
			}).done(function() {
				// We don't need to do anything here...
			});
		},

		"{tagPeople} click": function(tagPeople, event) {

			self.tagAdding = false;

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/videos/tagPeople', {
							"id": opts.id,
							"exclusion": opts.tagsExclusion
							}),
				bindings: {
					"{submit} click": function(submitButton, event) {

						if (self.tagAdding) {
							return;
						}

						// now we set the state
						self.tagAdding = true;

						var suggest = this.suggest().textboxlist("controller");
						var items = suggest.getAddedItems();

						if (items.length <= 0) {
							return;
						}

						var ids = $.pluck(items, "id");

						// Make an ajax call to the server to tag people in this video
						EasySocial.ajax('site/controllers/videos/tag', {
							"ids": ids,
							"id": opts.id
						}).done(function(tags) {

							if (! opts.tagsExclusion) {
								opts.tagsExclusion = [];
							}

							$.each(ids, function(i, id) {
								opts.tagsExclusion.push(id);
							});

							// Just try to remove the is-empty on the wrapper.
							self.tagsWrapper().removeClass('is-empty');

							// Append the tags to the wrapper
							self.tagsWrapper().append(tags);

							//clear items in dialog to avoid user click insert multiple time
							suggest.clearItems();

							// Hide the dialog
							EasySocial.dialog().close();

							// unset the state
							self.tagAdding = false;
						});
					}
				}
			})
		}
	}});

	module.resolve();


	});

});

EasySocial.module('videos/list', function($) {

	var module = this;

	EasySocial.require()
	.done(function($) {

	EasySocial.Controller('Videos.List', {
		defaultOptions: {

			// Video filters
			"{filter}": "[data-videos-filter]",
			"{sorting}": "[data-videos-sorting]",


			"{activeFilter}": ".filter-item.active a",

			// Videos result
			"{result}": "[data-videos-result]",

			// Video actions
			"{item}": "[data-video-item]",
			"{deleteButton}": "[data-video-delete]",
			"{featureButton}": "[data-video-feature]",
			"{unfeatureButton}": "[data-video-unfeature]"
		}
	}, function(self, opts, base) { return {

		init: function() {
		},

		// Default filter
		currentFilter: "",
		currentSorting: "",
		categoryId: null,

		setActiveFilter: function(filter) {

			// Remove all active classes.
			self.filter().parent().removeClass('active');

			// Set the active class to the filter's parent.
			filter.parent().addClass('active');
		},

		getVideos: function() {

			if (!self.currentSorting) {
				// Set the current sorting
				self.currentSorting = self.sorting().val();
			}

			if (!self.currentFilter) {
				// Set the current sorting
				self.currentFilter = self.activeFilter().data('type');
			}

			// if still empty the filter, just set to all.
			if (!self.currentFilter) {
				self.currentFilter = "all";
			}

			// Add loading class to the wrapper
			self.element.addClass('is-loading');

			EasySocial.ajax('site/controllers/videos/getVideos',{
				"filter": self.currentFilter,
				"categoryId": self.categoryId,
				"sort": self.currentSorting,
				"uid": opts.uid,
				"type": opts.type
			}).done(function(output) {

				// Stop the loading
				self.element.removeClass('is-loading');

				self.result().html(output);
			});
		},

		"{sorting} change": function(sorting, event) {

			// Set the current sorting
			self.currentSorting = sorting.val();

			if (sorting.val() != '') {
				var url = self.activeFilter().prop('href');

				if (url.indexOf('?') >= 0) {
					url = url + '&sort=' + sorting.val();
				} else {
					url = url + '?sort=' + sorting.val();
				}

				History.pushState( {state:1} , self.activeFilter().prop('title'), url );
			}

			// Get the videos
			self.getVideos();
		},

		"{filter} click": function(filter, event) {
			// Prevent bubbling up
			event.preventDefault();
			event.stopPropagation();

			var type = filter.data('type');

			// Route the inner filter links
			filter.route();

			// Add an active state to the parent
			self.setActiveFilter(filter);

			// Filter by category
			var categoryId = null;

			if (type == 'category') {
				type = 'all';
				categoryId = filter.data('id');
			}

			// Set the current filter
			self.currentFilter = type;
			self.categoryId = categoryId;

			self.getVideos(type, categoryId);
		},

		"{deleteButton} click": function(deleteButton, event) {

			var item = deleteButton.parents(self.item.selector);
			var id = item.data('id');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/videos/confirmDelete', {
					"id": id
				})
			});
		},

		"{unfeatureButton} click": function(unfeatureButton, event) {
			var item = unfeatureButton.parents(self.item.selector);
			var id = item.data('id');
			var returnUrl = unfeatureButton.data('return');

			var options = {
				"id": id
			};

			if (returnUrl.length > 0) {
				options["callbackUrl"] = returnUrl;
			}

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/videos/confirmUnfeature', options)
			});
		},

		"{featureButton} click": function(featureButton, event) {
			var item = featureButton.parents(self.item.selector);
			var id = item.data('id');
			var returnUrl = featureButton.data('return');

			var options = {
				"id": id
			};

			if (returnUrl) {
				options["callbackUrl"] = returnUrl;
			}

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/videos/confirmFeature', options)
			});
		}
	}});

	module.resolve();


	});

});

EasySocial.module('videos/process', function($) {

	var module = this;

	EasySocial.Controller('Videos.Process', {
		defaultOptions: {
			"{progressBar}": "[data-video-progress-bar]",
			"{progressResult}": "[data-video-progress-result]"
		}
	}, function(self, opts, base) { return {
		
		init: function() {

			// Set the global options
			opts.id = base.data('id');

			self.processVideo();
		},

		processVideo: function() {

			// Initialize the video processing here
			EasySocial.ajax('site/controllers/videos/process', {
				"id": opts.id
			}).done(function() {

				// Run check status
				self.status(opts.id);
			});
		},

		status: function(videoId) {
			// Initialize the video processing here
			EasySocial.ajax('site/controllers/videos/status', {
				"id": videoId
			}).done(function(permalink, progress) {
				
				if (progress == 'done') {
					self.progressBar().css('width', '100%');
					self.progressResult().html('100%');

					// Redirect the user upon completion
					window.location = permalink;
					
					return;
				}

				var percentage = progress + '%';

				// Reiterate the same method again until it's completed.
				self.progressBar().css('width', percentage);
				self.progressResult().html(percentage);

				self.status(videoId);

				return;
				// // Set the progress bar to at least 10%
				// self.progressBar().css('width', '10%');

				// // Run check status
				// self.status(logFile);
			});
		}

	}});

	module.resolve();
});
});
